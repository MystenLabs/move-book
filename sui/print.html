<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Move Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <meta name="robots" content="noindex">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap" rel="stylesheet">

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Foreword</div></li><li class="chapter-item expanded "><a href="history.html"><strong aria-hidden="true">3.</strong> History</a></li><li class="chapter-item expanded "><a href="before-we-begin/index.html"><strong aria-hidden="true">4.</strong> Before we begin</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="before-we-begin/install-sui.html"><strong aria-hidden="true">4.1.</strong> Install Sui</a></li><li class="chapter-item expanded "><a href="before-we-begin/ide-support.html"><strong aria-hidden="true">4.2.</strong> Set up your IDE</a></li><li class="chapter-item expanded "><a href="before-we-begin/move-2024.html"><strong aria-hidden="true">4.3.</strong> Move 2024</a></li></ol></li><li class="chapter-item expanded "><a href="your-first-move/index.html"><strong aria-hidden="true">5.</strong> Your First Move</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="your-first-move/hello-world.html"><strong aria-hidden="true">5.1.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="your-first-move/adding-tests.html"><strong aria-hidden="true">5.2.</strong> Adding Tests</a></li><li class="chapter-item expanded "><a href="your-first-move/debugging.html"><strong aria-hidden="true">5.3.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="your-first-move/generating-docs.html"><strong aria-hidden="true">5.4.</strong> Generating Docs</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/index.html"><strong aria-hidden="true">6.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/packages.html"><strong aria-hidden="true">6.1.</strong> What is a Package</a></li><li class="chapter-item expanded "><a href="concepts/manifest.html"><strong aria-hidden="true">6.2.</strong> Manifest</a></li><li class="chapter-item expanded "><a href="concepts/address.html"><strong aria-hidden="true">6.3.</strong> Addresses</a></li><li class="chapter-item expanded "><a href="concepts/modules.html"><strong aria-hidden="true">6.4.</strong> Module</a></li><li class="chapter-item expanded "><a href="concepts/user-interaction.html"><strong aria-hidden="true">6.5.</strong> Interacting with a Package</a></li><li class="chapter-item expanded "><a href="concepts/what-is-an-account.html"><strong aria-hidden="true">6.6.</strong> Account</a></li><li class="chapter-item expanded "><a href="concepts/what-is-a-transaction.html"><strong aria-hidden="true">6.7.</strong> Transaction</a></li><li class="chapter-item expanded "><a href="concepts/object-model.html"><strong aria-hidden="true">6.8.</strong> Object Model</a></li></ol></li><li class="chapter-item expanded "><a href="hello-sui/index.html"><strong aria-hidden="true">7.</strong> Your First Sui App</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-sui/hello-sui.html"><strong aria-hidden="true">7.1.</strong> Hello Sui!</a></li><li class="chapter-item expanded "><a href="hello-sui/module-structure.html"><strong aria-hidden="true">7.2.</strong> Using Objects</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Testing</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> Publish and Interact</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.</strong> Ideas</div></li></ol></li><li class="chapter-item expanded "><a href="basic-syntax/index.html"><strong aria-hidden="true">8.</strong> Syntax Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic-syntax/module.html"><strong aria-hidden="true">8.1.</strong> Module</a></li><li class="chapter-item expanded "><a href="basic-syntax/comments.html"><strong aria-hidden="true">8.2.</strong> Comments</a></li><li class="chapter-item expanded "><a href="basic-syntax/primitive-types.html"><strong aria-hidden="true">8.3.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="basic-syntax/address.html"><strong aria-hidden="true">8.4.</strong> Address Type</a></li><li class="chapter-item expanded "><a href="basic-syntax/expression.html"><strong aria-hidden="true">8.5.</strong> Expression</a></li><li class="chapter-item expanded "><a href="basic-syntax/struct.html"><strong aria-hidden="true">8.6.</strong> Struct</a></li><li class="chapter-item expanded "><a href="basic-syntax/drop-ability.html"><strong aria-hidden="true">8.7.</strong> Abilities: Drop</a></li><li class="chapter-item expanded "><a href="basic-syntax/importing-modules.html"><strong aria-hidden="true">8.8.</strong> Importing Modules</a></li><li class="chapter-item expanded "><a href="basic-syntax/standard-library.html"><strong aria-hidden="true">8.9.</strong> Standard Library</a></li><li class="chapter-item expanded "><a href="basic-syntax/vector.html"><strong aria-hidden="true">8.10.</strong> Vector</a></li><li class="chapter-item expanded "><a href="basic-syntax/option.html"><strong aria-hidden="true">8.11.</strong> Option</a></li><li class="chapter-item expanded "><a href="basic-syntax/string.html"><strong aria-hidden="true">8.12.</strong> String</a></li><li class="chapter-item expanded "><a href="basic-syntax/control-flow.html"><strong aria-hidden="true">8.13.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="basic-syntax/constants.html"><strong aria-hidden="true">8.14.</strong> Constants</a></li><li class="chapter-item expanded "><a href="basic-syntax/assert-and-abort.html"><strong aria-hidden="true">8.15.</strong> Assert and Abort</a></li><li class="chapter-item expanded "><a href="basic-syntax/function.html"><strong aria-hidden="true">8.16.</strong> Function</a></li><li class="chapter-item expanded "><a href="basic-syntax/struct-methods.html"><strong aria-hidden="true">8.17.</strong> Struct Methods</a></li><li class="chapter-item expanded "><a href="basic-syntax/visibility.html"><strong aria-hidden="true">8.18.</strong> Visibility Modifiers</a></li><li class="chapter-item expanded "><a href="basic-syntax/ownership-and-scope.html"><strong aria-hidden="true">8.19.</strong> Ownership and Scope</a></li><li class="chapter-item expanded "><a href="basic-syntax/copy-ability.html"><strong aria-hidden="true">8.20.</strong> Abilities: Copy</a></li><li class="chapter-item expanded "><a href="basic-syntax/references.html"><strong aria-hidden="true">8.21.</strong> References</a></li><li class="chapter-item expanded "><a href="basic-syntax/generics.html"><strong aria-hidden="true">8.22.</strong> Generics</a></li><li class="chapter-item expanded "><a href="basic-syntax/type-reflection.html"><strong aria-hidden="true">8.23.</strong> Type Reflection</a></li><li class="chapter-item expanded "><a href="programmability/testing.html"><strong aria-hidden="true">8.24.</strong> Testing</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Programming Digital Assets</div></li><li class="chapter-item expanded "><a href="object/index.html"><strong aria-hidden="true">10.</strong> It starts with an Object</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">10.1.</strong> The Key Ability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.2.</strong> What is an Object</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.3.</strong> True Ownership</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.4.</strong> Transfer Restrictions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.5.</strong> Shared State</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.6.</strong> Transfer to Object?</div></li></ol></li><li class="chapter-item expanded "><a href="programmability/index.html"><strong aria-hidden="true">11.</strong> Advanced Programmability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programmability/transaction-context.html"><strong aria-hidden="true">11.1.</strong> Transaction Context</a></li><li class="chapter-item expanded "><a href="programmability/capability.html"><strong aria-hidden="true">11.2.</strong> Pattern: Capability</a></li><li class="chapter-item expanded "><a href="programmability/fast-path.html"><strong aria-hidden="true">11.3.</strong> Fast Path</a></li><li class="chapter-item expanded "><a href="programmability/collections.html"><strong aria-hidden="true">11.4.</strong> Collections</a></li><li class="chapter-item expanded "><a href="programmability/dynamic-fields.html"><strong aria-hidden="true">11.5.</strong> Dynamic Fields</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.6.</strong> Dynamic Collections</div></li><li class="chapter-item expanded "><a href="programmability/epoch-and-time.html"><strong aria-hidden="true">11.7.</strong> Epoch and Time</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.8.</strong> Package Upgrades</div></li><li class="chapter-item expanded "><a href="programmability/witness-and-abstract-implementation.html"><strong aria-hidden="true">11.9.</strong> Witness and Abstract Implementation</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.10.</strong> One Time Witness</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.11.</strong> Transaction Blocks</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.12.</strong> Authorization Patterns</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.13.</strong> Cryptography and Hashing</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.14.</strong> Randomness</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Standards</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">12.1.</strong> Coin</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.2.</strong> Transfer Policy</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.3.</strong> Kiosk</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.4.</strong> Closed Loop Token</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Special Topics</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">13.1.</strong> BCS</div></li></ol></li><li class="chapter-item expanded "><a href="guides/index.html"><strong aria-hidden="true">14.</strong> Guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guides/2024-migration-guide.html"><strong aria-hidden="true">14.1.</strong> 2024 Migration Guide</a></li><li class="chapter-item expanded "><a href="guides/upgradeability-practices.html"><strong aria-hidden="true">14.2.</strong> Upgradability Practices</a></li><li class="chapter-item expanded "><a href="guides/building-against-limits.html"><strong aria-hidden="true">14.3.</strong> Building against Limits</a></li><li class="chapter-item expanded "><a href="guides/better-error-handling.html"><strong aria-hidden="true">14.4.</strong> Better error handling</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.5.</strong> Open-sourcing Libraries</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.6.</strong> Testing</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.7.</strong> Debugging</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.8.</strong> Coding Conventions</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Appendix</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/glossary.html"><strong aria-hidden="true">15.1.</strong> Glossary</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.2.</strong> References</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.3.</strong> Contributing</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.4.</strong> Acknowledgements</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Move Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-move-book"><a class="header" href="#the-move-book">The Move Book</a></h1>
<p>This is a book about the Move language and the Sui blockchain platform. It is a comprehensive guide to the language and the platform, and it is intended for developers who want to learn how to write application in Move and build on Sui.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="history"><a class="header" href="#history">History</a></h1>
<!--

Chapter: History
Goal: explain the history of Move as a language
Notes:

 -->
<ul>
<li>2019 - Libra is announced</li>
<li>2019 - Move a Language with Programmable Resources</li>
<li>2022 - The Diem Association is closed, Move is open sourced</li>
<li>2023 - ...</li>
<li>2024 - Move 2024 is released</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="before-we-begin"><a class="header" href="#before-we-begin">Before we begin</a></h1>
<p>This chapter covers the prerequisites for the Move language: how to set up your IDE, how to install the compiler and what is Move 2024. If you are already familiar with these topics or have a CLI installed, you can skip this chapter and proceed to <a href="before-we-begin/../your-first-move">the next one</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-sui"><a class="header" href="#install-sui">Install Sui</a></h1>
<p>Move is a compiled language, so you need to install a compiler to be able to write and run Move programs. The compiler is included into the Sui binary, which can be installed or downloaded using one of the methods below.</p>
<h2 id="download-binary"><a class="header" href="#download-binary">Download Binary</a></h2>
<p>You can download the latest Sui binary from the <a href="https://github.com/MystenLabs/sui/releases">releases page</a>. The binary is available for macOS, Linux and Windows. For education purposes and development, we recommend using the <code>mainnet</code> version.</p>
<h2 id="install-using-homebrew-macos"><a class="header" href="#install-using-homebrew-macos">Install using Homebrew (MacOS)</a></h2>
<p>You can install Sui using the <a href="https://brew.sh/">Homebrew</a> package manager.</p>
<pre><code class="language-bash">brew install sui
</code></pre>
<h2 id="build-using-cargo-macos-linux"><a class="header" href="#build-using-cargo-macos-linux">Build using Cargo (MacOS, Linux)</a></h2>
<p>You can install and build Sui locally by using the Cargo package manager (requires Rust)</p>
<pre><code class="language-bash">cargo install --git https://github.com/MystenLabs/sui.git --bin sui --branch mainnet
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p>For troubleshooting the installation process, please refer to the <a href="https://docs.sui.io/guides/developer/getting-started/sui-install">Install Sui</a> Guide.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set-up-your-ide"><a class="header" href="#set-up-your-ide">Set up your IDE</a></h1>
<p>There are two most popular IDEs for Move development: VSCode and IntelliJ IDEA. Both of them provide basic features like syntax highlighting and error messages, though they differ in their additional features. Whatever IDE you choose, you'll need to use the terminal to run the <a href="before-we-begin/./install-sui.html">Move CLI</a>.</p>
<blockquote>
<p><strong>IntelliJ Plugin does not support Move 2024 edition fully, some syntax won't get highlighted and not supported.</strong></p>
</blockquote>
<h2 id="vscode"><a class="header" href="#vscode">VSCode</a></h2>
<ul>
<li><a href="https://code.visualstudio.com/">VSCode</a> is a free and open source IDE from Microsoft.</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=move.move-analyzer">Move Analyzer</a> is a language server extension for Move maintained by <a href="https://mystenlabs.com">MystenLabs</a>.</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax">Move Syntax</a> a simple syntax highlighting extension for Move by <a href="https://github.com/damirka/">Damir Shamanaev</a>.</li>
</ul>
<h2 id="intellij-idea"><a class="header" href="#intellij-idea">IntelliJ IDEA</a></h2>
<ul>
<li><a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a> is a commercial IDE from JetBrains.</li>
<li><a href="https://plugins.jetbrains.com/plugin/14721-move-language">Move Language Plugin</a> provides a Move language extension for IntelliJ IDEA by <a href="https://pontem.network/">Pontem Network</a>.</li>
</ul>
<h2 id="emacs"><a class="header" href="#emacs">Emacs</a></h2>
<ul>
<li><a href="https://www.gnu.org/software/emacs/">Emacs</a> is a free and open source text editor.</li>
<li><a href="https://github.com/amnn/move-mode">move-mode</a> is a Move mode for Emacs by <a href="https://github.com/amnn">Ashok Menon</a>.</li>
</ul>
<h2 id="github-codespaces"><a class="header" href="#github-codespaces">Github Codespaces</a></h2>
<p>Web based IDE from Github, can be run right in the browser and provides almost a full-featured VSCode experience.</p>
<ul>
<li><a href="https://github.com/features/codespaces">Github Codespaces</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax">Move Syntax</a> is also available in the extensions marketplace.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-2024"><a class="header" href="#move-2024">Move 2024</a></h1>
<p>Move 2024 is the new version of the Move language that is maintained by Mysten Labs. All of the examples in this book are written in Move 2024. If you're used to the pre-2024 version of Move, please, refer to the <a href="before-we-begin/./../guides/2024-migration-guide.html">Move 2024 Migration Guide</a> to learn about the differences between the two versions.</p>
<!-- Notes ? -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-move"><a class="header" href="#your-first-move">Your first Move</a></h1>
<p>In this section you'll get to experience the Move language and the Move compiler first-hand. You'll learn how to create a package, write a simple module, test it and generate documentation. You can also use this section as a quick CLI reference for your own projects.</p>
<p>This guide mentions topics which you will learn later in this book. If you are not familiar with some of the concepts, don't worry, you'll learn them later. Try to focus on the task at hand and don't get distracted by the details.</p>
<blockquote>
<p>It is important that you have a working Move environment. If you haven't set it up yet, please refer to the <a href="your-first-move/../before-we-begin/install-sui.html">Install Sui</a> section.</p>
</blockquote>
<p>This section is divided into the following parts (in order):</p>
<ul>
<li><a href="your-first-move/./hello-world.html">Hello World</a></li>
<li><a href="your-first-move/./adding-tests.html">Adding Tests</a></li>
<li><a href="your-first-move/./debugging.html">Debugging</a></li>
<li><a href="your-first-move/./generating-docs.html">Generating Docs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<!-- TODO: redo the tutorial based on new CLI scaffold features -->
<!--

- Hello World
    - copy-paste the example
    - explain the structure of the code
    - explain the module
    - explain the function
    - run sui move build
    - compare the output
    - leave a hint, show that there's more to it

-->
<p>It's time to write your first Move program. We'll start with the classic "Hello World" program which returns a String.</p>
<h2 id="initialize-a-project"><a class="header" href="#initialize-a-project">Initialize a project</a></h2>
<p>First, you need to initialize a new project. Assuming <a href="your-first-move/../before-we-begin/install-sui.html">you have Sui installed</a>, run the following command:</p>
<pre><code class="language-bash">$ sui move new hello_world
</code></pre>
<p>Sui CLI has a <code>move</code> subcommand which is used to work with Move packages. The <code>new</code> subcommand creates a new package with the given name in a new directory. In our case, the package name is <code>hello_world</code>, and it is located in the <code>hello_world</code> directory.</p>
<p>To make sure that the package was created successfully, we can check the contents of the current directory, and see that there is a new <code>hello_world</code> path.</p>
<pre><code class="language-bash">$ ls | grep hello_world
hello_world
</code></pre>
<!--
    Revisit, decide if we should go that deep and detailed;
    Expect the user to know how to use a terminal and a text editor?
-->
<p>If the output looks like this, then everything is fine, and we can proceed. The folder structure of the package is the folowing:</p>
<pre><code class="language-bash">hello_world
├── Move.toml
├── src/
│   └── hello_world.move
└── tests/
    └── hello_world_tests.move
</code></pre>
<p>The address I'm using in this book is always <code>0x0</code> and the name for it is "book". You can use any address you want, but make sure to change it in the examples. To make the examples work as is, please, add the following address to the <code>[addresses]</code> section in the <code>Move.toml</code>:</p>
<pre><code class="language-toml"># Move.toml
[addresses]
std = "0x1"
book = "0x0"
</code></pre>
<h2 id="create-a-module"><a class="header" href="#create-a-module">Create a module</a></h2>
<p>Let's create a new module called <code>hello_world</code>. To do so, create a new file in the <code>sources</code> folder called <code>hello_world.move</code>. So that the structure looks like this:</p>
<pre><code class="language-bash">sources/
    hello_world.move
Move.toml
</code></pre>
<p>And then add the following code to the <code>hello_world.move</code> file:</p>
<pre><code class="language-Move">// sources/hello_world.move
module book::hello_world {
    use std::string::{Self, String};

    public fun hello_world(): String {
        string::utf8(b"Hello, World!")
    }
}
</code></pre>
<p>While it's not a hard restriction, it's is considered a good practice to name the module the same as the file. So, in our case, the module name is <code>hello_world</code> and the file name is <code>hello_world.move</code>.</p>
<p>The module name and function names should be in <code>snake_case</code> - all lowercase letters with underscores between words. You can read more about coding conventions in the <a href="your-first-move/../special-topics/coding-conventions.html">Coding Conventions</a> section.</p>
<h2 id="dive-into-the-code"><a class="header" href="#dive-into-the-code">Dive into the code</a></h2>
<p>Let's take a closer look at the code we just wrote:</p>
<pre><code class="language-Move">module book::hello_world {
}
</code></pre>
<p>The first line of code declares a module called <code>hello_world</code> stored at the address <code>book</code>. The contents of the module go inside the curly braces <code>{}</code>. The last line closes the module declaration with a closing curly brace <code>}</code>. We will go through the module declaration in more detail in the <a href="your-first-move/../basic-syntax/modules.html">Modules</a> section.</p>
<p>Then we import two members of the <code>std::string</code> module (which is part of the <code>std</code> package). The <code>string</code> module contains the <code>String</code> type, and the <code>Self</code> keyword imports the module itself, so we can use its functions.</p>
<pre><code class="language-Move">    use std::string::{Self, String};
</code></pre>
<p>Then we define a <code>hello_world</code> function using the keyword <code>fun</code> which takes no arguments and returns a <code>String</code> type. The <code>public</code> keyword marks the visibility of the function - "public" functions can be accessed by other modules. The function body is inside the curly braces <code>{}</code>.</p>
<blockquote>
<p>In the <a href="your-first-move/../basic-syntax/function.html">Function</a> section we will learn more about functions.</p>
</blockquote>
<pre><code class="language-Move">    public fun hello_world(): String {
        string::utf8(b"Hello, World!")
    }
</code></pre>
<p>The function body consists of a single function call to the <code>string::utf8</code> function and returns a <code>String</code> type. The expression is a bytestring literal <code>b"Hello World!"</code>.</p>
<h2 id="compile-the-package"><a class="header" href="#compile-the-package">Compile the package</a></h2>
<p>To compile the package, run the following command:</p>
<pre><code class="language-bash">$ sui move build
</code></pre>
<p>If you see this (or - for other binaries - similar) output, then everything is fine, and the code compiled successfully:</p>
<pre><code class="language-bash">&gt; UPDATING GIT DEPENDENCY https://github.com/move-language/move.git
&gt; INCLUDING DEPENDENCY MoveStdlib
&gt; BUILDING Book
</code></pre>
<p>Congratulations! You've just compiled your first Move program. Now, let's add a test and some logging so we see that it works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-tests"><a class="header" href="#adding-tests">Adding Tests</a></h1>
<!--

- Adding Tests
    - describe what a test is
    - copy-paste the example into the code
    - explain the test
    - run sui move test
    - compare the output
    - try to break the test
    - check the output
    - leave a hint
    - anticipation for the next section

 -->
<p>To run a Move program there needs to be an environment which stores packages and executes transactions. The best way to test a Move program is to write some tests and run them locally. Move has built-in testing functionality, and the tests are written in Move as well. In this section, we will learn how to write tests for our <code>hello_world</code> module.</p>
<p>First, let's try to run tests. All of the Move binaries support the <code>test</code> command, and this is the command we will use to run tests:</p>
<pre><code class="language-bash">$ sui move test
</code></pre>
<p>If you see similar output, then everything is fine, and the test command has run successfully:</p>
<pre><code class="language-bash">INCLUDING DEPENDENCY MoveStdlib
BUILDING Book Samples
Running Move unit tests
Test result: OK. Total tests: 0; passed: 0; failed: 0
</code></pre>
<p>As you can see, the test command has run successfully, but it didn't find any tests. Let's add some tests to our module.</p>
<h2 id="your-first-test"><a class="header" href="#your-first-test">Your first test</a></h2>
<p>When the test command runs, it looks for all tests in all files in the directory. Tests can be either placed separate modules or in the same module as the code they test. First, let's add a test function to the <code>hello_world</code> module:</p>
<pre><code class="language-Move">module book::hello_world {
    use std::string::{Self, String};

    public fun hello_world(): String {
        string::utf8(b"Hello, World!")
    }

    #[test]
    fun test_is_hello_world() {
        let expected = string::utf8(b"Hello, World!");
        assert!(hello_world() == expected, 0)
    }
}
</code></pre>
<p>The test function is a function with a <code>#[test]</code> attribute. Normally it takes no arguments (but it can take arguments in some cases - you'll learn more about it closer to the end of this book) and returns nothing. Tests placed in the same module as the code they test are called "unit tests". They can access all functions and types in the module. We'll go through them in more detail in the <a href="your-first-move/../basic-syntax/test.html">Test</a> section.</p>
<pre><code class="language-Move">    #[test]
    fun test_is_hello_world() {
        let expected = string::utf8(b"Hello, World!");
        assert!(hello_world() == expected, 0)
    }
</code></pre>
<p>Inside the test function, we define the expected outcome by creating a String with the expected value and assign it to the <code>expected</code> variable. Then we use the special built-in <code>assert!()</code> which takes two arguments: a conditional expression and an error code. If the expression evaluates to <code>false</code>, then the test fails with the given error code. The equality operator <code>==</code> compares the <code>actual</code> and <code>expected</code> values and returns <code>true</code> if they are equal. We'll learn more about expressions in the <a href="your-first-move/../basic-syntax/expression-and-scope.html">Expression and Scope</a> section.</p>
<p>Now let's run the test command again:</p>
<pre><code class="language-bash">$ sui move test
</code></pre>
<p>You should see this output, which means that the test has run successfully:</p>
<pre><code class="language-bash">...
Test result: OK. Total tests: 1; passed: 1; failed: 0
</code></pre>
<h2 id="failed-experiment"><a class="header" href="#failed-experiment">Failed experiment</a></h2>
<p>Try replacing the equality operator  <code>==</code> inside the <code>assert!</code> with the inequality operator <code>!=</code> and run the test command again.</p>
<pre><code class="language-Move">    assert!(hello_world() != expected, 0)
</code></pre>
<p>You should see this output, which means that the test has failed:</p>
<pre><code class="language-bash">Running Move unit tests
[ FAIL    ] 0x0::hello_world::test_is_hello_world

Test failures:

Failures in 0x0::hello_world:

┌── test_is_hello_world ──────
│ error[E11001]: test failure
│    ┌─ ./sources/your-first-move/hello_world.move:14:9
│    │
│ 12 │     fun test_is_hello_world() {
│    │         ------------------- In this function in 0x0::hello_world
│ 13 │         let expected = string::utf8(b"Hello, World!");
│ 14 │         assert!(hello_world() != expected, 0)
│    │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Test was not expected to error, but it aborted with code 0 originating in the module 00000000000000000000000000000000::hello_world rooted here
│
│
└──────────────────

Test result: FAILED. Total tests: 1; passed: 0; failed: 1
</code></pre>
<p>Tests are used to verify the execution of the code. If the code is correct, the test should pass, otherwise it should fail. In this case, the test failed because we intentionally made a mistake in the test code. However, normally you should write tests that check the correctness of the code, not the other way around!</p>
<p>In the next section, we will learn how to debug Move programs and print intermediate values to the console.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<!--
- Debugging
    - describe what Move Compiler can do for debugging
    - debug is only available in test mode
    - copy-paste the example
    - explain the imported `std::debug` module
    - give a hint on how to do an inline call
    - pretty-print for strings / vectors
    - other debug functions: print, print_stack_trace

 -->
<p>Now that we have a package with a module and a test, let's take a slight detour and learn how to debug Move programs. Move Compiler has a built-in debugging tool that allows you to print intermediate values to the console. This is especially useful when you are writing tests and want to see what's going on inside the program.</p>
<h2 id="new-import"><a class="header" href="#new-import">New import</a></h2>
<p>To use the <code>debug</code> module, we need to import it in our module. Imports are usually grouped together for readability and they are placed at the top of the module. Let's add the import statement to the <code>hello_world</code> module:</p>
<pre><code class="language-Move">module book::hello_world {
    use std::string::{Self, String};
    use std::debug; // the added import!
</code></pre>
<p>Having imported the <code>std::debug</code> module, we can now use its functions. Let's add a <code>debug::print</code> function call to the <code>hello_world</code> function. To achieve that we need to change the function body. Instead of returning the value right away we will assign it to a variable, print it to the console and then return it:</p>
<pre><code class="language-Move">    public fun hello_world(): String {
        let result = string::utf8(b"Hello, World!");
        debug::print(&amp;result);
        result
    }
</code></pre>
<p>First, run the build command:</p>
<pre><code class="language-bash">$ sui move build
</code></pre>
<p>The output does not contain anything unusual, because our code was never executed. But running <code>build</code> is an important part of the routine - this way we make sure that the changes we added can compile. Let's run the test command now:</p>
<pre><code class="language-bash">$ sui move test
</code></pre>
<p>The output of the test command now contains the "Hello, World!" string:</p>
<pre><code class="language-bash">INCLUDING DEPENDENCY MoveNursery
INCLUDING DEPENDENCY MoveStdlib
BUILDING Book Samples
Running Move unit tests
[debug] "Hello, World!"
[ PASS    ] 0x0::hello_world::test_is_hello_world
Test result: OK. Total tests: 1; passed: 1; failed: 0
</code></pre>
<p>Now every time the <code>hello_world</code> function is run in tests, you'll see the "Hello, World!" string in the output.</p>
<h2 id="correct-usage"><a class="header" href="#correct-usage">Correct usage</a></h2>
<p>Debug should only be used in local environment and never published on-chain. Usually, during the publish, the <code>debug</code> module is either removed from the package or the publishing fails with an error. There's no way to use this functionality on-chain.</p>
<h2 id="hint"><a class="header" href="#hint">Hint</a></h2>
<p>There's one trick that allows you to save some time while debugging. Instead of adding a module-level import, use a fully qualified function name. This way you don't need to add an import statement to the module, but you can still use the <code>debug::print</code> function:</p>
<pre><code class="language-Move">    std::debug::print(&amp;my_variable);
</code></pre>
<p>Be mindful that the value passed into debug should be a reference (the <code>&amp;</code> symbol in front of the variable name). If you pass a value, the compiler will emit an error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-documentation"><a class="header" href="#generating-documentation">Generating Documentation</a></h1>
<!--

- Generating Docs
    - why docs are important
    - copy-paste the example
    - describe doc comments and what can be commented
    - show the output of the doc command
    - give a hint on how to set up the CIs
    - running --doc in `sui move test`


 -->
<p>Move CLI has a built-in tool for generating documentation for Move modules. The tool is included into the binary and available out of the box. In this section we will learn how to generate documentation for our <code>hello_world</code> module.</p>
<h2 id="adding-documentation-comments"><a class="header" href="#adding-documentation-comments">Adding documentation comments</a></h2>
<p>To generate documentation for a module, we need to add documentation comments to the module and its functions. Documentation comments are written in Markdown and start with <code>///</code> (three slashes). For example, let's add a documentation comment to the <code>hello_world</code> module:</p>
<pre><code class="language-Move">/// This module contains a function that returns a string "Hello, World!".
module book::hello_world {
</code></pre>
<p>Doc comments placed above the module are linked to the module itself, while doc comments placed above the function are linked to the function.</p>
<pre><code class="language-Move">    /// As the name says: returns a string "Hello, World!".
    public fun hello_world(): String {
        string::utf8(b"Hello, World!")
    }
</code></pre>
<p>If a documented member has an attribute, such as <code>#[test]</code> in the example below, the doc comment must be placed <em>after</em> the attribute:</p>
<blockquote>
<p>While it is possible to document <code>#[test]</code> functions, doc comments for tests will not be included in the generated documentation.</p>
</blockquote>
<pre><code class="language-Move">    #[test]
    /// This is a test for the `hello_world` function.
    fun test_is_hello_world() {
        let expected = string::utf8(b"Hello, World!");
        let actual = hello_world();

        assert!(actual == expected, 0)
    }
</code></pre>
<h2 id="generating-documentation-1"><a class="header" href="#generating-documentation-1">Generating documentation</a></h2>
<p>To generate documentation for a module, we need to run the <code>sui move build</code> command with a <code>--doc</code> flag. Let's run the command:</p>
<pre><code class="language-bash">$ sui move build --doc
...
...
BUILDING Book Samples
</code></pre>
<blockquote>
<p>Alternatively, you can use <code>move test --doc</code> - this can be useful if you want to test and generate documentation at the same time. For example, as a part of your CI/CD pipeline.</p>
</blockquote>
<p>Once the build is complete, the documentation will be available in the <code>build/docs</code> directory. Each modile will have its own <code>.md</code> file. The documentation for the <code>hello_world</code> module will be available in the <code>build/docs/hello_world.md</code> file.</p>
<details>
<summary><a style="cursor: pointer">Click to see an example of the `hello_world.md` contents</a></summary>
<pre><code class="language-move">&lt;a name="0x0_hello_world"&gt;&lt;/a&gt;

# Module `0x0::hello_world`
This module contains a function that returns a string "Hello, World!".
-  [Function `hello_world`](#0x0_hello_world_hello_world)
&lt;pre&gt;&lt;code&gt;&lt;b&gt;use&lt;/b&gt; &lt;a href=""&gt;0x1::debug&lt;/a&gt;;
&lt;b&gt;use&lt;/b&gt; &lt;a href=""&gt;0x1::string&lt;/a&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;a name="0x0_hello_world_hello_world"&gt;&lt;/a&gt;

## Function `hello_world`
As the name says: returns a string "Hello, World!".
&lt;pre&gt;&lt;code&gt;&lt;b&gt;fun&lt;/b&gt; &lt;a href="hello_world.md#0x0_hello_world"&gt;hello_world&lt;/a&gt;(): &lt;a href="_String"&gt;string::String&lt;/a&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;details&gt;
&lt;summary&gt;Implementation&lt;/summary&gt;
&lt;pre&gt;&lt;code&gt;&lt;b&gt;fun&lt;/b&gt; &lt;a href="hello_world.md#0x0_hello_world"&gt;hello_world&lt;/a&gt;(): String {
    &lt;b&gt;let&lt;/b&gt; result = &lt;a href="_utf8"&gt;string::utf8&lt;/a&gt;(b"Hello, World!");
    &lt;a href="_print"&gt;debug::print&lt;/a&gt;(&amp;result);
    result
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>In this chapter you will learn about the basic concepts of Sui and Move. You will learn what is a package, how to interact with it, what is an account and a transaction, and how data is stored on Sui. While this chapter is not a complete reference, and you should refer to the <a href="https://docs.sui.io">Sui Documentation</a> for that, it will give you a good understanding of the basic concepts required to write Move programs on Sui.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages"><a class="header" href="#packages">Packages</a></h1>
<!--

    - packages and how they're stored
        - overview of packages and their contents (use a diagram)
        - how a package is created, and what it consists of
        - what is the package manifest
        - describe how "name" field is used
        - mention the "edition" field
        - what are the folders in a package and what are they for
        - how packages are imported (give Sui as an example)
        - what are addresses, and how they identify packages
        - how packages are published
        - leave a note that packages are also *upgradable*

-->
<p>Move is a language for writing smart contracts - programs that stored and run on the blockchain. A single program is organized into a package. A package is published on the blockchain and is identified by an <a href="concepts/./address.html">address</a>. A published package can be interacted with by sending <a href="concepts/./what-is-a-transaction.html">transactions</a> calling its functions. It can also act as a dependency for other packages.</p>
<blockquote>
<p>To create a new package, use the <code>sui move new</code> command.
To learn more about the command, run <code>sui move new --help</code>.</p>
</blockquote>
<p>Package consists of modules - separate scopes that contain functions, types, and other items.</p>
<pre><code>package 0x...
    module a
        struct A1
        fun hello_world()
    module b
        struct B1
        fun hello_package()
</code></pre>
<h2 id="package-structure"><a class="header" href="#package-structure">Package Structure</a></h2>
<p>Locally, a package is a directory with a <code>Move.toml</code> file and a <code>sources</code> directory. The <code>Move.toml</code> file - called the "package manifest" - contains metadata about the package, and the <code>sources</code> directory contains the source code for the modules. Packages usually looks like this:</p>
<pre><code>sources/
    my_module.move
    another_module.move
    ...
tests/
    ...
examples/
    using_my_module.move
Move.toml
</code></pre>
<p>The <code>tests</code> directory is optional and contains tests for the package. Code placed into the <code>tests</code> directory is not published on-chain and is only availably in tests. The <code>examples</code> directory can be used for code examples, and is also not published on-chain.</p>
<h2 id="published-package"><a class="header" href="#published-package">Published Package</a></h2>
<p>During development, package doesn't have an address and it needs to be set to <code>0x0</code>. Once a package is published, it gets a single unique <a href="concepts/./address.html">address</a> on the blockchain containing its modules' bytecode. A published package becomes <em>immutable</em> and can be interacted with by sending transactions.</p>
<pre><code>0x...
    my_module: &lt;bytecode&gt;
    another_module: &lt;bytecode&gt;
</code></pre>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="concepts/./package-manifest.html">Package Manifest</a></li>
<li><a href="concepts/./address.html">Address</a></li>
<li><a href="concepts/./../hello-sui/build-and-publish.html">Publishing a Package</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-manifest"><a class="header" href="#package-manifest">Package Manifest</a></h1>
<p>The <code>Move.toml</code> is a manifest file that describes the <a href="concepts/./packages.html">package</a> and its dependencies. It is written in <a href="https://toml.io/en/">TOML</a> format and contains multiple sections, the most important of which are <code>[package]</code>, <code>[dependencies]</code> and <code>[addresses]</code>.</p>
<pre><code class="language-toml">[package]
name = "my_project"
version = "0.0.0"
edition = "2024"

[dependencies]
Sui = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/testnet" }

[addresses]
std =  "0x1"
alice = "0xA11CE"

[dev-addresses]
alice = "0xB0B"
</code></pre>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<h3 id="package"><a class="header" href="#package">Package</a></h3>
<p>The <code>[package]</code> section is used to describe the package. None of the fields in this section are published on chain, but they are used in tooling and release management; they also specify the Move edition for the compiler.</p>
<ul>
<li><code>name</code> - the name of the package when it is imported;</li>
<li><code>version</code> - the version of the package, can be used in release management;</li>
<li><code>edition</code> - the edition of the Move language; currently, the only valid value is <code>2024</code>.</li>
</ul>
<!-- published-at -->
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p>The <code>[dependencies]</code> section is used to specify the dependencies of the project. Each dependency is specified as a key-value pair, where the key is the name of the dependency, and the value is the dependency specification. The dependency specification can be a git repository URL or a path to the local directory.</p>
<pre><code class="language-toml"># git repository
Sui = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/testnet" }

# local directory
MyPackage = { local = "../my-package" }
</code></pre>
<p>Packages also import addresses from other packages. For example, the Sui dependency adds the <code>std</code> and <code>sui</code> addresses to the project. These addresses can be used in the code as aliases for the addresses.</p>
<h3 id="resolving-version-conflicts-with-override"><a class="header" href="#resolving-version-conflicts-with-override">Resolving version conflicts with override</a></h3>
<p>Sometimes dependencies have conflicting versions of the same package. For example, if you have two dependencies that use different versions of the Sui package, you can override the dependency in the <code>[dependencies]</code> section. To do so, add the <code>override</code> field to the dependency. The version of the dependency specified in the <code>[dependencies]</code> section will be used instead of the one specified in the dependency itself.</p>
<pre><code class="language-toml">[dependencies]
Sui = { override = true, git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/testnet" }
</code></pre>
<h3 id="dev-dependencies"><a class="header" href="#dev-dependencies">Dev-dependencies</a></h3>
<p>It is possible to add <code>[dev-dependencies]</code> section to the manifest. It is used to override dependencies in the dev and test modes. For example, if you want to use a different version of the Sui package in the dev mode, you can add a custom dependency specification to the <code>[dev-dependencies]</code> section.</p>
<h3 id="addresses"><a class="header" href="#addresses">Addresses</a></h3>
<p>The <code>[addresses]</code> section is used to add aliases for the addresses. Any address can be specified in this section, and then used in the code as an alias. For example, if you add <code>alice = "0xA11CE"</code> to this section, you can use <code>alice</code> as <code>0xA11CE</code> in the code.</p>
<h3 id="dev-addresses"><a class="header" href="#dev-addresses">Dev-addresses</a></h3>
<p>The <code>[dev-addresses]</code> section is the same as <code>[addresses]</code>, but only works for the test and dev modes. Important to note that it is impossible to introduce new aliases in this section, only override the existing ones. So in the example above, if you add <code>alice = "0xB0B"</code> to this section, the <code>alice</code> address will be <code>0xB0B</code> in the test and dev modes, and <code>0xA11CE</code> in the regular build.</p>
<h2 id="toml-styles"><a class="header" href="#toml-styles">TOML styles</a></h2>
<p>The TOML format supports two styles for tables: inline and multiline. The examples above are using the inline style, but it is also possible to use the multiline style. You wouldn't want to use it for the <code>[package]</code> section, but it can be useful for the dependencies.</p>
<pre><code class="language-toml"># Inline style
[dependencies]
Sui = { override = true, git = "", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/testnet" }
MyPackage = { local = "../my-package" }
</code></pre>
<pre><code class="language-toml"># Multiline style
[dependencies.Sui]
override = true
git = "https://github.com/MystenLabs/sui.git"
subdir = "crates/sui-framework/packages/sui-framework"
rev = "framework/testnet"

[dependencies.MyPackage]
local = "../my-package"
</code></pre>
<h2 id="links-1"><a class="header" href="#links-1">Links</a></h2>
<ul>
<li><a href="https://move-language.github.io/move/packages.html">Packages in the Move Documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addresses-1"><a class="header" href="#addresses-1">Addresses</a></h1>
<!--

Chapter: Concepts
Goal: explain locations and addresses
Notes:
    - don't talk about the type
    - packages, accounts and objects are identified by addresses
    - addresses are 32 bytes long
    - addresses are unique
    - represented as hex strings (64 characters) prefixed with 0x
    - addresses are case insensitive

Links:
    - address type


- mention what an address is, because it identifies a package
    - address is used for packages, objects, and accounts
    - address is a 32-byte value
    - address is written in hexadecimal notation
    - don't describe the type yet
    - focus on the concept of address on blockchain and on Sui in particular

 -->
<p>Address is a unique identifier of a location on the blockchain. It is used to identify <a href="concepts/./packages.html">packages</a>, <a href="concepts/./what-is-an-account.html">accounts</a>, and <a href="concepts/./object-storage.html">objects</a>. Address has a fixed size of 32 bytes and is usually represented as a hexadecimal string prefixed with <code>0x</code>. Addresses are case insensitive.</p>
<pre><code class="language-move">0xe51ff5cd221a81c3d6e22b9e670ddf99004d71de4f769b0312b68c7c4872e2f1
</code></pre>
<p>The address above is an example of a valid address. It is 64 characters long (32 bytes) and is prefixed with <code>0x</code>.</p>
<p>Sui also has reserved addresses that are used to identify standard packages and objects. Reserved addresses are typically simple values that are easy to remember and type. For example, the address of the Standard Library is <code>0x1</code>. Addresses, shorter than 32 bytes, are padded with zeros to the left.</p>
<pre><code class="language-move">0x1 = 0x0000000000000000000000000000000000000000000000000000000000000001
</code></pre>
<p>Here are some examples of reserved addresses:</p>
<ul>
<li><code>0x1</code> - address of the Sui Standard Library (alias <code>std</code>)</li>
<li><code>0x2</code> - address of the Sui Framework (alias <code>sui</code>)</li>
<li><code>0x5</code> - address of the Sui System object</li>
<li><code>0x6</code> - address of the system Clock object</li>
<li><code>0x403</code> - address of the DenyList system object</li>
</ul>
<h2 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h2>
<ul>
<li><a href="concepts/../basic-syntax/address.html">Address type</a> in Move</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module"><a class="header" href="#module">Module</a></h1>
<!--

- then the modules, where they're stored and how they're published
    - package consists of modules
    - modules are stored in the sources directory
    - there can be any number of modules in a package
    - modules can be stored at any path under sources
    - there can be other folders storing tests and examples
    - compiler protects non-sources modules from being published
    - module definition and path
    - module members are accessed via a path

 -->
<p>Module is the basic unit of organization in a package. A module is a separate scope that contains functions, types, and other items. A package consists of one or more modules.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-a-package"><a class="header" href="#interacting-with-a-package">Interacting with a Package</a></h1>
<p>Accounts interact with the blockchain by sending <a href="concepts/./what-is-a-transaction.html">transactions</a>. Transactions can call functions in a package, and can also deploy new packages. On Sui, a single transaction can contain multiple operations, we call them "commands". A command can be a call to a function, a deployment of a new package, upgrade of an existing one, or a combination of these. Commands can return values, which can be used in subsequent commands.</p>
<!--
    Add an overview of types of transactions
    Give a schematic example of a transaction
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="account"><a class="header" href="#account">Account</a></h1>
<!--

- user is an account
    - account is identified by an address
    - account is generated from a private key
    - account can own objects
    - account can send transactions
    - every transaction has a sender
    - sender is identified by an address
    - sui cryptographic agility
    - sui account types
    - supported curves: ed25519, secp256k1, zklogin

 -->
<p>An account is a way to identify a user. An account is generated from a private key, and is identified by an address. An account can own objects, and can send transactions. Every transaction has a sender, and the sender is identified by an <a href="concepts/./address.html">address</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction"><a class="header" href="#transaction">Transaction</a></h1>
<p>Transaction is a fundamental concept in the blockchain world. It is a way to interact with a blockchain. Transactions are used to change the state of the blockchain, and they are the only way to do so. In Move, transactions are used to call functions in a package, deploy new packages, and upgrade existing ones.</p>
<!--

- how user interacts with a program
    - mention public functions
    - give a concept of an entry / public function without getting into details
    - mention that functions are called in transactions
    - mention that transactions are sent by accounts
    - every transaction specifies object it operates on

 -->
<h2 id="transaction-structure"><a class="header" href="#transaction-structure">Transaction Structure</a></h2>
<p>Transactions consist of:</p>
<ul>
<li>a sender - the account that <em>signs</em> the transaction</li>
<li>a list (or a chain) of commands - the operations to be executed</li>
<li>command inputs - the arguments for the commands</li>
<li>a gas object - the object used to pay for the transaction</li>
<li>gas price and budget - the cost of the transaction</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-model"><a class="header" href="#object-model">Object Model</a></h1>
<!--

- now objects?
    - Sui does not have global storage
    - storage is split into a pool of objects
    - objects are identified by a 32-byte value
    - objects are stored in the blockchain storage
    - focus on infrastructure properties of objects

 -->
<p>Sui does not have global storage. Instead, storage is split into a pool of objects. Some of the objects are owned by accounts and available only to them, and some are <em>shared</em> and can be accessed by anyone on the network. There's also a special kind of <em>shared immutable</em> objects, also called <em>frozen</em>, which can't be modified, and act as public chain-wide constants.</p>
<p>Each object has a unique 32-byte identifier - UID, it is used to access and reference the object.</p>
<!-- TODO: better intro -->
<p>Sui object consists of:</p>
<ul>
<li>UID - 32-byte unique identifier (address)</li>
<li>Type - Move type with the <code>key</code> ability</li>
<li>Owner - can be <code>shared</code>, <code>account_address</code>, <code>object_owner</code> or <code>immutable</code></li>
<li>Digest - hash of the object's content</li>
<li>Version - acts as a nonce</li>
<li>Content - the actual data represented as BCS</li>
</ul>
<!--

    - UID is also an address
    - Object has an owner field which can be w`shared`, `account_address`, `object_owner` or `immutable`.
    - Object has a version which acts as a nonce - hence Sui does not require an account nonce
    - Object has a Move type with the `key` ability
    - Object has a digest which is a hash of the object's content
    - Object has a content field which is the actual data represented as BCS

    - Reentrancy protection is built into the object model, and account can execute txs in parallel
      if they don't modify the same object

 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-sui-app"><a class="header" href="#your-first-sui-app">Your First Sui App</a></h1>
<!-- REDO chapter after we've improved CLI -->
<p>In this chapter we illustrate the concepts of Sui by building a simple application. Unlike the <a href="hello-sui/../hello-world/README.html">Hello World</a> example which aims to illustrate Move Compiler, this application is focused on Sui specifics. It is also more complex - it uses <a href="hello-sui/./../concepts/object-model.html">objects</a>, and we will publish and use it on Sui.</p>
<p>The goal of this mini-project is to demonstrate the process of building, testing, and publishing a Sui application. The result is a simple but complete application that you can use as a starting point for your projects or as a playground to experiment with Sui as you learn.</p>
<p>The chapter is split into the following parts (in order):</p>
<ul>
<li><a href="hello-sui/./hello-sui.html">Hello Sui!</a></li>
<li><a href="hello-sui/./build-and-publish.html">Build and Publish</a></li>
<li><a href="hello-sui/./testing.html">Testing</a></li>
</ul>
<p>Additionally, there's a section with ideas for further development of the application which you may get back to as you progress through the book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-sui"><a class="header" href="#hello-sui">Hello Sui!</a></h1>
<p>Just like we did with the <a href="hello-sui/../your-first-move/hello-world.html">Hello World</a> example, we will start by initializing a new package using the Sui CLI, then we will implement a simple application that creates a "Postcard" - a digital postcard that can be sent to a friend.</p>
<h2 id="create-a-new-sui-package"><a class="header" href="#create-a-new-sui-package">Create a new Sui package</a></h2>
<p>Sui packages are no different to regular Move packages, and can be initialized using the <code>sui</code> CLI. The following command will create a new package called <code>postcard</code>:</p>
<pre><code class="language-bash">$ sui new postcard
</code></pre>
<p>This will create a new directory called <code>postcard</code> with the following structure:</p>
<pre><code class="language-plaintext">postcard
├── Move.toml
├── src/
│   └── postcard.move
└── tests/
    └── postcard_tests.move
</code></pre>
<p>The package manifest - <code>Move.toml</code> - already contains all required dependencies for Sui, and the <code>src/postcard.move</code> file is pre-created with a simple module layout.</p>
<blockquote>
<p>In case the <code>Move.toml</code> file does not feature the <code>edition</code> field, please, add it manually. The <code>edition</code> field under the <code>[package]</code> section should be set to <code>2024.beta</code>.</p>
<p>Like this: <code>edition = "2024.beta"</code></p>
</blockquote>
<h2 id="implement-the-postcard-application"><a class="header" href="#implement-the-postcard-application">Implement the Postcard application</a></h2>
<p>The Postcard application will be a simple module that defines an <a href="hello-sui/./../concepts/object-model.html">object</a>, and a set of functions to create, modify and send the postcard to any <a href="hello-sui/./../concepts/address.html">address</a>.</p>
<p>Let's start by inserting the code. Replace the contents of the <code>src/postcard.move</code> file with the following:</p>
<pre><code class="language-move">module postcard::postcard {
    use std::string::String;

    use fun sui::object::new as TxContext.fresh_uid;

    /// The Postcard object.
    public struct Postcard has key {
        /// The unique identifier of the Object.
        /// Created using the `object::new()` function.
        id: UID,
        /// The message to be printed on the gift card.
        message: String,
    }

    /// Create a new Postcard with a message.
    public fun new(message: String, ctx: &amp;mut TxContext): Postcard {
        Postcard {
            id: ctx.fresh_uid(),
            message,
        }
    }

    /// Send the Postcard to the specified address.
    public fun send_to(card: Postcard, to: address) {
        transfer::transfer(card, to)
    }

    /// Keep the Postcard for yourself.
    public fun keep(card: Postcard, ctx: &amp;TxContext) {
        transfer::transfer(card, ctx.sender())
    }

    /// Update the message on the Postcard.
    public fun update(card: &amp;mut Postcard, message: String) {
        card.message = message
    }
}
</code></pre>
<p>To make sure that everything is working as expected, run this command:</p>
<pre><code class="language-bash">$ sui move build
</code></pre>
<p>You should see this output, indicating that the package was built successfully. There shouldn't be any errors following the <code>BUILDING postcard</code> line:</p>
<pre><code class="language-plaintext">&gt; $ sui move build
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING postcard
</code></pre>
<p>If you do see errors, please, double check the code and the steps you've taken to create the package. It's very likely a typo in one of the commands.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next steps</a></h2>
<p><a href="hello-sui/./module-structure.html">In the next section</a> we will take a closer look at the structure of the <code>postcard.move</code> file and explain the code we've just inserted. We will also discuss the imports and the object definition in more detail.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-objects"><a class="header" href="#using-objects">Using Objects</a></h1>
<p>Let's take a look at the code we've inserted into the <code>postcard.move</code> file. We will discuss the structure of the module and the code in more detail, and explain the way the <code>Postcard</code> object is created, used and stored.</p>
<h2 id="module-1"><a class="header" href="#module-1">Module</a></h2>
<p>First line of the file is the module declaration. The address of the module is <code>package</code> - a name defined in the <code>Move.toml</code> file. The module name is also <code>postcard</code>. The module body is enclosed in curly braces <code>{}</code>.</p>
<pre><code class="language-move">module postcard::postcard {
</code></pre>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<p>In the top of the module we import <a href="hello-sui/./../basic-syntax/string.html">String</a> type from the <a href="hello-sui/./../basic-syntax/standard-library.html">Standard Library</a> (std). The rest of the types used in this module are <em>implicitly imported</em> from the <a href="hello-sui/./../programmability/sui-framework.html">Sui Framework</a>.</p>
<pre><code class="language-move">    use std::string::String;
</code></pre>
<h2 id="postcard-is-an-object"><a class="header" href="#postcard-is-an-object">Postcard is an Object</a></h2>
<p>A public struct <code>Postcard</code>, that goes after imports, is an object. A struct with the <code>key</code> ability is an object on Sui. As such, its first field must be <code>id</code> of type <code>UID</code> (that we imported from the Sui Framework). The <code>id</code> field is the unique identifier and an <a href="hello-sui/../concepts/address.html">address</a> of the object.</p>
<!-- TODO: better wording -->
<pre><code class="language-move">    /// The Postcard object.
    public struct Postcard has key {
        /// The unique identifier of the Object.
        /// Created using the `object::new()` function.
        id: UID,
        /// The message to be printed on the gift card.
        message: String,
    }
</code></pre>
<h2 id="creating-an-object"><a class="header" href="#creating-an-object">Creating an Object</a></h2>
<p>Sui has <a href="hello-sui/./../concepts/object-model.html">no global storage</a>, and the objects are stored independently of their package. This is why we defined a single <code>Postcard</code> and not a collection "Postcards". Objects have to be created and stored in the storage before they can be used.</p>
<p>The <code>new</code> function is a public function that creates a new instance of the <code>Postcard</code> object and returns it to the caller. It takes two arguments: the message of type <code>String</code>, which is the message on the postcard, and the <code>ctx</code> of type <code>TxContext</code>, a standard type that is automatically inserted by the Sui runtime.</p>
<pre><code class="language-move">    /// Create a new Postcard with a message.
    public fun new(message: String, ctx: &amp;mut TxContext): Postcard {
        Postcard {
            id: ctx.fresh_uid(),
            message,
        }
    }
</code></pre>
<p>When initializing an instance of <code>Postcard</code> we pass the fields of the struct as arguments, the <code>id</code> is generated from the <code>TxContext</code> argument via the <code>ctx.fresh_uid()</code> call. And the <code>message</code> is taken as-is from the <code>message</code> argument.</p>
<h2 id="sending-a-postcard"><a class="header" href="#sending-a-postcard">Sending a Postcard</a></h2>
<p>Objects can't be ignored, so when the function <code>new</code> is called, the returned <code>Postcard</code> needs to be stored. And here's when the <code>sui::transfer</code> module comes into play. The <code>sui::transfer::transfer</code> function is used to store the object at the specified address.</p>
<pre><code class="language-move">    /// Send the Postcard to the specified address.
    public fun send_to(card: Postcard, to: address) {
        transfer::transfer(card, to)
    }
</code></pre>
<p>The function takes the <code>Postcard</code> as the first argument and a value of the <code>address</code> type as the second argument. Both are passed into the <code>transfer</code> function to send — and hence, store — the object to the specified address.</p>
<h2 id="keeping-the-object"><a class="header" href="#keeping-the-object">Keeping the Object</a></h2>
<p>A very common scenario is transfering the object to the caller. This can be done by calling the <code>send_to</code> function with the sender address. It can be read from the <code>ctx</code> argument, which is a <code>TxContext</code> type.</p>
<pre><code class="language-move">    /// Keep the Postcard for yourself.
    public fun keep(card: Postcard, ctx: &amp;TxContext) {
        transfer::transfer(card, ctx.sender())
    }
</code></pre>
<h2 id="updating-the-object"><a class="header" href="#updating-the-object">Updating the Object</a></h2>
<p>The <code>update</code> function is another public function that takes a mutable reference to the <code>Postcard</code> and a <code>String</code> argument. It updates the <code>message</code> field of the <code>Postcard</code>. Because the <code>Postcard</code> is passed by a reference, the owner is not changed, and the object is not moved.</p>
<pre><code class="language-move">    /// Update the message on the Postcard.
    public fun update(card: &amp;mut Postcard, message: String) {
        card.message = message
    }
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next steps</a></h2>
<p>In the next section we will write a simple test for the <code>Postcard</code> module to see how it works. Later we will publish the package on Sui DevNet and learn how to use the Sui CLI to interact with the package.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax</a></h1>
<p>This chapter is all about the basic syntax of the Move language. It covers the basics of the language, such as types, modules, functions, and control flow. It focuses on the language without a storage model or a blockchain, and explains the essential concepts of the language.</p>
<!--


    This is an attempt to structure the narrative in a way that makes sense, and so that it builds
    up to the next section.

    Then why would we give "The first Move section" ?
        - it's great to give a taste of Move overall, without linking it to storage / specific blockchain
        - maybe it can be confusing; though if we call the first section "Hello Move", and the second
          "Hello Sui", then the reader would differentiate between the two
        // marking the above as an open question for now



    Introduction

    Foreword
        - this book is a product of collaboration between people who love Move and
          education and people who are incredibly smart and build the language

    What is Sui

    Setting Up the Environment
        - Install Sui
        - Set up your IDE
        - Project Setup         ??? not sure about this one
        - Manifest              ??? this one is also not sure

    Your First Move
        // goal: showcase main features of the CLI / compiler
        // note: this section is not about Sui, but about Move; it is interactive and
                can be run by anyone to get a taste of Move as a language and Sui CLI
                as a tool; it's pretty neat that Move has tests, and that there's a
                documentation generator, and that there's a way to debug the code;






 -->
<!--

The `name` field contains the name of the package. It is not a published name, but a name of the package when it is imported by other packages. The `edition` field contains the edition of the Move language, the "2024" edition is the most recent one. The `dependencies` section contains package dependencies. To run meaningful applications on Sui, you need to have the `Sui` package as a dependency.

The addresses section contains named aliases for addresses. Not yet published package always has the address `0x0`, but when it is published, the address should be changed to the actual address. Compiler will replace the aliases with the actual addresses when compiling the package. -->
<!-- This is a good example for why the book format is great -->
<!-- For convenience and readability, addresses section should contain at least one alias for the package address. It allows you to use the alias instead of the address when you need to access the package; it also splits the configuration and code, allowing you to change the value in one place. For example, instead of `0x0::module::member` you can use `book::module::member`.

Package is imported with its addresses - the `Sui` import will add `sui` and `std` aliases. They're standard aliases for Sui Framework - 0x2, and Standard Library - 0x1. -->
<!-- ## Module

While package can be considered an organizational unit, module is where the code lives. Module is a collection of functions, types, constants and other items. Module is declared with the `module` keyword:


The module declaration consists of the `module` keyword followed by the module path - a package address and a module name separated by `::`. The module path is followed by the module body - a collection of items inside curly braces `{}`. The module body is a scope, and all items inside it are inaccesible from outside the module by default.

Modules are stored in the `sources` directory (and its subdirectories). File system path doesn't affect the module path and will be omitted when publishing, so the module path is `book::my_module` regardless of the file system path. For example, if you have a directory structure like this:

```
sources/
    basics/
        my/
            module.move
Move.toml
```

The module path will be `book::my_module`, and **not** `book::basics::my::module`.

Modules can import other modules and access public functions and types. The dependency needs to be declared in the package manifest, so that the compiler knows where to find it. We will learn more about imports in the [Import](../basic-syntax/import.md) section.

Directories other than `sources` will not be compiled by default and hence won't be published. You can use them to store tests, documentation, examples, and other files. Though all folders are scanned when compiling in "test mode", so examples and tests can be checked for compilation errors.

Modules compiled in test mode won't be published, so there's no way to make a mistake publishing what wasn't meant to be published.

## Interaction with the blockchain

Function is a block of code that contains a sequence of statements and expressions. Function can take arguments and return a value. Function is declared with the `fun` keyword.


Like any module member, functions are accessed via a path. The path consists of the module path and the function name separated by `::`. For example, if you have a function called `my_function` in the `my_module` module in the `book` package, the path to it will be `book::my_module::my_function`.

Functions can be called in a transaction. User can send a transaction containing a call to a function, and the function will be executed on the blockchain. We will learn more about transactions in the [Transaction](../basic-syntax/transaction.md) section. Any public function can be called in a transaction.

So, if we made the `my_function` public, we can call it in a transaction:

To call it, a user would need to send a transaction containing a "move-call", which would roughly look like this:

```bash
sui client call \
    --package 0x... \
    --module book::my_module \
    --function my_function \
    --gas-budget 10000000
```

Having said that, Move modules define the interface of the package. For example, if there's a need to implement a database-like system with addition, modification and deletion of records, the module would define a matching set of functions. And users would be able to call those functions in transactions.

## Storage

Move is an object-oriented language, and as such, it stores data in objects. Objects are instances of types with the `key` ability and are stored in the blockchain storage. Every Object has a `UID` - a unique identifier that is used to access the object. The `UID` is a 32-byte value, and it is generated when the object is created. The internal value of the UID also contains an address.

> Package is also an immutable (unchangeable) object stored in the blockchain storage. However, it is a special case, and can't be used to store data except for the package bytecode.

## Accounts

Accounts are the main way to interact with the blockchain. Accounts are identified by addresses and can send transactions to the blockchain. An account is generated from a private key, and the private key is used to sign transactions. Every account has a standard 32-byte address.

Every transaction has a sender - an account that signed the transaction. The sender is identified by their address. Accounts can own objects

## End to end example

<!--
    After we explained the basics of the code organization. I think it makes sense to give an example,
    Rust Book does it. It's a good way to show how the code is organized and how it works. And it will
    leave the reader with something to play with.

    So that when we get to the next section, they will be able to modify the code and see how it works.
    And it will be a good way to introduce the next section.

    The example should be simple and short. It should be something that can be explained in a few
    sentences. It should be something that can be modified and played with. It should be something
    that can be used as a base for the next section.

    Maybe that's the point where we introduce objects and storage? They won't appear any time soon, but
    some bits can be illustrated upfront to create this anticipation for what is possible.
-->
<!-- ## Getting Ready

Now that we know what a package, account and storage are, let's get to the basics and learn to write some code.

This section covers:

- types
- functions
- structs
- constants
- control flow
- tests -->
<!-- TODO: rewrite the intro for the chapter -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="module-2"><a class="header" href="#module-2">Module</a></h1>
<!--

Chapter: Base Syntax
Goal: Introduce module keyword.
Notes:
    - modules are the base unit of code organization
    - module members are private by default
    - types internal to the module have special access rules
    - only module can pack and unpack its types

 -->
<p>Module is the base unit of code organization in Move. Modules are used to group and isolate code, and all of the members of the module are private to the module by default. In this section you will learn how to define a module, how to declare its members and how to access them from other modules.</p>
<h2 id="module-declaration"><a class="header" href="#module-declaration">Module declaration</a></h2>
<p>Modules are declared using the <code>module</code> keyword followed by the package address, module name and the module body inside the curly braces <code>{}</code>. The module name should be in <code>snake_case</code> - all lowercase letters with underscores between words. Modules names must be unique in the package.</p>
<p>Usually, a single file in the <code>sources/</code> folder contains a single module. The file name should match the module name - for example, a <code>donut_shop</code> module should be stored in the <code>donut_shop.move</code> file. You can read more about coding conventions in the <a href="basic-syntax/../special-topics/coding-conventions.html">Coding Conventions</a> section.</p>
<pre><code class="language-Move">module book::my_module {
    // module body
}
</code></pre>
<p>Structs, functions and constants, imports and friend declarations are all part of the module:</p>
<ul>
<li><a href="basic-syntax/./struct.html">Structs</a></li>
<li><a href="basic-syntax/./function.html">Functions</a></li>
<li><a href="basic-syntax/./constants.html">Constants</a></li>
<li><a href="basic-syntax/./importing-modules.html">Imports</a></li>
<li><a href="basic-syntax/">Friend declarations</a> <!-- TODO --></li>
<li><a href="basic-syntax/./struct-methods.html">Method Aliases</a></li>
</ul>
<h2 id="address--named-address"><a class="header" href="#address--named-address">Address / Named address</a></h2>
<p>Module address can be specified as both: an address <em>literal</em> (does not require the <code>@</code> prefix) or a named address specified in the <a href="basic-syntax/../concepts/package-manifest.html">Package Manifest</a>. In the example below, both are identical because there's a <code>book = "0x0"</code> record in the <code>[addresses]</code> section of the <code>Move.toml</code>.</p>
<pre><code class="language-Move">module 0x0::address_literal_example {
    // module body
}
</code></pre>
<p>Addresses section in the Move.toml:</p>
<pre><code class="language-toml"># Move.toml
[addresses]
book = "0x0"
</code></pre>
<h2 id="module-members"><a class="header" href="#module-members">Module members</a></h2>
<p>Module members are declared inside the module body. To illustrate that, let's define a simple module with a struct, a function and a constant:</p>
<pre><code class="language-Move">module book::my_module_with_members {
    // import
    use book::my_module;

    // friend declaration
    friend book::constants;

    // a constant
    const CONST: u8 = 0;

    // a struct
    public struct Struct {}

    // method alias
    public use fun function as Struct.struct_fun;

    // function
    fun function(_: &amp;Struct) { /* function body */ }
}
</code></pre>
<h2 id="address-block"><a class="header" href="#address-block">Address block</a></h2>
<p>Before the introduction of the <code>address::module_name</code> syntax, modules were organized into <code>address {}</code> blocks. This way of code organization is still available today, but is not used widely. Modern practices imply having a single module per file, so the <code>address {}</code> block is rather a redundant construct.</p>
<blockquote>
<p>Module addresses can be omitted if modules are organized into <code>address {}</code> blocks.</p>
</blockquote>
<pre><code class="language-Move">address book { // address block

module another_module {
    // module body
}

module yet_another_module {
    // module body
}
}
</code></pre>
<p>The modules defined in this code sample will be accessible as:</p>
<ul>
<li><code>book::another_module</code></li>
<li><code>book::yet_another_module</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<!--

Chapter: Basic Syntax
Goal: Introduce comments.
Notes:
    - doc comments are used in docgen
    - only public members are documented
    - doc comments are placed in between attributes and the definition
    - doc comments are allowed for: modules, structs, functions, constants
    - give an example of how doc comments are translated
 -->
<p>Comments are a way to add notes or document your code. They are ignored by the compiler and don't result in the Move bytecode. You can use comments to explain what your code does, to add notes to yourself or other developers, to temporarily remove a part of your code, or to generate documentation. There are three types of comments in Move: line comment, block comment, and doc comment.</p>
<h2 id="line-comment"><a class="header" href="#line-comment">Line comment</a></h2>
<pre><code class="language-Move">module book::comments_line {
    fun some_function() {
        // this is a comment line
    }
}
</code></pre>
<p>You can use double slash <code>//</code> to comment out the rest of the line. Everything after <code>//</code> will be ignored by the compiler.</p>
<pre><code class="language-Move">module book::comments_line_2 {
    // let's add a note to everything!
    fun some_function_with_numbers() {
        let a = 10;
        // let b = 10 this line is commented and won't be executed
        let b = 5; // here comment is placed after code
        a + b; // result is 15, not 10!
    }
}
</code></pre>
<h2 id="block-comment"><a class="header" href="#block-comment">Block comment</a></h2>
<p>Block comments are used to comment out a block of code. They start with <code>/*</code> and end with <code>*/</code>. Everything between <code>/*</code> and <code>*/</code> will be ignored by the compiler. You can use block comments to comment out a single line or multiple lines. You can even use them to comment out a part of a line.</p>
<pre><code class="language-Move">module book::comments_block {
    fun /* you can comment everywhere */ go_wild() {
        /* here
           there
           everywhere */ let a = 10;
        let b = /* even here */ 10; /* and again */
        a + b;
    }
    /* you can use it to remove certain expressions or definitions
    fun empty_commented_out() {

    }
    */
}
</code></pre>
<p>This example is a bit extreme, but it shows how you can use block comments to comment out a part of a line.</p>
<h2 id="doc-comment"><a class="header" href="#doc-comment">Doc comment</a></h2>
<p>Documentation comments are special comments that are used to generate documentation for your code. They are similar to block comments, but they start with three slashes <code>///</code> and are placed before the definition of the item they document.</p>
<pre><code class="language-Move">/// Module has documentation!
module book::comments_doc {

    /// This is a 0x0 address constant!
    const AN_ADDRESS: address = @0x0;

    /// This is a struct!
    public struct AStruct {
        /// This is a field of a struct!
        a_field: u8,
    }

    /// This function does something!
    /// And it's documented!
    fun do_something() {}
}
</code></pre>
<!-- TODO: docgen, which members are in the documentation -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<!-- TODO: Shall we split this into two pages? Maybe give an overview and focus more on specifics? -->
<p>For simple values, Move has a number of built-in primitive types. They're the base that makes up all other types. The primitive types are:</p>
<ul>
<li><a href="basic-syntax/primitive-types.html#booleans">Booleans</a></li>
<li><a href="basic-syntax/primitive-types.html#integers">Unsigned Integers</a></li>
<li><a href="basic-syntax/./address.html">Address</a> - covered in the next section</li>
</ul>
<p>However, before we get to the types, let's first look at how to declare and assign variables in Move.</p>
<h2 id="variables-and-assignment"><a class="header" href="#variables-and-assignment">Variables and assignment</a></h2>
<p>Variables are declared using the <code>let</code> keyword. They are immutable by default, but can be made mutable using the <code>let mut</code> keyword. The syntax for the <code>let mut</code> statement is:</p>
<pre><code>let &lt;variable_name&gt;[: &lt;type&gt;]  = &lt;expression&gt;;
let mut &lt;variable_name&gt;[: &lt;type&gt;] = &lt;expression&gt;;
</code></pre>
<p>Where:</p>
<ul>
<li><code>&lt;variable_name&gt;</code> - the name of the variable</li>
<li><code>&lt;type&gt;</code> - the type of the variable, optional</li>
<li><code>&lt;expression&gt;</code> - the value to be assigned to the variable</li>
</ul>
<pre><code class="language-move">let x: bool = true;
let mut y: u8 = 42;
</code></pre>
<p>A mutable variable can be reassigned using the <code>=</code> operator.</p>
<pre><code class="language-move">y = 43;
</code></pre>
<p>Variables can also be shadowed by re-declaring.</p>
<pre><code class="language-move">let x: u8 = 42;
let x: u8 = 43;
</code></pre>
<h2 id="booleans"><a class="header" href="#booleans">Booleans</a></h2>
<p>The <code>bool</code> type represents a boolean value - yes or no, true or false. It has two possible values: <code>true</code> and <code>false</code> which are keywords in Move. For booleans, there's no need to explicitly specify the type - the compiler can infer it from the value.</p>
<pre><code class="language-move">let x = true;
let y = false;
</code></pre>
<p>Booleans are often used to store flags and to control the flow of the program. Please, refer to the <a href="basic-syntax/./control-flow.html">Control Flow</a> section for more information.</p>
<h2 id="integer-types"><a class="header" href="#integer-types">Integer Types</a></h2>
<p>Move supports unsigned integers of various sizes: from 8-bit to 256-bit. The integer types are:</p>
<ul>
<li><code>u8</code> - 8-bit</li>
<li><code>u16</code> - 16-bit</li>
<li><code>u32</code> - 32-bit</li>
<li><code>u64</code> - 64-bit</li>
<li><code>u128</code> - 128-bit</li>
<li><code>u256</code> - 256-bit</li>
</ul>
<pre><code class="language-move">let x: u8 = 42;
let y: u16 = 42;
// ...
let z: u256 = 42;
</code></pre>
<p>Unlike booleans, integer types need to be inferred. In most of the cases, the compiler will infer the type from the value, usually defaulting to <code>u64</code>. However, sometimes the compiler is unable to infer the type and will require an explicit type annotation. It can either be provided during assignment or by using a type suffix.</p>
<pre><code class="language-move">// Both are equivalent
let x: u8 = 42;
let x = 42u8;
</code></pre>
<h3 id="operations"><a class="header" href="#operations">Operations</a></h3>
<p>Move supports the standard arithmetic operations for integers: addition, subtraction, multiplication, division, and remainder. The syntax for these operations is:</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Operation</th><th>Aborts If</th></tr></thead><tbody>
<tr><td>+</td><td>addition</td><td>Result is too large for the integer type</td></tr>
<tr><td>-</td><td>subtraction</td><td>Result is less than zero</td></tr>
<tr><td>*</td><td>multiplication</td><td>Result is too large for the integer type</td></tr>
<tr><td>%</td><td>modular division</td><td>The divisor is 0</td></tr>
<tr><td>/</td><td>truncating division</td><td>The divisor is 0</td></tr>
</tbody></table>
</div>
<p>The type of the operands <em>must match</em>, otherwise, the compiler will raise an error. The result of the operation will be of the same type as the operands. To perform operations on different types, the operands need to be cast to the same type.</p>
<!-- TODO: add examples + parentheses for arithmetic operations -->
<!-- TODO: add bitwise operators -->
<h3 id="casting-with-as"><a class="header" href="#casting-with-as">Casting with <code>as</code></a></h3>
<p>Move supports explicit casting between integer types. The syntax for it is:</p>
<pre><code class="language-move">(&lt;expression&gt; as &lt;type&gt;)
</code></pre>
<p>Note, that it requires parentheses around the expression to prevent ambiguity.</p>
<pre><code class="language-move">let x: u8 = 42;
let y: u16 = (x as u16);
</code></pre>
<p>A more complex example, preventing overflow:</p>
<pre><code class="language-move">let x: u8 = 255;
let y: u8 = 255;
let z: u16 = (x as u16) + ((y as u16) * 2);
</code></pre>
<h3 id="overflow"><a class="header" href="#overflow">Overflow</a></h3>
<p>Move does not support overflow / underflow, an operation that results in a value outside the range of the type will raise a runtime error. This is a safety feature to prevent unexpected behavior.</p>
<pre><code class="language-move">let x = 255u8;
let y = 1u8;

// This will raise an error
let z = x + y;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="address-type"><a class="header" href="#address-type">Address Type</a></h1>
<!--

Chapter: Basic Syntax
Goal: Introduce the address type
Notes:
    - a special type
    - named addresses via the Move.toml
    - address literals
    - 0x2 is 0x0000000...02

Links:
    - address concept
    - transaction context
    - Move.toml
    - your first move

 -->
<p>To represent <a href="basic-syntax/./../concepts/address.html">addresses</a>, Move uses a special type called <code>address</code>. It is a 32 byte value that can be used to represent any address on the blockchain. Addresses are used in two syntax forms: hexadecimal addresses prefixed with <code>0x</code> and named addresses.</p>
<pre><code class="language-move">// address literal
let value: address = @0x1;

// named address registered in Move.toml
let value = @std;
let other = @sui;
</code></pre>
<p>An address literal starts with the <code>@</code> symbol followed by a hexadecimal number or an identifier. The hexadecimal number is interpreted as a 32 byte value. The identifier is looked up in the <a href="basic-syntax/./../concepts/manifest.html">Move.toml</a> file and replaced with the corresponding address by the compiler. If the identifier is not found in the Move.toml file, the compiler will throw an error.</p>
<h2 id="conversion"><a class="header" href="#conversion">Conversion</a></h2>
<p>Sui Framework offers a set of helper functions to work with addresses. Given that the address type is a 32 byte value, it can be converted to a <code>u256</code> type and vice versa. It can also be converted to and from a <code>vector&lt;u8&gt;</code> type.</p>
<p>Example: Convert an address to a <code>u256</code> type and back.</p>
<pre><code class="language-move">use sui::address;

let addr_as_u256: u256 = address::to_u256(@0x1);
let addr = address::from_u256(addr_as_u256);
</code></pre>
<p>Example: Convert an address to a <code>vector&lt;u8&gt;</code> type and back.</p>
<pre><code class="language-move">use sui::address;

let addr_as_u8: vector&lt;u8&gt; = address::to_bytes(@0x1);
let addr = address::from_bytes(addr_as_u8);
</code></pre>
<p>Example: Convert an address into a string.</p>
<pre><code class="language-move">use sui::address;
use std::string::String;

let addr_as_string: String = address::to_string(@0x1);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expression"><a class="header" href="#expression">Expression</a></h1>
<p>In programming languages expression is a unit of code which returns a value, in Move, almost everything is an expression, - with the sole exception of <code>let</code> statement which is a declaration. In this section, we cover the types of expressions and introduce the concept of scope.</p>
<blockquote>
<p>Expressions are sequenced with semicolons <code>;</code>. If there's "no expression" after the semicolon, the compiler will insert an empty expression <code>()</code>.</p>
</blockquote>
<!-- ## Empty Expression

The very base of the expression is the empty expression. It is a valid expression that does nothing and returns nothing. An empty expression is written as empty parentheses `()`. It's rarely the case when you need to use an empty expression. The compiler automatically inserts empty expressions where needed, for example in an empty [Scope](#scope). Though, it may be helpful to know that it exists. Parentheses are also used to group expressions to control the order of evaluation.

```move
// variable `a` has no value;
let a;
```
-->
<h2 id="literals"><a class="header" href="#literals">Literals</a></h2>
<p>In the <a href="basic-syntax/./primitive-types.html">Primitive Types</a> section, we introduced the basic types of Move. And to illustrate them, we used literals. A literal is a notation for representing a fixed value in the source code. Literals are used to initialize variables and to pass arguments to functions. Move has the following literals:</p>
<ul>
<li><code>true</code> and <code>false</code> for boolean values</li>
<li><code>0</code>, <code>1</code>, <code>123123</code> or other numeric for integer values</li>
<li><code>0x0</code>, <code>0x1</code>, <code>0x123</code> or other hexadecimal for integer values</li>
<li><code>b"bytes_vector"</code> for byte vector values</li>
<li><code>x"0A"</code> HEX literal for byte values</li>
</ul>
<pre><code class="language-move">let b = true;     // true is a literal
let n = 1000;     // 1000 is a literal
let h = 0x0A;     // 0x0A is a literal
let v = b"hello"; // b'hello' is a byte vector literal
let x = x"0A";    // x'0A' is a byte vector literal
let c = vector[1, 2, 3]; // vector[] is a vector literal
</code></pre>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<p>Ariphmetic, logical, and bitwise operators are used to perform operations on values. The result of an operation is a value, so operators are also expressions.</p>
<pre><code class="language-move">let sum = 1 + 2;   // 1 + 2 is an expression
let sum = (1 + 2); // the same expression with parentheses
let is_true = true &amp;&amp; false; // true &amp;&amp; false is an expression
let is_true = (true &amp;&amp; false); // the same expression with parentheses
</code></pre>
<h2 id="blocks"><a class="header" href="#blocks">Blocks</a></h2>
<p>A block is a sequence of statements and expressions, and it returns the value of the last expression in the block. A block is written as a pair of curly braces <code>{}</code>. A block is an expression, so it can be used anywhere an expression is expected.</p>
<pre><code class="language-move">// block with an empty expression, however, the compiler will
// insert an empty expression automatically: `let none = { () }`
// let none = {};

// block with let statements and an expression.
let sum = {
    let a = 1;
    let b = 2;
    a + b // last expression is the value of the block
};

let none = {
    let a = 1;
    let b = 2;
    a + b // not returned - semicolon.
    // compiler automatically inserts an empty expression `()`
};
</code></pre>
<h2 id="function-calls"><a class="header" href="#function-calls">Function Calls</a></h2>
<p>We go into detail about functions in the <a href="basic-syntax/./functions.html">Functions</a> section. However, we already used function calls in the previous sections, so it's worth mentioning them here. A function call is an expression that calls a function and returns the value of the last expression in the function body.</p>
<pre><code class="language-move">fun add(a: u8, b: u8): u8 {
    a + b
}

#[test]
fun some_other() {
    let sum = add(1, 2); // add(1, 2) is an expression with type u8
}
</code></pre>
<h2 id="control-flow-expressions"><a class="header" href="#control-flow-expressions">Control Flow Expressions</a></h2>
<p>Control flow expressions are used to control the flow of the program. They are also expressions, so they return a value. We cover control flow expressions in the <a href="basic-syntax/./control-flow.html">Control Flow</a> section. Here's a very brief overview:</p>
<pre><code class="language-move">// if is an expression, so it returns a value; if there are 2 branches,
// the types of the branches must match.
if (bool_expr) expr1 else expr2;

// while is an expression, but it returns `()`.
while (bool_expr) { expr; };

// loop is an expression, but returns `()` as well.
loop { expr; break };
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-types-with-struct"><a class="header" href="#custom-types-with-struct">Custom Types with Struct</a></h1>
<p>Move type system shines when it comes to defining custom types. User defined types can be custom tailored to the specific needs of the application. Not just on the data level, but also in its behavior. In this section we introduce the struct definition and how to use it.</p>
<h2 id="struct"><a class="header" href="#struct">Struct</a></h2>
<p>To define a custom type, you can use the <code>struct</code> keyword followed by the name of the type. After the name, you can define the fields of the struct. Each field is defined with the <code>field_name: field_type</code> syntax. Field definitions must be separated by commas. The fields can be of any type, including other structs.</p>
<blockquote>
<p>Note: Move does not support recursive structs, meaning a struct cannot contain itself as a field.</p>
</blockquote>
<pre><code class="language-move">/// A struct representing an artist.
public struct Artist {
    /// The name of the artist.
    name: String,
}

/// A struct representing a music record.
public struct Record {
    /// The title of the record.
    title: String,
    /// The artist of the record. Uses the `Artist` type.
    artist: Artist,
    /// The year the record was released.
    year: u16,
    /// Whether the record is a debut album.
    is_debut: bool,
    /// The edition of the record.
    edition: Option&lt;u16&gt;,
}
</code></pre>
<p>In the example above, we define a <code>Record</code> struct with five fields. The <code>title</code> field is of type <code>String</code>, the <code>artist</code> field is of type <code>Artist</code>, the <code>year</code> field is of type <code>u16</code>, the <code>is_debut</code> field is of type <code>bool</code>, and the <code>edition</code> field is of type <code>Option&lt;u16&gt;</code>. The <code>edition</code> field is of type <code>Option&lt;u16&gt;</code> to represent that the edition is optional.</p>
<p>Structs are private by default, meaning they cannot be imported and used outside of the module they are defined in. Their fields are also private and can't be accessed from outside the module. See <a href="basic-syntax/./visibility.html">visibility</a> for more information on different visibility modifiers.</p>
<blockquote>
<p>A struct by default is <em>internal</em> to the module it is defined in.</p>
</blockquote>
<h2 id="create-and-use-an-instance"><a class="header" href="#create-and-use-an-instance">Create and use an instance</a></h2>
<p>We described how struct <em>definition</em> works. Now let's see how to initialize a struct and use it. A struct can be initialized using the <code>struct_name { field1: value1, field2: value2, ... }</code> syntax. The fields can be initialized in any order, and all of the fields must be set.</p>
<pre><code class="language-move">let mut artist = Artist {
    name: b"The Beatles".to_string()
};
</code></pre>
<p>In the example above, we create an instance of the <code>Artist</code> struct and set the <code>name</code> field to a string "The Beatles".</p>
<p>To access the fields of a struct, you can use the <code>.</code> operator followed by the field name.</p>
<pre><code class="language-move">// Access the `name` field of the `Artist` struct.
let artist_name = artist.name;

// Access a field of the `Artist` struct.
assert!(artist.name == string::utf8(b"The Beatles"), 0);

// Mutate the `name` field of the `Artist` struct.
artist.name = string::utf8(b"Led Zeppelin");

// Check that the `name` field has been mutated.
assert!(artist.name == string::utf8(b"Led Zeppelin"), 1);
</code></pre>
<p>Only module defining the struct can access its fields (both mutably and immutably). So the above code should be in the same module as the <code>Artist</code> struct.</p>
<h2 id="unpacking-a-struct"><a class="header" href="#unpacking-a-struct">Unpacking a struct</a></h2>
<p>Structs are non-discardable by default, meaning that the initiated struct value must be used: either stored or <em>unpacked</em>. Unpacking a struct means deconstructing it into its fields. This is done using the <code>let</code> keyword followed by the struct name and the field names.</p>
<pre><code class="language-move">// Unpack the `Artist` struct and create a new variable `name`
// with the value of the `name` field.
let Artist { name } = artist;
</code></pre>
<p>In the example above we unpack the <code>Artist</code> struct and create a new variable <code>name</code> with the value of the <code>name</code> field. Because the variable is not used, the compiler will raise a warning. To suppress the warning, you can use the underscore <code>_</code> to indicate that the variable is intentionally unused.</p>
<pre><code class="language-move">// Unpack the `Artist` struct and ignore the `name` field.
let Artist { name: _ } = artist;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abilities-drop"><a class="header" href="#abilities-drop">Abilities: Drop</a></h1>
<!-- TODO: reiterate, given that we introduce abilities one by one -->
<!--

// Shall we only talk about `drop` ?
// So that we don't explain scopes and `copy` / `move` semantics just yet?

Chapter: Basic Syntax
Goal: Introduce Copy and Drop abilities of Move. Follows the `struct` section
Notes:
    - compare them to primitive types introduces before;
    - what is an ability without drop
    - drop is not necessary for unpacking
    - make a joke about a bacteria pattern in the code
    - mention that a struct with only `drop` ability is called a Witness
    - mention that a struct without abilities is called a Hot Potato
    - mention that there are two more abilities which are covered in a later chapter

Links:
    - language reference (abilities)
    - authorization patterns (or witness)
    - hot potato pattern
    - key and store abilities (later chapter)

 -->
<p>Move has a unique type system which allows defining <em>type abilities</em>. <a href="basic-syntax/./struct.html">In the previous section</a>, we introduced the <code>struct</code> definition and how to use it. However, the instances of the <code>Artist</code> and <code>Record</code> structs had to be unpacked for the code to compile. This is default behavior of a struct without <em>abilities</em>. In this section, we introduce the first ability - <code>drop</code>.</p>
<h2 id="abilities-syntax"><a class="header" href="#abilities-syntax">Abilities syntax</a></h2>
<p>Abilities are set in the struct definition using the <code>has</code> keyword followed by a list of abilities. The abilities are separated by commas. Move supports 4 abilities: <code>copy</code>, <code>drop</code>, <code>key</code>, and <code>store</code>. In this section, we cover the first two abilities: <code>copy</code> and <code>drop</code>. The last two abilities are covered <a href="basic-syntax/./../programmability/README.html">in the programmability chapter</a>, when we introduce Objects and storage operations.</p>
<pre><code class="language-move">/// This struct has the `copy` and `drop` abilities.
struct VeryAble has copy, drop {
    // field: Type1,
    // field2: Type2,
    // ...
}
</code></pre>
<h2 id="no-abilities"><a class="header" href="#no-abilities">No abilities</a></h2>
<p>A struct without abilities cannot be discarded, or copied, or stored in the storage. We call such a struct a <em>Hot Potato</em>. It is a joke, but it is also a good way to remember that a struct without abilities is like a hot potato - it needs to be passed around and handled properly. Hot Potato is one of the most powerful patterns in Move, we go in detail about it in the <a href="basic-syntax/./../programmability/authorization-patterns.html">TODO: authorization patterns</a> chapter.</p>
<h2 id="drop-ability"><a class="header" href="#drop-ability">Drop ability</a></h2>
<p>The <code>drop</code> ability - the simplest of them - allows the instance of a struct to be <em>ignored</em> or <em>discarded</em>. In many programming languages this behavior is considered default. However, in Move, a struct without the <code>drop</code> ability is not allowed to be ignored. This is a safety feature of the Move language, which ensures that all assets are properly handled. An attempt to ignore a struct without the <code>drop</code> ability will result in a compilation error.</p>
<pre><code class="language-move">module book::drop_ability {

    /// This struct has the `drop` ability.
    public struct IgnoreMe has drop {
        a: u8,
        b: u8,
    }

    /// This struct does not have the `drop` ability.
    public struct NoDrop {}

    #[test]
    // Create an instance of the `IgnoreMe` struct and ignore it.
    // Even though we constructed the instance, we don't need to unpack it.
    fun test_ignore() {
        let no_drop = NoDrop {};
        let _ = IgnoreMe { a: 1, b: 2 }; // no need to unpack

        // The value must be unpacked for the code to compile.
        let NoDrop {} = no_drop; // OK
    }
}
</code></pre>
<p>The <code>drop</code> ability is often used on custom collection types to eliminate the need for special handling of the collection when it is no longer needed. For example, a <code>vector</code> type has the <code>drop</code> ability, which allows the vector to be ignored when it is no longer needed. However, the biggest feature of Move's type system is the ability to not have <code>drop</code>. This ensures that the assets are properly handled and not ignored.</p>
<p>A struct with a single <code>drop</code> ability is called a <em>Witness</em>. We explain the concept of a <em>Witness</em> in the <a href="basic-syntax/./../programmability/witness-and-abstract-implementation.html">Witness and Abstract Implementation</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="importing-modules"><a class="header" href="#importing-modules">Importing Modules</a></h1>
<!--
    TODO: create a better example for:
        1. Importing a module in general
        2. Importing a member
        3. Importing multiple members
        4. Grouping imports
        5. Self keyword for groups
-->
<!--

Goals:
    - Show the import syntax
    - Local dependencies
    - External dependencies
    - Importing modules from other packages

 -->
<p>Move achieves high modularity and code reuse by allowing module imports. Modules within the same package can import each other, and a new package can depend on already existing packages and use their modules too. This section will cover the basics of importing modules and how to use them in your own code.</p>
<h2 id="importing-a-module"><a class="header" href="#importing-a-module">Importing a Module</a></h2>
<p>Modules defined in the same package can import each other. The <code>use</code> keyword is followed by the module path, which consists of the package address (or alias) and the module name separated by <code>::</code>.</p>
<pre><code class="language-move">// File: sources/module_one.move
module book::module_one {
    /// Struct defined in the same module.
    public struct Character has drop {}

    /// Simple function that creates a new `Character` instance.
    public fun new(): Character { Character {} }
}
</code></pre>
<p>File: sources/module_two.move</p>
<pre><code class="language-move">// File: sources/module_two.move
module book::module_two {
    use book::module_one; // importing module_one from the same package

    /// Calls the `new` function from the `module_one` module.
    public fun create_and_ignore() {
        let _ = module_one::new();
    }
}
</code></pre>
<h2 id="importing-members"><a class="header" href="#importing-members">Importing Members</a></h2>
<p>You can also import specific members from a module. This is useful when you only need a single function or a single type from a module. The syntax is the same as for importing a module, but you add the member name after the module path.</p>
<pre><code class="language-move">module book::more_imports {
    use book::module_one::new;       // imports the `new` function from the `module_one` module
    use book::module_one::Character; // importing the `Character` struct from the `module_one` module

    /// Calls the `new` function from the `module_one` module.
    public fun create_character(): Character {
        new()
    }
}
</code></pre>
<h2 id="grouping-imports"><a class="header" href="#grouping-imports">Grouping Imports</a></h2>
<p>Imports can be grouped into a single <code>use</code> statement using the curly braces <code>{}</code>. This is useful when you need to import multiple members from the same module. Move allows grouping imports from the same module and from the same package.</p>
<pre><code class="language-move">module book::grouped_imports {
    // imports the `new` function and the `Character` struct from
    /// the `module_one` module
    use book::module_one::{new, Character};

    /// Calls the `new` function from the `module_one` module.
    public fun create_character(): Character {
        new()
    }
}
</code></pre>
<p>Single function imports are less common in Move, since the function names can overlap and cause confusion. A recommended practice is to import the entire module and use the module path to access the function. Types have unique names and should be imported individually.</p>
<p>To import members and the module itself in the group import, you can use the <code>Self</code> keyword. The <code>Self</code> keyword refers to the module itself and can be used to import the module and its members.</p>
<pre><code class="language-move">module book::self_imports {
    // imports the `Character` struct, and the `module_one` module
    use book::module_one::{Self, Character};

    /// Calls the `new` function from the `module_one` module.
    public fun create_character(): Character {
        module_one::new()
    }
}
</code></pre>
<h2 id="resolving-name-conflicts"><a class="header" href="#resolving-name-conflicts">Resolving Name Conflicts</a></h2>
<p>When importing multiple members from different modules, it is possible to have name conflicts. For example, if you import two modules that both have a function with the same name, you will need to use the module path to access the function. It is also possible to have modules with the same name in different packages. To resolve the conflict and avoid ambiguity, Move offers the <code>as</code> keyword to rename the imported member.</p>
<pre><code class="language-move">module book::conflict_resolution {
    // `as` can be placed after any import, including group imports
    use book::module_one::{Self as mod, Character as Char};

    /// Calls the `new` function from the `module_one` module.
    public fun create(): Char {
        mod::new()
    }
}
</code></pre>
<h2 id="adding-an-external-dependency"><a class="header" href="#adding-an-external-dependency">Adding an External Dependency</a></h2>
<p>Every new package generated via the <code>sui</code> binary features a <code>Move.toml</code> file with a single dependency on the <em>Sui Framework</em> package. The Sui Framework depends on the <em>Standard Library</em> package. And both of these packages are available in default configuration. Package dependencies are defined in the <a href="basic-syntax/./../concepts/manifest.html">Package Manifest</a> as follows:</p>
<pre><code class="language-toml">[dependencies]
Sui = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/testnet" }
Local = { local = "../my_other_package" }
</code></pre>
<p>The <code>dependencies</code> section contains a list of package dependencies. The key is the name of the package, and the value is either a git import table or a local path. The git import contains the URL of the package, the subdirectory where the package is located, and the revision of the package. The local path is a relative path to the package directory.</p>
<p>If a dependency is added to the <code>Move.toml</code> file, the compiler will automatically fetch (and later refetch) the dependencies when building the package.</p>
<h2 id="importing-a-module-from-another-package"><a class="header" href="#importing-a-module-from-another-package">Importing a Module from Another Package</a></h2>
<p>Normally, packages define their addresses in the <code>[addresses]</code> section, so you can use the alias instead of the address. For example, instead of <code>0x2::coin</code> module, you would use <code>sui::coin</code>. The <code>sui</code> alias is defined in the Sui Framework package. Similarly, the <code>std</code> alias is defined in the Standard Library package and can be used to access the standard library modules.</p>
<p>To import a module from another package, you use the <code>use</code> keyword followed by the module path. The module path consists of the package address (or alias) and the module name separated by <code>::</code>.</p>
<pre><code class="language-move">module book::imports {
    use std::string; // std = 0x1, string is a module in the standard library
    use sui::coin;   // sui = 0x2, coin is a module in the Sui Framework
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<!-- The Move standard library provides a set of modules  -->
<p>The Move Standard Library provides functionality for native types and operations. It is a standard collection of modules which does utilize the storage model, and operates on native types. It is the only dependency of the <a href="basic-syntax/../programmability/sui-framework.html">Sui Framework</a>, and is imported together with it.</p>
<h2 id="most-common-modules"><a class="header" href="#most-common-modules">Most Common Modules</a></h2>
<p>In this book we go into detail about most of the modules in the standard library, however, it is also helpful to give an overview of the features, so that you can get a sense of what is available and which module implements that.</p>
<!-- Custom CSS addition in the theme/chrome.css  -->
<div class="modules-table">
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Description</th><th>Chapter</th></tr></thead><tbody>
<tr><td>std::string</td><td>Provides basic string operations</td><td><a href="basic-syntax/./string.html">String</a></td></tr>
<tr><td>std::ascii</td><td>Provides basic ASCII operations</td><td><a href="basic-syntax/./string.html">String</a></td></tr>
<tr><td>std::option</td><td>Implements an <code>Option&lt;T&gt;</code></td><td><a href="basic-syntax/./option.html">Option</a></td></tr>
<tr><td>std::vector</td><td>Native operations on the vector type</td><td><a href="basic-syntax/./vector.html">Vector</a></td></tr>
<tr><td>std::hash</td><td>Hashing functions: <code>sha2_256</code> and <code>sha3_256</code></td><td><a href="basic-syntax/../programmability/cryptography-and-hashing.html">Cryptography and Hashing</a></td></tr>
<tr><td>std::bcs</td><td>Contains the <code>bcs::to_bytes()</code> function</td><td><a href="basic-syntax/../basic-syntax/bcs.html">BCS</a></td></tr>
<tr><td>std::address</td><td>Contains a single <code>address::length</code> function</td><td><a href="basic-syntax/./address.html">Address</a></td></tr>
<tr><td>std::type_name</td><td>Allows runtime <em>type reflection</em></td><td><a href="basic-syntax/./type-reflection.html">Type Reflection</a></td></tr>
<tr><td>std::debug</td><td>Contains debugging functions, which are available in only in <strong>test</strong> mode</td><td><a href="basic-syntax/./debugging.html">Debugging</a></td></tr>
<tr><td>std::bit_vector</td><td>Provides operations on bit vectors</td><td>-</td></tr>
<tr><td>std::fixed_point32</td><td>Provides the <code>FixedPoint32</code> type</td><td>-</td></tr>
</tbody></table>
</div></div>
<h2 id="implicit-imports"><a class="header" href="#implicit-imports">Implicit Imports</a></h2>
<p>Some of the modules are imported implicitly, and are available in the module without explicit <code>use</code> import. For Standard Library, these modules and types are:</p>
<ul>
<li>std::vector</li>
<li>std::option</li>
<li>std::option::Option</li>
</ul>
<h2 id="importing-std-without-sui-framework"><a class="header" href="#importing-std-without-sui-framework">Importing std without Sui Framework</a></h2>
<p>The Move Standard Library can be imported to the package directly. However, std alone is not enough to build a meaningful application, as it does not provide any storage capabilities, and can't interact with the on-chain state.</p>
<pre><code class="language-toml">MoveStdlib = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/move-stdlib", rev = "framework/mainnet" }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector"><a class="header" href="#vector">Vector</a></h1>
<p>Vectors are a native way to store collections of elements in Move. They are similar to arrays in other programming languages, but with a few differences. In this section, we introduce the <code>vector</code> type and its operations.</p>
<h2 id="vector-syntax"><a class="header" href="#vector-syntax">Vector syntax</a></h2>
<p>The <code>vector</code> type is defined using the <code>vector</code> keyword followed by the type of the elements in angle brackets. The type of the elements can be any valid Move type, including other vectors. Move has a vector literal syntax that allows you to create vectors using the <code>vector</code> keyword followed by square brackets containing the elements (or no elements for an empty vector).</p>
<pre><code class="language-move">// An empty vector of bool elements.
let empty: vector&lt;bool&gt; = vector[];

// A vector of u8 elements.
let v: vector&lt;u8&gt; = vector[10, 20, 30];

// A vector of vector&lt;u8&gt; elements.
let vv: vector&lt;vector&lt;u8&gt;&gt; = vector[
    vector[10, 20],
    vector[30, 40]
];
</code></pre>
<p>The <code>vector</code> type is a built-in type in Move, and does not need to be imported from a module. However, vector operations are defined in the <code>std::vector</code> module, and you need to import the module to use them.</p>
<h2 id="vector-operations"><a class="header" href="#vector-operations">Vector operations</a></h2>
<p>The standard library provides methods to manipulate vectors. The following are some of the most commonly used operations:</p>
<ul>
<li><code>push_back</code>: Adds an element to the end of the vector.</li>
<li><code>pop_back</code>: Removes the last element from the vector.</li>
<li><code>length</code>: Returns the number of elements in the vector.</li>
<li><code>is_empty</code>: Returns true if the vector is empty.</li>
<li><code>remove</code>: Removes an element at a given index.</li>
</ul>
<pre><code class="language-move">let mut v = vector[10u8, 20, 30];

assert!(v.length() == 3, 0);
assert!(!v.is_empty(), 1);

v.push_back(40);
let last_value = v.pop_back();

assert!(last_value == 40, 2);
</code></pre>
<h2 id="destroying-a-vector-of-non-droppable-types"><a class="header" href="#destroying-a-vector-of-non-droppable-types">Destroying a Vector of non-droppable types</a></h2>
<p>A vector of non-droppable types cannot be discarded. If you define a vector of types without <code>drop</code> ability, the vector value cannot be ignored. However, if the vector is empty, compiler requires an explicit call to <code>destroy_empty</code> function.</p>
<pre><code class="language-move">    /// A struct without `drop` ability.
    public struct NoDrop {}

    #[test]
    fun test_destroy_empty() {
        // Initialize a vector of `NoDrop` elements.
        let v = vector&lt;NoDrop&gt;[];

        // While we know that `v` is empty, we still need to call
        // the explicit `destroy_empty` function to discard the vector.
        v.destroy_empty();
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option"><a class="header" href="#option">Option</a></h1>
<p>Option is a type that represents an optional value which may or may not exist. The concept of Option in Move is borrowed from Rust, and it is a very useful primitive in Move. <code>Option</code> is defined in the <a href="basic-syntax/./standard-library.html">Standard Library</a>, and is defined as follows:</p>
<p>File: move-stdlib/source/option.move</p>
<pre><code class="language-move">/// Abstraction of a value that may or may not be present.
struct Option&lt;Element&gt; has copy, drop, store {
    vec: vector&lt;Element&gt;
}
</code></pre>
<blockquote>
<p>The 'std::option' module is implicitly imported in every module, and you don't need to add an import.</p>
</blockquote>
<p>The <code>Option</code> is a generic type which takes a type parameter <code>Element</code>. It has a single field <code>vec</code> which is a <code>vector</code> of <code>Element</code>. Vector can have length 0 or 1, and this is used to represent the presence or absence of a value.</p>
<p>Option type has two variants: <code>Some</code> and <code>None</code>. <code>Some</code> variant contains a value and <code>None</code> variant represents the absence of a value. The <code>Option</code> type is used to represent the absence of a value in a type-safe way, and it is used to avoid the need for empty or <code>undefined</code> values.</p>
<h2 id="in-practice"><a class="header" href="#in-practice">In Practice</a></h2>
<p>To showcase why Option type is necessary, let's look at an example. Consider an application which takes a user input and stores it in a variable. Some fields are required, and some are optional. For example, a user's middle name is optional. While we could use an empty string to represent the absence of a middle name, it would require extra checks to differentiate between an empty string and a missing middle name. Instead, we can use the <code>Option</code> type to represent the middle name.</p>
<pre><code class="language-move">module book::user_registry {
    use std::string::String;

    /// A struct representing a user record.
    public struct User has drop {
        first_name: String,
        middle_name: Option&lt;String&gt;,
        last_name: String,
    }

    /// Create a new `User` struct with the given fields.
    public fun register(
        first_name: String,
        middle_name: Option&lt;String&gt;,
        last_name: String,
    ): User {
        User { first_name, middle_name, last_name }
    }
}
</code></pre>
<p>In the example above, the <code>middle_name</code> field is of type <code>Option&lt;String&gt;</code>. This means that the <code>middle_name</code> field can either contain a <code>String</code> value or be empty. This makes it clear that the middle name is optional, and it avoids the need for extra checks to differentiate between an empty string and a missing middle name.</p>
<h2 id="using-option"><a class="header" href="#using-option">Using Option</a></h2>
<p>To use the <code>Option</code> type, you need to import the <code>std::option</code> module and use the <code>Option</code> type. You can then create an <code>Option</code> value using the <code>some</code> or <code>none</code> methods.</p>
<pre><code class="language-move">// `option::some` creates an `Option` value with a value.
let mut opt = option::some(b"Alice");

// `option.is_some()` returns true if option contains a value.
assert!(opt.is_some(), 1);

// internal value can be `borrow`ed and `borrow_mut`ed.
assert!(opt.borrow() == &amp;b"Alice", 0);

// `option.extract` takes the value out of the option, leaving the option empty.
let inner = opt.extract();

// `option.is_none()` returns true if option is None.
assert!(opt.is_none(), 2);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<p>While Move does not have a built-in to represent strings, it does have a <code>string</code> module in the <a href="basic-syntax/./standard-library.html">Standard Library</a> that provides a <code>String</code> type. The <code>string</code> module represents UTF-8 encoded strings, and another module, <code>ascii</code>, provides an ASCII-only <code>String</code> type.</p>
<p>Sui execution environment also allows Strings as transaction arguments, so in many cases, String does not to be constructed in the <a href="basic-syntax/./../concepts/what-is-a-transaction.html">Transaction Block</a>.</p>
<h2 id="bytestring-literal"><a class="header" href="#bytestring-literal">Bytestring Literal</a></h2>
<p>TODO:</p>
<ul>
<li>reference vector</li>
<li>reference literals - <a href="basic-syntax/./expression.html#literals">Expression</a></li>
</ul>
<h2 id="strings-are-bytes"><a class="header" href="#strings-are-bytes">Strings are bytes</a></h2>
<p>No matter which type of string you use, it is important to know that strings are just bytes. The wrappers provided by the <code>string</code> and <code>ascii</code> modules are just that: wrappers. They do provide extra checks and functionality than a vector of bytes, but under the hood, they are just vectors of bytes.</p>
<pre><code class="language-move">module book::custom_string {
    /// Anyone can implement a custom string-like type by wrapping a vector.
    public struct MyString {
        bytes: vector&lt;u8&gt;,
    }

    /// Implement a `from_bytes` function to convert a vector of bytes to a string.
    public fun from_bytes(bytes: vector&lt;u8&gt;): MyString {
        MyString { bytes }
    }

    /// Implement a `bytes` function to convert a string to a vector of bytes.
    public fun bytes(self: &amp;MyString): &amp;vector&lt;u8&gt; {
        &amp;self.bytes
    }
}
</code></pre>
<p>Both standard types provide conversions from and to vectors of bytes.</p>
<h2 id="working-with-utf-8-strings"><a class="header" href="#working-with-utf-8-strings">Working with UTF-8 Strings</a></h2>
<p>While there are two types of strings in the standard library, the <code>string</code> module should be considered the default. It has native implementations of many common operations, and hence is more efficient than the <code>ascii</code> module. To create a string or perform operations on it, you must import the <code>string</code> module:</p>
<pre><code class="language-move">module book::string_utf {
    use std::string;

    #[test]
    fun using_strings() {
        // strings are normally created using the `utf8` function
        let mut hello = string::utf8(b"Hello");
        let world = string::utf8(b", World!");

        // strings can be concatenated using the `append_utf8` function
        hello.append_utf8(*world.bytes()); // mutates the value

        // just like any other type, strings can be compared
        assert!(hello == string::utf8(b"Hello, World!"), 0x0);
    }
}
</code></pre>
<h2 id="safe-utf-8-operations"><a class="header" href="#safe-utf-8-operations">Safe UTF-8 Operations</a></h2>
<p>The default <code>utf8</code> method is potentially unsafe, as it does not check that the bytes passed to it are valid UTF-8. If you are not sure that the bytes you are passing are valid UTF-8, you should use the <code>try_utf8</code> method instead. It returns an <code>Option&lt;String&gt;</code>, which is <code>None</code> if the bytes are not valid UTF-8:</p>
<blockquote>
<p>The <code>try_*</code> pattern is used throughout the standard library to indicate that a function may fail. For more information, see the <a href="basic-syntax/./error-handling.html">Error Handling</a> section.</p>
</blockquote>
<pre><code class="language-move">module book::string_safe_utf {
    use std::string;

    #[test]
    fun safe_strings() {
        // this is a valid UTF-8 string
        let hello = string::try_utf8(b"Hello");

        assert!(hello.is_some(), 0); // abort if the value is not valid UTF-8

        // this is not a valid UTF-8 string
        let invalid = string::try_utf8(b"\xFF");

        assert!(invalid.is_none(), 0); // abort if the value is valid UTF-8
    }
}
</code></pre>
<h2 id="ascii-strings"><a class="header" href="#ascii-strings">ASCII Strings</a></h2>
<p>TODO: ASCII strings</p>
<pre><code class="language-move">module book::string_ascii {
    // use std::ascii::String;

    #[test]
    fun using_strings() {
        // strings are normally created using the `utf8` function
        // let mut hello = string::utf8(b"Hello");
        // let world = string::utf8(b", World!");

        // // strings can be concatenated using the `append_utf8` function
        // let hello_world = hello.append_utf8(*world.bytes());

        // // just like any other type, strings can be compared
        // assert!(hello_world == string::utf8(b"Hello, World!"), 0x0);
    }
}
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>TODO: summary</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<!--

Chapter: Basic Syntax
Goal: Introduce control flow statements.
Notes:
    - if/else is an expression
    - while () {} loop
    - continue and break
    - loop {}
    - infinite loop is possible but will lead to gas exhaustion
    - return keyword
    - if is an expression and as such requires a semicolon (!!!)

Links:
    - reference (control flow)
    - coding conventions (control flow)

 -->
<p>Control flow statements are used to control the flow of execution in a program. They are used to make decisions, to repeat a block of code, and to exit a block of code early. Move has the following control flow statements (explained in detail below):</p>
<ul>
<li><a href="basic-syntax/control-flow.html#conditional-statements"><code>if</code> and <code>if-else</code></a> - making decisions on whether to execute a block of code</li>
<li><a href="basic-syntax/control-flow.html#repeating-statements-with-loops"><code>loop</code> and <code>while</code> loops</a> - repeating a block of code</li>
<li><a href="basic-syntax/control-flow.html#exiting-a-loop-early"><code>break</code> and <code>continue</code> statements</a> - exiting a loop early</li>
<li><a href="basic-syntax/control-flow.html#return"><code>return</code></a> statement - exiting a function early</li>
</ul>
<h2 id="conditional-statements"><a class="header" href="#conditional-statements">Conditional Statements</a></h2>
<p>The <code>if</code> expression is used to make decisions in a program. It evaluates a <a href="basic-syntax/./expression.html#literals">boolean expression</a> and executes a block of code if the expression is true. Paired with <code>else</code>, it can execute a different block of code if the expression is false.</p>
<p>The syntax for the <code>if</code> expression is:</p>
<pre><code class="language-move">if (&lt;bool_expression&gt;) &lt;expression&gt;;
if (&lt;bool_expression&gt;) &lt;expression&gt; else &lt;expression&gt;;
</code></pre>
<p>Just like any other expression, <code>if</code> requires a semicolon, if there are other expressions following it. The <code>else</code> keyword is optional, except for the case when the resulting value is assigned to a variable. We will cover this below.</p>
<pre><code class="language-move">    #[test]
    fun test_if() {
        let x = 5;

        // `x &gt; 0` is a boolean expression.
        if (x &gt; 0) {
            std::debug::print(&amp;b"X is bigger than 0".to_string())
        };
    }
</code></pre>
<p>Let's see how we can use <code>if</code> and <code>else</code> to assign a value to a variable:</p>
<pre><code class="language-move">    #[test]
    fun test_if_else() {
        let x = 5;
        let y = if (x &gt; 0) {
            1
        } else {
            0
        };

        assert!(y == 1, 0);
    }
</code></pre>
<p>Here we assign the value of the <code>if</code> expression to the variable <code>y</code>. If <code>x</code> is greater than 0, <code>y</code> will be assigned the value 1, otherwise 0. The <code>else</code> block is necessary, because both branches must return a value of the same type. If we omit the <code>else</code> block, the compiler will throw an error.</p>
<!-- TODO: add an error -->
<p>Conditional expressions are one of the most important control flow statements in Move. They can use either user provided input or some already stored data to make decisions. In particular, they are used in the <a href="basic-syntax/./assert-and-abort.html"><code>assert!</code> macro</a> to check if a condition is true, and if not, to abort execution. We will get to it very soon!</p>
<h2 id="repeating-statements-with-loops"><a class="header" href="#repeating-statements-with-loops">Repeating Statements with Loops</a></h2>
<p>Loops are used to execute a block of code multiple times. Move has two built-in types of loops: <code>loop</code> and <code>while</code>. In many cases they can be used interchangeably, but usually <code>while</code> is used when the number of iterations is known in advance, and <code>loop</code> is used when the number of iterations is not known in advance or there are multiple exit points.</p>
<p>Loops are helpful when dealing with collections, such as vectors, or when we want to repeat a block of code until a certain condition is met. However, it is important to be careful with loops, as they can lead to infinite loops, which can lead to gas exhaustion and the transaction being aborted.</p>
<h2 id="the-while-loop"><a class="header" href="#the-while-loop">The <code>while</code> loop</a></h2>
<p>The <code>while</code> statement is used to execute a block of code as long as a boolean expression is true. Just like we've seen with <code>if</code>, the boolean expression is evaluated before each iteration of the loop. Just like conditional statements, the <code>while</code> loop is an expression and requires a semicolon if there are other expressions following it.</p>
<p>The syntax for the <code>while</code> loop is:</p>
<pre><code class="language-move">while (&lt;bool_expression&gt;) { &lt;expressions&gt;; };
</code></pre>
<p>Here is an example of a <code>while</code> loop with a very simple condition:</p>
<pre><code class="language-move">    // This function iterates over the `x` variable until it reaches 10, the
    // return value is the number of iterations it took to reach 10.
    //
    // If `x` is 0, then the function will return 10.
    // If `x` is 5, then the function will return 5.
    fun while_loop(mut x: u8): u8 {
        let mut y = 0;

        // This will loop until `x` is 10.
        // And will never run if `x` is 10 or more.
        while (x &lt; 10) {
            y = y + 1;
            x = x + 1;
        };

        y
    }

    #[test]
    fun test_while() {
        assert!(while_loop(0) == 10, 0); // 10 times
        assert!(while_loop(5) == 5, 0);  // 5 times
        assert!(while_loop(10) == 0, 0); // loop never executed
    }
</code></pre>
<h2 id="infinite-loop"><a class="header" href="#infinite-loop">Infinite <code>loop</code></a></h2>
<p>Now let's imagine a scenario where the boolean expression is always <code>true</code>. For example, if we literally passed <code>true</code> to the <code>while</code> condition. As you might expect, this would create an infinite loop, and this is almost what the <code>loop</code> statement works like.</p>
<pre><code class="language-move">    #[test, expected_failure(out_of_gas, location=Self)]
    fun test_infinite_while() {
        let mut x = 0;

        // This will loop forever.
        while (true) {
            x = x + 1;
        };

        // This line will never be executed.
        assert!(x == 5, 0);
    }
</code></pre>
<p>An infinite <code>while</code>, or <code>while</code> without a condition, is a <code>loop</code>. The syntax for it is simple:</p>
<pre><code class="language-move">loop { &lt;expressions&gt;; };
</code></pre>
<p>Let's rewrite the previous example using <code>loop</code> instead of <code>while</code>:</p>
<pre><code class="language-move">    #[test, expected_failure(out_of_gas, location=Self)]
    fun test_infinite_loop() {
        let mut x = 0;

        // This will loop forever.
        loop {
            x = x + 1;
        };

        // This line will never be executed.
        assert!(x == 5, 0);
    }
</code></pre>
<!-- TODO: that's a weak point lmao -->
<p>Infinite loops on their own are not very useful in Move, since every operation in Move costs gas, and an infinite loop will lead to gas exhaustion. However, they can be used in combination with <code>break</code> and <code>continue</code> statements to create more complex loops.</p>
<h2 id="exiting-a-loop-early"><a class="header" href="#exiting-a-loop-early">Exiting a Loop Early</a></h2>
<p>As we already mentioned, infinite loops are rather useless on their own. And that's where we introduce the <code>break</code> and <code>continue</code> statements. They are used to exit a loop early, and to skip the rest of the current iteration, respectively.</p>
<p>Syntax for the <code>break</code> statement is (without a semicolon):</p>
<pre><code class="language-move">break
</code></pre>
<p>The <code>break</code> statement is used to stop the execution of a loop and exit it early. It is often used in combination with a conditional statement to exit the loop when a certain condition is met. To illustrate this point, let's turn the infinite <code>loop</code> from the previous example into something that looks and behaves more like a <code>while</code> loop:</p>
<pre><code class="language-move">    #[test]
    fun test_break_loop() {
        let mut x = 0;

        // This will loop until `x` is 5.
        loop {
            x = x + 1;

            // If `x` is 5, then exit the loop.
            if (x == 5) {
                break // Exit the loop.
            }
        };

        assert!(x == 5, 0);
    }
</code></pre>
<p>Almost identical to the <code>while</code> loop, right? The <code>break</code> statement is used to exit the loop when <code>x</code> is 5. If we remove the <code>break</code> statement, the loop will run forever, just like the previous example.</p>
<h2 id="skipping-an-iteration"><a class="header" href="#skipping-an-iteration">Skipping an Iteration</a></h2>
<p>The <code>continue</code> statement is used to skip the rest of the current iteration and start the next one. Similarly to <code>break</code>, it is used in combination with a conditional statement to skip the rest of the iteration when a certain condition is met.</p>
<p>Syntax for the <code>continue</code> statement is (without a semicolon):</p>
<pre><code class="language-move">continue
</code></pre>
<p>The example below skips odd numbers and prints only even numbers from 0 to 10:</p>
<pre><code class="language-move">    #[test]
    fun test_continue_loop() {
        let mut x = 0;

        // This will loop until `x` is 10.
        loop {
            x = x + 1;

            // If `x` is odd, then skip the rest of the iteration.
            if (x % 2 == 1) {
                continue // Skip the rest of the iteration.
            };

            std::debug::print(&amp;x);

            // If `x` is 10, then exit the loop.
            if (x == 10) {
                break // Exit the loop.
            }
        };

        assert!(x == 10, 0); // 10
    }
</code></pre>
<p><code>break</code> and <code>continue</code> statements can be used in both <code>while</code> and <code>loop</code> loops.</p>
<h2 id="early-return"><a class="header" href="#early-return">Early Return</a></h2>
<p>The <code>return</code> statement is used to exit a <a href="basic-syntax/./function.html">function</a> early and return a value. It is often used in combination with a conditional statement to exit the function when a certain condition is met. The syntax for the <code>return</code> statement is:</p>
<pre><code class="language-move">return &lt;expression&gt;
</code></pre>
<p>Here is an example of a function that returns a value when a certain condition is met:</p>
<pre><code class="language-move">    /// This function returns `true` if `x` is greater than 0 and not 5,
    /// otherwise it returns `false`.
    fun is_positive(x: u8): bool {
        if (x == 5) {
            return false
        };

        if (x &gt; 0) {
            return true
        };

        false
    }

    #[test]
    fun test_return() {
        assert!(is_positive(5) == false, 0);
        assert!(is_positive(0) == false, 0);
        assert!(is_positive(1) == true, 0);
    }
</code></pre>
<p>Unlike in other languages, the <code>return</code> statement is not required for the last expression in a function. The last expression in a function block is automatically returned. However, the <code>return</code> statement is useful when we want to exit a function early if a certain condition is met.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<!--

Chapter: Basic Syntax
Goal: Introduce constants.
Notes:
    - constants are immutable
    - constants are private
    - start with a capital letter always
    - stored in the bytecode (but w/o a name)
    - mention standard for naming constants

Links:
    - next section (abort and assert)
    - coding conventions (constants)
    - constants (language reference)

 -->
<p>Constants are immutable values that are defined at the module level. They often serve as a way to give names to values that are used throughout a module. For example, if there's a default price for a product, you might define a constant for it. Constants are <em>internal</em> to the module and can not be accessed from other modules.</p>
<pre><code class="language-move">module book::shop_price {
    use sui::coin::Coin;
    use sui::sui::SUI;

    /// The price of an item in the shop.
    const ITEM_PRICE: u64 = 100;
    /// The owner of the shop, an address.
    const SHOP_OWNER: address = @0xa11ce;

    /// An item sold in the shop.
    public struct Item { /* ... */ }

    /// Purchase an item from the shop.
    public fun purchase(coin: Coin&lt;SUI&gt;): Item {
        assert!(coin.value() == ITEM_PRICE, 0);

        transfer::public_transfer(coin, SHOP_OWNER);

        Item { /* ... */ }
    }
}
</code></pre>
<h2 id="naming-convention"><a class="header" href="#naming-convention">Naming Convention</a></h2>
<p>Constants are named using <code>UPPER_SNAKE_CASE</code>. This is a convention that is used throughout the Move codebase. It's a way to make constants stand out from other identifiers in the code. Move compiler will error if the first letter of a constant is not an uppercase letter.</p>
<h2 id="constants-are-immutable"><a class="header" href="#constants-are-immutable">Constants are Immutable</a></h2>
<p>Constants can't be changed and assigned new values. They are part of the package bytecode, and inherently immutable.</p>
<pre><code class="language-move">module book::immutable_constants {
    const ITEM_PRICE: u64 = 100;

    // emits an error
    fun change_price() {
        ITEM_PRICE = 200;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assert-and-abort"><a class="header" href="#assert-and-abort">Assert and Abort</a></h1>
<!--

Chapter: Basic Syntax
Goal: Introduce abort keyword and `assert!` macro.
Notes:
    - previous chapter mentions constants
    - error constants standard ECamelCase
    - `assert!` macro
    - asserts should go before the main logic
    - Move has no catch mechanism
    - abort codes are local to the module
    - there are no error messages emitted
    - error codes should handle all possible scenarios in this module

Links:
    - constants (previous section)
 -->
<h2 id="abort"><a class="header" href="#abort">Abort</a></h2>
<p>The <code>abort</code> keyword is used to abort the execution of a transaction. It is used in combination with an abort code, which will be returned to the caller of the transaction. The abort code is an integer of type <code>u64</code> and can be any value.</p>
<pre><code class="language-move">let user_has_access = true;

// abort with a predefined constant if `user_has_access` is false
if (!user_has_access) {
    abort 0
};

// there's an alternative syntax using parenthesis`
if (user_has_access) {
   abort(1)
};
</code></pre>
<p>The code above will, of course, abort with abort code <code>1</code>.</p>
<h2 id="assert"><a class="header" href="#assert">assert!</a></h2>
<p>The <code>assert!</code> macro is a built-in macro that can be used to assert a condition. If the condition is false, the transaction will abort with the given abort code. The <code>assert!</code> macro is a convenient way to abort a transaction if a condition is not met. The macro shortens the code otherwise written with an <code>if</code> expression + <code>abort</code>.</p>
<pre><code class="language-move">// aborts if `user_has_access` is `false` with abort code 0
assert!(user_has_access, 0);

// expands into:
if (!user_has_access) {
    abort 0
};
</code></pre>
<h2 id="error-constants"><a class="header" href="#error-constants">Error constants</a></h2>
<p>To make error codes more descriptive, it is a good practice to define error constants. Error constants are defined as <code>const</code> declarations and are usually prefixed with <code>E</code> followed by a camel case name. Error constatns are no different from other constants and don't have special handling. So their addition is purely a practice for better code readability.</p>
<pre><code class="language-move">/// Error code for when the user has no access.
const ENoAccess: u64 = 0;
/// Trying to access a field that does not exist.
const ENoField: u64 = 1;

/// Updates a record.
public fun update_record(/* ... , */ user_has_access: bool, field_exists: bool) {
    // asserts are way more readable now
    assert!(user_has_access, ENoAccess);
    assert!(field_exists, ENoField);

    /* ... */
}
</code></pre>
<h2 id="further-reading-1"><a class="header" href="#further-reading-1">Further reading</a></h2>
<p>We suggest reading the <a href="basic-syntax/./../guides/better-error-handling.html">Better Error Handling</a> guide to learn about best practices for error handling in Move.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function"><a class="header" href="#function">Function</a></h1>
<p>Functions are the building blocks of Move programs. They are called from <a href="basic-syntax/../concepts/user-interaction.html">user transactions</a> and from other functions and group executable code into reusable units. Functions can take arguments and return a value. They are declared with the <code>fun</code> keyword at the module level. Just like any other module member, by default they're private and can only be accessed from within the module.</p>
<pre><code class="language-move">module book::math {
    /// Function takes two arguments of type `u64` and returns their sum.
    /// The `public` visibility modifier makes the function accessible from
    /// outside the module.
    public fun add(a: u64, b: u64): u64 {
        a + b
    }

    #[test]
    fun test_add() {
        let sum = add(1, 2);
        assert!(sum == 3, 0);
    }
}
</code></pre>
<p>In this example, we define a function <code>add</code> that takes two arguments of type <code>u64</code> and returns their sum. The function is called from the <code>test_add</code> function, which is a test function located in the same module. In the test we compare the result of the <code>add</code> function with the expected value and abort the execution if the result is different.</p>
<h2 id="function-declaration"><a class="header" href="#function-declaration">Function declaration</a></h2>
<blockquote>
<p>There's a convention to call functions in Move with the <code>snake_case</code> naming convention. This means that the function name should be all lowercase with words separated by underscores. For example, <code>do_something</code>, <code>add</code>, <code>get_balance</code>, <code>is_authorized</code>, and so on.</p>
</blockquote>
<p>A function is declared with the <code>fun</code> keyword followed by the function name (a valid Move identifier), a list of arguments in parentheses, and a return type. The function body is a block of code that contains a sequence of statements and expressions. The last expression in the function body is the return value of the function.</p>
<pre><code class="language-move">fun return_nothing() {
    // empty expression, function returns `()`
}
</code></pre>
<h2 id="accessing-functions"><a class="header" href="#accessing-functions">Accessing functions</a></h2>
<p>Just like any other module member, functions can be imported and accessed via a path. The path consists of the module path and the function name separated by <code>::</code>. For example, if you have a function called <code>add</code> in the <code>math</code> module in the <code>book</code> package, the path to it will be <code>book::math::add</code>, or, if the module is imported, <code>math::add</code>.</p>
<pre><code class="language-move">module book::use_math {
    use book::math;

    fun call_add() {
        // function is called via the path
        let sum = math::add(1, 2);
    }
}
</code></pre>
<h2 id="multiple-return-values"><a class="header" href="#multiple-return-values">Multiple return values</a></h2>
<p>Move functions can return multiple values, which is useful when you need to return more than one value from a function. The return type of the function is a tuple of types. The return value is a tuple of expressions.</p>
<pre><code class="language-move">fun get_name_and_age(): (vector&lt;u8&gt;, u8) {
    (b"John", 25)
}
</code></pre>
<p>Result of a function call with tuple return has to be unpacked into variables via <code>let (tuple)</code> syntax:</p>
<pre><code class="language-move">// Tuple must be destructured to access its elements.
// Name and age are declared as immutable variables.
let (name, age) = get_name_and_age();
assert!(name == b"John", 0);
assert!(age == 25, 0);
</code></pre>
<p>If any of the declared values need to be declared as mutable, the <code>mut</code> keyword is placed before the variable name:</p>
<pre><code class="language-move">// declare name as mutable, age as immutable
let (mut name, age) = get_name_and_age();
</code></pre>
<p>If some of the arguments are not used, they can be ignored with the <code>_</code> symbol:</p>
<pre><code class="language-move">// ignore the name, only use the age
let (_, age) = get_name_and_age();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-methods"><a class="header" href="#struct-methods">Struct Methods</a></h1>
<p>Move Compiler supports <em>receiver syntax</em>, which allows defining methods which can be called on instances of a struct. This is similar to the method syntax in other programming languages. It is a convenient way to define functions which operate on the fields of a struct.</p>
<h2 id="method-syntax"><a class="header" href="#method-syntax">Method syntax</a></h2>
<p>If the first argument of a function is a struct internal to the module, then the function can be called using the <code>.</code> operator. If the function uses a struct from another module, then method won't be associated with the struct by default. In this case, the function can be called using the standard function call syntax.</p>
<p>When a module is imported, the methods are automatically associated with the struct.</p>
<pre><code class="language-move">module book::hero {
    /// A struct representing a hero.
    public struct Hero has drop {
        health: u8,
        mana: u8,
    }

    /// Create a new Hero.
    public fun new(): Hero { Hero { health: 100, mana: 100 } }

    /// A method which casts a spell, consuming mana.
    public fun heal_spell(hero: &amp;mut Hero) {
        hero.health = hero.health + 10;
        hero.mana = hero.mana - 10;
    }

    /// A method which returns the health of the hero.
    public fun health(hero: &amp;Hero): u8 { hero.health }

    /// A method which returns the mana of the hero.
    public fun mana(hero: &amp;Hero): u8 { hero.mana }

    #[test]
    // Test the methods of the `Hero` struct.
    fun test_methods() {
        let mut hero = new();
        hero.heal_spell();

        assert!(hero.health() == 110, 1);
        assert!(hero.mana() == 90, 2);
    }
}
</code></pre>
<h2 id="method-aliases"><a class="header" href="#method-aliases">Method Aliases</a></h2>
<p>For modules that define multiple structs and their methods, it is possible to define method aliases to avoid name conflicts, or to provide a better-named method for a struct.</p>
<p>The syntax for aliases is:</p>
<pre><code class="language-move">// for local method association
use fun &lt;function_path&gt; as &lt;Type&gt;.&lt;method_name&gt;;

// exported alias
public use fun &lt;function_path&gt; as &lt;Type&gt;.&lt;method_name&gt;;
</code></pre>
<blockquote>
<p>Public aliases are only allowed for structs defined in the same module. If a struct is defined in another module, an alias can still be created but cannot be made public.</p>
</blockquote>
<p>In the example below, we changed the <code>hero</code> module and added another type - <code>Villain</code>. Both <code>Hero</code> and <code>Villain</code> have similar field names and methods. And to avoid name conflicts, we prefixed methods with <code>hero_</code> and <code>villain_</code> respectively. However, we can create aliases for these methods so that they can be called on the instances of the structs without the prefix.</p>
<pre><code class="language-move">module book::hero_and_villain {
    /// A struct representing a hero.
    public struct Hero has drop {
        health: u8,
    }

    /// A struct representing a villain.
    public struct Villain has drop {
        health: u8,
    }

    /// Create a new Hero.
    public fun new_hero(): Hero { Hero { health: 100 } }

    /// Create a new Villain.
    public fun new_villain(): Villain { Villain { health: 100 } }

    // Alias for the `hero_health` method. Will be imported automatically when
    // the module is imported.
    public use fun hero_health as Hero.health;

    public fun hero_health(hero: &amp;Hero): u8 { hero.health }

    // Alias for the `villain_health` method. Will be imported automatically
    // when the module is imported.
    public use fun villain_health as Villain.health;

    public fun villain_health(villain: &amp;Villain): u8 { villain.health }

    #[test]
    // Test the methods of the `Hero` and `Villain` structs.
    fun test_associated_methods() {
        let hero = new_hero();
        assert!(hero.health() == 100, 1);

        let villain = new_villain();
        assert!(villain.health() == 100, 3);
    }
}
</code></pre>
<p>As you can see, in the test function, we called the <code>health</code> method on the instances of <code>Hero</code> and <code>Villain</code> without the prefix. The compiler will automatically associate the methods with the structs.</p>
<h2 id="aliasing-an-external-modules-method"><a class="header" href="#aliasing-an-external-modules-method">Aliasing an external module's method</a></h2>
<p>It is also possible to associate a function defined in another module with a struct from the current module. Following the same approach, we can create an alias for the method defined in another module. Let's use the <code>bcs::to_bytes</code> method from the <a href="basic-syntax/./standard-library.html">Standard Library</a> and associate it with the <code>Hero</code> struct. It will allow serializing the <code>Hero</code> struct to a vector of bytes.</p>
<pre><code class="language-move">// TODO: better example (external module...)
module book::hero_to_bytes {
    // Alias for the `bcs::to_bytes` method. Imported aliases should be defined
    // in the top of the module.
    // public use fun bcs::to_bytes as Hero.to_bytes;

    /// A struct representing a hero.
    public struct Hero has drop {
        health: u8,
        mana: u8,
    }

    /// Create a new Hero.
    public fun new(): Hero { Hero { health: 100, mana: 100 } }

    #[test]
    // Test the methods of the `Hero` struct.
    fun test_hero_serialize() {
        // let mut hero = new();
        // let serialized = hero.to_bytes();
        // assert!(serialized.length() == 3, 1);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visibility-modifiers"><a class="header" href="#visibility-modifiers">Visibility Modifiers</a></h1>
<p>Every module member has a visibility. By default, all module members are <em>private</em> - meaning they are only accessible within the module they are defined in. However, you can add a visibility modifier to make a module member <em>public</em> - visible outside the module, or <em>friend</em> - visible in "friend" modules within the same package, or <em>entry</em> - can be called from a transaction but can't be called from other modules.</p>
<h2 id="internal-visibility"><a class="header" href="#internal-visibility">Internal Visibility</a></h2>
<p>A function or a struct defined in a module which has no visibility modifier is <em>private</em>.</p>
<pre><code class="language-move">module book::internal_visbility {
    // This function can be called from other functions in the same module
    fun internal() { /* ... */ }

    // Same module -&gt; can call internal()
    fun call_internal() {
        internal();
    }
}
</code></pre>
<p>Move compiler won't allow this code to compile:</p>
<!-- TODO: add failure flag to example -->
<pre><code class="language-move">module book::try_calling_internal {
    use book::internal_visbility;

    // Different module -&gt; can't call internal()
    fun try_calling_internal() {
        internal_visbility::internal();
    }
}
</code></pre>
<h2 id="public-visibility"><a class="header" href="#public-visibility">Public Visibility</a></h2>
<p>A struct or a function can be made <em>public</em> by adding the <code>public</code> keyword before the <code>fun</code> or <code>struct</code> keyword.</p>
<pre><code class="language-move">module book::public_visibility {
    // This function can be called from other modules
    public fun public() { /* ... */ }
}
</code></pre>
<p>A public function can be imported and called from other modules. The following code will compile:</p>
<pre><code class="language-move">module book::try_calling_public {
    use book::public_visibility;

    // Different module -&gt; can call public()
    fun try_calling_public() {
        public_visibility::public();
    }
}
</code></pre>
<h2 id="friend-visibility"><a class="header" href="#friend-visibility">Friend Visibility</a></h2>
<p>Modules within the same package can be declared as <em>friends</em> to each other, and that enables the <em>friend visibility</em> modifier. A function with <em>friend visibility</em> can be called by friend modules. However, to the rest of the packages and non-friend modules, it is <em>private</em>.</p>
<pre><code class="language-move">module book::friend_visibility {
    friend book::try_calling_friend;

    // This function can be called from friend modules
    public(friend) fun friend_only() { /* ... */ }
}
</code></pre>
<p>A friend function can be called from a friend module, but not from a non-friend module:</p>
<pre><code class="language-move">module book::try_calling_friend {
    use book::friend_visibility;

    // Same package, friend module -&gt; can call friend()
    fun try_calling_friend() {
        friend_visibility::friend_only();
    }
}
</code></pre>
<h2 id="package-visibility"><a class="header" href="#package-visibility">Package Visibility</a></h2>
<blockquote>
<p>This feature of Move 2024 is not yet implemented.</p>
</blockquote>
<p>Move 2024 introduces the <em>package visibility</em> modifier. A function with <em>package visibility</em> can be called from any module within the same package. It can't be called from other packages.</p>
<pre><code class="language-move">module book::package_visibility {
    public(package) fun package_only() { /* ... */ }
}
</code></pre>
<p>A package function can be called from any module within the same package:</p>
<pre><code class="language-move">module book::try_calling_package {
    use book::package_visibility;

    // Same package `book` -&gt; can call package_only()
    fun try_calling_package() {
        package_visibility::package_only();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-scope"><a class="header" href="#ownership-and-scope">Ownership and Scope</a></h1>
<p>Every variable in Move has a scope and an owner. The scope is the range of code where the variable is valid, and the owner is the scope that this variable belongs to. Once the owner scope ends, the variable is dropped. This is a fundamental concept in Move, and it is important to understand how it works.</p>
<!--

- Borrow Checker
- Mention Rust's borrow checker
- Borrowing / References intro

-->
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>A variable defined in a function scope is owned by this scope. The runtime goes through the function scope and executes every expression and statement. Once the function scope end, the variables defined in it are dropped or deallocated.</p>
<pre><code class="language-move">module book::ownership {
    public fun owner() {
        let a = 1; // a is owned by the `owner` function
    } // a is dropped here

    #[test]
    fun test_owner() {
        owner();
        // a is not valid here
    }
}
</code></pre>
<p>In the example above, the variable <code>a</code> is owned by the <code>owner</code> function, and the variable <code>b</code> is owned by the <code>other</code> function. When each of these functions are called, the variables are defined, and when the function ends, the variables are discarded.</p>
<h2 id="returning-a-value"><a class="header" href="#returning-a-value">Returning a Value</a></h2>
<p>If we changed the <code>owner</code> function to return the variable <code>a</code>, then the ownership of <code>a</code> would be transferred to the caller of the function.</p>
<pre><code class="language-move">module book::ownership {
    public fun owner(): u8 {
        let a = 1; // a defined here
        a // scope ends, a is returned
    }

    #[test]
    fun test_owner() {
        let a = owner();
        // a is valid here
    } // a is dropped here
}
</code></pre>
<h2 id="passing-by-value"><a class="header" href="#passing-by-value">Passing by Value</a></h2>
<p>Additionally, if we passed the variable <code>a</code> to another function, the ownership of <code>a</code> would be transferred to this function. When performing this operation, we <em>move</em> the value from one scope to another. This is also called <em>move semantics</em>.</p>
<pre><code class="language-move">module book::ownership {
    public fun owner(): u8 {
        let a = 10;
        a
    } // a is returned

    public fun take_ownership(v: u8) {
        // v is owned by `take_ownership`
    } // v is dropped here

    #[test]
    fun test_owner() {
        let a = owner();
        take_ownership(a);
        // a is not valid here
    }
}
</code></pre>
<h2 id="scopes-with-blocks"><a class="header" href="#scopes-with-blocks">Scopes with Blocks</a></h2>
<p>Function has a main scope, and it can also have sub-scopes via the use of blocks. A block is a sequence of statements and expressions, and it has its own scope. Variables defined in a block are owned by this block, and when the block ends, the variables are dropped.</p>
<pre><code class="language-move">module book::ownership {
    public fun owner() {
        let a = 1; // a is owned by the `owner` function's scope
        {
            let b = 2; // b is owned by the block
            {
                let c = 3; // c is owned by the block
            }; // c is dropped here
        }; // b is dropped here
        // a = b; // error: b is not valid here
        // a = c; // error: c is not valid here
    } // a is dropped here
}
</code></pre>
<p>However, shall we use the return value of a block, the ownership of the variable is transferred to the caller of the block.</p>
<pre><code class="language-move">module book::ownership {
    public fun owner(): u8 {
        let a = 1; // a is owned by the `owner` function's scope
        let b = {
            let c = 2; // c is owned by the block
            c // c is returned
        }; // c is dropped here
        a + b // both a and b are valid here
    }
}
</code></pre>
<h2 id="copyable-types"><a class="header" href="#copyable-types">Copyable Types</a></h2>
<p>Some types in Move are <em>copyable</em>, which means that they can be copied without transferring the ownership. This is useful for types that are small and cheap to copy, such as integers and booleans. Move compiler will automatically copy these types when they are passed to a function or returned from a function, or when they're <em>moved</em> to a scope and then accessed in their original scope.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abilities-copy"><a class="header" href="#abilities-copy">Abilities: Copy</a></h1>
<p>In Move, the <em>copy</em> ability on a type indicates that the instance or the value of the type can be copied. While this behavior may feel very natural when working with numbers or other simple types, it is not the default for custom types in Move. This is because Move is designed to express digital assets and resources, and inability to copy is a key element of the resource model.</p>
<p>However, Move type system allows you to define custom types with the <em>copy</em> ability.</p>
<pre><code class="language-move">public struct Copyable has copy {}
</code></pre>
<p>In the example above, we define a custom type <code>Copyable</code> with the <em>copy</em> ability. This means that instances of <code>Copyable</code> can be copied, both implicitly and explicitly.</p>
<pre><code class="language-move">let a = Copyable {};
let b = a;   // `a` is copied to `b`
let c = *&amp;b; // explicit copy via dereference operator
</code></pre>
<p>In the example above, <code>a</code> is copied to <code>b</code> implicitly, and then explicitly copied to <code>c</code> using the dereference operator. If <code>Copyable</code> did not have the <em>copy</em> ability, the code would not compile, and the Move compiler would raise an error.</p>
<h2 id="copying-and-drop"><a class="header" href="#copying-and-drop">Copying and Drop</a></h2>
<p>The <code>copy</code> ability is closely related to <a href="basic-syntax/./drop-ability.html"><code>drop</code> ability</a>. If a type has the <em>copy</em> ability, very likely that it should have <code>drop</code> too. This is because the <em>drop</em> ability is required to clean up the resources when the instance is no longer needed. If a type has only <em>copy</em>, then managing its instances gets more complicated, as the values cannot be ignored.</p>
<pre><code class="language-move">public struct Value has copy, drop {}
</code></pre>
<p>All of the primitive types in Move behave as if they have the <em>copy</em> and <em>drop</em> abilities. This means that they can be copied and dropped, and the Move compiler will handle the memory management for them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<!--

Chapter: Basic Syntax
Goal: Show what the borrow checker is and how it works.
Notes:
    - give the metro pass example
    - show why passing by reference is useful
    - mention that reference comparison is faster
    - references can be both mutable and immutable
    - immutable access to shared objects is faster
    - implicit copy
    - moving the value
    - unpacking a reference (mutable and immutable)

 -->
<p>In <a href="basic-syntax/./ownership-and-scope.html">the previous section</a> we explained the ownership and scope in Move. We showed how the value is <em>moved</em> to a new scope, and how it changes the owner. In this section, we will explain how to <em>borrow</em> a reference to a value to avoid moving it, and how Move's <em>borrow checker</em> ensures that the references are used correctly.</p>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<p>References are a way to borrow a value without changing its owner. Immutable references allow the function to read the value without changing it or moving it. And mutable references allow the function to read and modify the value without moving it. To illustrate this, let's consider a simple example - an application for a metro (subway) pass. We will look at 4 different scenarios:</p>
<ol>
<li>Card can be purchased at the kiosk for a fixed price</li>
<li>Card can be shown to inspectors to prove that the passenger has a valid pass</li>
<li>Card can be used at the turnstile to enter the metro, and spend a ride</li>
<li>Card can be recycled once it's empty</li>
</ol>
<pre><code class="language-move">module book::references {

    /// Error code for when the card is empty.
    const ENoUses: u64 = 0;

    /// Number of uses for a metro pass card.
    const USES: u8 = 3;

    /// A metro pass card
    struct Card { uses: u8 }

    /// Purchase a metro pass card.
    public fun purchase(/* pass a Coin */): Card {
        Card { uses: USES }
    }

    /// Show the metro pass card to the inspector.
    public fun show(card: &amp;Card): bool {
        card.uses &gt; 0
    }

    /// Use the metro pass card at the turnstile to enter the metro.
    public fun enter_metro(card: &amp;mut Card) {
        assert!(card.uses &gt; 0, ENoUses);
        card.uses = card.uses - 1;
    }

    /// Recycle the metro pass card.
    public fun recycle(card: Card) {
        assert!(card.uses == 0, ENoUses);
        let Card { uses: _ } = card;
    }

    #[test]
    fun test_card() {
        // declaring variable as mutable because we modify it
        let mut card = purchase();

        card.enter_metro(); // modify the card but don't move it
        assert!(card.show(), true); // read the card!

        card.enter_metro(); // modify the card but don't move it
        card.enter_metro(); // modify the card but don't move it

        card.recycle(); // move the card out of the scope
    }
}
</code></pre>
<h2 id="mutable-references"><a class="header" href="#mutable-references">Mutable References</a></h2>
<!-- TODO: talk about the number of references at a time -->
<h2 id="dereference-and-copy"><a class="header" href="#dereference-and-copy">Dereference and Copy</a></h2>
<!-- TODO: defer and copy, *& -->
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<!--
    Move 2024 is great but it's better to show the example with explicit &t and &mut t
    ...and then say that the example could be rewritten with the new syntax


-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Generics are a way to define a type or function that can work with any type. This is useful when you want to write a function which can be used with different types, or when you want to define a type that can hold any other type. Generics are the foundation of many advanced features in Move, such as collections, abstract implementations, and more.</p>
<h2 id="in-the-standard-library"><a class="header" href="#in-the-standard-library">In the Standard Library</a></h2>
<p>In this chapter we already mentioned the <a href="basic-syntax/./vector.html">vector</a> type, which is a generic type that can hold any other type. Another example of a generic type in the standard library is the <a href="basic-syntax/./option.html">Option</a> type, which is used to represent a value that may or may not be present.</p>
<h2 id="generic-syntax"><a class="header" href="#generic-syntax">Generic Syntax</a></h2>
<p>To define a generic type or function, a type signature needs to have a list of generic parameters enclosed in angle brackets (<code>&lt;</code> and <code>&gt;</code>). The generic parameters are separated by commas.</p>
<pre><code class="language-move">/// Container for any type `T`.
public struct Container&lt;T&gt; has drop {
    value: T,
}

/// Function that creates a new `Container` with a generic value `T`.
public fun new&lt;T&gt;(value: T): Container&lt;T&gt; {
    Container { value }
}
</code></pre>
<p>In the example above, <code>Container</code> is a generic type with a single type parameter <code>T</code>, the <code>value</code> field of the container stores the <code>T</code>. The <code>new</code> function is a generic function with a single type parameter <code>T</code>, and it returns a <code>Container</code> with the given value. Generic types must be initialed with a concrete type, and generic functions must be called with a concrete type.</p>
<pre><code class="language-move">#[test]
fun test_container() {
    // these three lines are equivalent
    let container: Container&lt;u8&gt; = new(10); // type inference
    let container = new&lt;u8&gt;(10); // create a new `Container` with a `u8` value
    let container = new(10u8);

    assert!(container.value == 10, 0x0);

    // Value can be ignored only if it has the `drop` ability.
    let Container { value: _ } = container;
}
</code></pre>
<p>In the test function <code>test_generic</code> we demonstrate three equivalent ways to create a new <code>Container</code> with a <code>u8</code> value. Because numeric types need to be inferred, we specify the type of the number literal.</p>
<h2 id="multiple-type-parameters"><a class="header" href="#multiple-type-parameters">Multiple Type Parameters</a></h2>
<p>You can define a type or function with multiple type parameters. The type parameters are then separated by commas.</p>
<pre><code class="language-move">/// A pair of values of any type `T` and `U`.
public struct Pair&lt;T, U&gt; {
    first: T,
    second: U,
}

/// Function that creates a new `Pair` with two generic values `T` and `U`.
public fun new_pair&lt;T, U&gt;(first: T, second: U): Pair&lt;T, U&gt; {
    Pair { first, second }
}
</code></pre>
<p>In the example above, <code>Pair</code> is a generic type with two type parameters <code>T</code> and <code>U</code>, and the <code>new_pair</code> function is a generic function with two type parameters <code>T</code> and <code>U</code>. The function returns a <code>Pair</code> with the given values. The order of the type parameters is important, and it should match the order of the type parameters in the type signature.</p>
<pre><code class="language-move">#[test]
fun test_generic() {
    // these three lines are equivalent
    let pair_1: Pair&lt;u8, bool&gt; = new_pair(10, true); // type inference
    let pair_2 = new_pair&lt;u8, bool&gt;(10, true); // create a new `Pair` with a `u8` and `bool` values
    let pair_3 = new_pair(10u8, true);

    assert!(pair_1.first == 10, 0x0);
    assert!(pair_1.second, 0x0);

    // Unpacking is identical.
    let Pair { first: _, second: _ } = pair_1;
    let Pair { first: _, second: _ } = pair_2;
    let Pair { first: _, second: _ } = pair_3;

}
</code></pre>
<p>If we added another instance where we swapped type parameters in the <code>new_pair</code> function, and tried to compare two types, we'd see that the type signatures are different, and cannot be compared.</p>
<pre><code class="language-move">#[test]
fun test_swap_type_params() {
    let pair1: Pair&lt;u8, bool&gt; = new_pair(10u8, true);
    let pair2: Pair&lt;bool, u8&gt; = new_pair(true, 10u8);

    // this line will not compile
    // assert!(pair1 == pair2, 0x0);

    let Pair { first: pf1, second: ps1 } = pair1; // first1: u8, second1: bool
    let Pair { first: pf2, second: ps2 } = pair2; // first2: bool, second2: u8

    assert!(pf1 == ps2, 0x0); // 10 == 10
    assert!(ps1 == pf2, 0x0); // true == true
}
</code></pre>
<p>Types for variables <code>pair1</code> and <code>pair2</code> are different, and the comparison will not compile.</p>
<h2 id="why-generics"><a class="header" href="#why-generics">Why Generics?</a></h2>
<p>In the examples above we focused on instantiating generic types and calling generic functions to create instances of these types. However, the real power of generics is the ability to define shared behavior for the base, generic type, and then use it independently of the concrete types. This is especially useful when working with collections, abstract implementations, and other advanced features in Move.</p>
<pre><code class="language-move">/// A user record with name, age, and some generic metadata
public struct User&lt;T&gt; {
    name: String,
    age: u8,
    /// Varies depending on application.
    metadata: T,
}
</code></pre>
<p>In the example above, <code>User</code> is a generic type with a single type parameter <code>T</code>, with shared fields <code>name</code> and <code>age</code>, and the generic <code>metadata</code> field which can store any type. No matter what the <code>metadata</code> is, all of the instances of <code>User</code> will have the same fields and methods.</p>
<pre><code class="language-move">/// Updates the name of the user.
public fun update_name&lt;T&gt;(user: &amp;mut User&lt;T&gt;, name: String) {
    user.name = name;
}

/// Updates the age of the user.
public fun update_age&lt;T&gt;(user: &amp;mut User&lt;T&gt;, age: u8) {
    user.age = age;
}
</code></pre>
<h2 id="phantom-type-parameters"><a class="header" href="#phantom-type-parameters">Phantom Type Parameters</a></h2>
<p>In some cases, you may want to define a generic type with a type parameter that is not used in the fields or methods of the type. This is called a <em>phantom type parameter</em>. Phantom type parameters are useful when you want to define a type that can hold any other type, but you want to enforce some constraints on the type parameter.</p>
<pre><code class="language-move">/// A generic type with a phantom type parameter.
public struct Coin&lt;phantom T&gt; {
    value: u64
}
</code></pre>
<p>The <code>Coin</code> type here does not contain any fields or methods that use the type parameter <code>T</code>. It is used to differentiate between different types of coins, and to enforce some constraints on the type parameter <code>T</code>.</p>
<pre><code class="language-move">public struct USD {}
public struct EUR {}

#[test]
fun test_phantom_type() {
    let coin1: Coin&lt;USD&gt; = Coin { value: 10 };
    let coin2: Coin&lt;EUR&gt; = Coin { value: 20 };

    // Unpacking is identical because the phantom type parameter is not used.
    let Coin { value: _ } = coin1;
    let Coin { value: _ } = coin2;
}
</code></pre>
<p>In the example above, we demonstrate how to create two different instances of <code>Coin</code> with different phantom type parameters <code>USD</code> and <code>EUR</code>. The type parameter <code>T</code> is not used in the fields or methods of the <code>Coin</code> type, but it is used to differentiate between different types of coins. It will make sure that the <code>USD</code> and <code>EUR</code> coins are not mixed up.</p>
<h2 id="constraints-on-type-parameters"><a class="header" href="#constraints-on-type-parameters">Constraints on Type Parameters</a></h2>
<p>Type parameters can be constrained to have certain abilities. This is useful when you need the inner type to allow certain behavior, such as <em>copy</em> or <em>drop</em>. The syntax for constraining a type parameter is <code>T: &lt;ability&gt; + &lt;ability&gt;</code>.</p>
<pre><code class="language-move">/// A generic type with a type parameter that has the `drop` ability.
public struct Droppable&lt;T: drop&gt; {
    value: T,
}

/// A generic struct with a type parameter that has the `copy` and `drop` abilities.
public struct CopyableDroppable&lt;T: copy + drop&gt; {
    value: T, // T must have the `copy` and `drop` abilities
}
</code></pre>
<p>Move Compiler will enforce that the type parameter <code>T</code> has the specified abilities. If the type parameter does not have the specified abilities, the code will not compile.</p>
<!-- TODO: failure case -->
<pre><code class="language-move">/// Type without any abilities.
public struct NoAbilities {}

#[test]
fun test_constraints() {
    // Fails - `NoAbilities` does not have the `drop` ability
    // let droppable = Droppable&lt;NoAbilities&gt; { value: 10 };

    // Fails - `NoAbilities` does not have the `copy` and `drop` abilities
    // let copyable_droppable = CopyableDroppable&lt;NoAbilities&gt; { value: 10 };
}
</code></pre>
<h2 id="further-reading-2"><a class="header" href="#further-reading-2">Further Reading</a></h2>
<!-- Abilities propagation to parent -->
<!--  -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-reflection"><a class="header" href="#type-reflection">Type Reflection</a></h1>
<p>In programming languages <em>reflection</em> is the ability of a program to examine and modify its own structure and behavior. In Move, there's a limited form of reflection that allows you to inspect the type of a value at runtime. This is useful when you need to store type information in a homogeneous collection, or when you need to check if a type belongs to a package.</p>
<p>Type reflection is implemented in the <a href="basic-syntax/./standard-library.html">Standard Library</a> module <code>std::type_name</code>. Expressed very roughly, it gives a single function <code>get&lt;T&gt;()</code> which returns the name of the type <code>T</code>.</p>
<h2 id="in-practice-1"><a class="header" href="#in-practice-1">In practice</a></h2>
<p>The module is pretty straightforward, and operations allowed on the result are limited to getting a string representation and extracting the module and address of the type.</p>
<pre><code class="language-move">module book::type_reflection {
    use std::ascii::String;
    use std::type_name::{Self, TypeName};

    use fun std::ascii::string as vector.to_ascii_string;

    /// A function that returns the name of the type `T` and its module and address.
    public fun i_dont_know_you&lt;T&gt;(): (String, String, String) {
        let type_name: TypeName = type_name::get&lt;T&gt;();

        // there's a way to borrow
        let str: &amp;String = type_name.borrow_string();

        let module_name: String = type_name.get_module();
        let address_str: String = type_name.get_address();

        // and a way to consume the value
        let str = type_name.into_string();

        (str, module_name, address_str)
    }

    #[test_only]
    public struct MyType {}

    #[test]
    fun test_type_reflection() {
        let (type_name, module_name, _address_str) = i_dont_know_you&lt;MyType&gt;();

        //
        assert!(module_name == b"type_reflection".to_ascii_string(), 1);
    }
}
</code></pre>
<h2 id="further-reading-3"><a class="header" href="#further-reading-3">Further reading</a></h2>
<p>Type reflection is an important part of the language, and it is a crucial part of some of the more advanced patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>A crucial part of any software development, and even more - blockchain development, is testing. Here, we will cover the basics of testing in Move and how to write and organize tests for your Move code.</p>
<h2 id="the-test-attribute"><a class="header" href="#the-test-attribute">The <code>#[test]</code> attribute</a></h2>
<p>Tests in Move are functions marked with the <code>#[test]</code> attribute. This attribute tells the compiler that the function is a test function, and it should be run when the tests are executed. Test functions are regular functions, but they must return <code>()</code> and take no arguments. They are excluded from the bytecode, and are not included in the final package.</p>
<pre><code class="language-move">module book::testing {
    // Test attribute is placed before the `fun` keyword. Can be both above or
    // right before the `fun` keyword: `#[test] fun my_test() { ... }`
    // The name of the test would be `book::testing::simple_test`.
    #[test]
    fun simple_test() {
        let sum = 2 + 2;
        assert!(sum == 4, 1);
    }

    // The name of the test would be `book::testing::more_advanced_test`.
    #[test] fun more_advanced_test() {
        let sum = 2 + 2 + 2;
        assert!(sum == 4, 1);
    }
}
</code></pre>
<h2 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h2>
<p>To run tests, you can use the <code>sui move test</code> command. This command will first build the package in the <em>test mode</em> and then run all the tests found in the package. During test mode, modules from both <code>sources/</code> and <code>tests/</code> directories are processed, and the tests are executed.</p>
<pre><code class="language-bash">$ sui move test
&gt; INCLUDING DEPENDENCY Sui
&gt; INCLUDING DEPENDENCY MoveStdlib
&gt; BUILDING book
&gt; Running Move unit tests
&gt; ...
</code></pre>
<!-- TODO: fill output -->
<h2 id="utilities-with-test_only"><a class="header" href="#utilities-with-test_only">Utilities with <code>#[test_only]</code></a></h2>
<p>In some cases, it is helpful to give the test environment access to some of the internal functions or features. It simplifies the testing process and allows for more thorough testing. However, it is important to remember that these functions should not be included in the final package. This is where the <code>#[test_only]</code> attribute comes in handy.</p>
<pre><code class="language-move">module book::testing {
    // Public function which uses the `secret` function.
    public fun multiply_by_secret(x: u64): u64 {
        x * secret()
    }

    /// Private function which is not available to the public.
    fun secret(): u64 { 100 }

    #[test_only]
    /// This function is only available for testing purposes in tests and other
    /// test-only functions. Mind the visibility - for `#[test_only]` it is
    /// common to use `public` visibility.
    public fun secret_for_testing(): u64 {
        secret()
    }

    #[test]
    // In the test environment we have access to the `secret_for_testing` function.
    fun test_multiply_by_secret() {
        let expected = secret_for_testing() * 2;
        assert!(multiply_by_secret(2) == expected, 1);
    }
}
</code></pre>
<p>Functions marked with the <code>#[test_only]</code> will be available to the test environment, and to the other modules if their visibility is set so.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="it-starts-with-an-object"><a class="header" href="#it-starts-with-an-object">It starts with an Object</a></h1>
<p>In the <a href="object/../basic-syntax/README.html">Basic Syntax</a> section, we learned about the basics of Move. And there was one topic that we never touched upon - storage. As a language, Move does not have a built-in storage model, and it is up to the platform developers to implement the storage model. This is an important aspect of Move, as it allows the platform to be flexible and adapt to different use cases. In this section, we will focus on the Sui storage model, which is the <em>Object Model</em>. We will dive into the details of parallel execution, and how the Object Model helps solve the scalability and concurrent data access challenges of blockchain platforms.</p>
<p>This chapter is split into the following sections:</p>
<ul>
<li><a href="object/./key-ability.html">The Key Ability</a> - there we introduce the <code>key</code> ability and explain how it is used in Sui to define Objects.</li>
<li><a href="object/./what-is-an-object.html">What is an Object</a> - we expand on the <a href="object/./../concepts/object-model.html">concept of an Object</a> and provide a more in-depth explanation of its use in practice.</li>
<li><a href="object/./true-ownership.html">True Ownership</a> - we explain the concept of <em>true ownership</em> and how it is addressed and implemented in the Sui Object Model. It has its befenits and drawbacks, and we will illustrate and explain them.</li>
<li><a href="object/./transfer-restrictions.html">Transfer Restrictions</a> - a fundamental concept in Sui - the ability to restrict or relax the transfer ability of an Object using the <code>store</code> ability.</li>
<li><a href="object/./shared-state.html">Immutable Data</a> - fundamental principles of shared state in Sui, and how shared immutable data is used in concurrent execution.</li>
<li><a href="object/./shared-state.html">Shared State</a> - we explain how shared state works in Sui, and how it is used to implement concurrent execution.</li>
<li><a href="object/./transfer-to-object.html">Transfer to Object</a> - rather special scenario in the Object model which allows transferring an Object to another Object.</li>
</ul>
<p>The goal of this chapter is to provide a comprehensive understanding of the Object Model and its use on Sui. And in the <a href="object/./../programmability/README.html">next chapter</a>, we will dive deepere into <em>special</em> features of Sui which make it unique and powerful.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-programmability"><a class="header" href="#advanced-programmability">Advanced Programmability</a></h1>
<p>In previous chapters we've covered <a href="programmability/./../basic-syntax/README.html">the basics of Move</a> and <a href="programmability/./../programmability/README.html">Sui Storage Model</a>. Now it's time to dive deeper into the advanced topics of Sui programmability.</p>
<p>This chapter introduces more complex concepts, practices and features of Move and Sui that are essential for building more sophisticated applications. It is intended for developers who are already familiar with the basics of Move and Sui, and are looking to expand their knowledge and skills.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-context"><a class="header" href="#transaction-context">Transaction Context</a></h1>
<p>Every transaction has the execution context. The context is a set of pre-defined variables that are available to the program during execution. For example, every transaction has a sender address, and the transaction context contains a variable that holds the sender address.</p>
<p>The transaction context is available to the program through the <code>TxContext</code> struct. The struct is defined in the <code>sui::tx_context</code> module and contains the following fields:</p>
<p>File: sui-framework/tx_context.move</p>
<pre><code class="language-move">/// Information about the transaction currently being executed.
/// This cannot be constructed by a transaction--it is a privileged object created by
/// the VM and passed in to the entrypoint of the transaction as `&amp;mut TxContext`.
struct TxContext has drop {
    /// The address of the user that signed the current transaction
    sender: address,
    /// Hash of the current transaction
    tx_hash: vector&lt;u8&gt;,
    /// The current epoch number
    epoch: u64,
    /// Timestamp that the epoch started at
    epoch_timestamp_ms: u64,
    /// Counter recording the number of fresh id's created while executing
    /// this transaction. Always 0 at the start of a transaction
    ids_created: u64
}
</code></pre>
<p>Transaction context cannot be constructed manually or directly modified. It is created by the system and passed to the function as a reference in a transaction. Any function called in a <a href="programmability/./transaction-blocks.html">Transaction Block</a> has access to the context and can pass it into the nested calls.</p>
<blockquote>
<p><code>TxContext</code> has to be the last argument in the function signature.</p>
</blockquote>
<h2 id="reading-the-transaction-context"><a class="header" href="#reading-the-transaction-context">Reading the Transaction Context</a></h2>
<p>With only exception of the <code>ids_created</code>, all of the fields in the <code>TxContext</code> have getters. The getters are defined in the <code>sui::tx_context</code> module and are available to the program. The getters don't require <code>&amp;mut</code> because they don't modify the context.</p>
<pre><code class="language-move">public fun some_action(ctx: &amp;TxContext) {
    let _me = ctx.sender()
    let _epoch = ctx.epoch();
    let _digest = ctx.digest();
    // ...
}
</code></pre>
<h2 id="mutability"><a class="header" href="#mutability">Mutability</a></h2>
<p>The <code>TxContext</code> is required to create new objects (or just <code>UID</code>s) in the system. New UIDs are derived from the transaction digest, and for the digest to be unique, there needs to be a changing parameter. Sui uses the <code>ids_created</code> field for that. Every time a new UID is created, the <code>ids_created</code> field is incremented by one. This way, the digest is always unique.</p>
<p>Internally, it is represented as the <code>derive_id</code> function:</p>
<p><em>File: sui-framework/tx_context.move</em></p>
<pre><code class="language-move">native fun derive_id(tx_hash: vector&lt;u8&gt;, ids_created: u64): address;
</code></pre>
<h2 id="generating-unique-addresses"><a class="header" href="#generating-unique-addresses">Generating unique addresses</a></h2>
<p>The underlying <code>derive_id</code> function can also be utilized in your program to generate unique addresses. The function itself is not exposed, but a wrapper function <code>fresh_object_address</code> is available in the <code>sui::tx_context</code> module. It may be useful if you need to generate a unique identifier in your program.</p>
<p>File: sui-framework/tx_context.move</p>
<pre><code class="language-move">/// Create an `address` that has not been used. As it is an object address, it will never
/// occur as the address for a user.
/// In other words, the generated address is a globally unique object ID.
public fun fresh_object_address(ctx: &amp;mut TxContext): address {
    let ids_created = ctx.ids_created;
    let id = derive_id(*&amp;ctx.tx_hash, ids_created);
    ctx.ids_created = ids_created + 1;
    id
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-capability"><a class="header" href="#pattern-capability">Pattern: Capability</a></h1>
<p>In programming, a <em>capability</em> is a token that gives the owner the right to perform a specific action. It is a pattern that is used to control access to resources and operations. A simple example of a capability is a key to a door. If you have the key, you can open the door. If you don't have the key, you can't open the door. A more practical example is an Admin Capability which allows the owner to perform administrative operations, which regular users cannot.</p>
<h2 id="capability-is-an-object"><a class="header" href="#capability-is-an-object">Capability is an Object</a></h2>
<p>In the <a href="programmability/./../concepts/object-model.html">Sui Object Model</a>, capabilities are represented as objects. An owner of an object can pass this object to a function to prove that they have the right to perform a specific action. Due to strict typing, the function taking a capability as an argument can only be called with the correct capability.</p>
<pre><code class="language-move">module book::capability {
    use std::string::String;

    use sui::object::new as TxContext.fresh_uid;

    /// The capability granting the application admin the right to create new
    /// accounts in the system.
    struct AdminCap has key, store { id: UID }

    /// The user account in the system.
    struct Account has key, store {
        id: UID,
        name: String
    }

    /// Creates a new account in the system. Requires the `AdminCap` capability
    /// to be passed as the first argument.
    public fun new(_: &amp;AdminCap, name: String, ctx: &amp;mut TxContext): Account {
        Account {
            id: ctx.fresh_uid(),
            name,
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fast-path"><a class="header" href="#fast-path">Fast Path</a></h1>
<p>Due to the object model and the data organization model of Sui, some operations can be performed in a more efficient and parallelized way. This is called the <strong>fast path</strong>. Transaction that touches shared state requires consensus because it can be accessed by multiple parties at the same time. However, if the transaction only touches the private state (owned objects), there is no need for consensus. This is the fast path.</p>
<p>We have a favorite example for this: a coffee machine and a coffee cup. The coffee machine placed in the office is a shared resource - everyone can use it, but there can be only one user at a time. The coffee cup, on the other hand, is a private resource - it belongs to a specific person, and only that person can use it. To make coffee, one needs to use the coffee machine and wait if there's someone else using it. However, once the coffee is made and poured into the cup, the person can take the cup and drink the coffee without waiting for anyone else.</p>
<p>The same principle applies to Sui. If a transaction only touches the private state (the cup with coffee), it can be executed without consensus. If it touches the shared state (the coffee machine), it requires consensus. This is the fast path.</p>
<h2 id="frozen-objects"><a class="header" href="#frozen-objects">Frozen objects</a></h2>
<p>Consensus is only required for mutating the shared state. If the object is immutable, it is treated as a "constant" and can be accessed in parallel. Frozen objects can be used to share unchangable data between multiple parties without requiring consensus.</p>
<h2 id="in-practice-2"><a class="header" href="#in-practice-2">In practice</a></h2>
<pre><code class="language-move">module book::coffee_machine {
    use sui::object::{Self, UID};
    use sui::tx_context::TxContext;

    /// Coffee machine is a shared object, hence requires `key` ability.
    struct CoffeeMachine has key { id: UID, counter: u16 }

    /// Cup is an owned object.
    struct Cup has key, store { id: UID, has_coffee: bool }

    /// Initialize the module and share the `CoffeeMachine` object.
    fun init(ctx: &amp;mut TxContext) {
        transfer::share_object(CoffeeMachine {
            id: object::new(ctx),
            counter: 0
        });
    }

    /// Take a cup out of thin air. This is a fast path operation.
    public fun take_cup(ctx: &amp;mut TxContext): Cup {
        Cup { id: object::new(ctx), has_coffee: false }
    }

    /// Make coffee and pour it into the cup. Requires consensus.
    public fun make_coffee(mut machine: &amp;mut CoffeeMachine, mut cup: &amp;mut Cup) {
        machine.counter = machine.counter + 1;
        cup.has_coffee = true;
    }

    /// Drink coffee from the cup. This is a fast path operation.
    public fun drink_coffee(mut cup: &amp;mut Cup) {
        cup.has_coffee = false;
    }

    /// Put the cup back. This is a fast path operation.
    public fun put_back(cup: Cup) {
        let Cup { id, has_coffee: _ } = cup;
        object::delete(id);
    }
}
</code></pre>
<h2 id="special-case-clock"><a class="header" href="#special-case-clock">Special case: Clock</a></h2>
<p>The <code>Clock</code> object with the reserved address <code>0x6</code> is a special case of a shared object which maintains the fast path. While being a shared object, it cannot be passed by a mutable reference in a regular transaction. An attempt to do so will not succeed, and the transaction will be rejected.</p>
<!-- Add more on why and how -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections"><a class="header" href="#collections">Collections</a></h1>
<p>Collection types are a fundamental part of any programming language. They are used to store a collection of data, such as a list of items. The <code>vector</code> type has already been covered in the <a href="programmability/../basic-syntax/standard-library.html">vector section</a>, and in this chapter we will cover the collection types offered by the Sui Framework.</p>
<ul>
<li><a href="programmability/collections.html#VecSet">VecSet</a></li>
<li><a href="programmability/collections.html#VecMap">VecMap</a></li>
</ul>
<h2 id="vecset"><a class="header" href="#vecset">VecSet</a></h2>
<p><code>VecSet</code> is a collection type that stores a set of unique items. It is similar to a <code>vector</code>, but it does not allow duplicate items. This makes it useful for storing a collection of unique items, such as a list of unique IDs or addresses.</p>
<pre><code class="language-move">module book::collections {
    use sui::vec_set::{Self, VecSet};

    struct App has drop {
        /// `VecSet` used in the struct definition
        subscribers: VecSet&lt;address&gt;
    }

    #[test]
    fun vec_set_playground() {
        let set = vec_set::empty(); // create an empty set
        let set = vec_set::sigleton(1); // create a set with a single item

        set.insert(2); // add an item to the set
        set.insert(3);

        assert!(set.contains(1), 0); // check if an item is in the set
        assert!(set.size() == 3, 1); // get the number of items in the set
        assert!(!set.is_empty(), 2); // check if the set is empty

        set.remove(2); // remove an item from the set
    }
}
</code></pre>
<h2 id="vecmap"><a class="header" href="#vecmap">VecMap</a></h2>
<p><code>VecMap</code> is a collection type that stores a map of key-value pairs. It is similar to a <code>VecSet</code>, but it allows you to associate a value with each item in the set. This makes it useful for storing a collection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs and their associated data.</p>
<p>Keys in a <code>VecMap</code> are unique, and each key can only be associated with a single value. If you try to insert a key-value pair with a key that already exists in the map, the old value will be replaced with the new value.</p>
<pre><code class="language-move">module book::collections {
    use std::string::String;
    use sui::vec_map::{Self, VecMap};

    struct Metadata has drop {
        name: String
        /// `VecMap` used in the struct definition
        attributes: VecMap&lt;String, String&gt;
    }

    #[test]
    fun vec_map_playground() {
        let mut map = vec_map::empty(); // create an empty map

        map.insert(2, b"two".to_string()); // add a key-value pair to the map
        map.insert(3, b"three".to_string());

        assert!(map.contains(1), 0); // check if a key is in the map

        map.remove(&amp;2); // remove a key-value pair from the map
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-fields"><a class="header" href="#dynamic-fields">Dynamic Fields</a></h1>
<p>Sui Object model allows objects to be attached to other objects as <em>dynamic fields</em>. The behavior is similar to how a <code>Map</code> works in other programming languages, however, the types of attached objects can be any. This allows for a wide range of use cases, such as attaching an accessory to a character, or storing large, non-heterogeneous collections in a single object.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>Dynamic fields are attached to an object via a <em>key</em>, which can be any type with the <em>store</em>, <em>copy</em> and <em>drop</em> abilities. The key is used to access the attached object, and can be used to update or remove it. The attached object can be any type, if it has the <em>store</em> ability.</p>
<!-- In practice, the representation of an object is its UID, so dynamic fields are attached not to the object itself, but to its UID. This means two things: first, dynamic fields can be attached to an object, and second - they can be attached to a UID directly. -->
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Dynamic fields are defined in the <code>sui::dynamic_field</code> module.</p>
<pre><code class="language-move">module book::accessories {

    struct Character has key {
        id: UID,
        name: String
    }

    /// An accessory that can be attached to a character.
    struct Accessory has store {
        type: String,
        name: String,
    }
}
</code></pre>
<h2 id="dynamic-object-fields"><a class="header" href="#dynamic-object-fields">Dynamic Object Fields</a></h2>
<p>TODO:</p>
<ul>
<li>dynamic object fields</li>
<li>discoverability benefits of DOFs</li>
</ul>
<h2 id="custom-fields-for-keys"><a class="header" href="#custom-fields-for-keys">Custom Fields for Keys</a></h2>
<p>TODO: explain how custom fields ca</p>
<h2 id="applications"><a class="header" href="#applications">Applications</a></h2>
<p>Dynamic fields are used for:</p>
<ul>
<li>Heterogeneous collections</li>
<li>Storing large data that does not fit into the object limit size</li>
<li>Attaching objects to other objects as a part of application logic</li>
<li>Extending existing types with additional data</li>
<li>Storing data that is not always present</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epoch-and-time"><a class="header" href="#epoch-and-time">Epoch and Time</a></h1>
<p>Sui has two ways of accessing the current time: <code>Epoch</code> and <code>Time</code>. The former represents operational periods in the system and changed roughly every 24 hours. The latter represents the current time in milliseconds since the Unix Epoch. Both can be accessed freely in the program.</p>
<h2 id="epoch"><a class="header" href="#epoch">Epoch</a></h2>
<p>Epochs are used to separate the system into operational periods. During an epoch the validator set is fixed, however, at the epoch boundary, the validator set can be changed. Epochs play a crucial role in the consensus algorithm and are used to determine the current validator set. They are also used as measurement in the staking mechanism.</p>
<p>Epoch can be read from the <a href="programmability/./transaction-context.html">transaction context</a>:</p>
<pre><code class="language-move">public fun current_epoch(ctx: &amp;TxContext) {
    let epoch = ctx.epoch();
    // ...
}
</code></pre>
<p>It is also possible to get the unix timestamp of the epoch start:</p>
<pre><code class="language-move">public fun current_epoch_start(ctx: &amp;TxContext) {
    let epoch_start = ctx.epoch_timestamp_ms();
    // ...
}
</code></pre>
<p>Normally, epochs are used in staking and system operations, however, in custom scenarios they can be used to emulate 24h periods. They are cricital if an application relies on the staking logic or needs to know the current validator set.</p>
<h2 id="time"><a class="header" href="#time">Time</a></h2>
<p>For a more precise time measurement, Sui provides the <code>Clock</code> object. It is a system object that is updated during checkpoints by the system, which stores the current time in milliseconds since the Unix Epoch. The <code>Clock</code> object is defined in the <code>sui::clock</code> module and has a reserved address <code>0x6</code>.</p>
<p>Clock is a shared object and normally would require consensus to access. However, <code>Clock</code> is special, and the system won't allow accessing it mutably, so that the only way to access it is immutably. This limitation allows parallel access to the <code>Clock</code> object and makes it a <a href="programmability/./fast-path.html">fast path operation</a>.</p>
<p>File: sui-framework/clock.move</p>
<pre><code class="language-move">/// Singleton shared object that exposes time to Move calls.  This
/// object is found at address 0x6, and can only be read (accessed
/// via an immutable reference) by entry functions.
///
/// Entry Functions that attempt to accept `Clock` by mutable
/// reference or value will fail to verify, and honest validators
/// will not sign or execute transactions that use `Clock` as an
/// input parameter, unless it is passed by immutable reference.
struct Clock has key {
    id: UID,
    /// The clock's timestamp, which is set automatically by a
    /// system transaction every time consensus commits a
    /// schedule, or by `sui::clock::increment_for_testing` during
    /// testing.
    timestamp_ms: u64,
}
</code></pre>
<p>There is only one public function available in the <code>Clock</code> module - <code>timestamp_ms</code>. It returns the current time in milliseconds since the Unix Epoch.</p>
<pre><code class="language-move">/// Clock needs to be passed as an immutable reference.
public fun current_time(clock: &amp;Clock) {
    let _time = clock.timestamp_ms();
    // ...
}
</code></pre>
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<p>TODO: how to use Clock in tests.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abstract-class"><a class="header" href="#abstract-class">Abstract Class</a></h1>
<!-- Walk through a Coin example -->
<p>Some of the language features combined together can create patterns that are similar to other programming languages. The simplest example would be "getters and setters" - functions that get and set the value of a field. This pattern is possible, because struct fields are private by default, and can only be accessed through functions.</p>
<p>However, there are more advanced patterns, such as the abstract class. An abstract class is a class that cannot be instantiated, but can be inherited from. While Move does not have inheritance, it has generic structs, which can be instantiated with different types. This allows us to create a generic struct that can be used as an abstract class. Combined with a set of Witness-gated functions, this allows us to create a generic struct with a generic implementation.</p>
<p>Some of the methods in this approach will be shared and available to all implementations, while others will be abstract and will need to be implemented by the concrete implementations.</p>
<h2 id="generic-struct"><a class="header" href="#generic-struct">Generic Struct</a></h2>
<!--

Talk through Generic Struct and how it can be instantiated with a witness.

 -->
<h2 id="common-methods"><a class="header" href="#common-methods">Common methods</a></h2>
<!--

Showcase how common methods can be implemented for a generic struct.

 -->
<h2 id="witness-gated-functions"><a class="header" href="#witness-gated-functions">Witness-gated Functions</a></h2>
<!--

Showcase how witness-gated functions can be used to implement abstract methods.

 -->
<h2 id="differences-from-oop"><a class="header" href="#differences-from-oop">Differences from OOP</a></h2>
<p>While this approach imitates the abstract class pattern well, it is not the same as the abstract class in OOP. The main difference is that the abstract class in OOP and its implementors have different type. In Move, the base type stays the same, and the implementors set a generic type parameter. Another notable difference is that due to lack of dynamic dispatch and interfaces, the implemented methods are not available through the base type and can even be missing.</p>
<h2 id="usage-in-sui-framework"><a class="header" href="#usage-in-sui-framework">Usage in Sui Framework</a></h2>
<p>The Sui Framework uses this pattern to implement the <code>Coin</code> type and the underlying <code>Balance</code>. Its variation is also used in the Closed Loop Token implementation, however, the latter is a bit more complex, because it uses the Request pattern to dynamically implement the interface.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guides"><a class="header" href="#guides">Guides</a></h1>
<p>This section contains a collection of guides that cover various aspects of programming on Sui. They are intended to provide a deeper understanding of Sui blockchain and Move language, while also aiming at practical challenges and solutions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-2024-migration-guide"><a class="header" href="#move-2024-migration-guide">Move 2024 Migration Guide</a></h1>
<p>Move 2024 is the new edition of the Move language that is maintained by Mysten Labs. This guide is intended to help you understand the differences between the 2024 edition and the previous version of the Move language.</p>
<h2 id="using-the-new-edition"><a class="header" href="#using-the-new-edition">Using the New Edition</a></h2>
<p>To use the new edition, you need to specify the edition in the <code>move</code> file. The edition is specified in the <code>move</code> file using the <code>edition</code> keyword. Currently, the only available edition is <code>2024.alpha</code>.</p>
<pre><code class="language-ini">edition = "2024.beta";
</code></pre>
<h2 id="struct-visibility"><a class="header" href="#struct-visibility">Struct Visibility</a></h2>
<p>In Move 2024, structs get a visibility modifier. Just like functions, structs can be public, friend, or private.</p>
<pre><code class="language-move">// Move 2020
struct Book {}

// Move 2024
public struct Book {}
</code></pre>
<h2 id="struct-methods-1"><a class="header" href="#struct-methods-1">Struct Methods</a></h2>
<p>In the new edition, functions which have a struct as the first argument are associated with the struct. This means that the function can be called using the dot notation. Methods defined in the same module with the type are automatically exported.</p>
<pre><code class="language-move">public fun count(c: &amp;Counter): u64 { /* ... */ }

fun use_counter() {
    // move 2020
    let count = counter::count(&amp;c);

    // move 2024
    let count = c.count();
}
</code></pre>
<h2 id="borrowing-operator"><a class="header" href="#borrowing-operator">Borrowing Operator</a></h2>
<p>The <code>borrow</code> and <code>borrow_mut</code> functions (when defined) can be accessed using the square brackets. Just like the method syntax, the borrowing functions are associated with the type.</p>
<pre><code class="language-move">fun play_vec() {
    let v = vector[1,2,3,4];
    let first = v[0]; // calls vector::borrow(v, 0)
    v[0] = 5;         // calls vector::borrow_mut(v, 0)
}
</code></pre>
<h2 id="method-aliases-1"><a class="header" href="#method-aliases-1">Method Aliases</a></h2>
<p>In Move 2024, generic methods can be associated with types. The alias can be defined for any type privately to the module, or publicly, if the type is defined in the same module.</p>
<pre><code class="language-move">use fun my_custom_function as vector.do_magic;
</code></pre>
<h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>Macros are introduced in Move 2024. And <code>assert!</code> is no longer a built-in function - Instead, it's a macro.</p>
<pre><code class="language-move">// can be called as for!(0, 10, |i| call(i));
macro fun for($start: u64, $stop: u64, $body: |u64|) {
    let mut i = $start;
    let stop = $stop;
    while (i &lt; stop) {
        $body(i);
        i = i + 1
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgradability-practices"><a class="header" href="#upgradability-practices">Upgradability Practices</a></h1>
<p>To talk about best practices for upgradability, we need to first understand what can be upgraded in a package. The base premise of upgradability is that an upgrade should not break public compatibility with the previous version. The parts of the module which can be used in dependent packages should not change their static signature. This applies to modules - a module can not be removed from a package, public structs - they can be used in function signatures and public functions - they can be called from other packages.</p>
<pre><code class="language-move">// module can not be removed from the package
module book::upgradable {
    // dependencies can be changed
    use sui::tx_context::TxContext;
    use sui::object::UID;

    // public structs can not be removed and can't be changed
    public struct Book has key {
        id: UID
    }

    // public functions can not be removed and their signature can never change
    public fun create_book(ctx: &amp;mut TxContext): Book {
        create_book_internal(ctx)
    }

    // friend-only functions can be removed and changed
    public(friend) fun create_book_friend(ctx: &amp;mut TxContext): Book {
        create_book_internal(ctx)
    }

    // entry functions can be removed and changed as long they're not public
    entry fun create_book_entry(ctx: &amp;mut TxContext): Book {
        create_book_internal(ctx)
    }

    // private functions can be removed and changed
    fun create_book_internal(ctx: &amp;mut TxContext): Book {
        abort 0
    }
}
</code></pre>
<h2 id="using-entry-and-friend-functions"><a class="header" href="#using-entry-and-friend-functions">Using entry and friend functions</a></h2>
<p>TODO: Add a section about entry and friend functions</p>
<h2 id="versioning-objects"><a class="header" href="#versioning-objects">Versioning objects</a></h2>
<!-- This practice is for function version locking based on a shared state -->
<p>To discard previous versions of the package, the objects can be versioned. As long as the object contains a version field, and the code which uses the object expects and asserts a specific version, the code can be force-migrated to the new version. Normally, after an upgrade, admin functions can be used to update the version of the shared state, so that the new version of code can be used, and the old version aborts with a version mismatch.</p>
<pre><code class="language-move">module book::versioned_state {

    const EVersionMismatch: u64 = 0;

    const VERSION: u8 = 1;

    /// The shared state (can be owned too)
    struct SharedState has key {
        id: UID,
        version: u8,
        /* ... */
    }

    public fun mutate(state: &amp;mut SharedState) {
        assert!(state.version == VERSION, EVersionMismatch);
        // ...
    }
}
</code></pre>
<h2 id="versioning-configuration-with-dynamic-fields"><a class="header" href="#versioning-configuration-with-dynamic-fields">Versioning configuration with dynamic fields</a></h2>
<!-- This practice is for versioning the contents / structure of objects -->
<p>There's a common pattern in Sui which allows changing the stored configuration of an object while retaining the same object signature. This is done by keeping the base object simple and versioned and adding an actual configuration object as a dynamic field. Using this <em>anchor</em> pattern, the configuration can be changed with package upgrades while keeping the same base object signature.</p>
<pre><code class="language-move">module book::versioned_config {
    use sui::vec_map::VecMap;
    use std::string::String;

    /// The base object
    struct Config has key {
        id: UID,
        version: u16
    }

    /// The actual configuration
    struct ConfigV1 has store {
        data: Bag,
        metadata: VecMap&lt;String, String&gt;
    }

    // ...
}
</code></pre>
<h2 id="modular-architecture"><a class="header" href="#modular-architecture">Modular architecture</a></h2>
<p>TODO: add two patterns for modular architecture: object capability (SuiFrens) and witness registry (SuiNS)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-against-limits"><a class="header" href="#building-against-limits">Building against Limits</a></h1>
<p>To guarantee the safety and security of the network, Sui has certain limits and restrictions. These limits are in place to prevent abuse and to ensure that the network remains stable and efficient. This guide provides an overview of these limits and restrictions, and how to build your application to work within them.</p>
<p>The limits are defined in the protocol configuration and are enforced by the network. If any of the limits are exceeded, the transaction will either be rejected or aborted. The limits, being a part of the protocol, can only be changed through a network upgrade.</p>
<h2 id="transaction-size"><a class="header" href="#transaction-size">Transaction Size</a></h2>
<p>The size of a transaction is limited to 128KB. This includes the size of the transaction payload, the size of the transaction signature, and the size of the transaction metadata. If a transaction exceeds this limit, it will be rejected by the network.</p>
<h2 id="object-size"><a class="header" href="#object-size">Object Size</a></h2>
<p>The size of an object is limited to 256KB. This includes the size of the object data. If an object exceeds this limit, it will be rejected by the network. While a single object cannot bypass this limit, for more extensive storage options, one could use a combination of a base object with other attached to it using dynamic fields (eg Bag).</p>
<h2 id="single-pure-argument-size"><a class="header" href="#single-pure-argument-size">Single Pure Argument Size</a></h2>
<p>The size of a single pure argument is limited to 16KB. A transaction argument bigger than this limit will result in execution failure. So in order to create a vector of more than ~500 addresses (given that a single address is 32 bytes), it needs to be joined dynamically either in Transaction Block or in a Move function. Standard functions like <code>vector::append()</code> can join two vectors of ~16KB resulting in a ~32KB of data as a single value.</p>
<h2 id="maximum-number-of-objects-created"><a class="header" href="#maximum-number-of-objects-created">Maximum Number of Objects created</a></h2>
<p>The maximum number of objects that can be created in a single transaction is 2048. If a transaction attempts to create more than 2048 objects, it will be rejected by the network. This also affects <a href="guides/./../programmability/dynamic-fields.html">dynamic fields</a>, as both the key and the value are objects. So the maximum number of dynamic fields that can be created in a single transaction is 1024.</p>
<h2 id="maximum-number-of-events"><a class="header" href="#maximum-number-of-events">Maximum Number of Events</a></h2>
<p>The maximum number of events that can be emitted in a single transaction is 1024. If a transaction attempts to emit more than 1024 events, it will be aborted.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="better-error-handling"><a class="header" href="#better-error-handling">Better error handling</a></h1>
<p>Whenever execution encounters an abort, transaction fails and abort code is returned to the caller. Move VM returns the module name that aborted the transaction and the abort code. This behavior is not fully transparent to the caller of the transaction, especially when a single function contains multiple calls to the same function which may abort. In this case, the caller will not know which call aborted the transaction, and it will be hard to debug the issue or provide meaningful error message to the user.</p>
<pre><code class="language-move">module book::module_a {
    use book::module_b;

    public fun do_something() {
        let field_1 = module_b::get_field(1); // may abort with 0
        /* ... a lot of logic ... */
        let field_2 = module_b::get_field(2); // may abort with 0
        /* ... some more logic ... */
        let field_3 = module_b::get_field(3); // may abort with 0
    }
}
</code></pre>
<p>The example above illustrates the case when a single function contains multiple calls which may abort. If the caller of the <code>do_something</code> function receives an abort code <code>0</code>, it will be hard to understand which call to <code>module_b::get_field</code> aborted the transaction. To address this problem, there are common patterns that can be used to improve error handling.</p>
<h2 id="rule-1-handle-all-possible-scenarios"><a class="header" href="#rule-1-handle-all-possible-scenarios">Rule 1: Handle all possible scenarios</a></h2>
<p>It is considered a good practice to provide a safe "check" function that returns a boolean value indicating whether an operation can be performed safely. If the <code>module_b</code> provides a function <code>has_field</code> that returns a boolean value indicating whether a field exists, the <code>do_something</code> function can be rewritten as follows:</p>
<pre><code class="language-move">module book::module_a {
    use book::module_b;

    const ENoField: u64 = 0;

    public fun do_something() {
        assert!(module_b::has_field(1), ENoField);
        let field_1 = module_b::get_field(1);
        /* ... */
        assert!(module_b::has_field(1), ENoField);
        let field_2 = module_b::get_field(2);
        /* ... */
        assert!(module_b::has_field(1), ENoField);
        let field_3 = module_b::get_field(3);
    }
}
</code></pre>
<p>By adding custom checks before each call to <code>module_b::get_field</code>, the developer of the <code>module_a</code> takes control over the error handling. And it allows implementing the second rule.</p>
<h2 id="rule-2-abort-with-different-codes"><a class="header" href="#rule-2-abort-with-different-codes">Rule 2: Abort with different codes</a></h2>
<p>The second trick, once the abort codes are handled by the caller module, is to use different abort codes for different scenarios. This way, the caller module can provide a meaningful error message to the user. The <code>module_a</code> can be rewritten as follows:</p>
<pre><code class="language-move">module book::module_a {
    use book::module_b;

    const ENoFieldA: u64 = 0;
    const ENoFieldB: u64 = 1;
    const ENoFieldC: u64 = 2;

    public fun do_something() {
        assert!(module_b::has_field(1), ENoFieldA);
        let field_1 = module_b::get_field(1);
        /* ... */
        assert!(module_b::has_field(1), ENoFieldB);
        let field_2 = module_b::get_field(2);
        /* ... */
        assert!(module_b::has_field(1), ENoFieldC);
        let field_3 = module_b::get_field(3);
    }
}
</code></pre>
<p>Now, the caller module can provide a meaningful error message to the user. If the caller receives an abort code <code>0</code>, it can be translated to "Field 1 does not exist". If the caller receives an abort code <code>1</code>, it can be translated to "Field 2 does not exist". And so on.</p>
<h2 id="rule-3-return-bool-instead-of-assert"><a class="header" href="#rule-3-return-bool-instead-of-assert">Rule 3: Return bool instead of assert</a></h2>
<p>A developer is often tempted to add a public function that would assert all the conditions and abort the execution. However, it is a better practice to create a function that returns a boolean value instead. This way, the caller module can handle the error and provide a meaningful error message to the user.</p>
<pre><code class="language-move">module book::some_app_assert {

    const ENotAuthorized: u64 = 0;

    public fun do_a() {
        assert_is_authorized();
        // ...
    }

    public fun do_b() {
        assert_is_authorized();
        // ...
    }

    /// Don't do this
    public fun assert_is_authorized() {
        assert!(/* some condition */ true, ENotAuthorized);
    }
}
</code></pre>
<p>This module can be rewritten as follows:</p>
<pre><code class="language-move">module book::some_app {
    const ENotAuthorized: u64 = 0;

    public fun do_a() {
        assert!(is_authorized(), ENotAuthorized);
        // ...
    }

    public fun do_b() {
        assert!(is_authorized(), ENotAuthorized);
        // ...
    }

    public fun is_authorized(): bool {
        /* some condition */ true
    }

    // a private function can still be used to avoid code duplication for a case
    // when the same condition with the same abort code is used in multiple places
    fun assert_is_authorized() {
        assert!(is_authorized(), ENotAuthorized);
    }
}
</code></pre>
<p>Utilizing these three rules will make the error handling more transparent to the caller of the transaction, and it will allow other developers to use custom abort codes in their modules.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<ul>
<li>Fast Path - term used to describe a transaction that does not involve shared objects, and can be executed without the need for consensus.</li>
<li>Internal Type - type that is defined within the module. Fields of this type can not be accessed from outside the module, and, in case of "key"-only abilities, can not be used in <code>public_*</code> transfer functions.</li>
</ul>
<h2 id="abilities"><a class="header" href="#abilities">Abilities</a></h2>
<ul>
<li>key - ability that allows the struct to be used as a key in the storage. On Sui, the key ability marks an object and requires the first field to be a <code>id: UID</code>.</li>
<li>store - ability that allows the struct to be stored inside other objects. This ability relaxes restrictions applied to internal structs, allowing <code>public_*</code> transfer functions to accept them as arguments. It also enables the object to be stored as a dynamic field.</li>
<li>copy - ability that allows the struct to be copied. On Sui, the <code>copy</code> ability conflicts with the <code>key</code> ability, and can not be used together with it.</li>
<li>drop - ability that allows the struct to be ignored or discarded. On Sui, the <code>drop</code> ability cannot be used together with the <code>key</code> ability, as objects are not allowed to be ignored.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
