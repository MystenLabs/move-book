# 함수

함수는 Move 상에서 실행이 이루어지는 유일한 요소입니다. 함수는 `fun`키워드로 시작하여 함수 이름, 인수가 들어가는 소괄호 및 바디가 들어가는 중괄호가 뒤에 따라오는 구조입니다.

```Move
fun function_name(arg1: u64, arg2: bool): u64 {
    // function body
}
```

앞서 몇 가지 함수를 보셨을 텐데, 이제 사용법을 알아보도록 하겠습니다.

> **비고:** Move에서 함수는 *snake_case* 형태, 즉 소문자를 사용하고 공백 대신 밑줄로 띄어쓰기를 대체하는 형태로 작성합니다.

## 스크립트의 함수

스크립트 블록은 메인으로 간주되는 하나의 함수만을 포함할 수 있습니다. 인수를 포함하는 경우도 있는 이 함수가 트랜잭션으로 실행됩니다. 아주 제한적인데, 값을 반환하는 것이 불가능하며 이미 발행된 모듈에 존재하는 다른 함수를 작동하기 위해서만 사용할 수 있습니다.

주소가 존재하는지를 확인하는 간단한 스크립트의 예시입니다.

```Move
script {
    use 0x1::Account;

    fun main(addr: address) {
        assert(Account::exists(addr), 1);
    }
}
```

이 함수는 인수를 지닐 수 있는데, 이 경우 `addr` 인수와 유형 `address`를 가지며 불러온 모듈을 작동시킬 수도 있습니다.

> **비고:** 함수가 단 하나 존재하기 때문에 이름은 자유롭게 붙이셔도 무방합니다. 그러나 일반적인 프로그래밍 개념을 따라 **main**이라고 칭하는 것이 좋습니다.

## 모듈에 있는 함수

스크립트 환경은 상당히 제한되어 있으며, 모듈에서 비로소 함수의 전체 잠재력이 발휘됩니다. 다시 복습해 보자면 모듈은 함수와 유형을 하나로 묶어 발행한 집합이며(다음 장에서 알아보겠습니다) 단일 또는 복수의 작업을 해결하게 됩니다.

여기에서 우리는 간단한 수학 모듈을 생성하여 기본적인 수학적 함수와 몇 가지 도움 메서드를 사용자들에게 제공해 보도록 하겠습니다. 대부분의 요소들은 모듈 없이도 활용이 가능하지만 우리의 목적은 교육이니까요!

```Move
module Math {
    fun zero(): u8 {
        0
    }
}
```

먼저 `Math`라는 이름의 모듈을 정의하고 함수를 하나 넣어두었습니다. `zero()`라는 함수이며, `u8`유형의 값인 `0`을 반환합니다. [표현식](/syntax-basics/expression-and-scope.md) 을 기억하시나요? `0`은 이 함수의 *반환값*이기 때문에 뒤에 세미콜론이 오지 않습니다. 블록에서도 마찬가지이죠. 즉 함수 바디는 블록과 매우 흡사합니다.

First step: we've defined a module named `Math` with one function in it: `zero()`, which returns 0 - a value of type `u8`. Remember [expressions](/syntax-basics/expression-and-scope.md)? There's no semicolon after `0` as it is the *return value* of this function. Just like you would do with block. Yeah, function body is very similar to block.

### 함수의 인수

이미 매우 잘 알고 계시겠지만 다시 반복합시다. 함수는 함수로 전달되는 값인 인수를 가져올 수 있습니다. 개수 제한 없이 필요한 만큼 가져올 수 있는데, 각 인수는 함수 바디 내부에서의 이름과 Move의 다른 변수들과 동일하게 유형을 두 가지 속성으로 가집니다.

함수의 인수는 스코프 내부에서 정의되는 다른 모든 변수들과 마찬가지로 함수 바디 내부에만 존재합니다. 함수 블록이 끝난 시점에는 변수도 소멸됩니다.

```Move
module Math {

    public fun sum(a: u64, b: u64): u64 {
        a + b
    }

    fun zero(): u8 {
        0
    }
}
```

우리가 보고 있는 Math의 경우 함수 `sum(a,b)`가 새로 등장하는데, 2개의 `u64`값을 합하여 결과인 `u64` 합을 반환합니다(유형은 변경할 수 없습니다).

몇 가지 구문 규칙들을 살펴봅시다.

1.  인수에는 반드시 유형이 존재해야 하며 쉼표로 분리해야 합니다.
2.  함수의 반환 값은 소괄호 뒤에 위치하며 콜론이 뒤에 와야 합니다.

이 함수를 스크립트에서는 어떻게 사용할 수 있을까요? 바로 불러오기 기능입니다!

```Move
script {
    use 0x1::Math;  // used 0x1 here; could be your address
    use 0x1::Debug; // this one will be covered later!

    fun main(first_num: u64, second_num: u64) {

        // variables names don't have to match the function's ones
        let sum = Math::sum(first_num, second_num);

        Debug::print<u64>(&sum);
    }
}
```

### `return` 키워드

`return` 키워드를 사용하면 함수의 실행을 종료하고 값을 반환하도록 만들 수 있습니다. 이 때 `if` 조건과 함께 사용해야 하는데, 제어 흐름에서 조건부 스위치를 만들 수 있는 유일한 방법이기 때문입니다.

```Move
module M {

    public fun conditional_return(a: u8): bool {
        if (a == 10) {
            return true // semi is not put!
        };

        if (a < 10) {
            true
        } else {
            false
        }
    }
}
```

### 다수의 반환값

기존 예시에서는 반환값이 없거나 하나인 경우를 다루었습니다. 만약 유형을 불문하고 여러 개의 값을 반환할 수 있는 방법이 있다면 사용해 보고 싶지 않으신가요? 함께 진행해 보겠습니다!

다수의 반환값을 명시하려면 소괄호를 사용해야 합니다.

```Move
module Math {

    // ...

    public fun max(a: u8, b: u8): (u8, bool) {
        if (a > b) {
            (a, false)
        } else if (a < b) {
            (b, false)
        } else {
            (a, true)
        }
    }
}
```

이 함수는 `a`와 `b`라는 두 개의 인수를 가져다가 *두 개의 값*을 반환합니다. 첫 번째 값은 전달된 두 값 중 최댓값이며 두 번째 값은 논리값, 즉 입력된 숫자 두 개가 동일한지를 나타냅니다. 구문을 잘 살펴보시면 단일 반환 인수를 명시하는 대신에 *소괄호*를 추가하였고 반환 인수 유형들을 기재하였습니다.

이제 이 함수의 결과를 스크립트 상 존재하는 다른 함수에서 어떻게 사용할 수 있는지를 보겠습니다.

```Move
script {
    use 0x1::Debug;
    use 0x1::Math;

    fun main(a: u8, b: u8)  {
        let (max, is_equal) = Math::max(99, 100);

        assert(is_equal, 1)

        Debug::print<u8>(&max);
    }
}
```

이 예시에서는 튜플을 *파괴*했는데, *max* 함수의 반환 값이 가지는 값과 유형을 토대로 새로운 변수를 두 개 생성했습니다. 순서는 보존되어 있으며 변수 *max*는 *u8* 유형을 가지게 되고 최댓값을 저장하는데, 이 때 *is_equal*은 *논리값*입니다.

굳이 2개로 제한되지는 않습니다. 반환되는 인수의 개수는 전적으로 여러분에게 달려있는데, 데이터 구조에 대해 배우게 되면서 복잡한 데이터를 반환할 수 있는 다른 수단을 곧 알게 되실 것입니다.

### 함수의 가시성

모듈을 정의할 때는 어떤 함수들은 다른 개발자들이 접근할 수 있게 하고, 다른 함수들은 감춰둔 상태로 둘 필요가 있습니다. 이럴 때 *함수 가시성 제어자*를 사용하게 됩니다.

초기 설정 상태의 경우 모듈에서 정의된 모든 함수는 개인, 즉 다른 모듈이나 스크립트에서 접근할 수 없습니다. 지금까지 집중해 오셨다면 우리가 Math 모듈에서 정의했던 함수들 중 몇몇은 정의 구간에 앞서 `public`이라는 키워드가 붙어 있었다는 걸 알고 계실 것입니다.

```Move
module Math {

    public fun sum(a: u64, b: u64): u64 {
        a + b
    }

    fun zero(): u8 {
        0
    }
}
```

이 예시에서 `sum()` 함수는 모듈을 불러왔을 때 외부에서 접근할 수 있으나, `zero()` 함수는 초기 설정 상 개인 수준으로 정의되어 있어 접근할 수 없습니다.

> `public` 키워드는 함수의 기본 가시성 수준인 *비공개* 를 변경하여 *공개*, 즉 외부에서 접근할 수 있도록 변경해 줍니다.

즉 사실상 `sum()` 함수를 *공개*해 두지 않았다면 이 작업은 진행할 수 없을 것입니다.

```Move
script {
    use 0x1::Math;

    fun main() {
        Math::sum(10, 100); // won't compile!
    }
}
```

### 로컬 함수 접근

접근이 불가능하다면 개인 함수를 생성하는 것에 아무런 의미가 없을 것입니다. 공개 함수가 호출되는 기능이 있는 반면 개인 함수는 *내부* 작업을 진행하는 역할을 맡습니다.

> 개인 함수는 정의된 모듈 내부에서만 접근할 수 있습니다.

그럼 동일한 모듈에 있는 함수들을 어떻게 접근할 수 있을까요? 불러왔을 때와 동일하게 해당 함수를 호출해 주기만 하면 됩니다!

```Move
module Math {

    public fun is_zero(a: u8): bool {
        a == zero()
    }

    fun zero(): u8 {
        0
    }
}
```

모듈에 정의된 모든 함수는 동일한 모듈에서 접근할 수 있으며, 이 때 가시성 제어자의 유무나 종류는 전혀 관계없습니다. 이러한 방식을 통해 개인 함수는 개인 기능이나 지나치게 위험한 작업을 드러내는 일 없이 공개 함수 내부에서 호출되는 형태로 사용될 수 있습니다.

### 네이티브 함수

*네이티브 함수*는 특별한 종류의 함수인데, Move가 제공하는 범위를 뛰어넘는 기능을 구현하여 추가적인 성능을 발휘할 수 있도록 합니다. 네이티브 함수는 VM에서 자체적으로 정의하면 다양한 구현마다 다르게 나타날 수 있습니다. 즉 이들은 Move 구문에서는 구현을 지니지 않으며 함수 바디를 가지는 대신 세미콜론으로 끝납니다. `native` 키워드를 사용하면 네이티브 함수를 표시할 수 있습니다. 함수 가시성 조정자와 충돌하지 않으며, 동일한 함수가 동시에 `native` 및 `public` 함수로 작동할 수도 있습니다.

Diem의 표준 라이브러리에 등장하는 예시입니다.

```Move
module Signer {

    native public fun borrow_address(s: &signer): &address;

    // ... some other functions ...
}
```
