<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sahiplik ve Referanslar</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Move Programlama Dili</a></li><li class="chapter-item expanded "><a href="../introduction/foreword.html"><strong aria-hidden="true">2.</strong> Önsöz</a></li><li class="chapter-item expanded "><a href="../introduction/getting-started.html"><strong aria-hidden="true">3.</strong> Giriş</a></li><li class="chapter-item expanded "><a href="../syntax-basics/index.html"><strong aria-hidden="true">4.</strong> Temel Syntax Kavramları</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../syntax-basics/concept.html"><strong aria-hidden="true">4.1.</strong> Konsept</a></li><li class="chapter-item expanded "><a href="../syntax-basics/primitives.html"><strong aria-hidden="true">4.2.</strong> İlkel Veri Tipleri</a></li><li class="chapter-item expanded "><a href="../syntax-basics/comments.html"><strong aria-hidden="true">4.3.</strong> Comment (Yorum)</a></li><li class="chapter-item expanded "><a href="../syntax-basics/expression-and-scope.html"><strong aria-hidden="true">4.4.</strong> ifade ve Kapsam</a></li><li class="chapter-item expanded "><a href="../syntax-basics/control-flow.html"><strong aria-hidden="true">4.5.</strong> Kontrol Akışı</a></li><li class="chapter-item expanded "><a href="../syntax-basics/module.html"><strong aria-hidden="true">4.6.</strong> Modüller ve İçe Aktarım (Import)</a></li><li class="chapter-item expanded "><a href="../syntax-basics/constants.html"><strong aria-hidden="true">4.7.</strong> Sabitler (Constants)</a></li><li class="chapter-item expanded "><a href="../syntax-basics/function.html"><strong aria-hidden="true">4.8.</strong> Fonksiyonlar</a></li></ol></li><li class="chapter-item expanded "><a href="../advanced-topics/index.html"><strong aria-hidden="true">5.</strong> Gelişmiş Başlıklar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../advanced-topics/struct.html"><strong aria-hidden="true">5.1.</strong> Yapılar (Structures)</a></li><li class="chapter-item expanded "><a href="../advanced-topics/types-with-abilities.html"><strong aria-hidden="true">5.2.</strong> Yetenekli Tipler</a></li><li class="chapter-item expanded "><a href="../advanced-topics/ownership-and-references.html" class="active"><strong aria-hidden="true">5.3.</strong> Sahiplik ve Referanslar</a></li><li class="chapter-item expanded "><a href="../advanced-topics/understanding-generics.html"><strong aria-hidden="true">5.4.</strong> Jenerikler (Generics)</a></li><li class="chapter-item expanded "><a href="../advanced-topics/managing-collections-with-vectors.html"><strong aria-hidden="true">5.5.</strong> Vektör ile Koleksiyonları Kontrol Etmek</a></li></ol></li><li class="chapter-item expanded "><a href="../resources/index.html"><strong aria-hidden="true">6.</strong> Programlanabilir Kaynaklar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../resources/signer-type.html"><strong aria-hidden="true">6.1.</strong> Göndericinin Signer Olması</a></li><li class="chapter-item expanded "><a href="../resources/what-is-resource.html"><strong aria-hidden="true">6.2.</strong> Kaynak Nedir</a></li><li class="chapter-item expanded "><a href="../resources/resource-by-example/index.html"><strong aria-hidden="true">6.3.</strong> Kaynak Örnekleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../resources/resource-by-example/storing-new-resource.html"><strong aria-hidden="true">6.3.1.</strong> Kaynak Yaratma ve Taşıma</a></li><li class="chapter-item expanded "><a href="../resources/resource-by-example/access-resource-with-borrow.html"><strong aria-hidden="true">6.3.2.</strong> Kaynak Okuyup Değiştirme</a></li><li class="chapter-item expanded "><a href="../resources/resource-by-example/destroy-resource.html"><strong aria-hidden="true">6.3.3.</strong> Kaynakları Alıp Yok Etme</a></li><li class="chapter-item expanded "><a href="../resources/resource-by-example/furher-steps.html"><strong aria-hidden="true">6.3.4.</strong> Sonraki Adımlar</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../tutorials/index.html"><strong aria-hidden="true">7.</strong> Öğretici (Tutorial)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorials/erc20.html"><strong aria-hidden="true">7.1.</strong> ERC20 Token Yazmak</a></li></ol></li><li class="chapter-item expanded "><a href="../translations.html"><strong aria-hidden="true">8.</strong> Çeviriler</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#sahiplik-ve-referanslar" id="sahiplik-ve-referanslar">Sahiplik ve Referanslar</a></h1>
<p>Move VM, Rust’a benzeyen bir sahiplik sistemi uygular ve bu konseptin en iyi açıklaması <a href="https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html">Rust kitabındadır.</a>. </p>
<p>Rust syntax’ının farklı olması ve bazı örneklerinin anlaşılması daha zor olmasına rağmen Rust Kitabı’ndaki sahiplik kısmını okumanızı tavsiye ediyorum. Bu bölümde ana kısımlara değineceğim.</p>
<blockquote>
<p>Her değişkenin sadece bir sahip kapsamı vardır. Sahip kapsamı bittiğinde sahip değişkenleri atılır.</p>
</blockquote>
<p>Bu hareketi daha önce <a href="/syntax-basics/expression-and-scope.html">ifadeler</a> bölümünde gördük. Bir değişkenin, kapsamı bitene kadar yaşadığını hatırlayalım. Şimdi işin derinliklerine inip neden böyle olduğunu anlama zamanı.</p>
<p>Owner (sahip), bir değişkene sahip olan bir kapsama verilen addır. Değişkenler bu kapsamda tanımlanabilir (örn. <code>let</code>) ya da kapsama argüman olarak geçirilebilirler. Move dilindeki tek kapsam fonksiyonlar olduğu için kapsamlara değişken koymanın başka bir yolu yoktur. </p>
<p>Her değişkenin sadece tek sahibi vardır. Bu da demek oluyor ki; bir değişken fonksiyona argüman olarak geçirildiğinde bu fonksiyon <em>yeni owner</em>’a dönüşüyor ve artık eski fonksiyon değişkenin sahibi olarak görülmüyor. Kısacası, diğer fonksiyonun <em>değişkenin sahipliğini aldığını</em> söyleyebilirsiniz.</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        // Module::T is a struct
        let a : Module::T = Module::create(10);

        // burada değişken 'a' 'main' fonksiyonunun bölgesinden ayrılıyor
        // ve `M::value` fonksiyonunun yeni bölgesine koyuluyor
        M::value(a);

        // bu bölgede artık bir değişken yok
        // bu kod derlenmeyecek
        M::value(a);
    }
}
</code></pre>
<p>Değerimizi içine geçirince <code>value()</code> fonksiyonuna ne olduğuna bakalım</p>
<pre><code class="language-Move">module M {
    // create_fun atlandı
    struct T { value: u8 }

    public fun create(value: u8): T {
        T { value }
    }

    // M::T tipinin t değişkeni geçirildi
    // `value()` fonksiyonu sahipliği alıyor
    public fun value(t: T): u8 {
        // t değişken olarak kullanılabilir
        t.value
    }
    // fonksiyon bölgesi bitiyor, t atılıyor, sadece u8 sonucu dönüş yaptı
    // t artık yok
}
</code></pre>
<p>Hızlı çözüm olarak orijinal değişken ve ek sonuçlarla bir veri grubu döndürebilirdik. (dönüş değeri <code>(T, u8)</code> olurdu) ama Move’un daha iyi bir çözümü var</p>
<h3><a class="header" href="#move-taşı-ve-copy-kopyala" id="move-taşı-ve-copy-kopyala">Move (taşı) ve Copy (kopyala)</a></h3>
<p>Öncelikle Move VM’sinin nasıl çalıştığını ve değerinizi bir fonksiyondan geçirdiğinizde ne olduğunu anlamanız gerekiyor. VM’de iki bytecode talimatı vardır: <em>MoveLoc</em> ve <em>CopyLoc</em> - <code>move</code> ve <code>copy</code> anahtar sözcükleriyle kullanılabilirler. </p>
<p>Bir değişken başka bir fonksiyona geçirildiğinde <em>taşınmış (moved)</em> olur ve <em>MoveLoc</em> OpCode kullanılmış olur. <code>move</code> anahtar kelimesini kullanınca kodumuzun nasıl olacağına bakalım:</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let a : Module::T = Module::create(10);

        M::value(move a); // a değişkeni taşındı

        // yerel a droplandı
    }
}
</code></pre>
<p>Bu geçerli bir Move kodu fakat değerin zaten taşınacağını bildiğiniz için <em>taşımanıza</em> gerek yok. Bunu anladığımıza göre <em>copy</em> anahtar sözcüğüne geçiyoruz.</p>
<h3><a class="header" href="#copy-anahtar-sözcüğü" id="copy-anahtar-sözcüğü"><code>copy</code> anahtar sözcüğü</a></h3>
<p>Eğer bir değeri fonksiyona (taşındığı yere) geçirmek ve değişkeninizin bir kopyasın kaydetmek isterseniz, <code>copy</code> anahtar kelimesini kullanabilirsiniz.</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let a : Module::T = Module::create(10);

        // copy anahtar kelimesini bu yapıyı kopyalamak için kullanıyoruz
        // `let a_copy = copy a` olarak kullanılabilir
        M::value(copy a);
        M::value(a); // başarısız olmayacak, a hala orada
    }
}
</code></pre>
<p>Bu örnekte <code>a</code> değişkeninin (yani değerin) <em>kopyasını</em> <code>value</code>  metodunun ilk çağrısına geçirdik ve <code>a</code>‘yı yerel kapsamda ikinci bir çağırıda kullanmak için muhafaza ettik.</p>
<p>Bir değeri, kullanılabilmesi amacıyla, kopyalayarak çoğalttık ve programımızın hafıza büyüklüğünü arttırmış olduk. Fakat büyük boyutlu veriler kopyalarsanız fazla hafıza kullanabilir. Unutmayın – blockchainlerde her byte bizim için önemlidir ve işlemin bedelini büyük oranda etkiler. Yani her zaman <code>copy</code> kullanmak pahalıya patlayabilir.</p>
<p>Şimdi referansları öğrenmeye hazırsınız – Sizi gereksiz kopyalamadan kurtaracak ve para kaybetmemenizi sağlayacak bir araç.</p>
<h2><a class="header" href="#referenslar" id="referenslar">Referenslar</a></h2>
<p>Birçok programlama dili referansların uygulanmasına sahiptir (<a href="https://en.wikipedia.org/wiki/Reference_(computer_science)">Wikipedia'dan bakınız</a>) Referans, bir değişkene (genelde hafızadaki bir bölüme) bağlanan bir bağlantıdır. <em>Referansları</em> kullanarak bir değeri taşımak yerine, değerleri programın diğer parçalarına geçirebilirsiniz.</p>
<blockquote>
<p>&amp; ile işaretli referanslar sizin bir değerin sahipliğini almadan o değere başvurmanızı sağlar.</p>
</blockquote>
<p>Hadi örneğimizi değiştirelim ve referanların nasıl kullanılabileceğini görelim.</p>
<pre><code class="language-Move">module M {
    struct T { value: u8 }
    // ...
    // ...
    // değeri taşımak yerine bir referans geçireceğiz
    public fun value(t: &amp;T): u8 {
        t.value
    }
}
</code></pre>
<p>T argüman tipine &amp; ekledik ve bunu yaparak argüman tipini T yerine <em>T’nin referansına</em> yani &amp;T‘ye değiştirmiş olduk.</p>
<blockquote>
<p>Move dili iki tür referans destekler: s<em>usturulamaz (immutable)</em> - &amp; ile tanımlanır(örneğin &amp;T ). Ve <em>susturulabilir (mutable)</em> - &amp;mut (örneğin &amp;mut T ).</p>
</blockquote>
<p>Susturulamaz referanslar değerin değiştirmeden okunmasını sağlarken susturulabilir referanslar tam tersi olarak değerin okunmasını ve değiştirilmesini sağlar</p>
<pre><code class="language-Move">module M {
    struct T { value: u8 }

    // dönüş yapan değer referans olmayan tipten
    public fun create(value: u8): T {
        T { value }
    }

    // susturulamaz referanslar okumaya izin verir
    public fun value(t: &amp;T): u8 {
        t.value
    }

    // susturulabilir referanslar değerin okunmasını ve değiştirilmesini sağlar
    public fun change(t: &amp;mut T, value: u8) {
        t.value = value;
    }
}
</code></pre>
<p>Şimdi geliştirilmiş M modülümüzü nasıl kullanacağımıza bakalım.</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let t = M::create(10);

        // doğrudan bir referans oluştur
        M::change(&amp;mut t, 20);

        // ya da bir değişkene referans yaz
        let mut_ref_t = &amp;mut t;

        M::change(mut_ref_t, 100);

        // susturulamaz referansla da aynı
        let value = M::value(&amp;t);

        // bu metot sadece referansları alır
        // yazılan değer 100 olacak

        0x1::Debug::print&lt;u8&gt;(&amp;value);
    }
}
</code></pre>
<blockquote>
<p>Yapılardan veri okumak için susturulamaz (&amp;) referans kullanın. Değiştirmek için susturulabilir (mut&amp;) referans kullanın. Uygun türde referanslar kullanarak güvenliğin sağlanmasına ve modüllerin okunmasına yardım edersiniz. Böylece okuyucu metodun değeri sadece okunacağını ya da değerde değiştirme yapılacağını anlar.</p>
</blockquote>
<h3><a class="header" href="#Ödünç-borrow-kontrolü" id="Ödünç-borrow-kontrolü">Ödünç (borrow) kontrolü</a></h3>
<p>Move dili referansları nasıl kullandığınızı kontrol eder ve beklenmedik zorlukları engellemenizi sağlar. Bunu nasıl yaptığını anlamak için bir örneğe bakalım. Bir modül ve yazı vereceğim ve sonrasında ne olduğuna ve neden olduğuna yorum yapacağız.</p>
<pre><code class="language-Move">module Borrow {

    struct B { value: u64 }
    struct A { b: B }

    // içteki B ile A’yı oluştur
    public fun create(value: u64): A {
        A { b: B { value } }
    }

    // içteki B’ye susturulabilir referans ver
    public fun ref_from_mut_a(a: &amp;mut A): &amp;mut B {
        &amp;mut a.b
    }

    // B’yi değiştir
    public fun change_b(b: &amp;mut B, value: u64) {
        b.value = value;
    }
}
</code></pre>
<pre><code class="language-Move">script {
    use {{sender}}::Borrow;

    fun main() {
        // yapı oluştur A { b: B { value: u64 } }
        let a = Borrow::create(0);

        // susturulabilir referansı mut A’dan mut B’ye getir
        let mut_a = &amp;mut a;
        let mut_b = Borrow::ref_from_mut_a(mut_a);

        // B'yi değiştir
        Borrow::change_b(mut_b, 100000);

        // A'dan başka bir susturulabilir referans al
        let _ = Borrow::ref_from_mut_a(mut_a);
    }
}
</code></pre>
<p>Bu kod hatasız bir şekilde çalışır ve derlenir. <code>A</code>’da susturulabilir referans kullanıyoruz ki susturulabilir referansı iç yapısındaki <code>B</code>’ye getirelim. Sonra <code>B</code>’yi değiştiriyoruz. Bunun ardından işlem tekrarlanabilir.</p>
<p>Peki ya son iki ifadenin yerini değiştirip önce <code>B</code> hala canlıyken <code>A</code>’ya yeni bir susturulabilir referans açmaya çalışsaydık?</p>
<pre><code class="language-Move">let mut_a = &amp;mut a;
let mut_b = Borrow::ref_from_mut_a(mut_a);

let _ = Borrow::ref_from_mut_a(mut_a);

Borrow::change_b(mut_b, 100000);
</code></pre>
<p>Şu hatayı alırdık:</p>
<pre><code class="language-Move">    ┌── /scripts/script.move:10:17 ───
    │
 10 │         let _ = Borrow::ref_from_mut_a(mut_a);
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid usage of reference as function argument. Cannot transfer a mutable reference that is being borrowed
    ·
  8 │         let mut_b = Borrow::ref_from_mut_a(mut_a);
    │                     ----------------------------- It is still being mutably borrowed by this reference
    │
</code></pre>
<p>Bu kod derlenemez. Niye? Çünkü <code>&amp;mut A</code> , <code>&amp;mut B</code> tarafından ödünç (borrow) alınıyor. Eğer içindekilere susturulabilir bir referansa sahipken <code>A</code>’yı değiştirebilseydik, içindekilere referansların hala var olduğu ama A’nın değiştirilebilir olduğu garip bir duruma girerdik. Eğer gerçek bir <code>B </code>olmasaydı <code>mut_b</code> nereyi gösterirdi? </p>
<p>Özetle:</p>
<ol>
<li>Bir derleme sorunu alıyoruz, bu demek ki Move derleyicisi bu olayları engelliyor. Buna <em>ödünç kontrolü</em> deniyor (Aslında Rust dilinden bir konsept). Derleyici bir ödünç grafiği inşa ediyor ve <em>ödünç alınan değerlerin taşınmasına</em> izin vermiyor. Bu Move’un blokchainlerde kullanılmasının bu kadar güvenli olmasının bir sebebi de budur.</li>
<li>Referanstan referans üretebilirsiniz. Böylece asıl referans yeni bir referansa <em>ödünç alınabilir</em>. Susturulabilir referanslardan iki tür referansı da oluşturabiliriz. Susturulamaz fonksiyonlardansa sadece başka bir susturulamaz fonksiyon oluşturabiliriz.</li>
<li>Referanslar <em>ödünç alındığıklarında</em> taşınamazlar çünkü başka değerler onlara bağlıdır.</li>
</ol>
<h3><a class="header" href="#referanstan-ayırmak-dereference" id="referanstan-ayırmak-dereference">Referanstan ayırmak (Dereference)</a></h3>
<p>Referanslar, bağlantılı değeri almak için referanstan ayrılabilir bunu yapmak için <code>*</code> kullanın.</p>
<blockquote>
<p>Referans ayrımı yaparken bir kopya yaparız. Bu yüzden değerin Copy yeteneğine sahip olduğundan emin olun.</p>
</blockquote>
<pre><code class="language-Move">module M {
    struct T has copy {}

    // burdaki t değeri referans türünden
    public fun deref(t: &amp;T): T {
        *t
    }
}
</code></pre>
<blockquote>
<p>Referans ayırma operatörü orijinal değeri aktif kapsama taşımaz, onun yerine bu değerin bir kopyasını oluşturur.</p>
</blockquote>
<p>Move’da bir yapının iç alanını kopyalamak için bu tekniği kullanırız: <code>*&amp;</code></p>
<p>Kısa bir örnek:</p>
<pre><code class="language-Move">module M {
    struct H has copy {}
    struct T { inner: H }

    // ...

    // Susturulamaz bir referanstan bile yapabiliriz!
    public fun copy_inner(t: &amp;T): H {
        *&amp;t.inner
    }
}
</code></pre>
<p><code>*&amp;</code> kullanarak (derleyici bile böyle yapmanızı önerecektir) bir yapının iç değerini kopyaladık.</p>
<h3><a class="header" href="#İlkel-tipleri-referanslamak-referencing-primitive-types" id="İlkel-tipleri-referanslamak-referencing-primitive-types">İlkel tipleri referanslamak (Referencing primitive types)</a></h3>
<p>İlkel tiplerin (basitliklerinden dolayı) referans olarak geçirilmelerine gerek yoktur. Onun yerine kopyalama operasyonu yapılır. Onları bir fonksiyona değerleriyle geçirseniz bile o anki kapsamlarında kalırlar. <code>move</code> anahtar sözcüğünü kullanabilirsiniz fakat ilkel tipler çok küçük boyutta oldukları için onları kopyalamak, referansla geçirmekten veya taşımaktan daha hesaplı olabilir.</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let a = 10;
        M::do_smth(a);
        let _ = a;
    }
}
</code></pre>
<p>Bu kod <code>a</code>‘yı referans olarak geçirmememize rağmen derlenir. <code>Copy</code> eklemek gereksizdir- VM zaten oraya onu koyuyor.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../advanced-topics/types-with-abilities.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../advanced-topics/understanding-generics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../advanced-topics/types-with-abilities.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../advanced-topics/understanding-generics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
