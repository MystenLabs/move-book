<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Jenerikler (Generics)</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Move Programlama Dili</a></li><li class="chapter-item expanded "><a href="../introduction/foreword.html"><strong aria-hidden="true">2.</strong> Önsöz</a></li><li class="chapter-item expanded "><a href="../introduction/getting-started.html"><strong aria-hidden="true">3.</strong> Giriş</a></li><li class="chapter-item expanded "><a href="../syntax-basics/index.html"><strong aria-hidden="true">4.</strong> Temel Syntax Kavramları</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../syntax-basics/concept.html"><strong aria-hidden="true">4.1.</strong> Konsept</a></li><li class="chapter-item expanded "><a href="../syntax-basics/primitives.html"><strong aria-hidden="true">4.2.</strong> İlkel Veri Tipleri</a></li><li class="chapter-item expanded "><a href="../syntax-basics/comments.html"><strong aria-hidden="true">4.3.</strong> Comment (Yorum)</a></li><li class="chapter-item expanded "><a href="../syntax-basics/expression-and-scope.html"><strong aria-hidden="true">4.4.</strong> ifade ve Kapsam</a></li><li class="chapter-item expanded "><a href="../syntax-basics/control-flow.html"><strong aria-hidden="true">4.5.</strong> Kontrol Akışı</a></li><li class="chapter-item expanded "><a href="../syntax-basics/module.html"><strong aria-hidden="true">4.6.</strong> Modüller ve İçe Aktarım (Import)</a></li><li class="chapter-item expanded "><a href="../syntax-basics/constants.html"><strong aria-hidden="true">4.7.</strong> Sabitler (Constants)</a></li><li class="chapter-item expanded "><a href="../syntax-basics/function.html"><strong aria-hidden="true">4.8.</strong> Fonksiyonlar</a></li></ol></li><li class="chapter-item expanded "><a href="../advanced-topics/index.html"><strong aria-hidden="true">5.</strong> Gelişmiş Başlıklar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../advanced-topics/struct.html"><strong aria-hidden="true">5.1.</strong> Yapılar (Structures)</a></li><li class="chapter-item expanded "><a href="../advanced-topics/types-with-abilities.html"><strong aria-hidden="true">5.2.</strong> Yetenekli Tipler</a></li><li class="chapter-item expanded "><a href="../advanced-topics/ownership-and-references.html"><strong aria-hidden="true">5.3.</strong> Sahiplik ve Referanslar</a></li><li class="chapter-item expanded "><a href="../advanced-topics/understanding-generics.html" class="active"><strong aria-hidden="true">5.4.</strong> Jenerikler (Generics)</a></li><li class="chapter-item expanded "><a href="../advanced-topics/managing-collections-with-vectors.html"><strong aria-hidden="true">5.5.</strong> Vektör ile Koleksiyonları Kontrol Etmek</a></li></ol></li><li class="chapter-item expanded "><a href="../resources/index.html"><strong aria-hidden="true">6.</strong> Programlanabilir Kaynaklar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../resources/signer-type.html"><strong aria-hidden="true">6.1.</strong> Göndericinin Signer Olması</a></li><li class="chapter-item expanded "><a href="../resources/what-is-resource.html"><strong aria-hidden="true">6.2.</strong> Kaynak Nedir</a></li><li class="chapter-item expanded "><a href="../resources/resource-by-example/index.html"><strong aria-hidden="true">6.3.</strong> Kaynak Örnekleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../resources/resource-by-example/storing-new-resource.html"><strong aria-hidden="true">6.3.1.</strong> Kaynak Yaratma ve Taşıma</a></li><li class="chapter-item expanded "><a href="../resources/resource-by-example/access-resource-with-borrow.html"><strong aria-hidden="true">6.3.2.</strong> Kaynak Okuyup Değiştirme</a></li><li class="chapter-item expanded "><a href="../resources/resource-by-example/destroy-resource.html"><strong aria-hidden="true">6.3.3.</strong> Kaynakları Alıp Yok Etme</a></li><li class="chapter-item expanded "><a href="../resources/resource-by-example/furher-steps.html"><strong aria-hidden="true">6.3.4.</strong> Sonraki Adımlar</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../tutorials/index.html"><strong aria-hidden="true">7.</strong> Öğretici (Tutorial)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorials/erc20.html"><strong aria-hidden="true">7.1.</strong> ERC20 Token Yazmak</a></li></ol></li><li class="chapter-item expanded "><a href="../translations.html"><strong aria-hidden="true">8.</strong> Çeviriler</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#jenerikler-generics" id="jenerikler-generics">Jenerikler (Generics)</a></h1>
<p>Jenerikler Move için esastır. Jenerik, Move’un esnekliğinin kaynağıdır ve blockchain dünyasında bu dili bu kadar özgün yapan unsurdur.</p>
<p><a href="https://doc.rust-lang.org/stable/book/ch10-00-generics.html">Rust Kitabı</a>’ndan bir kesitle başlayalım: Jenerikler somut tipler ve diğer özellikler için oluşturulan soyut yedeklerdir. Bir fonksiyonu yazmamızı sağlayan unsurlardır. Bu fonksiyonlar da sonradan her tip için kullanılabilirler. Her tip için kalıp işleyicisi (template handler) olarak kullanılabildikleri için onlara kalıp (template) da diyebiliriz.</p>
<p>Move’da jenerikler, <code>struct</code> ve <code>function</code> imzalarına uygulanabilir.</p>
<h3><a class="header" href="#struct-tanımında-jenerikler" id="struct-tanımında-jenerikler">Struct tanımında jenerikler</a></h3>
<p>Önce <code>u64</code> değerini tutan bir kutu oluşturacağız. Bunları daha önce de gördük.</p>
<pre><code class="language-Move">module Storage {
    struct Box {
        value: u64
    }
}
</code></pre>
<p>Bu kutu sadece <code>u64</code> tipinde değer içerebilir. Peki ya aynı kutuyu <code>u8</code> ya da <code>bool</code> tipleri için yapmak isteseydik? <code>Box1</code> sonra <code>Box2</code> mı yapmamız gerekirdi? Yoksa farklı bir modül mü üretirdik? Hayır, jenerik kullanırdık.</p>
<pre><code class="language-Move">module Storage {
    struct Box&lt;T&gt; {
        value: T
    }
}
</code></pre>
<p>Struct adının yanına <code>&lt;T&gt;</code> koyduk. Açılı ayraçların <code>&lt;..&gt; </code>olduğu yer jenerik tiplerini tanımlama yeridir. <code>T</code>, bu struct'da kalıba çevirdiğimiz bir tiptir. Struct gövdesi tanımımızın içinde <code>T</code>‘yi sıradan bir tip olarak kullandık. <code>T</code> tipi diye bir şey yok. Sadece <em>herhangi bir tip</em> için bir yer tutucu (placeholder) olarak orada duruyor.</p>
<h3><a class="header" href="#fonksiyon-imzasında-function-signature-jenerikler" id="fonksiyon-imzasında-function-signature-jenerikler">Fonksiyon imzasında (function signature) jenerikler</a></h3>
<p>Şimdi <code>u64</code>‘yi değer olarak kullanacak bu struct için bir yapıcı metod (constructor) oluşturalım.</p>
<pre><code class="language-Move">module Storage {
    struct Box&lt;T&gt; {
        value: T
    }

    // u64 tipi açılı ayraçların içince koyulmuş
    // demek ki u64 tipinde Box kullanıyoruz
    public fun create_box(value: u64): Box&lt;u64&gt; {
        Box&lt;u64&gt;{ value }
    }
}
</code></pre>
<p>Jenerikleri tanımlamak biraz daha karışık bir işlemdir. Çünkü belirtilen parametrelerine ihtiyaç duyarlar ve sıradan <code>Box</code> sturct'ı <code>Box&lt;u64&gt;</code>’a dönüşür. Jenerikleri tanımlarken açılı ayraçlara istediğiniz tipi geçirebilirsiniz. Bunun üzerine bir kısıtlama yoktur. <code>create_box</code> metodumuzu genelleştirmek ve kullanıcıların her tipi belirtmesi için başka bir jenerik kullanırız. Bu sefer bunu fonksiyon imzasının içinde yapalım!</p>
<pre><code class="language-Move">module Storage {
    // ...
    public fun create_box&lt;T&gt;(value: T): Box&lt;T&gt; {
        Box&lt;T&gt; { value }
    }

    // Buna biraz sonra gireceğiz bana güvenin
    public fun value&lt;T: copy&gt;(box: &amp;Box&lt;T&gt;): T {
        *&amp;box.value
    }
}
</code></pre>
<h3><a class="header" href="#fonksiyon-çağrılarında-jenerikler" id="fonksiyon-çağrılarında-jenerikler">Fonksiyon çağrılarında jenerikler</a></h3>
<p>Yaptığımız şey fonksiyon isminden hemen sonra fonksiyona açılı ayraç eklemekti. Aynı struct'larda yaptığımız gibi. Peki bu fonksiyonu nasıl kullanırız? Fonksiyon çağrısında tip belirterek.</p>
<pre><code class="language-Move">script {
    use {{sender}}::Storage;
    use 0x1::Debug;

    fun main() {
        // değer Storage::Box&lt;bool&gt; tipinde olacak
        let bool_box = Storage::create_box&lt;bool&gt;(true);
        let bool_val = Storage::value(&amp;bool_box);

        assert(bool_val, 0);

        // integerla da aynısını yapabiliriz
        let u64_box = Storage::create_box&lt;u64&gt;(1000000);
        let _ = Storage::value(&amp;u64_box);

        // başka bir kutuyla da aynısını yapalım!
        let u64_box_in_box = Storage::create_box&lt;Storage::Box&lt;u64&gt;&gt;(u64_box);

        // bu kutunun değerine ulaşmak zorlu olacak :)
        // Box&lt;u64&gt; bir tip ve Box&lt;Box&lt;u64&gt;&gt; de bir tip
        let value: u64 = Storage::value&lt;u64&gt;(
            &amp;Storage::value&lt;Storage::Box&lt;u64&gt;&gt;( // Box&lt;u64&gt; type
                &amp;u64_box_in_box // Box&lt;Box&lt;u64&gt;&gt; type
            )
        );

        // şimdi Debug::print&lt;T&gt; metodunu gördünüz
        // o da herhangi bir tipi yazdırmak için jenerik kullanıyor
        Debug::print&lt;u64&gt;(&amp;value);
    }
}
</code></pre>
<p>Burada Box struct'ını 3 tiple kullandık <code>bool</code> , <code>u64</code> ve <code>Box&lt;u64&gt;</code> - sonuncusu çok karmaşık gelebilir fakat alıştığınız ve nasıl çalıştığını anladığınız zaman rutininizin pir parçası oluyor.</p>
<!-- , Move opens in new way - the way you probably could never imagine in blockchains. -->
<p>Daha fazla ileri gitmeden önce bir adım geri gidelim. <code>Box</code> struct'ına jenerik ekleyerek bu kutuyu <em>soyut</em> yaptık. Tanımı, bize verdiği kapasiteyle karşılaştırıldığına oldukça basit. Artık herhangi bir tiple <code>Box</code> oluşturmayı biliyoruz. Bu <code>u64</code>, <code>adress</code>, başka bir box ya da başka bir struct olabilir.</p>
<h3><a class="header" href="#yetenekleri-kontrol-etmeye-dair-kısıtlamalar" id="yetenekleri-kontrol-etmeye-dair-kısıtlamalar">Yetenekleri kontrol etmeye dair kısıtlamalar</a></h3>
<p><a href="/advanced-topics/abilities/README.html">Yetenekleri</a> öğrendik. Jeneriklerle “kontrol edilebilir” ya da <em>kısıtlanabilirler</em>. Kısıtlamalar, isimlerini yeteneklerinden alırlar:</p>
<pre><code class="language-Move">fun name&lt;T: copy&gt;() {} // sadece kopyalanabilir değerlere izin ver
fun name&lt;T: copy + drop&gt;() {} // değerler kopyalanabilir ya da atılabilir
fun name&lt;T: key + store + drop + copy&gt;() {} // 4 yetenek birden var
</code></pre>
<p>...ya da struct ile:</p>
<pre><code class="language-Move">struct name&lt;T: copy + drop&gt; { value: T } // T kopyalanabilir a da atılabilir
struct name&lt;T: store&gt; { value: T } // T genel depoda depolanabilir
</code></pre>
<blockquote>
<p>Bu syntax’ı unutmamaya çalışın: <code>+</code> (artı) işaretini ilk başta garipseyebilirsiniz. Çünkü Move’un anahtar kelime listesinde <code>+</code> kullanılan tek yer burası.</p>
</blockquote>
<p>Kısıtlamalarla bir sistem örneği:</p>
<pre><code class="language-Move">module Storage {

    // kutunun içerikleri depolanabilir
    struct Box&lt;T: store&gt; has key, store {
        content: T
    }
}
</code></pre>
<p>İç tipler (ya da jenerik tipler) kapsayıcılarının tüm yeteneklerine (<code>key</code> hariç) sahip olmaları ZORUNLUDUR. Düşündüğünüzde her şey mantıklı ve sezgisel işliyor: kopyalama yeteneği olan bir yapının içeriği de <strong>kopyalama</strong> yeteneğine sahip olmalı. Öbür türlü kapsayan obje kopyalanabilir olamaz. Move derleyicisi bu mantığı takip etmeyen kodlar yazmanıza izin verir fakat bu yetenekleri kullanamazsınız.Örnek:</p>
<pre><code class="language-Move">module Storage {
    // kopyalanamaz ya da atılamaz yapı
    struct Error {}

    // kısıtlamalar belirtilmemiş
    struct Box&lt;T&gt; has copy, drop {
        contents: T
    }

    // bu metod kopyalanamayan veya atılamayan (not droppable) içerikli bir kutu oluşturuyor
    public fun create_box(): Box&lt;Error&gt; {
        Box { contents: Error {} }
    }
}
</code></pre>
<p>Bu kod başarılı bir şekilde yazılır ve derlenir, ama kullanmaya çalışırsanız...</p>
<pre><code class="language-Move">script {
    fun main() {
        {{sender}}::Storage::create_box() // değer oluşturuldu ve atıldı
    }
}
</code></pre>
<p>Box’nun atılamaz (not droppable) olduğunu söyleyen bir hatayla karşılaşacaksınız:</p>
<pre><code>   ┌── scripts/main.move:5:9 ───
   │
 5 │   Storage::create_box();
   │   ^^^^^^^^^^^^^^^^^^^^^ Cannot ignore values without the 'drop' ability. The value must be used
   │
</code></pre>
<p>Bu durum iç değerin atma yeteneğine sahip olmamasından kaynaklanıyor. Kapsayıcı otomatik olarak içindekiler tarafından kısıtlanıyor, yani, örneğin eğer kopyalama, atma ve depolama yeteneğine sahip bir kapsayıcınız ve içinde sadece atma yeteneği olan bir yapınız varsa bu kapsayıcıyı kopyalamak ya da depolamak imkansız olacaktır. Kısacası, bir kapsayıcının içindeki tiplere dair kısıtlayıcıları olmak zorunda değildir, esnek olabilir - içindeki her tip için kullanılabilir.</p>
<blockquote>
<p>Fakat hatalardan kaçınmak için fonksiyonlarda ve yapılarda jenerik kısıtlamalarını kontrol edin ve gerekiyorsa belirtin.</p>
</blockquote>
<p>Bu örnekte daha güvenli bir yapı tanımı şu olabilirdi:</p>
<pre><code class="language-Move">// ebeveynin kısıtlamalarını yazıyoruz
// şimdi iç tip kopyalanabilir ve atılabilir OLMALI
struct Box&lt;T: copy + drop&gt; has copy, drop {
    contents: T
}
</code></pre>
<h3><a class="header" href="#jeneriklerde-çoklu-tipler" id="jeneriklerde-çoklu-tipler">Jeneriklerde çoklu tipler</a></h3>
<p>Sadece bir tip kullanabildiğiniz gibi isterseniz birden fazla tip de kullanabilirsiniz. Jenerik tipler açılı ayraçların içine konup virgülle ayrılır. Şimdi yeni bir tip olan <code>Shelf</code>’i ekleyelim. İki farklı tipteki iki kutuyu tutacak.</p>
<pre><code class="language-Move">module Storage {

    struct Box&lt;T&gt; {
        value: T
    }

    struct Shelf&lt;T1, T2&gt; {
        box_1: Box&lt;T1&gt;,
        box_2: Box&lt;T2&gt;
    }

    public fun create_shelf&lt;Type1, Type2&gt;(
        box_1: Box&lt;Type1&gt;,
        box_2: Box&lt;Type2&gt;
    ): Shelf&lt;Type1, Type2&gt; {
        Shelf {
            box_1,
            box_2
        }
    }
}
</code></pre>
<p><code>Shelf</code> için tip parametreleri yapının bölgesinin tanımının içinde listelenip eşlenmiştir. Ayrıca görebildiğiniz gibi jeneriklerin içindeki tip parametrelerinin ismi önemli değil, düzgün bir tane seçmek size bağlı. Ve her bir tip parametre tanım içinde geçerli yani <code>T1</code> veya <code>T2‘yi</code> <code>T</code> ile eşleştirmeye gerek yok.</p>
<p>Birden fazla jenerik tip parametresi kullanmak, bir tane kullanmaya benzer:</p>
<pre><code class="language-Move">script {
    use {{sender}}::Storage;

    fun main() {
        let b1 = Storage::create_box&lt;u64&gt;(100);
        let b2 = Storage::create_box&lt;u64&gt;(200);

        // herhangi bir tip kullanabilirsin – yani aynı olanlar da geçerli
        let _ = Storage::create_shelf&lt;u64, u64&gt;(b1, b2);
    }
}
</code></pre>
<p><em>Bir tanımda 18,446,744,073,709,551,615 (u64 boyutu) sayısına kadar jeneriğe sahip olabilirsiniz. Bu sınıra kesinlikle varmayacaksınız, o yüzden istediğiniz kadar kullanın.</em></p>
<h3><a class="header" href="#kullanılmamış-tip-parametreleri" id="kullanılmamış-tip-parametreleri">Kullanılmamış tip parametreleri</a></h3>
<p>Jeneriklerde belirtilmiş her tip kullanılmak zorunda değildir. Bu örneğe bakınız:</p>
<pre><code class="language-Move">module Storage {

    // bu iki tip kutunun shelf’ten alındığında
    // nereye gönderileceğini işaretlemek için kullanılacak
    struct Abroad {}
    struct Local {}

    // düzenlenmiş Box aynı hedef niteliğe sahip olacak
    struct Box&lt;T, Destination&gt; {
        value: T
    }

    public fun create_box&lt;T, Dest&gt;(value: T): Box&lt;T, Dest&gt; {
        Box { value }
    }
}
</code></pre>
<p>Bazen jenerikleri kısıtlamak ya da sabit olarak kullanmak faydalı oluyor. Kodda nasıl kullanılabildiğine bakalım:</p>
<pre><code class="language-Move">
script {
    use {{sender}}::Storage;

    fun main() {
        // değer Storage::Box&lt;bool&gt; tipinde olacak
        let _ = Storage::create_box&lt;bool, Storage::Abroad&gt;(true);
        let _ = Storage::create_box&lt;u64, Storage::Abroad&gt;(1000);

        let _ = Storage::create_box&lt;u128, Storage::Local&gt;(1000);
        let _ = Storage::create_box&lt;address, Storage::Local&gt;(0x1);

        // or even u64 destination!
        let _ = Storage::create_box&lt;address, u64&gt;(0x1);
    }
}
</code></pre>
<p>Burada jeneriği tipi işaretlemek için kullanıyoruz ama aslında kullanmıyoruz. İlerde, kaynaklar konseptine geldiğimizde bu tanımın neden önemli olduğunu öğreneceksiniz. Şimdilik bu, sadece onları kullanmanın farklı bir yolu.</p>
<!-- ### Copyable

*Copyable kind* - is a kind of types, value of which can be copied. `struct`, `vector` and primitive types - are three main groups of types fitting into this kind.

To understand why Move needs this constraint let's see this example:

```Move
module M {
    public fun deref<T>(t: &T): T {
        *t
    }
}
```

By using *dereference* on a reference you can *copy* the original value and return it as a regular. But what if we've tried to use `resource` in this example? Resource can't be copied, hence this code would fail. Hopefully compiler won't let you compile this type, and kinds exist to manage cases like this.

```Move
module M {
    public fun deref<T: copyable>(t: &T): T {
        *t
    }
}
```

We've added `: copyable` constraint into generic definition, and now type `T` must be of kind *copyable*. So now function accepts only `struct`, `vector` and primitives as type parameters. This code compiles as constraint provides safety over used types and passing non-copyable value here is impossible.

### Resource

Another kind has only one type inside is a `resource` kind. It is used in the same manner:

```Move
module M {
    public fun smth<T: resource>(t: &T) {
        // do smth
    }
}
```

This example here is only needed to show syntax, we'll get to resources soon and you'll learn actual use cases for this constraint. -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../advanced-topics/ownership-and-references.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../advanced-topics/managing-collections-with-vectors.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../advanced-topics/ownership-and-references.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../advanced-topics/managing-collections-with-vectors.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
