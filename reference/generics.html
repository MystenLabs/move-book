<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Generics - The Move Reference</title>


        <!-- Custom HTML head -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap" rel="stylesheet">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-B1E7R0BHX4"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-B1E7R0BHX4');
        </script>

        <meta name="description" content="The Move Language Reference maintained by the Move core team.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">The Move Reference</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">1.</strong> Modules</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Concepts</li><li class="chapter-item expanded "><a href="primitive-types.html"><strong aria-hidden="true">2.</strong> Primitive Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitive-types/integers.html"><strong aria-hidden="true">2.1.</strong> Integers</a></li><li class="chapter-item expanded "><a href="primitive-types/bool.html"><strong aria-hidden="true">2.2.</strong> Bool</a></li><li class="chapter-item expanded "><a href="primitive-types/address.html"><strong aria-hidden="true">2.3.</strong> Address</a></li><li class="chapter-item expanded "><a href="primitive-types/vector.html"><strong aria-hidden="true">2.4.</strong> Vector</a></li><li class="chapter-item expanded "><a href="primitive-types/references.html"><strong aria-hidden="true">2.5.</strong> References</a></li><li class="chapter-item expanded "><a href="primitive-types/tuples.html"><strong aria-hidden="true">2.6.</strong> Tuples and Unit</a></li></ol></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">3.</strong> Local Variables and Scopes</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">4.</strong> Equality</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">5.</strong> Abort and Assert</a></li><li class="chapter-item expanded "><a href="control-flow.html"><strong aria-hidden="true">6.</strong> Control Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="control-flow/conditionals.html"><strong aria-hidden="true">6.1.</strong> Conditional Expressions</a></li><li class="chapter-item expanded "><a href="control-flow/loops.html"><strong aria-hidden="true">6.2.</strong> Loops</a></li><li class="chapter-item expanded "><a href="control-flow/labeled-control-flow.html"><strong aria-hidden="true">6.3.</strong> Labeled Control FLow</a></li><li class="chapter-item expanded "><a href="control-flow/pattern-matching.html"><strong aria-hidden="true">6.4.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">7.</strong> Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functions/macros.html"><strong aria-hidden="true">7.1.</strong> Macro Functions</a></li></ol></li><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">8.</strong> Structs</a></li><li class="chapter-item expanded "><a href="enums.html"><strong aria-hidden="true">9.</strong> Enums</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">10.</strong> Constants</a></li><li class="chapter-item expanded "><a href="generics.html" class="active"><strong aria-hidden="true">11.</strong> Generics</a></li><li class="chapter-item expanded "><a href="abilities.html"><strong aria-hidden="true">12.</strong> Type Abilities</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">13.</strong> Uses and Aliases</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Concepts</li><li class="chapter-item expanded "><a href="method-syntax.html"><strong aria-hidden="true">14.</strong> Method Syntax</a></li><li class="chapter-item expanded "><a href="index-syntax.html"><strong aria-hidden="true">15.</strong> Index Syntax Methods</a></li><li class="chapter-item expanded affix "><li class="part-title">Tooling</li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">16.</strong> Packages</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">17.</strong> Unit Tests</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">18.</strong> Coding Conventions</a></li><li class="chapter-item expanded affix "><li class="part-title">Deprecated</li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">19.</strong> Friends</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Move Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MystenLabs/move-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/move-language/move/edit/main/language/documentation/book/src/generics.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Generics can be used to define functions and structs over different input data types. This language
feature is sometimes referred to as parametric polymorphism. In Move, we will often use the term
generics interchangeably with <em>type parameters</em> and <em>type arguments</em>.</p>
<p>Generics are commonly used in library code, such as in <a href="./primitive-types/vector.html">vector</a>, to
declare code that works over any possible type (that satisfies the specified constraints). This sort
of parameterization allows you to reuse the same implementation across multiple types and
situations.</p>
<h2 id="declaring-type-parameters"><a class="header" href="#declaring-type-parameters">Declaring Type Parameters</a></h2>
<p>Both functions and structs can take a list of type parameters in their signatures, enclosed by a
pair of angle brackets <code>&lt;...&gt;</code>.</p>
<h3 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h3>
<p>Type parameters for functions are placed after the function name and before the (value) parameter
list. The following code defines a generic identity function that takes a value of any type and
returns that value unchanged.</p>
<pre><code class="language-move">fun id&lt;T&gt;(x: T): T {
    // this type annotation is unnecessary but valid
    (x: T)
}
</code></pre>
<p>Once defined, the type parameter <code>T</code> can be used in parameter types, return types, and inside the
function body.</p>
<h3 id="generic-structs"><a class="header" href="#generic-structs">Generic Structs</a></h3>
<p>Type parameters for structs are placed after the struct name, and can be used to name the types of
the fields.</p>
<pre><code class="language-move">public struct Foo&lt;T&gt; has copy, drop { x: T }

public struct Bar&lt;T1, T2&gt; has copy, drop {
    x: T1,
    y: vector&lt;T2&gt;,
}
</code></pre>
<p>Note that <a href="#unused-type-parameters">type parameters do not have to be used</a></p>
<h2 id="type-arguments"><a class="header" href="#type-arguments">Type Arguments</a></h2>
<h3 id="calling-generic-functions"><a class="header" href="#calling-generic-functions">Calling Generic Functions</a></h3>
<p>When calling a generic function, one can specify the type arguments for the function's type
parameters in a list enclosed by a pair of angle brackets.</p>
<pre><code class="language-move">fun foo() {
    let x = id&lt;bool&gt;(true);
}
</code></pre>
<p>If you do not specify the type arguments, Move's <a href="#type-inference">type inference</a> will supply them
for you.</p>
<h3 id="using-generic-structs"><a class="header" href="#using-generic-structs">Using Generic Structs</a></h3>
<p>Similarly, one can attach a list of type arguments for the struct's type parameters when
constructing or destructing values of generic types.</p>
<pre><code class="language-move">fun foo() {
    // type arguments on construction
    let foo = Foo&lt;bool&gt; { x: true };
    let bar = Bar&lt;u64, u8&gt; { x: 0, y: vector&lt;u8&gt;[] };

    // type arguments on destruction
    let Foo&lt;bool&gt; { x } = foo;
    let Bar&lt;u64, u8&gt; { x, y } = bar;
}
</code></pre>
<p>In any case if you do not specify the type arguments, Move's <a href="#type-inference">type inference</a> will
supply them for you.</p>
<h3 id="type-argument-mismatch"><a class="header" href="#type-argument-mismatch">Type Argument Mismatch</a></h3>
<p>If you specify the type arguments and they conflict with the actual values supplied, an error will
be given:</p>
<pre><code class="language-move">fun foo() {
    let x = id&lt;u64&gt;(true); // ERROR! true is not a u64
}
</code></pre>
<p>and similarly:</p>
<pre><code class="language-move">fun foo() {
    let foo = Foo&lt;bool&gt; { x: 0 }; // ERROR! 0 is not a bool
    let Foo&lt;address&gt; { x } = foo; // ERROR! bool is incompatible with address
}
</code></pre>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>In most cases, the Move compiler will be able to infer the type arguments so you don't have to write
them down explicitly. Here's what the examples above would look like if we omit the type arguments:</p>
<pre><code class="language-move">fun foo() {
    let x = id(true);
    //        ^ &lt;bool&gt; is inferred

    let foo = Foo { x: true };
    //           ^ &lt;bool&gt; is inferred

    let Foo { x } = foo;
    //     ^ &lt;bool&gt; is inferred
}
</code></pre>
<p>Note: when the compiler is unable to infer the types, you'll need annotate them manually. A common
scenario is to call a function with type parameters appearing only at return positions.</p>
<pre><code class="language-move">module a::m {

    fun foo() {
        let v = vector[]; // ERROR!
        //            ^ The compiler cannot figure out the element type, since it is never used

        let v = vector&lt;u64&gt;[];
        //            ^~~~~ Must annotate manually in this case.
    }
}
</code></pre>
<p>Note that these cases are a bit contrived since the <code>vector[]</code> is never used, ad as such, Move's
type inference cannot infer the type.</p>
<p>However, the compiler will be able to infer the type if that value is used later in that function:</p>
<pre><code class="language-move">module a::m {
    fun foo() {
        let v = vector[];
        //            ^ &lt;u64&gt; is inferred
        vector::push_back(&amp;mut v, 42);
        //               ^ &lt;u64&gt; is inferred
    }
}
</code></pre>
<h3 id="_-type"><a class="header" href="#_-type"><code>_</code> Type</a></h3>
<p>In some cases, you might want to explicitly annotate some of the type arguments, but let the
compiler infer the others. The <code>_</code> type serves as such a placeholder for the compiler to infer the
type.</p>
<pre><code class="language-move">let bar = Bar&lt;u64, _&gt; { x: 0, y: vector[b&quot;hello&quot;] };
//                 ^ vector&lt;u8&gt; is inferred
</code></pre>
<p>The placeholder <code>_</code> may only appear in expressions and macro function definitions, not signatures.
This means you cannot use <code>_</code> as part of the definition of a function parameter, function return
type, constant definition type, and datatype field.</p>
<h2 id="integers"><a class="header" href="#integers">Integers</a></h2>
<p>In Move, the integer types <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, and <code>u256</code> are all distinct types.
However, each one of these types can be created with the same numerical value syntax. In other
words, if a type suffix is not provided, the compiler will infer the integer type based on the usage
of the value.</p>
<pre><code class="language-move">let x8: u8 = 0;
let x16: u16 = 0;
let x32: u32 = 0;
let x64: u64 = 0;
let x128: u128 = 0;
let x256: u256 = 0;
</code></pre>
<p>If the value is not used in a context that requires a specific integer type, <code>u64</code> is taken as a
default.</p>
<pre><code class="language-move">let x = 0;
//      ^ u64 is used by default
</code></pre>
<p>If the value however is too large for the inferred type, an error will be given</p>
<pre><code class="language-move">let i: u8 = 256; // ERROR!
//          ^^^ too large for u8
let x = 340282366920938463463374607431768211454;
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ too large for u64
</code></pre>
<p>In cases where the number is too large, you might need to annotate it explicitly</p>
<pre><code class="language-move">let x = 340282366920938463463374607431768211454u128;
//                                             ^^^^ valid!
</code></pre>
<h2 id="unused-type-parameters"><a class="header" href="#unused-type-parameters">Unused Type Parameters</a></h2>
<p>For a struct definition, an unused type parameter is one that does not appear in any field defined
in the struct, but is checked statically at compile time. Move allows unused type parameters so the
following struct definition is valid:</p>
<pre><code class="language-move">public struct Foo&lt;T&gt; {
    foo: u64
}
</code></pre>
<p>This can be convenient when modeling certain concepts. Here is an example:</p>
<pre><code class="language-move">module a::m {
    // Currency Specifiers
    public struct A {}
    public struct B {}

    // A generic coin type that can be instantiated using a currency
    // specifier type.
    //   e.g. Coin&lt;A&gt;, Coin&lt;B&gt; etc.
    public struct Coin&lt;Currency&gt; has store {
        value: u64
    }

    // Write code generically about all currencies
    public fun mint_generic&lt;Currency&gt;(value: u64): Coin&lt;Currency&gt; {
        Coin { value }
    }

    // Write code concretely about one currency
    public fun mint_a(value: u64): Coin&lt;A&gt; {
        mint_generic(value)
    }
    public fun mint_b(value: u64): Coin&lt;B&gt; {
        mint_generic(value)
    }
}
</code></pre>
<p>In this example, <code>Coin&lt;Currency&gt;</code> is generic on the <code>Currency</code> type parameter, which specifies the
currency of the coin and allows code to be written either generically on any currency or concretely
on a specific currency. This generality applies even when the <code>Currency</code> type parameter does not
appear in any of the fields defined in <code>Coin</code>.</p>
<h3 id="phantom-type-parameters"><a class="header" href="#phantom-type-parameters">Phantom Type Parameters</a></h3>
<p>In the example above, although <code>struct Coin</code> asks for the <code>store</code> ability, neither <code>Coin&lt;A&gt;</code> nor
<code>Coin&lt;B&gt;</code> will have the <code>store</code> ability. This is because of the rules for
<a href="./abilities.html#conditional-abilities-and-generic-types">Conditional Abilities and Generic Types</a>
and the fact that <code>A</code> and <code>B</code> don't have the <code>store</code> ability, despite the fact that they are not
even used in the body of <code>struct Coin</code>. This might cause some unpleasant consequences. For example,
we are unable to put <code>Coin&lt;A&gt;</code> into a wallet in storage.</p>
<p>One possible solution would be to add spurious ability annotations to <code>A</code> and <code>B</code> (i.e.,
<code>public struct Currency1 has store {}</code>). But, this might lead to bugs or security vulnerabilities
because it weakens the types with unnecessary ability declarations. For example, we would never
expect a value in the storage to have a field in type <code>A</code>, but this would be possible with the
spurious <code>store</code> ability. Moreover, the spurious annotations would be infectious, requiring many
functions generic on the unused type parameter to also include the necessary constraints.</p>
<p>Phantom type parameters solve this problem. Unused type parameters can be marked as <em>phantom</em> type
parameters, which do not participate in the ability derivation for structs. In this way, arguments
to phantom type parameters are not considered when deriving the abilities for generic types, thus
avoiding the need for spurious ability annotations. For this relaxed rule to be sound, Move's type
system guarantees that a parameter declared as <code>phantom</code> is either not used at all in the struct
definition, or it is only used as an argument to type parameters also declared as <code>phantom</code>.</p>
<h4 id="declaration"><a class="header" href="#declaration">Declaration</a></h4>
<p>In a struct definition a type parameter can be declared as phantom by adding the <code>phantom</code> keyword
before its declaration.</p>
<pre><code class="language-move">public struct Coin&lt;phantom Currency&gt; has store {
    value: u64
}
</code></pre>
<p>If a type parameter is declared as phantom we say it is a phantom type parameter. When defining a
struct, Move's type checker ensures that every phantom type parameter is either not used inside the
struct definition or it is only used as an argument to a phantom type parameter.</p>
<pre><code class="language-move">public struct S1&lt;phantom T1, T2&gt; { f: u64 }
//               ^^^^^^^ valid, T1 does not appear inside the struct definition

public struct S2&lt;phantom T1, T2&gt; { f: S1&lt;T1, T2&gt; }
//               ^^^^^^^ valid, T1 appears in phantom position
</code></pre>
<p>The following code shows examples of violations of the rule:</p>
<pre><code class="language-move">public struct S1&lt;phantom T&gt; { f: T }
//               ^^^^^^^ ERROR!  ^ Not a phantom position

public struct S2&lt;T&gt; { f: T }
public struct S3&lt;phantom T&gt; { f: S2&lt;T&gt; }
//               ^^^^^^^ ERROR!     ^ Not a phantom position
</code></pre>
<p>More formally, if a type is used as an argument to a phantom type parameter we say the type appears
in <em>phantom position</em>. With this definition in place, the rule for the correct use of phantom
parameters can be specified as follows: <strong>A phantom type parameter can only appear in phantom
position</strong>.</p>
<p>Note that specifying <code>phantom</code> is not required, but the compiler will warn if a type parameter could
be <code>phantom</code> but was not marked as such.</p>
<h4 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h4>
<p>When instantiating a struct, the arguments to phantom parameters are excluded when deriving the
struct abilities. For example, consider the following code:</p>
<pre><code class="language-move">public struct S&lt;T1, phantom T2&gt; has copy { f: T1 }
public struct NoCopy {}
public struct HasCopy has copy {}
</code></pre>
<p>Consider now the type <code>S&lt;HasCopy, NoCopy&gt;</code>. Since <code>S</code> is defined with <code>copy</code> and all non-phantom
arguments have <code>copy</code> then <code>S&lt;HasCopy, NoCopy&gt;</code> also has <code>copy</code>.</p>
<h4 id="phantom-type-parameters-with-ability-constraints"><a class="header" href="#phantom-type-parameters-with-ability-constraints">Phantom Type Parameters with Ability Constraints</a></h4>
<p>Ability constraints and phantom type parameters are orthogonal features in the sense that phantom
parameters can be declared with ability constraints.</p>
<pre><code class="language-move">public struct S&lt;phantom T: copy&gt; {}
</code></pre>
<p>When instantiating a phantom type parameter with an ability constraint, the type argument has to
satisfy that constraint, even though the parameter is phantom. The usual restrictions apply and <code>T</code>
can only be instantiated with arguments having <code>copy</code>.</p>
<h2 id="constraints"><a class="header" href="#constraints">Constraints</a></h2>
<p>In the examples above, we have demonstrated how one can use type parameters to define &quot;unknown&quot;
types that can be plugged in by callers at a later time. This however means the type system has
little information about the type and has to perform checks in a very conservative way. In some
sense, the type system must assume the worst case scenario for an unconstrained generic--a type with
no <a href="./abilities.html">abilities</a>.</p>
<p>Constraints offer a way to specify what properties these unknown types have so the type system can
allow operations that would otherwise be unsafe.</p>
<h3 id="declaring-constraints"><a class="header" href="#declaring-constraints">Declaring Constraints</a></h3>
<p>Constraints can be imposed on type parameters using the following syntax.</p>
<pre><code class="language-move">// T is the name of the type parameter
T: &lt;ability&gt; (+ &lt;ability&gt;)*
</code></pre>
<p>The <code>&lt;ability&gt;</code> can be any of the four <a href="./abilities.html">abilities</a>, and a type parameter can be
constrained with multiple abilities at once. So all of the following would be valid type parameter
declarations:</p>
<pre><code class="language-move">T: copy
T: copy + drop
T: copy + drop + store + key
</code></pre>
<h3 id="verifying-constraints"><a class="header" href="#verifying-constraints">Verifying Constraints</a></h3>
<p>Constraints are checked at instantiation sites</p>
<pre><code class="language-move">public struct Foo&lt;T: copy&gt; { x: T }

public struct Bar { x: Foo&lt;u8&gt; }
//                         ^^ valid, u8 has `copy`

public struct Baz&lt;T&gt; { x: Foo&lt;T&gt; }
//                            ^ ERROR! T does not have 'copy'
</code></pre>
<p>And similarly for functions</p>
<pre><code class="language-move">fun unsafe_consume&lt;T&gt;(x: T) {
    // ERROR! x does not have 'drop'
}

fun consume&lt;T: drop&gt;(x: T) {
    // valid, x will be dropped automatically
}

public struct NoAbilities {}

fun foo() {
    let r = NoAbilities {};
    consume&lt;NoAbilities&gt;(NoAbilities);
    //      ^^^^^^^^^^^ ERROR! NoAbilities does not have 'drop'
}
</code></pre>
<p>And some similar examples, but with <code>copy</code></p>
<pre><code class="language-move">fun unsafe_double&lt;T&gt;(x: T) {
    (copy x, x)
    // ERROR! T does not have 'copy'
}

fun double&lt;T: copy&gt;(x: T) {
    (copy x, x) // valid, T has 'copy'
}

public struct NoAbilities {}

fun foo(): (NoAbilities, NoAbilities) {
    let r = NoAbilities {};
    double&lt;NoAbilities&gt;(r)
    //     ^ ERROR! NoAbilities does not have 'copy'
}
</code></pre>
<p>For more information, see the abilities section on
<a href="./abilities.html#conditional-abilities-and-generic-types">conditional abilities and generic types</a>.</p>
<h2 id="limitations-on-recursions"><a class="header" href="#limitations-on-recursions">Limitations on Recursions</a></h2>
<h3 id="recursive-structs"><a class="header" href="#recursive-structs">Recursive Structs</a></h3>
<p>Generic structs can not contain fields of the same type, either directly or indirectly, even with
different type arguments. All of the following struct definitions are invalid:</p>
<pre><code class="language-move">public struct Foo&lt;T&gt; {
    x: Foo&lt;u64&gt; // ERROR! 'Foo' containing 'Foo'
}

public struct Bar&lt;T&gt; {
    x: Bar&lt;T&gt; // ERROR! 'Bar' containing 'Bar'
}

// ERROR! 'A' and 'B' forming a cycle, which is not allowed either.
public struct A&lt;T&gt; {
    x: B&lt;T, u64&gt;
}

public struct B&lt;T1, T2&gt; {
    x: A&lt;T1&gt;
    y: A&lt;T2&gt;
}
</code></pre>
<h3 id="advanced-topic-type-level-recursions"><a class="header" href="#advanced-topic-type-level-recursions">Advanced Topic: Type-level Recursions</a></h3>
<p>Move allows generic functions to be called recursively. However, when used in combination with
generic structs, this could create an infinite number of types in certain cases, and allowing this
means adding unnecessary complexity to the compiler, vm and other language components. Therefore,
such recursions are forbidden.</p>
<p>This restriction might be relaxed in the future, but for now, the following examples should give you
an idea of what is allowed and what is not.</p>
<pre><code class="language-move">module a::m {
    public struct A&lt;T&gt; {}

    // Finitely many types -- allowed.
    // foo&lt;T&gt; -&gt; foo&lt;T&gt; -&gt; foo&lt;T&gt; -&gt; ... is valid
    fun foo&lt;T&gt;() {
        foo&lt;T&gt;();
    }

    // Finitely many types -- allowed.
    // foo&lt;T&gt; -&gt; foo&lt;A&lt;u64&gt;&gt; -&gt; foo&lt;A&lt;u64&gt;&gt; -&gt; ... is valid
    fun foo&lt;T&gt;() {
        foo&lt;A&lt;u64&gt;&gt;();
    }
}
</code></pre>
<p>Not allowed:</p>
<pre><code class="language-move">module a::m {
    public struct A&lt;T&gt; {}

    // Infinitely many types -- NOT allowed.
    // error!
    // foo&lt;T&gt; -&gt; foo&lt;A&lt;T&gt;&gt; -&gt; foo&lt;A&lt;A&lt;T&gt;&gt;&gt; -&gt; ...
    fun foo&lt;T&gt;() {
        foo&lt;Foo&lt;T&gt;&gt;();
    }
}
</code></pre>
<p>And similarly, not allowed:</p>
<pre><code class="language-move">module a::n {
    public struct A&lt;T&gt; {}

    // Infinitely many types -- NOT allowed.
    // error!
    // foo&lt;T1, T2&gt; -&gt; bar&lt;T2, T1&gt; -&gt; foo&lt;T2, A&lt;T1&gt;&gt;
    //   -&gt; bar&lt;A&lt;T1&gt;, T2&gt; -&gt; foo&lt;A&lt;T1&gt;, A&lt;T2&gt;&gt;
    //   -&gt; bar&lt;A&lt;T2&gt;, A&lt;T1&gt;&gt; -&gt; foo&lt;A&lt;T2&gt;, A&lt;A&lt;T1&gt;&gt;&gt;
    //   -&gt; ...
    fun foo&lt;T1, T2&gt;() {
        bar&lt;T2, T1&gt;();
    }

    fun bar&lt;T1, T2&gt; {
        foo&lt;T1, A&lt;T2&gt;&gt;();
    }
}
</code></pre>
<p>Note, the check for type level recursions is based on a conservative analysis on the call sites and
does NOT take control flow or runtime values into account.</p>
<pre><code class="language-move">module a::m {
    public struct A&lt;T&gt; {}

    // Infinitely many types -- NOT allowed.
    // error!
    fun foo&lt;T&gt;(n: u64) {
        if (n &gt; 0) foo&lt;A&lt;T&gt;&gt;(n - 1);
    }
}
</code></pre>
<p>The function in the example above will technically terminate for any given input and therefore only
creating finitely many types, but it is still considered invalid by Move's type system.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="constants.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="abilities.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="constants.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="abilities.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/switcher.js"></script>


    </div>
    </body>
</html>
