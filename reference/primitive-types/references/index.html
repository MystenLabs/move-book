<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-reference docs-version-current docs-doc-page docs-doc-id-primitive-types/references" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">References | Reference | The Move Book</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://move-book.com/reference/primitive-types/references"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="algolia-site-verification" content="BCA21DA2879818D2"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-reference-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-reference-current"><meta data-rh="true" property="og:title" content="References | Reference | The Move Book"><link data-rh="true" rel="icon" href="/favicon.svg"><link data-rh="true" rel="canonical" href="https://move-book.com/reference/primitive-types/references"><link data-rh="true" rel="alternate" href="https://move-book.com/reference/primitive-types/references" hreflang="en"><link data-rh="true" rel="alternate" href="https://move-book.com/reference/primitive-types/references" hreflang="x-default"><link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B1E7R0BHX4"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-B1E7R0BHX4",{anonymize_ip:!0})</script>



<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Rubik:wght@300&amp;amp;display=swap">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"><link rel="stylesheet" href="/assets/css/styles.f79f3242.css">
<script src="/assets/js/runtime~main.f4555ab1.js" defer="defer"></script>
<script src="/assets/js/main.9757aefb.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_OH5z" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"></a><a class="navbar__item navbar__link" href="/">Move Book</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/reference">Move Reference</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><div class="navbarSearchContainer_aspp"><div class="navbar__search searchBarContainer_reza" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input searchInput_Kpxf" value=""><div class="loadingRing_LRD_ searchBarLoadingRing_lY7z"><div></div><div></div><div></div><div></div></div></div></div><a href="https://github.com/MystenLabs/move-book" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><i class="fab fa-github"></i></a><div class="toggle_MW0i colorModeToggle_RHuM"><button class="clean-btn toggleButton_yw5v toggleButtonDisabled_BJd7" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><i aria-hidden="true" class="toggleIcon_oIOL lightToggleIcon_SFTY fas fa-moon"></i><i aria-hidden="true" class="toggleIcon_oIOL darkToggleIcon_ekgs fas fa-sun"></i><i aria-hidden="true" class="toggleIcon_oIOL systemToggleIcon_yi_a fas fa-moon"></i></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_wWoK"><div class="docsWrapper_nrtX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_xs6u" type="button"></button><div class="docRoot_XRUv"><aside class="theme-doc-sidebar-container docSidebarContainer_vhZZ"><div class="sidebarViewport_HXJ_"><div class="sidebar_B2tA"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_RelJ"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/reference/">The Move Reference</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link">Getting Started</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/modules">1. Modules</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active">Basic Concepts</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active" tabindex="0" href="/reference/primitive-types">2. Primitive Types</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/primitive-types/integers">2.1 Integers</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/primitive-types/bool">2.2 Bool</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/primitive-types/address">2.3 Address</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/primitive-types/vector">2.4 Vector</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/reference/primitive-types/references">2.5 References</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/primitive-types/tuples">2.6 Tuples and Unit</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/variables">3. Local Variables and Scopes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/equality">4. Equality</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link" tabindex="0" href="/reference/abort-and-assert">5. Abort and Assert</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/abort-and-assert/clever-errors">5.1 Clever Errors</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link" tabindex="0" href="/reference/control-flow">6. Control Flow</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/control-flow/conditionals">6.1 Conditional Expressions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/control-flow/loops">6.2 Loops</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/control-flow/labeled-control-flow">6.3 Labeled Control Flow</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/control-flow/pattern-matching">6.4 Pattern Matching</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link" tabindex="0" href="/reference/functions">7. Functions</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/functions/macros">7.1 Macros</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/structs">8. Structs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/enums">9. Enums</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/constants">10. Constants</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/generics">11. Generics</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/abilities">12. Abilities</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/uses">13. Uses and Aliases</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link">Advanced Concepts</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/method-syntax">14. Method Syntax</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/index-syntax">15. Index Syntax</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link">Tooling</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/packages">16. Packages</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/unit-testing">17. Unit Testing</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link">Reference</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/coding-conventions">18. Coding Conventions</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link">Deprecated</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/reference/friends">19. Friends</a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_oT2n"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_LCKf"><div class="docItemContainer_Jixr"><article><div class="tocCollapsible_vYTS theme-doc-toc-mobile tocMobile_QhsY"><button type="button" class="clean-btn tocCollapsibleButton_nB9w">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>References</h1></header>
<p>Move has two types of references: immutable <span class="inline-code">&amp;</span> and mutable <span class="inline-code">&amp;mut</span>. Immutable references are read
only, and cannot modify the underlying value (or any of its fields). Mutable references allow for
modifications via a write through that reference. Move&#x27;s type system enforces an ownership
discipline that prevents reference errors.</p>
<h2 class="anchor anchorWithStickyNavbar_kl3l" id="reference-operators">Reference Operators<a href="#reference-operators" class="hash-link" aria-label="Direct link to Reference Operators" title="Direct link to Reference Operators">​</a></h2>
<p>Move provides operators for creating and extending references as well as converting a mutable
reference to an immutable one. Here and elsewhere, we use the notation <span class="inline-code">e: T</span> for &quot;expression <span class="inline-code">e</span>
has type <span class="inline-code">T</span>&quot;.</p>
<table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><span class="inline-code">&amp;e</span></td><td><span class="inline-code">&amp;T</span> where <span class="inline-code">e: T</span> and <span class="inline-code">T</span> is a non-reference type</td><td>Create an immutable reference to <span class="inline-code">e</span></td></tr><tr><td><span class="inline-code">&amp;mut e</span></td><td><span class="inline-code">&amp;mut T</span> where <span class="inline-code">e: T</span> and <span class="inline-code">T</span> is a non-reference type</td><td>Create a mutable reference to <span class="inline-code">e</span>.</td></tr><tr><td><span class="inline-code">&amp;e.f</span></td><td><span class="inline-code">&amp;T</span> where <span class="inline-code">e.f: T</span></td><td>Create an immutable reference to field <span class="inline-code">f</span> of struct <span class="inline-code">e</span>.</td></tr><tr><td><span class="inline-code">&amp;mut e.f</span></td><td><span class="inline-code">&amp;mut T</span> where <span class="inline-code">e.f: T</span></td><td>Create a mutable reference to field <span class="inline-code">f</span> of struct<span class="inline-code">e</span>.</td></tr><tr><td><span class="inline-code">freeze(e)</span></td><td><span class="inline-code">&amp;T</span> where <span class="inline-code">e: &amp;mut T</span></td><td>Convert the mutable reference <span class="inline-code">e</span> into an immutable reference.</td></tr></tbody></table>
<p>The <span class="inline-code">&amp;e.f</span> and <span class="inline-code">&amp;mut e.f</span> operators can be used both to create a new reference into a struct or to
extend an existing reference:</p>
<div class="language-move codeBlockContainer_AE_o theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_YOHW"><pre tabindex="0" class="prism-code language-move codeBlock_q9R9 thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_bu_M"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> s = </span><span class="token struct-types entity" style="color:#C18401">S</span><span class="token plain"> { </span><span class="token property-name function-argument struct-property-name">f</span><span class="token plain">: </span><span class="token literals number" style="color:hsl(35, 99%, 36%)">10</span><span class="token plain"> };</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> </span><span class="token property-name function-argument struct-property-name">f_ref1</span><span class="token plain">: &amp;</span><span class="token built-in-types support" style="color:#0184BC">u64</span><span class="token plain"> = &amp;s.f; </span><span class="token comment" style="color:#A0A1A7">// works</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> </span><span class="token let-statement">s_ref</span><span class="token plain">: &amp;</span><span class="token struct-types entity" style="color:#C18401">S</span><span class="token plain"> = &amp;s;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> </span><span class="token property-name function-argument struct-property-name">f_ref2</span><span class="token plain">: &amp;</span><span class="token built-in-types support" style="color:#0184BC">u64</span><span class="token plain"> = &amp;s_ref.f </span><span class="token comment" style="color:#A0A1A7">// also works</span><br></span></code></pre></div></div>
<p>A reference expression with multiple fields works as long as both structs are in the same module:</p>
<div class="language-move codeBlockContainer_AE_o theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_YOHW"><pre tabindex="0" class="prism-code language-move codeBlock_q9R9 thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_bu_M"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token visibility keyword" style="color:hsl(301, 63%, 40%)">public</span><span class="token plain"> </span><span class="token struct-or-enum-definition struct-keyword keyword" style="color:hsl(301, 63%, 40%)">struct</span><span class="token struct-or-enum-definition"> </span><span class="token struct-or-enum-definition struct-name entity" style="color:#C18401">A</span><span class="token struct-or-enum-definition"> {</span><span class="token plain"> </span><span class="token property-name function-argument struct-property-name">b</span><span class="token plain">: </span><span class="token struct-types entity" style="color:#C18401">B</span><span class="token plain"> }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token visibility keyword" style="color:hsl(301, 63%, 40%)">public</span><span class="token plain"> </span><span class="token struct-or-enum-definition struct-keyword keyword" style="color:hsl(301, 63%, 40%)">struct</span><span class="token struct-or-enum-definition"> </span><span class="token struct-or-enum-definition struct-name entity" style="color:#C18401">B</span><span class="token struct-or-enum-definition"> {</span><span class="token plain"> </span><span class="token property-name function-argument struct-property-name">c</span><span class="token plain"> : </span><span class="token built-in-types support" style="color:#0184BC">u64</span><span class="token plain"> }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token function-keyword keyword" style="color:hsl(301, 63%, 40%)">fun</span><span class="token plain"> </span><span class="token function-name function" style="color:hsl(221, 87%, 60%)">f</span><span class="token plain">(</span><span class="token property-name function-argument struct-property-name">a</span><span class="token plain">: &amp;</span><span class="token struct-types entity" style="color:#C18401">A</span><span class="token plain">): &amp;</span><span class="token built-in-types support" style="color:#0184BC">u64</span><span class="token plain"> {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    &amp;a.b.c</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>Finally, note that references to references are not allowed:</p>
<div class="language-move codeBlockContainer_AE_o theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_YOHW"><pre tabindex="0" class="prism-code language-move codeBlock_q9R9 thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_bu_M"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> x = </span><span class="token literals number" style="color:hsl(35, 99%, 36%)">7</span><span class="token plain">;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> </span><span class="token let-statement">y</span><span class="token plain">: &amp;</span><span class="token built-in-types support" style="color:#0184BC">u64</span><span class="token plain"> = &amp;x;</span><br></span><span class="token-line error-comment" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> </span><span class="token let-statement">z</span><span class="token plain">: &amp;&amp;</span><span class="token built-in-types support" style="color:#0184BC">u64</span><span class="token plain"> = &amp;y; </span><span class="token comment" style="color:#A0A1A7">// ERROR! will not compile</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_kl3l" id="reading-and-writing-through-references">Reading and Writing Through References<a href="#reading-and-writing-through-references" class="hash-link" aria-label="Direct link to Reading and Writing Through References" title="Direct link to Reading and Writing Through References">​</a></h2>
<p>Both mutable and immutable references can be read to produce a copy of the referenced value.</p>
<p>Only mutable references can be written. A write <span class="inline-code">*x = v</span> discards the value previously stored in <span class="inline-code">x</span>
and updates it with <span class="inline-code">v</span>.</p>
<p>Both operations use the C-like <span class="inline-code">*</span> syntax. However, note that a read is an expression, whereas a
write is a mutation that must occur on the left hand side of an equals.</p>
<table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><span class="inline-code">*e</span></td><td><span class="inline-code">T</span> where <span class="inline-code">e</span> is <span class="inline-code">&amp;T</span> or <span class="inline-code">&amp;mut T</span></td><td>Read the value pointed to by <span class="inline-code">e</span></td></tr><tr><td><span class="inline-code">*e1 = e2</span></td><td><span class="inline-code">()</span> where <span class="inline-code">e1: &amp;mut T</span> and <span class="inline-code">e2: T</span></td><td>Update the value in <span class="inline-code">e1</span> with <span class="inline-code">e2</span>.</td></tr></tbody></table>
<p>In order for a reference to be read, the underlying type must have the
<a href="/reference/abilities"><span class="inline-code">copy</span> ability</a> as reading the reference creates a new copy of the value. This rule
prevents the copying of assets:</p>
<div class="language-move codeBlockContainer_AE_o theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_YOHW"><pre tabindex="0" class="prism-code language-move codeBlock_q9R9 thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_bu_M"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token function-keyword keyword" style="color:hsl(301, 63%, 40%)">fun</span><span class="token plain"> </span><span class="token function-name function" style="color:hsl(221, 87%, 60%)">copy_coin_via_ref_bad</span><span class="token plain">(</span><span class="token property-name function-argument struct-property-name">c</span><span class="token plain">: </span><span class="token struct-types entity" style="color:#C18401">Coin</span><span class="token plain">) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> c_ref = &amp;c;</span><br></span><span class="token-line error-comment" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> </span><span class="token let-statement">counterfeit</span><span class="token plain">: </span><span class="token struct-types entity" style="color:#C18401">Coin</span><span class="token plain"> = *c_ref; </span><span class="token comment" style="color:#A0A1A7">// not allowed!</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token function-call function" style="color:hsl(221, 87%, 60%)">pay</span><span class="token plain">(c);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token function-call function" style="color:hsl(221, 87%, 60%)">pay</span><span class="token plain">(counterfeit);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>Dually: in order for a reference to be written to, the underlying type must have the
<a href="/reference/abilities"><span class="inline-code">drop</span> ability</a> as writing to the reference will discard (or &quot;drop&quot;) the old value.
This rule prevents the destruction of resource values:</p>
<div class="language-move codeBlockContainer_AE_o theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_YOHW"><pre tabindex="0" class="prism-code language-move codeBlock_q9R9 thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_bu_M"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token function-keyword keyword" style="color:hsl(301, 63%, 40%)">fun</span><span class="token plain"> </span><span class="token function-name function" style="color:hsl(221, 87%, 60%)">destroy_coin_via_ref_bad</span><span class="token plain">(</span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> </span><span class="token property-name function-argument struct-property-name">ten_coins</span><span class="token plain">: </span><span class="token struct-types entity" style="color:#C18401">Coin</span><span class="token plain">, </span><span class="token property-name function-argument struct-property-name">c</span><span class="token plain">: </span><span class="token struct-types entity" style="color:#C18401">Coin</span><span class="token plain">) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> ref = &amp;</span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> ten_coins;</span><br></span><span class="token-line error-comment" style="color:hsl(230, 8%, 24%)"><span class="token plain">    *ref = c; </span><span class="token comment" style="color:#A0A1A7">// ERROR! not allowed--would destroy 10 coins!</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_kl3l" id="freeze-inference"><span class="inline-code">freeze</span> inference<a href="#freeze-inference" class="hash-link" aria-label="Direct link to freeze-inference" title="Direct link to freeze-inference">​</a></h2>
<p>A mutable reference can be used in a context where an immutable reference is expected:</p>
<div class="language-move codeBlockContainer_AE_o theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_YOHW"><pre tabindex="0" class="prism-code language-move codeBlock_q9R9 thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_bu_M"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> </span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> x = </span><span class="token literals number" style="color:hsl(35, 99%, 36%)">7</span><span class="token plain">;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> </span><span class="token let-statement">y</span><span class="token plain">: &amp;</span><span class="token built-in-types support" style="color:#0184BC">u64</span><span class="token plain"> = &amp;</span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> x;</span><br></span></code></pre></div></div>
<p>This works because the under the hood, the compiler inserts <span class="inline-code">freeze</span> instructions where they are
needed. Here are a few more examples of <span class="inline-code">freeze</span> inference in action:</p>
<div class="language-move codeBlockContainer_AE_o theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_YOHW"><pre tabindex="0" class="prism-code language-move codeBlock_q9R9 thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_bu_M"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token function-keyword keyword" style="color:hsl(301, 63%, 40%)">fun</span><span class="token plain"> </span><span class="token function-name function" style="color:hsl(221, 87%, 60%)">takes_immut_returns_immut</span><span class="token plain">(</span><span class="token property-name function-argument struct-property-name">x</span><span class="token plain">: &amp;</span><span class="token built-in-types support" style="color:#0184BC">u64</span><span class="token plain">): &amp;</span><span class="token built-in-types support" style="color:#0184BC">u64</span><span class="token plain"> { x }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token comment" style="color:#A0A1A7">// freeze inference on return value</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token function-keyword keyword" style="color:hsl(301, 63%, 40%)">fun</span><span class="token plain"> </span><span class="token function-name function" style="color:hsl(221, 87%, 60%)">takes_mut_returns_immut</span><span class="token plain">(</span><span class="token property-name function-argument struct-property-name">x</span><span class="token plain">: &amp;</span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> </span><span class="token built-in-types support" style="color:#0184BC">u64</span><span class="token plain">): &amp;</span><span class="token built-in-types support" style="color:#0184BC">u64</span><span class="token plain"> { x }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token function-keyword keyword" style="color:hsl(301, 63%, 40%)">fun</span><span class="token plain"> </span><span class="token function-name function" style="color:hsl(221, 87%, 60%)">expression_examples</span><span class="token plain">() {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> </span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> x = </span><span class="token literals number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain">;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> </span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> y = </span><span class="token literals number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain">;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token function-call function" style="color:hsl(221, 87%, 60%)">takes_immut_returns_immut</span><span class="token plain">(&amp;x); </span><span class="token comment" style="color:#A0A1A7">// no inference</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token function-call function" style="color:hsl(221, 87%, 60%)">takes_immut_returns_immut</span><span class="token plain">(&amp;</span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> x); </span><span class="token comment" style="color:#A0A1A7">// inferred freeze(&amp;mut x)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token function-call function" style="color:hsl(221, 87%, 60%)">takes_mut_returns_immut</span><span class="token plain">(&amp;</span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> x); </span><span class="token comment" style="color:#A0A1A7">// no inference</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token macro-call macro-name support" style="color:#0184BC">assert</span><span class="token macro-call">!</span><span class="token plain">(&amp;x == &amp;</span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> y, </span><span class="token literals number" style="color:hsl(35, 99%, 36%)">42</span><span class="token plain">); </span><span class="token comment" style="color:#A0A1A7">// inferred freeze(&amp;mut y)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token function-keyword keyword" style="color:hsl(301, 63%, 40%)">fun</span><span class="token plain"> </span><span class="token function-name function" style="color:hsl(221, 87%, 60%)">assignment_examples</span><span class="token plain">() {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> x = </span><span class="token literals number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain">;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> y = </span><span class="token literals number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain">;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> </span><span class="token let-statement">imm_ref</span><span class="token plain">: &amp;</span><span class="token built-in-types support" style="color:#0184BC">u64</span><span class="token plain"> = &amp;x;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    imm_ref = &amp;x; </span><span class="token comment" style="color:#A0A1A7">// no inference</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    imm_ref = &amp;</span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> y; </span><span class="token comment" style="color:#A0A1A7">// inferred freeze(&amp;mut y)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_kl3l" id="subtyping">Subtyping<a href="#subtyping" class="hash-link" aria-label="Direct link to Subtyping" title="Direct link to Subtyping">​</a></h3>
<p>With this <span class="inline-code">freeze</span> inference, the Move type checker can view <span class="inline-code">&amp;mut T</span> as a subtype of <span class="inline-code">&amp;T</span>. As shown
above, this means that anywhere for any expression where a <span class="inline-code">&amp;T</span> value is used, a <span class="inline-code">&amp;mut T</span> value can
also be used. This terminology is used in error messages to concisely indicate that a <span class="inline-code">&amp;mut T</span> was
needed where a <span class="inline-code">&amp;T</span> was supplied. For example</p>
<div class="language-move codeBlockContainer_AE_o theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_YOHW"><pre tabindex="0" class="prism-code language-move codeBlock_q9R9 thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_bu_M"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token module-header module-keyword keyword" style="color:hsl(301, 63%, 40%)">module</span><span class="token module-header"> </span><span class="token module-header package-name constant" style="color:hsl(35, 99%, 36%)">a</span><span class="token module-header double-colon punctuation" style="color:hsl(119, 34%, 47%)">::</span><span class="token module-header module-name entity" style="color:#C18401">example</span><span class="token module-header"> {</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token function-keyword keyword" style="color:hsl(301, 63%, 40%)">fun</span><span class="token plain"> </span><span class="token function-name function" style="color:hsl(221, 87%, 60%)">read_and_assign</span><span class="token plain">(</span><span class="token abilities support" style="color:#0184BC">store</span><span class="token plain">: &amp;</span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> </span><span class="token built-in-types support" style="color:#0184BC">u64</span><span class="token plain">, </span><span class="token property-name function-argument struct-property-name">new_value</span><span class="token plain">: &amp;</span><span class="token built-in-types support" style="color:#0184BC">u64</span><span class="token plain">) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        *</span><span class="token abilities support" style="color:#0184BC">store</span><span class="token plain"> = *new_value</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token function-keyword keyword" style="color:hsl(301, 63%, 40%)">fun</span><span class="token plain"> </span><span class="token function-name function" style="color:hsl(221, 87%, 60%)">subtype_examples</span><span class="token plain">() {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> </span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> </span><span class="token let-statement">x</span><span class="token plain">: &amp;</span><span class="token built-in-types support" style="color:#0184BC">u64</span><span class="token plain"> = &amp;</span><span class="token literals number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain">;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> </span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> </span><span class="token let-statement">y</span><span class="token plain">: &amp;</span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> </span><span class="token built-in-types support" style="color:#0184BC">u64</span><span class="token plain"> = &amp;</span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> </span><span class="token literals number" style="color:hsl(35, 99%, 36%)">1</span><span class="token plain">;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        x = &amp;</span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> </span><span class="token literals number" style="color:hsl(35, 99%, 36%)">1</span><span class="token plain">; </span><span class="token comment" style="color:#A0A1A7">// valid</span><span class="token plain"></span><br></span><span class="token-line error-comment" style="color:hsl(230, 8%, 24%)"><span class="token plain">        y = &amp;</span><span class="token literals number" style="color:hsl(35, 99%, 36%)">2</span><span class="token plain">; </span><span class="token comment" style="color:#A0A1A7">// ERROR! invalid!</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token function-call function" style="color:hsl(221, 87%, 60%)">read_and_assign</span><span class="token plain">(y, x); </span><span class="token comment" style="color:#A0A1A7">// valid</span><span class="token plain"></span><br></span><span class="token-line error-comment" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token function-call function" style="color:hsl(221, 87%, 60%)">read_and_assign</span><span class="token plain">(x, y); </span><span class="token comment" style="color:#A0A1A7">// ERROR! invalid!</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>will yield the following error messages</p>
<div class="language-text codeBlockContainer_AE_o theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_YOHW"><pre tabindex="0" class="prism-code language-text codeBlock_q9R9 thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_bu_M"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">error:</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    ┌── example.move:11:9 ───</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    │</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> 12 │         y = &amp;2; // invalid!</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    │         ^ Invalid assignment to local &#x27;y&#x27;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    ·</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> 12 │         y = &amp;2; // invalid!</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    │             -- The type: &#x27;&amp;{integer}&#x27;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    ·</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">  9 │         let mut y: &amp;mut u64 = &amp;mut 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    │                    -------- Is not a subtype of: &#x27;&amp;mut u64&#x27;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    │</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">error:</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    ┌── example.move:14:9 ───</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    │</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> 15 │         read_and_assign(x, y); // invalid!</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    │         ^^^^^^^^^^^^^^^^^^^^^ Invalid call of &#x27;a::example::read_and_assign&#x27;. Invalid argument for parameter &#x27;store&#x27;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    ·</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">  8 │         let mut x: &amp;u64 = &amp;0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    │                    ---- The type: &#x27;&amp;u64&#x27;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    ·</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">  3 │     fun read_and_assign(store: &amp;mut u64, new_value: &amp;u64) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    │                                -------- Is not a subtype of: &#x27;&amp;mut u64&#x27;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    │</span><br></span></code></pre></div></div>
<p>The only other types that currently have subtyping are <a href="/reference/primitive-types/tuples">tuples</a></p>
<h2 class="anchor anchorWithStickyNavbar_kl3l" id="ownership">Ownership<a href="#ownership" class="hash-link" aria-label="Direct link to Ownership" title="Direct link to Ownership">​</a></h2>
<p>Both mutable and immutable references can always be copied and extended <em>even if there are existing
copies or extensions of the same reference</em>:</p>
<div class="language-move codeBlockContainer_AE_o theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_YOHW"><pre tabindex="0" class="prism-code language-move codeBlock_q9R9 thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_bu_M"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token function-keyword keyword" style="color:hsl(301, 63%, 40%)">fun</span><span class="token plain"> </span><span class="token function-name function" style="color:hsl(221, 87%, 60%)">reference_copies</span><span class="token plain">(</span><span class="token property-name function-argument struct-property-name">s</span><span class="token plain">: &amp;</span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> </span><span class="token struct-types entity" style="color:#C18401">S</span><span class="token plain">) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">  </span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> s_copy1 = s; </span><span class="token comment" style="color:#A0A1A7">// ok</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">  </span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> s_extension = &amp;</span><span class="token mut-keyword keyword" style="color:hsl(301, 63%, 40%)">mut</span><span class="token plain"> s.f; </span><span class="token comment" style="color:#A0A1A7">// also ok</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">  </span><span class="token let-keyword keyword" style="color:hsl(301, 63%, 40%)">let</span><span class="token plain"> s_copy2 = s; </span><span class="token comment" style="color:#A0A1A7">// still ok</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>This might be surprising for programmers familiar with Rust&#x27;s ownership system, which would reject
the code above. Move&#x27;s type system is more permissive in its treatment of
<a href="/reference/variables#move-and-copy">copies</a>, but equally strict in ensuring unique ownership of mutable
references before writes.</p>
<h3 class="anchor anchorWithStickyNavbar_kl3l" id="references-cannot-be-stored">References Cannot Be Stored<a href="#references-cannot-be-stored" class="hash-link" aria-label="Direct link to References Cannot Be Stored" title="Direct link to References Cannot Be Stored">​</a></h3>
<p>References and tuples are the <em>only</em> types that cannot be stored as a field value of structs, which
also means that they cannot exist in storage or <a href="/reference/abilities/object">objects</a>. All references
created during program execution will be destroyed when a Move program terminates; they are entirely
ephemeral. This also applies to all types without the <span class="inline-code">store</span> ability: any value of a non-<span class="inline-code">store</span>
type must be destroyed before the program terminates. <a href="/reference/abilities">ability</a>, but note that
references and tuples go a step further by never being allowed in structs in the first place.</p>
<p>This is another difference between Move and Rust, which allows references to be stored inside of
structs.</p>
<p>One could imagine a fancier, more expressive, type system that would allow references to be stored
in structs. We could allow references inside of structs that do not have the <span class="inline-code">store</span>
<a href="/reference/abilities">ability</a>, but the core difficulty is that Move has a fairly complex system for
tracking static reference safety. This aspect of the type system would also have to be extended to
support storing references inside of structs. In short, Move&#x27;s reference safety system would have to
expand to support stored references, and it is something we are keeping an eye on as the language
evolves.</p></div></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/reference/primitive-types/vector"><div class="pagination-nav__label"><i class="fa fa-angle-left"></i><span class="pagination-nav__label">2.4 Vector</span> </div></a><a class="pagination-nav__link pagination-nav__link--next" href="/reference/primitive-types/tuples"><div class="pagination-nav__label"><span class="pagination-nav__label">2.6 Tuples and Unit</span> <i class="fa fa-angle-right"></i></div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_VdoB thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#reference-operators" class="table-of-contents__link toc-highlight">Reference Operators</a></li><li><a href="#reading-and-writing-through-references" class="table-of-contents__link toc-highlight">Reading and Writing Through References</a></li><li><a href="#freeze-inference" class="table-of-contents__link toc-highlight"><code>freeze</code> inference</a><ul><li><a href="#subtyping" class="table-of-contents__link toc-highlight">Subtyping</a></li></ul></li><li><a href="#ownership" class="table-of-contents__link toc-highlight">Ownership</a><ul><li><a href="#references-cannot-be-stored" class="table-of-contents__link toc-highlight">References Cannot Be Stored</a></li></ul></li></ul></div></div></div></div></main></div></div></div></div>
</body>
</html>