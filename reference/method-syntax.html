<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Method Syntax - The Move Reference</title>


        <!-- Custom HTML head -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap" rel="stylesheet">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-B1E7R0BHX4"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-B1E7R0BHX4');
        </script>

        <meta name="description" content="The Move Language Reference maintained by the Move core team.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">The Move Reference</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">1.</strong> Modules</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Concepts</li><li class="chapter-item expanded "><a href="primitive-types.html"><strong aria-hidden="true">2.</strong> Primitive Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitive-types/integers.html"><strong aria-hidden="true">2.1.</strong> Integers</a></li><li class="chapter-item expanded "><a href="primitive-types/bool.html"><strong aria-hidden="true">2.2.</strong> Bool</a></li><li class="chapter-item expanded "><a href="primitive-types/address.html"><strong aria-hidden="true">2.3.</strong> Address</a></li><li class="chapter-item expanded "><a href="primitive-types/vector.html"><strong aria-hidden="true">2.4.</strong> Vector</a></li><li class="chapter-item expanded "><a href="primitive-types/references.html"><strong aria-hidden="true">2.5.</strong> References</a></li><li class="chapter-item expanded "><a href="primitive-types/tuples.html"><strong aria-hidden="true">2.6.</strong> Tuples and Unit</a></li></ol></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">3.</strong> Local Variables and Scopes</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">4.</strong> Equality</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">5.</strong> Abort and Assert</a></li><li class="chapter-item expanded "><a href="control-flow.html"><strong aria-hidden="true">6.</strong> Control Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="control-flow/conditionals.html"><strong aria-hidden="true">6.1.</strong> Conditional Expressions</a></li><li class="chapter-item expanded "><a href="control-flow/loops.html"><strong aria-hidden="true">6.2.</strong> Loops</a></li><li class="chapter-item expanded "><a href="control-flow/labeled-control-flow.html"><strong aria-hidden="true">6.3.</strong> Labeled Control FLow</a></li><li class="chapter-item expanded "><a href="control-flow/pattern-matching.html"><strong aria-hidden="true">6.4.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">7.</strong> Functions</a></li><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">8.</strong> Structs</a></li><li class="chapter-item expanded "><a href="enums.html"><strong aria-hidden="true">9.</strong> Enums</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">10.</strong> Constants</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">11.</strong> Generics</a></li><li class="chapter-item expanded "><a href="abilities.html"><strong aria-hidden="true">12.</strong> Type Abilities</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">13.</strong> Uses and Aliases</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Concepts</li><li class="chapter-item expanded "><a href="method-syntax.html" class="active"><strong aria-hidden="true">14.</strong> Method Syntax</a></li><li class="chapter-item expanded "><a href="index-syntax.html"><strong aria-hidden="true">15.</strong> Index Syntax Methods</a></li><li class="chapter-item expanded affix "><li class="part-title">Tooling</li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">16.</strong> Packages</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">17.</strong> Unit Tests</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">18.</strong> Coding Conventions</a></li><li class="chapter-item expanded affix "><li class="part-title">Deprecated</li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">19.</strong> Friends</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Move Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MystenLabs/move-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/move-language/move/edit/main/language/documentation/book/src/method-syntax.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<p>As a syntactic convenience, some functions in Move can be called as &quot;methods&quot; on a value. This is done
by using the <code>.</code> operator to call the function, where the value on the left-hand side of the <code>.</code> is
the first argument to the function (sometimes called the receiver). The type of that value
statically determines which function is called. This is an important difference from some other
languages, where this syntax might indicate a dynamic call, where the function to be called is
determined at runtime. In Move, all function calls are statically determined.</p>
<p>In short, this syntax exists to make it easier to call functions without having to create an alias
with <code>use</code>, and without having to explicitly borrow the first argument to the function.
Additionally, this can make code more readable, as it reduces the amount of boilerplate needed to
call a function and makes it easier to chain function calls.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>The syntax for calling a method is as follows:</p>
<pre><code class="language-text">&lt;expression&gt; . &lt;identifier&gt; &lt;[type_arguments],*&gt; ( &lt;arguments&gt; )
</code></pre>
<p>For example</p>
<pre><code class="language-move">coin.value();
*nums.borrow_mut(i) = 5;
</code></pre>
<h2 id="method-resolution"><a class="header" href="#method-resolution">Method Resolution</a></h2>
<p>When a method is called, the compiler will statically determine which function is called based on
the type of the receiver (the argument on the left-hand side of the <code>.</code>). The compiler maintains a
mapping from type and method name to the module and function name that should be called. This
mapping is created form the <code>use fun</code> aliases that are currently in scope, and from the appropriate
functions in the receiver type's defining module. In all cases, the receiver type is the first
argument to the function, whether by-value or by-reference.</p>
<p>In this section, when we say a method &quot;resolves&quot; to a function, we mean that the compiler will
statically replace the method with a normal <a href="./functions.html">function</a> call. For example if we have
<code>x.foo(e)</code> with <code>foo</code> resolving to <code>a::m::foo</code>, the compiler will replace <code>x.foo(e)</code> with
<code>a::m::foo(x, e)</code>, potentially <a href="#automatic-borrowing">automatically borrowing</a> <code>x</code>.</p>
<h3 id="functions-in-the-defining-module"><a class="header" href="#functions-in-the-defining-module">Functions in the Defining Module</a></h3>
<p>In a type’s defining module, the compiler will automatically create a method alias for any function
declaration for its types when the type is the first argument in the function. For example,</p>
<pre><code class="language-move">module a::m {
    public struct X() has copy, drop, store;
    public fun foo(x: &amp;X) { ... }
    public fun bar(flag: bool, x: &amp;X) { ... }
}
</code></pre>
<p>The function <code>foo</code> can be called as a method on a value of type <code>X</code>. However, not the first argument
(and one is not created for <code>bool</code> since <code>bool</code> is not defined in that module). For example,</p>
<pre><code class="language-move">fun example(x: a::m::X) {
    x.foo(); // valid
    // x.bar(true); ERROR!
}
</code></pre>
<h3 id="use-fun-aliases"><a class="header" href="#use-fun-aliases"><code>use fun</code> Aliases</a></h3>
<p>Like a traditional <a href="uses.html"><code>use</code></a>, a <code>use fun</code> statement creates an alias local to its current
scope. This could be for the current module or the current expression block. However, the alias is
associated to a type.</p>
<p>The syntax for a <code>use fun</code> statement is as follows:</p>
<pre><code class="language-move">use fun &lt;function&gt; as &lt;type&gt;.&lt;method alias&gt;;
</code></pre>
<p>This creates an alias for the <code>&lt;function&gt;</code>, which the <code>&lt;type&gt;</code> can receive as <code>&lt;method alias&gt;</code>.</p>
<p>For example</p>
<pre><code class="language-move">module a::cup {
    public struct Cup&lt;T&gt;(T) has copy, drop, store;

    public fun cup_borrow&lt;T&gt;(c: &amp;Cup&lt;T&gt;): &amp;T {
        &amp;c.0
    }

    public fun cup_value&lt;T&gt;(c: Cup&lt;T&gt;): T {
        let Cup(t) = c;
        t
    }

    public fun cup_swap&lt;T: drop&gt;(c: &amp;mut Cup&lt;T&gt;, t: T) {
        c.0 = t;
    }
}
</code></pre>
<p>We can now create <code>use fun</code> aliases to these functions</p>
<pre><code class="language-move">module b::example {
    use fun a::cup::cup_borrow as Cup.borrow;
    use fun a::cup::cup_value as Cup.value;
    use fun a::cup::cup_swap as Cup.set;

    fun example(c: &amp;mut Cup&lt;u64&gt;) {
        let _ = c.borrow(); // resolves to a::cup::cup_borrow
        let v = c.value(); // resolves to a::cup::cup_value
        c.set(v * 2); // resolves to a::cup::cup_swap
    }
}
</code></pre>
<p>Note that the <code>&lt;function&gt;</code> in the <code>use fun</code> does not have to be a fully resolved path, and an alias
can be used instead, so the declarations in the above example could equivalently be written as</p>
<pre><code class="language-move">    use a::cup::{Self, cup_swap};

    use fun cup::cup_borrow as Cup.borrow;
    use fun cup::cup_value as Cup.value;
    use fun cup_swap as Cup.set;
</code></pre>
<p>While these examples are cute for renaming the functions in the current module, the feature is
perhaps more useful for declaring methods on types from other modules. For example, if we wanted to
add a new utility to <code>Cup</code>, we could do so with a <code>use fun</code> alias and still use method syntax</p>
<pre><code class="language-move">module b::example {

    fun double(c: &amp;Cup&lt;u64&gt;): Cup&lt;u64&gt; {
        let v = c.value();
        Cup::new(v * 2)
    }

}
</code></pre>
<p>Normally, we would be stuck having to call it as <code>double(&amp;c)</code> because <code>b::example</code> did not define
<code>Cup</code>, but instead we can use a <code>use fun</code> alias</p>
<pre><code class="language-move">    fun double_double(c: Cup&lt;u64&gt;): (Cup&lt;u64&gt;, Cup&lt;u64&gt;) {
        use fun b::example::double as Cup.dub;
        (c.dub(), c.dub()) // resolves to b::example::double in both calls
    }
</code></pre>
<p>While <code>use fun</code> can be made in any scope, the target <code>&lt;function&gt;</code> of the <code>use fun</code> must have a first
argument that is the same as the <code>&lt;type&gt;</code>.</p>
<pre><code class="language-move">public struct X() has copy, drop, store;

fun new(): X { X() }
fun flag(flag: bool): u8 { if (flag) 1 else 0 }

use fun new as X.new; // ERROR!
use fun flag as X.flag; // ERROR!
// Neither `new` nor `flag` has first argument of type `X`
</code></pre>
<p>But any first argument of the <code>&lt;type&gt;</code> can be used, including references and mutable references</p>
<pre><code class="language-move">public struct X() has copy, drop, store;

public fun by_val(_: X) {}
public fun by_ref(_: &amp;X) {}
public fun by_mut(_: &amp;mut X) {}

// All 3 valid, in any scope
use fun by_val as X.v;
use fun by_ref as X.r;
use fun by_mut as X.m;
</code></pre>
<p>Note for generics, the methods are associated for <em>all</em> instances of the generic type. You cannot
overload the method to resolve to different functions depending on the instantiation.</p>
<pre><code class="language-move">public struct Cup&lt;T&gt;(T) has copy, drop, store;

public fun value&lt;T: copy&gt;(c: &amp;Cup&lt;T&gt;): T {
    c.0
}

use fun value as Cup&lt;bool&gt;.flag; // ERROR!
use fun value as Cup&lt;u64&gt;.num; // ERROR!
// In both cases, `use fun` aliases cannot be generic, they must work for all instances of the type
</code></pre>
<h3 id="public-use-fun-aliases"><a class="header" href="#public-use-fun-aliases"><code>public use fun</code> Aliases</a></h3>
<p>Unlike a traditional <a href="uses.html"><code>use</code></a>, the <code>use fun</code> statement can be made <code>public</code>, which allows it
to be used outside of its declared scope. A <code>use fun</code> can be made <code>public</code> if it is declared in the
module that defines the receivers type, much like the method aliases that are
<a href="#functions-in-the-defining-module">automatically created</a> for functions in the defining module. Or
conversely, one can think that an implicit <code>public use fun</code> is created automatically for every
function in the defining module that has a first argument of the receiver type (if it is defined in
that module). Both of these views are equivalent.</p>
<pre><code class="language-move">module a::cup {
    public struct Cup&lt;T&gt;(T) has copy, drop, store;

    public use fun cup_borrow as Cup.borrow;
    public fun cup_borrow&lt;T&gt;(c: &amp;Cup&lt;T&gt;): &amp;T {
        &amp;c.0
    }
}
</code></pre>
<p>In this example, a public method alias is created for <code>a::cup::Cup.borrow</code> and
<code>a::cup::Cup.cup_borrow</code>. Both resolve to <code>a::cup::cup_borrow</code>. And both are &quot;public&quot; in the sense
that they can be used outside of <code>a::cup</code>, without an additional <code>use</code> or <code>use fun</code>.</p>
<pre><code class="language-move">module b::example {

    fun example&lt;T: drop&gt;(c: a::cup::Cup&lt;u64&gt;) {
        c.borrow(); // resolves to a::cup::cup_borrow
        c.cup_borrow(); // resolves to a::cup::cup_borrow
    }
}
</code></pre>
<p>The <code>public use fun</code> declarations thus serve as a way of renaming a function if you want to give it
a cleaner name for use with method syntax. This is especially helpful if you have a module with
multiple types, and similarly named functions for each type.</p>
<pre><code class="language-move">module a::shapes {

    public struct Rectangle { base: u64, height: u64 }
    public struct Box { base: u64, height: u64, depth: u64 }

    // Rectangle and Box can have methods with the same name

    public use fun rectangle_base as Rectangle.base;
    public fun rectangle_base(rectangle: &amp;Rectangle): u64 {
        rectangle.base
    }

    public use fun box_base as Box.base;
    public fun box_base(box: &amp;Box): u64 {
        box.base
    }

}
</code></pre>
<p>Another use for <code>public use fun</code> is adding methods to types from other modules. This can be helpful
in conjunction with functions spread out across a single package.</p>
<pre><code class="language-move">module a::cup {
    public struct Cup&lt;T&gt;(T) has copy, drop, store;

    public fun new&lt;T&gt;(t: T): Cup&lt;T&gt; { Cup(t) }
    public fun borrow&lt;T&gt;(c: &amp;Cup&lt;T&gt;): &amp;T {
        &amp;c.0
    }
    // `public use fun` to a function defined in another module
    public use fun a::utils::split as Cup.split;
}

module a::utils {
    use a::m::{Self, Cup};

    public fun split&lt;u64&gt;(c: Cup&lt;u64&gt;): (Cup&lt;u64&gt;, Cup&lt;u64&gt;) {
        let Cup(t) = c;
        let half = t / 2;
        let rem = if (t &gt; 0) t - half else 0;
        (cup::new(half), cup::new(rem))
    }

}
</code></pre>
<p>And note that this <code>public use fun</code> does not create a circular dependency, as the <code>use fun</code> is not
present after the module is compiled--all methods are resolved statically.</p>
<h3 id="interactions-with-use-aliases"><a class="header" href="#interactions-with-use-aliases">Interactions with <code>use</code> Aliases</a></h3>
<p>A small detail to note is that method aliases respect normal <code>use</code> aliases.</p>
<pre><code class="language-move">module a::cup {
    public struct Cup&lt;T&gt;(T) has copy, drop, store;

    public fun cup_borrow&lt;T&gt;(c: &amp;Cup&lt;T&gt;): &amp;T {
        &amp;c.0
    }
}

module b::other {
    use a::cup::{Cup, cup_borrow as borrow};

    fun example(c: &amp;Cup&lt;u64&gt;) {
        c.borrow(); // resolves to a::cup::cup_borrow
    }
}
</code></pre>
<p>A helpful way to think about this is that <code>use</code> creates an implicit <code>use fun</code> alias for the function
whenever it can. In this case the <code>use a::cup::cup_borrow as borrow</code> creates an implicit
<code>use fun a::cup::cup_borrow as Cup.borrow</code> because it would be a valid <code>use fun</code> alias. Both views
are equivalent. This line of reasoning can inform how specific methods will resolve with shadowing.
See the cases in <a href="#scoping">Scoping</a> for more details.</p>
<h3 id="scoping"><a class="header" href="#scoping">Scoping</a></h3>
<p>If not <code>public</code>, a <code>use fun</code> alias is local to its scope, much like a normal <a href="uses.html"><code>use</code></a>. For
example</p>
<pre><code class="language-move">module a::m {
    public struct X() has copy, drop, store;
    public fun foo(_: &amp;X) {}
    public fun bar(_: &amp;X) {}
}

module b::other {
    use a::m::X;

    use fun a::m::foo as X.f;

    fun example(x: &amp;X) {
        x.f(); // resolves to a::m::foo
        {
            use a::m::bar as f;
            x.f(); // resolves to a::m::bar
        };
        x.f(); // still resolves to a::m::foo
        {
            use fun a::m::bar as X.f;
            x.f(); // resolves to a::m::bar
        }
    }
</code></pre>
<h2 id="automatic-borrowing"><a class="header" href="#automatic-borrowing">Automatic Borrowing</a></h2>
<p>When resolving a method, the compiler will automatically borrow the receiver if the function expects
a reference. For example</p>
<pre><code class="language-move">module a::m {
    public struct X() has copy, drop;
    public fun by_val(_: X) {}
    public fun by_ref(_: &amp;X) {}
    public fun by_mut(_: &amp;mut X) {}

    fun example(mut x: X) {
        x.by_ref(); // resolves to a::m::by_ref(&amp;x)
        x.by_mut(); // resolves to a::m::by_mut(&amp;mut x)
    }
}
</code></pre>
<p>In these examples, <code>x</code> was automatically borrowed to <code>&amp;x</code> and <code>&amp;mut x</code> respectively. This will also
work through field access</p>
<pre><code class="language-move">module a::m {
    public struct X() has copy, drop;
    public fun by_val(_: X) {}
    public fun by_ref(_: &amp;X) {}
    public fun by_mut(_: &amp;mut X) {}

    public struct Y has drop { x: X }

    fun example(mut y: Y) {
        y.x.by_ref(); // resolves to a::m::by_ref(&amp;y.x)
        y.x.by_mut(); // resolves to a::m::by_mut(&amp;mut y.x)
    }
}
</code></pre>
<p>Note that in both examples, the local variable had to be labeled as <a href="./variables.html"><code>mut</code></a> to allow
for the <code>&amp;mut</code> borrow. Without this, there would be an error saying that <code>x</code> (or <code>y</code> in the second
example) is not mutable.</p>
<p>Keep in mind that without a reference, normal rules for variable and field access come into play.
Meaning a value might be moved or copied if it is not borrowed.</p>
<pre><code class="language-move">module a::m {
    public struct X() has copy, drop;
    public fun by_val(_: X) {}
    public fun by_ref(_: &amp;X) {}
    public fun by_mut(_: &amp;mut X) {}

    public struct Y has drop { x: X }
    public fun drop_y(y: Y) { y }

    fun example(y: Y) {
        y.x.by_val(); // copies `y.x` since `by_val` is by-value and `X` has `copy`
        y.drop_y(); // moves `y` since `drop_y` is by-value and `Y` does _not_ have `copy`
    }
}
</code></pre>
<h2 id="chaining"><a class="header" href="#chaining">Chaining</a></h2>
<p>Method calls can be chained, because any expression can be the receiver of the method.</p>
<pre><code class="language-move">module a::shapes {
    public struct Point has copy, drop, store { x: u64, y: u64 }
    public struct Line has copy, drop, store { start: Point, end: Point }

    public fun x(p: &amp;Point): u64 { p.x }
    public fun y(p: &amp;Point): u64 { p.y }

    public fun start(l: &amp;Line): &amp;Point { &amp;l.start }
    public fun end(l: &amp;Line): &amp;Point { &amp;l.end }

}

module b::example {
    use a::shapes::Line;

    public fun x_values(l: Line): (u64, u64) {
        (l.start().x(), l.end().x())
    }

}
</code></pre>
<p>In this example for <code>l.start().x()</code>, the compiler first resolves <code>l.start()</code> to
<code>a::shapes::start(&amp;l)</code>. Then <code>.x()</code> is resolved to <code>a::shapes::x(a::shapes::start(&amp;l))</code>. Similarly
for <code>l.end().x()</code>. Keep in mind, this feature is not &quot;special&quot;--the left-hand side of the <code>.</code> can be
any expression, and the compiler will resolve the method call as normal. We simply draw attention to
this sort of &quot;chaining&quot; because it is a common practice to increase readability.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="uses.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="index-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="uses.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="index-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/switcher.js"></script>


    </div>
    </body>
</html>
