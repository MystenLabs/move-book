<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Structs - The Move Reference</title>


        <!-- Custom HTML head -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap" rel="stylesheet">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-B1E7R0BHX4"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-B1E7R0BHX4');
        </script>

        <meta name="description" content="The Move Language Reference maintained by the Move core team.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">The Move Reference</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">1.</strong> Modules</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Concepts</li><li class="chapter-item expanded "><a href="primitive-types.html"><strong aria-hidden="true">2.</strong> Primitive Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitive-types/integers.html"><strong aria-hidden="true">2.1.</strong> Integers</a></li><li class="chapter-item expanded "><a href="primitive-types/bool.html"><strong aria-hidden="true">2.2.</strong> Bool</a></li><li class="chapter-item expanded "><a href="primitive-types/address.html"><strong aria-hidden="true">2.3.</strong> Address</a></li><li class="chapter-item expanded "><a href="primitive-types/vector.html"><strong aria-hidden="true">2.4.</strong> Vector</a></li><li class="chapter-item expanded "><a href="primitive-types/references.html"><strong aria-hidden="true">2.5.</strong> References</a></li><li class="chapter-item expanded "><a href="primitive-types/tuples.html"><strong aria-hidden="true">2.6.</strong> Tuples and Unit</a></li></ol></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">3.</strong> Local Variables and Scopes</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">4.</strong> Equality</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">5.</strong> Abort and Assert</a></li><li class="chapter-item expanded "><a href="control-flow.html"><strong aria-hidden="true">6.</strong> Control Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="control-flow/conditionals.html"><strong aria-hidden="true">6.1.</strong> Conditional Expressions</a></li><li class="chapter-item expanded "><a href="control-flow/loops.html"><strong aria-hidden="true">6.2.</strong> Loops</a></li><li class="chapter-item expanded "><a href="control-flow/labeled-control-flow.html"><strong aria-hidden="true">6.3.</strong> Labeled Control FLow</a></li><li class="chapter-item expanded "><a href="control-flow/pattern-matching.html"><strong aria-hidden="true">6.4.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">7.</strong> Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functions/macros.html"><strong aria-hidden="true">7.1.</strong> Macro Functions</a></li></ol></li><li class="chapter-item expanded "><a href="structs.html" class="active"><strong aria-hidden="true">8.</strong> Structs</a></li><li class="chapter-item expanded "><a href="enums.html"><strong aria-hidden="true">9.</strong> Enums</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">10.</strong> Constants</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">11.</strong> Generics</a></li><li class="chapter-item expanded "><a href="abilities.html"><strong aria-hidden="true">12.</strong> Type Abilities</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">13.</strong> Uses and Aliases</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Concepts</li><li class="chapter-item expanded "><a href="method-syntax.html"><strong aria-hidden="true">14.</strong> Method Syntax</a></li><li class="chapter-item expanded "><a href="index-syntax.html"><strong aria-hidden="true">15.</strong> Index Syntax Methods</a></li><li class="chapter-item expanded affix "><li class="part-title">Tooling</li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">16.</strong> Packages</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">17.</strong> Unit Tests</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">18.</strong> Coding Conventions</a></li><li class="chapter-item expanded affix "><li class="part-title">Deprecated</li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">19.</strong> Friends</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Move Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MystenLabs/move-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/move-language/move/edit/main/language/documentation/book/src/structs.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="structs-and-resources"><a class="header" href="#structs-and-resources">Structs and Resources</a></h1>
<p>A <em>struct</em> is a user-defined data structure containing typed fields. Structs can store any
non-reference, non-tuple type, including other structs.</p>
<p>Structs can be used to define all &quot;asset&quot; values or unrestricted values, where the operations
performed on those values can be controlled by the struct's <a href="./abilities.html">abilities</a>. By default,
structs are linear and ephemeral. By this we mean that they: cannot be copied, cannot be dropped,
and cannot be stored in storage. This means that all values have to have ownership transferred
(linear) and the values must be dealt with by the end of the program's execution (ephemeral). We can
relax this behavior by giving the struct <a href="./abilities.html">abilities</a> which allow values to be copied
or dropped and also to be stored in storage or to define storage schemas.</p>
<h2 id="defining-structs"><a class="header" href="#defining-structs">Defining Structs</a></h2>
<p>Structs must be defined inside a module, and the struct's fields can either be named or positional:</p>
<pre><code class="language-move">module a::m {
    public struct Foo { x: u64, y: bool }
    public struct Bar {}
    public struct Baz { foo: Foo, }
    //                          ^ note: it is fine to have a trailing comma

    public struct PosFoo(u64, bool)
    public struct PosBar()
    public struct PosBaz(Foo)
}
</code></pre>
<p>Structs cannot be recursive, so the following definitions are invalid:</p>
<pre><code class="language-move">public struct Foo { x: Foo }
//                     ^ ERROR! recursive definition

public struct A { b: B }
public struct B { a: A }
//                   ^ ERROR! recursive definition

public struct D(D)
//              ^ ERROR! recursive definition
</code></pre>
<h3 id="visibility"><a class="header" href="#visibility">Visibility</a></h3>
<p>As you may have noticed, all structs are declared as <code>public</code>. This means that the type of the
struct can be referred to from any other module. However, the fields of the struct, and the ability
to create or destroy the struct, are still internal to the module that defines the struct.</p>
<p>In the future, we plan on adding to declare structs as <code>public(package)</code> or as internal, much like
<a href="./functions.html#visibility">functions</a>.</p>
<h3 id="abilities"><a class="header" href="#abilities">Abilities</a></h3>
<p>As mentioned above: by default, a struct declaration is linear and ephemeral. So to allow the value
to be used in these ways (e.g., copied, dropped, stored in an <a href="./abilities/object.html">object</a>, or
used to define a storable <a href="./abilities/object.html">object</a>), structs can be granted
<a href="./abilities.html">abilities</a> by annotating them with <code>has &lt;ability&gt;</code>:</p>
<pre><code class="language-move">module a::m {
    public struct Foo has copy, drop { x: u64, y: bool }
}
</code></pre>
<p>The ability declaration can occur either before or after the struct's fields. However, only one or
the other can be used, and not both. If declared after the struct's fields, the ability declaration
must be terminated with a semicolon:</p>
<pre><code class="language-move">module a::m {
    public struct PreNamedAbilities has copy, drop { x: u64, y: bool }
    public struct PostNamedAbilities { x: u64, y: bool } has copy, drop;
    public struct PostNamedAbilitiesInvalid { x: u64, y: bool } has copy, drop
    //                                                                        ^ ERROR! missing semicolon

    public struct NamedInvalidAbilities has copy { x: u64, y: bool } has drop;
    //                                                               ^ ERROR! duplicate ability declaration

    public struct PrePositionalAbilities has copy, drop (u64, bool)
    public struct PostPositionalAbilities (u64, bool) has copy, drop;
    public struct PostPositionalAbilitiesInvalid (u64, bool) has copy, drop
    //                                                                     ^ ERROR! missing semicolon
    public struct InvalidAbilities has copy (u64, bool) has drop;
    //                                                  ^ ERROR! duplicate ability declaration
}
</code></pre>
<p>For more details, see the section on
<a href="./abilities.html#annotating-structs-and-enums">annotating a struct's abilities</a>.</p>
<h3 id="naming"><a class="header" href="#naming">Naming</a></h3>
<p>Structs must start with a capital letter <code>A</code> to <code>Z</code>. After the first letter, struct names can
contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<pre><code class="language-move">public struct Foo {}
public struct BAR {}
public struct B_a_z_4_2 {}
public struct P_o_s_Foo()
</code></pre>
<p>This naming restriction of starting with <code>A</code> to <code>Z</code> is in place to give room for future language
features. It may or may not be removed later.</p>
<h2 id="using-structs"><a class="header" href="#using-structs">Using Structs</a></h2>
<h3 id="creating-structs"><a class="header" href="#creating-structs">Creating Structs</a></h3>
<p>Values of a struct type can be created (or &quot;packed&quot;) by indicating the struct name, followed by
value for each field.</p>
<p>For a struct with named fields, the order of the fields does not matter, but the field name needs to
be provided. For a struct with positional fields, the order of the fields must match the order of
the fields in the struct definition, and it must be created using <code>()</code> instead of <code>{}</code> to enclose
the parameters.</p>
<pre><code class="language-move">module a::m {
    public struct Foo has drop { x: u64, y: bool }
    public struct Baz has drop { foo: Foo }
    public struct Positional(u64, bool) has drop;

    fun example() {
        let foo = Foo { x: 0, y: false };
        let baz = Baz { foo: foo };
        // Note: positional struct values are created using parentheses and
        // based on position instead of name.
        let pos = Positional(0, false);
        let pos_invalid = Positional(false, 0);
        //                           ^ ERROR! Fields are out of order and the types don't match.
    }
}
</code></pre>
<p>For structs with named fields, you can use the following shorthand if you have a local variable with
the same name as the field:</p>
<pre><code class="language-move">let baz = Baz { foo: foo };
// is equivalent to
let baz = Baz { foo };
</code></pre>
<p>This is sometimes called &quot;field name punning&quot;.</p>
<h3 id="destroying-structs-via-pattern-matching"><a class="header" href="#destroying-structs-via-pattern-matching">Destroying Structs via Pattern Matching</a></h3>
<p>Struct values can be destroyed by binding or assigning them in patterns using similar syntax to
constructing them.</p>
<pre><code class="language-move">module a::m {
    public struct Foo { x: u64, y: bool }
    public struct Bar(Foo)
    public struct Baz {}
    public struct Qux()

    fun example_destroy_foo() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y: foo_y } = foo;
        //        ^ shorthand for `x: x`

        // two new bindings
        //   x: u64 = 3
        //   foo_y: bool = false
    }

    fun example_destroy_foo_wildcard() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y: _ } = foo;

        // only one new binding since y was bound to a wildcard
        //   x: u64 = 3
    }

    fun example_destroy_foo_assignment() {
        let x: u64;
        let y: bool;
        Foo { x, y } = Foo { x: 3, y: false };

        // mutating existing variables x and y
        //   x = 3, y = false
    }

    fun example_foo_ref() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y } = &amp;foo;

        // two new bindings
        //   x: &amp;u64
        //   y: &amp;bool
    }

    fun example_foo_ref_mut() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y } = &amp;mut foo;

        // two new bindings
        //   x: &amp;mut u64
        //   y: &amp;mut bool
    }

    fun example_destroy_bar() {
        let bar = Bar(Foo { x: 3, y: false });
        let Bar(Foo { x, y }) = bar;
        //            ^ nested pattern

        // two new bindings
        //   x: u64 = 3
        //   y: bool = false
    }

    fun example_destroy_baz() {
        let baz = Baz {};
        let Baz {} = baz;
    }

    fun example_destroy_qux() {
        let qux = Qux();
        let Qux() = qux;
    }
}
</code></pre>
<h3 id="accessing-struct-fields"><a class="header" href="#accessing-struct-fields">Accessing Struct Fields</a></h3>
<p>Fields of a struct can be accessed using the dot operator <code>.</code>.</p>
<p>For structs with named fields, the fields can be accessed by their name:</p>
<pre><code class="language-move">public struct Foo { x: u64, y: bool }
let foo = Foo { x: 3, y: true };
let x = foo.x;  // x == 3
let y = foo.y;  // y == true
</code></pre>
<p>For positional structs, fields can be accessed by their position in the struct definition:</p>
<pre><code class="language-move">public struct PosFoo(u64, bool)
let pos_foo = PosFoo(3, true);
let x = pos_foo.0;  // x == 3
let y = pos_foo.1;  // y == true
</code></pre>
<p>Accessing struct fields without borrowing or copying them is subject to the field's ability
constraints. For more details see the sections on
<a href="#borrowing-structs-and-fields">borrowing structs and fields</a> and
<a href="#reading-and-writing-fields">reading and writing fields</a> for more information.</p>
<h3 id="borrowing-structs-and-fields"><a class="header" href="#borrowing-structs-and-fields">Borrowing Structs and Fields</a></h3>
<p>The <code>&amp;</code> and <code>&amp;mut</code> operator can be used to create references to structs or fields. These examples
include some optional type annotations (e.g., <code>: &amp;Foo</code>) to demonstrate the type of operations.</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let foo_ref: &amp;Foo = &amp;foo;
let y: bool = foo_ref.y;         // reading a field via a reference to the struct
let x_ref: &amp;u64 = &amp;foo.x;        // borrowing a field by extending a reference to the struct

let x_ref_mut: &amp;mut u64 = &amp;mut foo.x;
*x_ref_mut = 42;            // modifying a field via a mutable reference
</code></pre>
<p>It is possible to borrow inner fields of nested structs:</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let bar = Bar(foo);

let x_ref = &amp;bar.0.x;
</code></pre>
<p>You can also borrow a field via a reference to a struct:</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let foo_ref = &amp;foo;
let x_ref = &amp;foo_ref.x;
// this has the same effect as let x_ref = &amp;foo.x
</code></pre>
<h3 id="reading-and-writing-fields"><a class="header" href="#reading-and-writing-fields">Reading and Writing Fields</a></h3>
<p>If you need to read and copy a field's value, you can then dereference the borrowed field:</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let bar = Bar(copy foo);
let x: u64 = *&amp;foo.x;
let y: bool = *&amp;foo.y;
let foo2: Foo = *&amp;bar.0;
</code></pre>
<p>More canonically, the dot operator can be used to read fields of a struct without any borrowing. As
is true with
<a href="./primitive-types/references.html#reading-and-writing-through-references">dereferencing</a>, the field
type must have the <code>copy</code> <a href="./abilities.html">ability</a>.</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let x = foo.x;  // x == 3
let y = foo.y;  // y == true
</code></pre>
<p>Dot operators can be chained to access nested fields:</p>
<pre><code class="language-move">let bar = Bar(Foo { x: 3, y: true });
let x = baz.0.x; // x = 3;
</code></pre>
<p>However, this is not permitted for fields that contain non-primitive types, such a vector or another
struct:</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let bar = Bar(foo);
let foo2: Foo = *&amp;bar.0;
let foo3: Foo = bar.0; // error! must add an explicit copy with *&amp;
</code></pre>
<p>We can mutably borrow a field to a struct to assign it a new value:</p>
<pre><code class="language-move">let mut foo = Foo { x: 3, y: true };
*&amp;mut foo.x = 42;     // foo = Foo { x: 42, y: true }
*&amp;mut foo.y = !foo.y; // foo = Foo { x: 42, y: false }
let mut bar = Bar(foo);               // bar = Bar(Foo { x: 42, y: false })
*&amp;mut bar.0.x = 52;                   // bar = Bar(Foo { x: 52, y: false })
*&amp;mut bar.0 = Foo { x: 62, y: true }; // bar = Bar(Foo { x: 62, y: true })
</code></pre>
<p>Similar to dereferencing, we can instead directly use the dot operator to modify a field. And in
both cases, the field type must have the <code>drop</code> <a href="./abilities.html">ability</a>.</p>
<pre><code class="language-move">let mut foo = Foo { x: 3, y: true };
foo.x = 42;     // foo = Foo { x: 42, y: true }
foo.y = !foo.y; // foo = Foo { x: 42, y: false }
let mut bar = Bar(foo);         // bar = Bar(Foo { x: 42, y: false })
bar.0.x = 52;                   // bar = Bar(Foo { x: 52, y: false })
bar.0 = Foo { x: 62, y: true }; // bar = Bar(Foo { x: 62, y: true })
</code></pre>
<p>The dot syntax for assignment also works via a reference to a struct:</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let foo_ref = &amp;mut foo;
foo_ref.x = foo_ref.x + 1;
</code></pre>
<h2 id="privileged-struct-operations"><a class="header" href="#privileged-struct-operations">Privileged Struct Operations</a></h2>
<p>Most struct operations on a struct type <code>T</code> can only be performed inside the module that declares
<code>T</code>:</p>
<ul>
<li>Struct types can only be created (&quot;packed&quot;), destroyed (&quot;unpacked&quot;) inside the module that defines
the struct.</li>
<li>The fields of a struct are only accessible inside the module that defines the struct.</li>
</ul>
<p>Following these rules, if you want to modify your struct outside the module, you will need to
provide public APIs for them. The end of the chapter contains some examples of this.</p>
<p>However as stated <a href="#visibility">in the visibility section above</a>, struct <em>types</em> are always visible
to another module</p>
<pre><code class="language-move">module a::m {
    public struct Foo has drop { x: u64 }

    public fun new_foo(): Foo {
        Foo { x: 42 }
    }
}

module a::n {
    use a::m::Foo;

    public struct Wrapper has drop {
        foo: Foo
        //   ^ valid the type is public

    }

    fun f1(foo: Foo) {
        let x = foo.x;
        //      ^ ERROR! cannot access fields of `Foo` outside of `a::m`
    }

    fun f2() {
        let foo_wrapper = Wrapper { foo: m::new_foo() };
        //                               ^ valid the function is public
    }
}

</code></pre>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>As mentioned above in <a href="#defining-structs">Defining Structs</a>, structs are by default linear and
ephemeral. This means they cannot be copied or dropped. This property can be very useful when
modeling real world assets like money, as you do not want money to be duplicated or get lost in
circulation.</p>
<pre><code class="language-move">module a::m {
    public struct Foo { x: u64 }

    public fun copying() {
        let foo = Foo { x: 100 };
        let foo_copy = copy foo; // ERROR! 'copy'-ing requires the 'copy' ability
        let foo_ref = &amp;foo;
        let another_copy = *foo_ref // ERROR! dereference requires the 'copy' ability
    }

    public fun destroying_1() {
        let foo = Foo { x: 100 };

        // error! when the function returns, foo still contains a value.
        // This destruction requires the 'drop' ability
    }

    public fun destroying_2(f: &amp;mut Foo) {
        *f = Foo { x: 100 } // error!
                            // destroying the old value via a write requires the 'drop' ability
    }
}
</code></pre>
<p>To fix the example <code>fun destroying_1</code>, you would need to manually &quot;unpack&quot; the value:</p>
<pre><code class="language-move">module a::m {
    public struct Foo { x: u64 }

    public fun destroying_1_fixed() {
        let foo = Foo { x: 100 };
        let Foo { x: _ } = foo;
    }
}
</code></pre>
<p>Recall that you are only able to deconstruct a struct within the module in which it is defined. This
can be leveraged to enforce certain invariants in a system, for example, conservation of money.</p>
<p>If on the other hand, your struct does not represent something valuable, you can add the abilities
<code>copy</code> and <code>drop</code> to get a struct value that might feel more familiar from other programming
languages:</p>
<pre><code class="language-move">module a::m {
    public struct Foo has copy, drop { x: u64 }

    public fun run() {
        let foo = Foo { x: 100 };
        let foo_copy = foo;
        //             ^ this code copies foo,
        //             whereas `let x = move foo` would move foo

        let x = foo.x;            // x = 100
        let x_copy = foo_copy.x;  // x = 100

        // both foo and foo_copy are implicitly discarded when the function returns
    }
}
</code></pre>
<h2 id="storage"><a class="header" href="#storage">Storage</a></h2>
<p>Structs can be used to define storage schemas, but the details are different per deployment of Move.
See the documentation for the <a href="./abilities.html#key"><code>key</code> ability</a> and
<a href="./abilities/object.html">Sui objects</a> for more details.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="functions/macros.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="enums.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="functions/macros.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="enums.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/switcher.js"></script>


    </div>
    </body>
</html>
