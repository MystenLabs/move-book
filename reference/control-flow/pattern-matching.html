<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pattern Matching - The Move Reference</title>


        <!-- Custom HTML head -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap" rel="stylesheet">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-B1E7R0BHX4"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-B1E7R0BHX4');
        </script>

        <meta name="description" content="The Move Language Reference maintained by the Move core team.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/css/custom.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">The Move Reference</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="../modules.html"><strong aria-hidden="true">1.</strong> Modules</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Concepts</li><li class="chapter-item expanded "><a href="../primitive-types.html"><strong aria-hidden="true">2.</strong> Primitive Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../primitive-types/integers.html"><strong aria-hidden="true">2.1.</strong> Integers</a></li><li class="chapter-item expanded "><a href="../primitive-types/bool.html"><strong aria-hidden="true">2.2.</strong> Bool</a></li><li class="chapter-item expanded "><a href="../primitive-types/address.html"><strong aria-hidden="true">2.3.</strong> Address</a></li><li class="chapter-item expanded "><a href="../primitive-types/vector.html"><strong aria-hidden="true">2.4.</strong> Vector</a></li><li class="chapter-item expanded "><a href="../primitive-types/references.html"><strong aria-hidden="true">2.5.</strong> References</a></li><li class="chapter-item expanded "><a href="../primitive-types/tuples.html"><strong aria-hidden="true">2.6.</strong> Tuples and Unit</a></li></ol></li><li class="chapter-item expanded "><a href="../variables.html"><strong aria-hidden="true">3.</strong> Local Variables and Scopes</a></li><li class="chapter-item expanded "><a href="../equality.html"><strong aria-hidden="true">4.</strong> Equality</a></li><li class="chapter-item expanded "><a href="../abort-and-assert.html"><strong aria-hidden="true">5.</strong> Abort and Assert</a></li><li class="chapter-item expanded "><a href="../control-flow.html"><strong aria-hidden="true">6.</strong> Control Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../control-flow/conditionals.html"><strong aria-hidden="true">6.1.</strong> Conditional Expressions</a></li><li class="chapter-item expanded "><a href="../control-flow/loops.html"><strong aria-hidden="true">6.2.</strong> Loops</a></li><li class="chapter-item expanded "><a href="../control-flow/labeled-control-flow.html"><strong aria-hidden="true">6.3.</strong> Labeled Control FLow</a></li><li class="chapter-item expanded "><a href="../control-flow/pattern-matching.html" class="active"><strong aria-hidden="true">6.4.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="../functions.html"><strong aria-hidden="true">7.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../structs.html"><strong aria-hidden="true">8.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../enums.html"><strong aria-hidden="true">9.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../constants.html"><strong aria-hidden="true">10.</strong> Constants</a></li><li class="chapter-item expanded "><a href="../generics.html"><strong aria-hidden="true">11.</strong> Generics</a></li><li class="chapter-item expanded "><a href="../abilities.html"><strong aria-hidden="true">12.</strong> Type Abilities</a></li><li class="chapter-item expanded "><a href="../uses.html"><strong aria-hidden="true">13.</strong> Uses and Aliases</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Concepts</li><li class="chapter-item expanded "><a href="../method-syntax.html"><strong aria-hidden="true">14.</strong> Method Syntax</a></li><li class="chapter-item expanded "><a href="../index-syntax.html"><strong aria-hidden="true">15.</strong> Index Syntax Methods</a></li><li class="chapter-item expanded affix "><li class="part-title">Tooling</li><li class="chapter-item expanded "><a href="../packages.html"><strong aria-hidden="true">16.</strong> Packages</a></li><li class="chapter-item expanded "><a href="../unit-testing.html"><strong aria-hidden="true">17.</strong> Unit Tests</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="../coding-conventions.html"><strong aria-hidden="true">18.</strong> Coding Conventions</a></li><li class="chapter-item expanded affix "><li class="part-title">Deprecated</li><li class="chapter-item expanded "><a href="../friends.html"><strong aria-hidden="true">19.</strong> Friends</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Move Reference</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MystenLabs/move-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/move-language/move/edit/main/language/documentation/book/src/control-flow/pattern-matching.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<p>A <code>match</code> expression is a powerful control structure that allows you to compare a value against a
series of patterns and then execute code based on which pattern matches first. Patterns can be
anything from simple literals to complex, nested struct and enum definitions. As opposed to <code>if</code>
expressions, which change control flow based on a <code>bool</code>-typed test expression, a <code>match</code> expression
operates over a value of any type and selects one of many arms.</p>
<p>A <code>match</code> expression can match Move values as well as mutable or immutable references, binding
sub-patterns accordingly.</p>
<p>For example:</p>
<pre><code class="language-move">fun run(x: u64): u64 {
    match (x) {
        1 =&gt; 2,
        2 =&gt; 3,
        x =&gt; x,
    }
}

run(1); // returns 2
run(2); // returns 3
run(3); // returns 3
run(0); // returns 0
</code></pre>
<h2 id="match-syntax"><a class="header" href="#match-syntax"><code>match</code> Syntax</a></h2>
<p>A <code>match</code> takes an expression and a non-empty series of <em>match arms</em> delimited by commas.</p>
<p>Each match arm consists of a pattern (<code>p</code>), an optional guard (<code>if (g)</code> where <code>g</code> is an expression
of type <code>bool</code>), an arrow (<code>=&gt;</code>), and an arm expression (<code>e</code>) to execute when the pattern matches.
For example,</p>
<pre><code class="language-move">match (expression) {
    pattern1 if (guard_expression) =&gt; expression1,
    pattern2 =&gt; expression2,
    pattern3 =&gt; { expression3, expression4, ... },
}
</code></pre>
<p>Match arms are checked in order from top to bottom, and the first pattern that matches (with a guard
expression, if present, that evaluates to <code>true</code>) will be executed.</p>
<p>Note that the series of match arms within a <code>match</code> must be exhaustive, meaning that every possible
value of the type being matched must be covered by one of the patterns in the <code>match</code>. If the series
of match arms is not exhaustive, the compiler will raise an error.</p>
<h2 id="pattern-syntax"><a class="header" href="#pattern-syntax">Pattern Syntax</a></h2>
<p>A pattern is matched by a value if the value is equal to the pattern, and where variables and
wildcards (e.g., <code>x</code>, <code>y</code>, <code>_</code>, or <code>..</code>) are &quot;equal&quot; to anything.</p>
<p>Patterns are used to match values. Patterns can be</p>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Description</th></tr></thead><tbody>
<tr><td>Literal</td><td>A literal value, such as <code>1</code>, <code>true</code>, <code>@0x1</code></td></tr>
<tr><td>Constant</td><td>A constant value, e.g., <code>MyConstant</code></td></tr>
<tr><td>Variable</td><td>A variable, e.g., <code>x</code>, <code>y</code>, <code>z</code></td></tr>
<tr><td>Wildcard</td><td>A wildcard, e.g., <code>_</code></td></tr>
<tr><td>Constructor</td><td>A constructor pattern, e.g., <code>MyStruct { x, y }</code>, <code>MyEnum::Variant(x)</code></td></tr>
<tr><td>At-pattern</td><td>An at-pattern, e.g., <code>x @ MyEnum::Variant(..)</code></td></tr>
<tr><td>Or-pattern</td><td>An or-pattern, e.g., <code>MyEnum::Variant(..) \| MyEnum::OtherVariant(..)</code></td></tr>
<tr><td>Multi-arity wildcard</td><td>A multi-arity wildcard, e.g., <code>MyEnum::Variant(..)</code></td></tr>
<tr><td>Mutable-binding</td><td>A mutable-binding pattern, e.g., <code>mut x</code></td></tr>
</tbody></table>
</div>
<p>Patterns in Move have the following grammar:</p>
<pre><code class="language-bnf">pattern = &lt;literal&gt;
        | &lt;constant&gt;
        | &lt;variable&gt;
        | _
        | C { &lt;variable&gt; : inner-pattern [&quot;,&quot; &lt;variable&gt; : inner-pattern]* } // where C is a struct or enum variant
        | C ( inner-pattern [&quot;,&quot; inner-pattern]* ... )                       // where C is a struct or enum variant
        | C                                                                  // where C is an enum variant
        | &lt;variable&gt; @ top-level-pattern
        | pattern | pattern
        | mut &lt;variable&gt;
inner-pattern = pattern
              | ..     // multi-arity wildcard
</code></pre>
<p>Some examples of patterns are:</p>
<pre><code class="language-move">// literal pattern
1

// constant pattern
MyConstant

// variable pattern
x

// wildcard pattern
_

// constructor pattern that matches `MyEnum::Variant` with the fields `1` and `true`
MyEnum::Variant(1, true)

// constructor pattern that matches `MyEnum::Variant` with the fields `1` and binds the second field's value to `x`
MyEnum::Variant(1, x)

// multi-arity wildcard pattern that matches multiple fields within the `MyEnum::Variant` variant
MyEnum::Variant(..)

// constructor pattern that matches the `x` field of `MyStruct` and binds the `y` field to `other_variable`
MyStruct { x, y: other_variable }

// at-pattern that matches `MyEnum::Variant` and binds the entire value to `x`
x @ MyEnum::Variant(..)

// or-pattern that matches either `MyEnum::Variant` or `MyEnum::OtherVariant`
MyEnum::Variant(..) | MyEnum::OtherVariant(..)

// same as the above or-pattern, but with explicit wildcards
MyEnum::Variant(_, _) | MyEnum::OtherVariant(_, _)

// or-pattern that matches either `MyEnum::Variant` or `MyEnum::OtherVariant` and binds the u64 field to `x`
MyEnum::Variant(x, _) | MyEnum::OtherVariant(_, x)

// constructor pattern that matches `OtherEnum::V` and if the inner `MyEnum` is `MyEnum::Variant`
OtherEnum::V(MyEnum::Variant(..))
</code></pre>
<h3 id="patterns-and-variables"><a class="header" href="#patterns-and-variables">Patterns and Variables</a></h3>
<p>Patterns that contain variables bind them to the match subject or subject subcomponent being
matched. These variables can then be used either in any match guard expressions, or on the
right-hand side of the match arm. For example:</p>
<pre><code class="language-move">public struct Wrapper(u64)

fun add_under_wrapper_unless_equal(wrapper: Wrapper, x: u64): u64 {
    match (wrapper) {
        Wrapper(y) if (y == x) =&gt; Wrapper(y),
        Wrapper(y) =&gt; y + x,
    }
}
add_under_wrapper_unless_equal(Wrapper(1), 2); // returns Wrapper(3)
add_under_wrapper_unless_equal(Wrapper(2), 3); // returns Wrapper(5)
add_under_wrapper_unless_equal(Wrapper(3), 3); // returns Wrapper(3)
</code></pre>
<h3 id="combining-patterns"><a class="header" href="#combining-patterns">Combining Patterns</a></h3>
<p>Patterns can be nested, but patterns can also be combined using the or operator (<code>|</code>). For example,
<code>p1 | p2</code> succeeds if either pattern <code>p1</code> or <code>p2</code> matches the subject. This pattern can occur
anywhere -- either as a top-level pattern or a sub-pattern within another pattern.</p>
<pre><code class="language-move">public enum MyEnum has drop {
    Variant(u64, bool),
    OtherVariant(bool, u64),
}

fun test_or_pattern(x: u64): u64 {
    match (x) {
        MyEnum::Variant(1 | 2 | 3, true) | MyEnum::OtherVariant(true, 1 | 2 | 3) =&gt; 1,
        MyEnum::Variant(8, true) | MyEnum::OtherVariant(_, 6 | 7) =&gt; 2,
        _ =&gt; 3,
    }
}

test_or_pattern(MyEnum::Variant(3, true)); // returns 1
test_or_pattern(MyEnum::OtherVariant(true, 2)); // returns 1
test_or_pattern(MyEnum::Variant(8, true)); // returns 2
test_or_pattern(MyEnum::OtherVariant(false, 7)); // returns 2
test_or_pattern(MyEnum::OtherVariant(false, 80)); // returns 3
</code></pre>
<h3 id="restrictions-on-some-patterns"><a class="header" href="#restrictions-on-some-patterns">Restrictions on Some Patterns</a></h3>
<p>The <code>mut</code> and <code>..</code> patterns also have specific conditions placed on when, where, and how they can be
used, as detailed in <a href="#limitations-on-specific-patterns">Limitations on Specific Patterns</a>. At a
high level, the <code>mut</code> modifier can only be used on variable patterns, and the <code>..</code> pattern can only
be used once within a constructor pattern -- and not as a top-level pattern.</p>
<p>The following is an <em>invalid</em> usage of the <code>..</code> pattern because it is used as a top-level pattern:</p>
<pre><code class="language-move">match (x) {
    .. =&gt; 1,
    // ERROR: `..` pattern can only be used within a constructor pattern
}

match (x) {
    MyStruct(.., ..) =&gt; 1,
    // ERROR:    ^^  `..` pattern can only be used once within a constructor pattern
}
</code></pre>
<h3 id="pattern-typing"><a class="header" href="#pattern-typing">Pattern Typing</a></h3>
<p>Patterns are not expressions, but they are nevertheless typed. This means that the type of a pattern
must match the type of the value it matches. For example, the pattern <code>1</code> has an integer type, the
pattern <code>MyEnum::Variant(1, true)</code> has type <code>MyEnum</code>, the pattern <code>MyStruct { x, y }</code> has type
<code>MyStruct</code>, and <code>OtherStruct&lt;bool&gt; { x: true, y: 1}</code> has type <code>OtherStruct&lt;bool&gt;</code>. If you try to
match on an expression that differs from the type of the pattern in the match, this will result in a
type error. For example:</p>
<pre><code class="language-move">match (1) {
    // The `true` literal pattern is of type `bool` so this is a type error.
    true =&gt; 1,
    // TYPE ERROR: expected type u64, found bool
    _ =&gt; 2,
}
</code></pre>
<p>Similarly, the following would also result in a type error because <code>MyEnum</code> and <code>MyStruct</code> are
different types:</p>
<pre><code class="language-move">match (MyStruct { x: 0, y: 0 }) {
    MyEnum::Variant(..) =&gt; 1,
    // TYPE ERROR: expected type MyEnum, found MyStruct
}
</code></pre>
<h2 id="matching"><a class="header" href="#matching">Matching</a></h2>
<p>Prior to delving into the specifics of pattern matching and what it means for a value to &quot;match&quot; a
pattern, let's examine a few examples to provide an intuition for the concept.</p>
<pre><code class="language-move">fun test_lit(x: u64): u8 {
    match (x) {
        1 =&gt; 2,
        2 =&gt; 3,
        _ =&gt; 4,
    }
}
test_lit(1); // returns 2
test_lit(2); // returns 3
test_lit(3); // returns 4
test_lit(10); // returns 4

fun test_var(x: u64): u64 {
    match (x) {
        y =&gt; y,
    }
}
test_var(1); // returns 1
test_var(2); // returns 2
test_var(3); // returns 3
...

const MyConstant: u64 = 10;
fun test_constant(x: u64): u64 {
    match (x) {
        MyConstant =&gt; 1,
        _ =&gt; 2,
    }
}
test_constant(MyConstant); // returns 1
test_constant(10); // returns 1
test_constant(20); // returns 2

fun test_or_pattern(x: u64): u64 {
    match (x) {
        1 | 2 | 3 =&gt; 1,
        4 | 5 | 6 =&gt; 2,
        _ =&gt; 3,
    }
}
test_or_pattern(3); // returns 1
test_or_pattern(5); // returns 2
test_or_pattern(70); // returns 3

fun test_or_at_pattern(x: u64): u64 {
    match (x) {
        x @ (1 | 2 | 3) =&gt; x + 1,
        y @ (4 | 5 | 6) =&gt; y + 2,
        z =&gt; z + 3,
    }
}
test_or_pattern(2); // returns 3
test_or_pattern(5); // returns 7
test_or_pattern(70); // returns 73
</code></pre>
<p>The most important thing to note from these examples is that a pattern matches a value if the value
is equal to the pattern, and wildcard/variable patterns match anything. This is true for literals,
variables, and constants. For example, in the <code>test_lit</code> function, the value <code>1</code> matches the pattern
<code>1</code>, the value <code>2</code> matches the pattern <code>2</code>, and the value <code>3</code> matches the wildcard <code>_</code>. Similarly,
in the <code>test_var</code> function, both the value <code>1</code> and the value <code>2</code> matches the pattern <code>y</code>.</p>
<p>A variable <code>x</code> matches (or &quot;equals&quot;) any value, and a wildcard <code>_</code> matches any value (but only one
value). Or-patterns are like a logical OR, where a value matches the pattern if it matches any of
patterns in the or-pattern so <code>p1 | p2 | p3</code> should be read &quot;matches p1, or p2, or p3&quot;.</p>
<h3 id="matching-constructors"><a class="header" href="#matching-constructors">Matching Constructors</a></h3>
<p>Pattern matching includes the concept of constructor patterns. These patterns allow you to inspect
and access deep within both structs and enums, and are one of the most powerful parts of pattern
matching. Constructor patterns, coupled with variable bindings, allow you to match on values by
their structure, and pull out the parts of the value you care about for usage on the right-hand side
of the match arm.</p>
<p>Take the following:</p>
<pre><code class="language-move">fun f(x: MyEnum) {
    match (x) {
        MyEnum::Variant(1, true) =&gt; 1,
        MyEnum::OtherVariant(_, 3) =&gt; 2,
        MyEnum::Variant(..) =&gt; 3,
        MyEnum::OtherVariant(..) =&gt; 4,
}
f(MyEnum::Variant(1, true)); // returns 1
f(MyEnum::Variant(2, true)); // returns 3
f(MyEnum::OtherVariant(false, 3)); // returns 2
f(MyEnum::OtherVariant(true, 3)); // returns 2
f(MyEnum::OtherVariant(true, 2)); // returns 4
</code></pre>
<p>This is saying that &quot;if <code>x</code> is <code>MyEnum::Variant</code> with the fields <code>1</code> and <code>true</code>, then return <code>1</code>. If
it is <code>MyEnum::OtherVariant</code> with any value for the first field, and <code>3</code> for the second, then return
<code>2</code>. If it is <code>MyEnum::Variant</code> with any fields, then return <code>3</code>. Finally, if it is
<code>MyEnum::OtherVariant</code> with any fields, then return <code>4</code>&quot;.</p>
<p>You can also nest patterns. So, if you wanted to match either 1, 2, or 10, instead of just matching
1 in the previous <code>MyEnum::Variant</code>, you could do so with an or-pattern:</p>
<pre><code class="language-move">fun f(x: MyEnum) {
    match (x) {
        MyEnum::Variant(1 | 2 | 10, true) =&gt; 1,
        MyEnum::OtherVariant(_, 3) =&gt; 2,
        MyEnum::Variant(..) =&gt; 3,
        MyEnum::OtherVariant(..) =&gt; 4,
}
f(MyEnum::Variant(1, true)); // returns 1
f(MyEnum::Variant(2, true)); // returns 1
f(MyEnum::Variant(10, true)); // returns 1
f(MyEnum::Variant(10, false)); // returns 3
</code></pre>
<h3 id="ability-constraints"><a class="header" href="#ability-constraints">Ability Constraints</a></h3>
<p>Additionally, match bindings are subject to the same ability restrictions as other aspects of Move.
In particular, the compiler will signal an error if you try to match a value (not-reference) without
<code>drop</code> using a wildcard, as the wildcard expects to drop the value. Similarly, if you bind a
non-<code>drop</code> value using a binder, it must be used in the right-hand side of the match arm. In
addition, if you fully destruct that value, you have unpacked it, matching the semantics of
<a href="../structs.html#destroying-structs-via-pattern-matching">non-<code>drop</code> struct unpacking</a>. See the
<a href="../abilities.html#drop">abilities section on <code>drop</code></a> for more details about the <code>drop</code> capability.</p>
<pre><code class="language-move">public struct NonDrop(u64)

fun drop_nondrop(x: NonDrop) {
    match (x) {
        NonDrop(1) =&gt; 1,
        _ =&gt; 2
        // ERROR: cannot wildcard match on a non-droppable value
    }
}

fun destructure_nondrop(x: NonDrop) {
    match (x) {
        NonDrop(1) =&gt; 1,
        NonDrop(_) =&gt; 2
        // OK!
    }
}

fun use_nondrop(x: NonDrop): NonDrop {
    match (x) {
        NonDrop(1) =&gt; NonDrop(8),
        x =&gt; x
    }
}
</code></pre>
<h2 id="exhaustiveness"><a class="header" href="#exhaustiveness">Exhaustiveness</a></h2>
<p>The <code>match</code> expression in Move must be <em>exhaustive</em>: every possible value of the type being matched
must be covered by one of the patterns in one of the match's arms. If the series of match arms is
not exhaustive, the compiler will raise an error. Note that any arm with a guard expression does not
contribute to match exhaustion, as it might fail to match at runtime.</p>
<p>As an example, a match on a <code>u8</code> is exhaustive only if it matches on <em>every</em> number from 0 to 255
inclusive, unless there is a wildcard or variable pattern present. Similarly, a match on a <code>bool</code>
would need to match on both <code>true</code> and <code>false</code>, unless there is a wildcard or variable pattern
present.</p>
<p>For structs, because there is only one type of constructor for the type, only one constructor needs
to be matched, but the fields within the struct need to be matched exhaustively as well. Conversely,
enums may define multiple variants, and each variant must be matched (including any sub-fields) for
the match to be considered exhaustive.</p>
<p>Because underscores and variables are wildcards that match anything, they count as matching all
values of the type they are matching on in that position. Additionally, the multi-arity wildcard
pattern <code>..</code> can be used to match on multiple values within a struct or enum variant.</p>
<p>To see some examples of <em>non-exhaustive</em> matches, consider the following:</p>
<pre><code class="language-move">public enum MyEnum {
    Variant(u64, bool),
    OtherVariant(bool, u64),
}

public struct Pair&lt;T&gt;(T, T)

fun f(x: MyEnum): u8 {
    match (x) {
        MyEnum::Variant(1, true) =&gt; 1,
        MyEnum::Variant(_, _) =&gt; 1,
        MyEnum::OtherVariant(_, 3) =&gt; 2,
        // ERROR: not exhaustive as the value `MyEnum::OtherVariant(_, 4)` is not matched.
    }
}

fun match_pair_bool(x: Pair&lt;bool&gt;): u8 {
    match (x) {
        Pair(true, true) =&gt; 1,
        Pair(true, false) =&gt; 1,
        Pair(false, false) =&gt; 1,
        // ERROR: not exhaustive as the value `Pair(false, true)` is not matched.
    }
}
</code></pre>
<p>These examples can then be made exhaustive by adding a wildcard pattern to the end of the match arm,
or by fully matching on the remaining values:</p>
<pre><code class="language-move">fun f(x: MyEnum): u8 {
    match (x) {
        MyEnum::Variant(1, true) =&gt; 1,
        MyEnum::Variant(_, _) =&gt; 1,
        MyEnum::OtherVariant(_, 3) =&gt; 2,
        // Now exhaustive since this will match all values of MyEnum::OtherVariant
        MyEnum::OtherVariant(..) =&gt; 2,

    }
}

fun match_pair_bool(x: Pair&lt;bool&gt;): u8 {
    match (x) {
        Pair(true, true) =&gt; 1,
        Pair(true, false) =&gt; 1,
        Pair(false, false) =&gt; 1,
        // Now exhaustive since this will match all values of Pair&lt;bool&gt;
        Pair(false, true) =&gt; 1,
    }
}
</code></pre>
<h2 id="guards"><a class="header" href="#guards">Guards</a></h2>
<p>As previously mentioned, you can add a guard to a match arm by adding an <code>if</code> clause after the
pattern. This guard will run <em>after</em> the pattern has been matched but <em>before</em> the expression on the
right hand side of the arrow is evaluated. If the guard expression evaluates to <code>true</code> then the
expression on the right hand side of the arrow will be evaluated, if it evaluates to <code>false</code> then it
will be considered a failed match and the next match arm in the <code>match</code> expression will be checked.</p>
<pre><code class="language-move">fun match_with_guard(x: u64): u64 {
    match (x) {
        1 if (false) =&gt; 1,
        1 =&gt; 2,
        _ =&gt; 3,
    }
}

match_with_guard(1); // returns 2
match_with_guard(0); // returns 3
</code></pre>
<p>Guard expressions can reference variables bound in the pattern during evaluation. However, note that
<em>variables are only available as immutable reference in guards</em> regardless of the pattern being
matched -- even if there are mutability specifiers on the variable or if the pattern is being
matched by value.</p>
<pre><code class="language-move">fun incr(x: &amp;mut u64) {
    *x = *x + 1;
}

fun match_with_guard_incr(x: u64): u64 {
    match (x) {
        x if ({ incr(&amp;mut x); x == 1 }) =&gt; 1,
        // ERROR:    ^^^ invalid borrow of immutable value
        _ =&gt; 2,
    }
}

fun match_with_guard_incr2(x: &amp;mut u64): u64 {
    match (x) {
        x if ({ incr(&amp;mut x); x == 1 }) =&gt; 1,
        // ERROR:    ^^^ invalid borrow of immutable value
        _ =&gt; 2,
    }
}
</code></pre>
<p>Additionally, it is important to note any match arms that have guard expressions will not be
considered either for exhaustivity purposes because the compiler has no way of evaluating the guard
expression statically.</p>
<h2 id="limitations-on-specific-patterns"><a class="header" href="#limitations-on-specific-patterns">Limitations on Specific Patterns</a></h2>
<p>There are some restrictions on when the <code>..</code> and <code>mut</code> pattern modifiers can be used in a pattern.</p>
<h3 id="mutability-usage"><a class="header" href="#mutability-usage">Mutability Usage</a></h3>
<p>A <code>mut</code> modifier can be placed on a variable pattern to specify that the <em>variable</em> is to be mutated
in the right-hand expression of the match arm. Note that since the <code>mut</code> modifier only signifies
that the variable is to be mutated, not the underlying data, this can be used on all types of match
(by value, immutable reference, and mutable reference).</p>
<p>Note that the <code>mut</code> modifier can only be applied to variables, and not other types of patterns.</p>
<pre><code class="language-move">public struct MyStruct(u64)

fun top_level_mut(x: MyStruct) {
    match (x) {
        mut MyStruct(y) =&gt; 1,
        // ERROR: cannot use mut on a non-variable pattern
    }
}

fun mut_on_immut(x: &amp;MyStruct): u64 {
    match (x) {
        MyStruct(mut y) =&gt; {
            y = &amp;(*y + 1);
            *y
        }
    }
}

fun mut_on_value(x: MyStruct): u64 {
    match (x) {
        MyStruct(mut y) =&gt;  {
            *y = *y + 1;
            *y
        },
    }
}

fun mut_on_mut(x: &amp;mut MyStruct): u64 {
    match (x) {
        MyStruct(mut y) =&gt;  {
            *y = *y + 1;
            *y
        },
    }
}

let mut x = MyStruct(1);

mut_on_mut(&amp;mut x); // returns 2
x.0; // returns 2

mut_on_immut(&amp;x); // returns 3
x.0; // returns 2

mut_on_value(x); // returns 3
</code></pre>
<h3 id="-usage"><a class="header" href="#-usage"><code>..</code> Usage</a></h3>
<p>The <code>..</code> pattern can only be used within a constructor pattern as a wildcard that matches any number
of fields -- the<br />
the compiler expands the <code>..</code> to inserting <code>_</code> in any missing fields in the constructor pattern (if
any). So <code>MyStruct(_, _, _)</code> is the same as <code>MyStruct(..)</code>, <code>MyStruct(1, _, _)</code> is the same as
<code>MyStruct(1, ..)</code>. Because of this, there are some restrictions on how, and where the <code>..</code> pattern
can be used:</p>
<ul>
<li>It can only be used <strong>once</strong> within the constructor pattern;</li>
<li>In positional arguments it can be used at the beginning, middle, or end of the patterns within the
constructor;</li>
<li>In named arguments it can only be used at the end of the patterns within the constructor;</li>
</ul>
<pre><code class="language-move">public struct MyStruct(u64, u64, u64, u64) has drop;

public struct MyStruct2 {
    x: u64,
    y: u64,
    z: u64,
    w: u64,
}

fun wild_match(x: MyStruct) {
    match (x) {
        MyStruct(.., 1) =&gt; 1,
        // OK! The `..` pattern can be used at the begining of the constructor pattern
        MyStruct(1, ..) =&gt; 2,
        // OK! The `..` pattern can be used at the end of the constructor pattern
        MyStruct(1, .., 1) =&gt; 3,
        // OK! The `..` pattern can be used at the middle of the constructor pattern
        MyStruct(1, .., 1, 1) =&gt; 4,
        MyStruct(..) =&gt; 5,
    }
}

fun wild_match2(x: MyStruct2) {
    match (x) {
        MyStruct2 { x: 1, .. } =&gt; 1,
        MyStruct2 { x: 1, w: 2 .. } =&gt; 2,
        MyStruct2 { .. } =&gt; 3,
    }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../control-flow/labeled-control-flow.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../control-flow/labeled-control-flow.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/switcher.js"></script>


    </div>
    </body>
</html>
