<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Enums - The Move Reference</title>


        <!-- Custom HTML head -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap" rel="stylesheet">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-B1E7R0BHX4"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-B1E7R0BHX4');
        </script>

        <meta name="description" content="The Move Language Reference maintained by the Move core team.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">The Move Reference</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">1.</strong> Modules</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Concepts</li><li class="chapter-item expanded "><a href="primitive-types.html"><strong aria-hidden="true">2.</strong> Primitive Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitive-types/integers.html"><strong aria-hidden="true">2.1.</strong> Integers</a></li><li class="chapter-item expanded "><a href="primitive-types/bool.html"><strong aria-hidden="true">2.2.</strong> Bool</a></li><li class="chapter-item expanded "><a href="primitive-types/address.html"><strong aria-hidden="true">2.3.</strong> Address</a></li><li class="chapter-item expanded "><a href="primitive-types/vector.html"><strong aria-hidden="true">2.4.</strong> Vector</a></li><li class="chapter-item expanded "><a href="primitive-types/references.html"><strong aria-hidden="true">2.5.</strong> References</a></li><li class="chapter-item expanded "><a href="primitive-types/tuples.html"><strong aria-hidden="true">2.6.</strong> Tuples and Unit</a></li></ol></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">3.</strong> Local Variables and Scopes</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">4.</strong> Equality</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">5.</strong> Abort and Assert</a></li><li class="chapter-item expanded "><a href="control-flow.html"><strong aria-hidden="true">6.</strong> Control Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="control-flow/conditionals.html"><strong aria-hidden="true">6.1.</strong> Conditional Expressions</a></li><li class="chapter-item expanded "><a href="control-flow/loops.html"><strong aria-hidden="true">6.2.</strong> Loops</a></li><li class="chapter-item expanded "><a href="control-flow/labeled-control-flow.html"><strong aria-hidden="true">6.3.</strong> Labeled Control FLow</a></li><li class="chapter-item expanded "><a href="control-flow/pattern-matching.html"><strong aria-hidden="true">6.4.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">7.</strong> Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functions/macros.html"><strong aria-hidden="true">7.1.</strong> Macro Functions</a></li></ol></li><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">8.</strong> Structs</a></li><li class="chapter-item expanded "><a href="enums.html" class="active"><strong aria-hidden="true">9.</strong> Enums</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">10.</strong> Constants</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">11.</strong> Generics</a></li><li class="chapter-item expanded "><a href="abilities.html"><strong aria-hidden="true">12.</strong> Type Abilities</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">13.</strong> Uses and Aliases</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Concepts</li><li class="chapter-item expanded "><a href="method-syntax.html"><strong aria-hidden="true">14.</strong> Method Syntax</a></li><li class="chapter-item expanded "><a href="index-syntax.html"><strong aria-hidden="true">15.</strong> Index Syntax Methods</a></li><li class="chapter-item expanded affix "><li class="part-title">Tooling</li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">16.</strong> Packages</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">17.</strong> Unit Tests</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">18.</strong> Coding Conventions</a></li><li class="chapter-item expanded affix "><li class="part-title">Deprecated</li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">19.</strong> Friends</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Move Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MystenLabs/move-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/move-language/move/edit/main/language/documentation/book/src/enums.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="enumerations"><a class="header" href="#enumerations">Enumerations</a></h1>
<p>An <em>enum</em> is a user-defined data structure containing one or more <em>variants</em>. Each variant can
optionally contain typed fields. The number, and types of these fields can differ for each variant
in the enumeration. Fields in enums can store any non-reference, non-tuple type, including other
structs or enums.</p>
<p>As a simple example, consider the following enum definition in Move:</p>
<pre><code class="language-move">public enum Action {
    Stop,
    Pause { duration: u32 },
    MoveTo { x: u64, y: u64 },
    Jump(u64),
}
</code></pre>
<p>This declares an enum <code>Action</code> that represents different actions that can be taken by a game -- you
can <code>Stop</code>, <code>Pause</code> for a given duration, <code>MoveTo</code> a specific location, or <code>Jump</code> to a specific
height.</p>
<p>Similar to structs, enums can have <a href="./abilities.html">abilities</a> that control what operations can be
performed on them. It is important to note however that enums cannot have the <code>key</code> ability since
they cannot be top-level objects.</p>
<h2 id="defining-enums"><a class="header" href="#defining-enums">Defining Enums</a></h2>
<p>Enums must be defined in a module, an enum must contain at least one variant, and each variant of an
enum can either have no fields, positional fields, or named fields. Here are some examples of each:</p>
<pre><code class="language-move">module a::m {
    public enum Foo has drop {
        VariantWithNoFields,
        //                 ^ note: it is fine to have a trailing comma after variant declarations
    }
    public enum Bar has copy, drop {
        VariantWithPositionalFields(u64, bool),
    }
    public enum Baz has drop {
        VariantWithNamedFields { x: u64, y: bool, z: Bar },
    }
}
</code></pre>
<p>Enums cannot be recursive in any of their variants, so the following definitions of an enum are not
allowed because they would be recursive in at least one variant.</p>
<p>Incorrect:</p>
<pre><code class="language-move">module a::m {
    public enum Foo {
        Recursive(Foo),
        //        ^ error: recursive enum variant
    }
    public enum List {
        Nil,
        Cons { head: u64, tail: List },
        //                      ^ error: recursive enum variant
    }
    public enum BTree&lt;T&gt; {
        Leaf(T),
        Node { left: BTree&lt;T&gt;, right: BTree&lt;T&gt; },
        //           ^ error: recursive enum variant
    }

    // Mutually recursive enums are also not allowed
    public enum MutuallyRecursiveA {
        Base,
        Other(MutuallyRecursiveB),
        //    ^^^^^^^^^^^^^^^^^^ error: recursive enum variant
    }

    public enum MutuallyRecursiveB {
        Base,
        Other(MutuallyRecursiveA),
        //    ^^^^^^^^^^^^^^^^^^ error: recursive enum variant
    }
}
</code></pre>
<h2 id="visibility"><a class="header" href="#visibility">Visibility</a></h2>
<p>All enums are declared as <code>public</code>. This means that the type of the enum can be referred to from any
other module. However, the variants of the enum, the fields within each variant, and the ability to
create or destroy variants of the enum are internal to the module that defines the enum.</p>
<h3 id="abilities"><a class="header" href="#abilities">Abilities</a></h3>
<p>Just like with structs, by default an enum declaration is linear and ephemeral. To use an enum value
in a non-linear or non-ephemeral way -- i.e., copied, dropped, or stored in an
<a href="./abilities/object.html">object</a> -- you need to grant it additional <a href="./abilities.html">abilities</a> by
annotating them with <code>has &lt;ability&gt;</code>:</p>
<pre><code class="language-move">module a::m {
    public enum Foo has copy, drop {
        VariantWithNoFields,
    }
}
</code></pre>
<p>The ability declaration can occur either before or after the enum's variants, however only one or
the other can be used, and not both. If declared after the variants, the ability declaration must be
terminated with a semicolon:</p>
<pre><code class="language-move">module a::m {
    public enum PreNamedAbilities has copy, drop { Variant }
    public enum PostNamedAbilities { Variant } has copy, drop;
    public enum PostNamedAbilitiesInvalid { Variant } has copy, drop
    //                                                              ^ ERROR! missing semicolon

    public enum NamedInvalidAbilities has copy { Variant } has drop;
    //                                                     ^ ERROR! duplicate ability declaration
}
</code></pre>
<p>For more details, see the section on
<a href="./abilities.html#annotating-structs-and-enums">annotating abilities</a>.</p>
<h2 id="naming"><a class="header" href="#naming">Naming</a></h2>
<p>Enums and variants within enums must start with a capital letter <code>A</code> to <code>Z</code>. After the first letter,
enum names can contain underscores <code>_</code>, lowercase letters <code>a</code> to <code>z</code>, uppercase letters <code>A</code> to <code>Z</code>,
or digits <code>0</code> to <code>9</code>.</p>
<pre><code class="language-move">public enum Foo { Variant }
public enum BAR { Variant }
public enum B_a_z_4_2 { V_a_riant_0 }
</code></pre>
<p>This naming restriction of starting with <code>A</code> to <code>Z</code> is in place to give room for future language
features.</p>
<h2 id="using-enums"><a class="header" href="#using-enums">Using Enums</a></h2>
<h3 id="creating-enum-variants"><a class="header" href="#creating-enum-variants">Creating Enum Variants</a></h3>
<p>Values of an enum type can be created (or &quot;packed&quot;) by indicating a variant of the enum, followed by
a value for each field in the variant. The variant name must always be qualified by the enum's name.</p>
<p>Similarly to structs, for a variant with named fields, the order of the fields does not matter but
the field names need to be provided. For a variant with positional fields, the order of the fields
matters and the order of the fields must match the order in the variant declaration. It must also be
created using <code>()</code> instead of <code>{}</code>. If the variant has no fields, the variant name is sufficient and
no <code>()</code> or <code>{}</code> needs to be used.</p>
<pre><code class="language-move">module a::m {
    public enum Action has drop {
        Stop,
        Pause { duration: u32 },
        MoveTo { x: u64, y: u64 },
        Jump(u64),
    }
    public enum Other has drop {
        Stop(u64),
    }

    fun example() {
        // Note: The `Stop` variant of `Action` doesn't have fields so no parentheses or curlies are needed.
        let stop = Action::Stop;
        let pause = Action::Pause { duration: 10 };
        let move_to = Action::MoveTo { x: 10, y: 20 };
        let jump = Action::Jump(10);
        // Note: The `Stop` variant of `Other` does have positional fields so we need to supply them.
        let other_stop = Other::Stop(10);
    }
}
</code></pre>
<p>For variants with named fields you can also use the shorthand syntax that you might be familiar with
from structs to create the variant:</p>
<pre><code class="language-move">let duration = 10;

let pause = Action::Pause { duration: duration };
// is equivalent to
let pause = Action::Pause { duration };
</code></pre>
<h3 id="pattern-matching-enum-variants-and-destructuring"><a class="header" href="#pattern-matching-enum-variants-and-destructuring">Pattern Matching Enum Variants and Destructuring</a></h3>
<p>Since enum values can take on different shapes, dot access to fields of variants is not allowed like
it is for struct fields. Instead, to access fields within a variant -- either by value, or immutable
or mutable reference -- you must use pattern matching.</p>
<p>You can pattern match on Move values by value, immutable reference, and mutable reference. When
pattern matching by value, the value is moved into the match arm. When pattern matching by
reference, the value is borrowed into the match arm (either immutably or mutably). We'll go through
a brief description of pattern matching using <code>match</code> here, but for more information on pattern
matching using <code>match</code> in Move see the <a href="./control-flow/pattern-matching.html">Pattern Matching</a>
section.</p>
<p>A <code>match</code> statement is used to pattern match on a Move value and consists of a number of <em>match
arms</em>. Each match arm consists of a pattern, an arrow <code>=&gt;</code>, and an expression, followed by a comma
<code>,</code>. The pattern can be a struct, enum variant, binding (<code>x</code>, <code>y</code>), wildcard (<code>_</code> or <code>..</code>), constant
(<code>ConstValue</code>), or literal value (<code>true</code>, <code>42</code>, and so on). The value is matched against each
pattern from the top-down, and will match the first pattern that structurally matches the value.
Once the value is matched, the expression on the right hand side of the <code>=&gt;</code> is executed.</p>
<p>Additionally, match arms can have optional <em>guards</em> that are checked after the pattern matches but
<em>before</em> the expression is executed. Guards are specified by the <code>if</code> keyword followed by an
expression that must evaluate to a boolean value before the <code>=&gt;</code>.</p>
<pre><code class="language-move">module a::m {
    public enum Action has drop {
        Stop,
        Pause { duration: u32 },
        MoveTo { x: u64, y: u64 },
        Jump(u64),
    }

    public struct GameState {
        // Fields containing a game state
        character_x: u64,
        character_y: u64,
        character_height: u64,
        // ...
    }

    fun perform_action(stat: &amp;mut GameState, action: Action) {
        match (action) {
            // Handle the `Stop` variant
            Action::Stop =&gt; state.stop(),
            // Handle the `Pause` variant
            // If the duration is 0, do nothing
            Action::Pause { duration: 0 } =&gt; (),
            Action::Pause { duration } =&gt; state.pause(duration),
            // Handle the `MoveTo` variant
            Action::MoveTo { x, y } =&gt; state.move_to(x, y),
            // Handle the `Jump` variant
            // if the game disallows jumps then do nothing
            Action::Jump(_) if (state.jumps_not_allowed()) =&gt; (),
            // otherwise, jump to the specified height
            Action::Jump(height) =&gt; state.jump(height),
        }
    }
}

</code></pre>
<p>To see how to pattern match on an enum to update values within it mutably, let's take the following
example of a simple enum that has two variants, each with a single field. We can then write two
functions, one that only increments the value of the first variant, and another that only increments
the value of the second variant:</p>
<pre><code class="language-move">module a::m {
    public enum SimpleEnum {
        Variant1(u64),
        Variant2(u64),
    }

    public fun incr_enum_variant1(simple_enum: &amp;mut SimpleEnum) {
        match (simple_enum) {
            SimpleEnum::Variant1(mut value) =&gt; *value += 1,
            _ =&gt; (),
        }
    }

    public fun incr_enum_variant2(simple_enum: &amp;mut SimpleEnum) {
        match (simple_enum) {
            SimpleEnum::Variant2(mut value) =&gt; *value += 1,
            _ =&gt; (),
        }
    }
}

</code></pre>
<p>Now, if we have a value of <code>SimpleEnum</code> we can use the functions to increment the value of this
variant:</p>
<pre><code class="language-move">let mut x = SimpleEnum::Variant1(10);
incr_enum_variant1(&amp;mut x);
assert!(x == SimpleEnum::Variant1(11));
// Doesn't increment since it increments a different variant
incr_enum_variant2(&amp;mut x);
assert!(x == SimpleEnum::Variant1(11));
</code></pre>
<p>When pattern matching on a Move value that does not have the <code>drop</code> ability, the value must be
consumed or destructured in each match arm. If the value is not consumed or destructured in a match
arm, the compiler will raise an error. This is to ensure that all possible values are handled in the
match statement.</p>
<p>As an example, consider the following code:</p>
<pre><code class="language-move">module a::m {
    public enum X { Variant { x: u64 } }

    public fun bad(x: X) {
        match (x) {
            _ =&gt; (),
           // ^ ERROR! value of type `X` is not consumed or destructured in this match arm
        }
    }
}
</code></pre>
<p>To properly handle this, you will need to destructure <code>X</code> and all its variants in the match's
arm(s):</p>
<pre><code class="language-move">module a::m {
    public enum X { Variant { x: u64 } }

    public fun good(x: X) {
        match (x) {
            // OK! Compiles since the value is destructured
            X::Variant { x: _ } =&gt; (),
        }
    }
}
</code></pre>
<h3 id="overwriting-to-enum-values"><a class="header" href="#overwriting-to-enum-values">Overwriting to Enum Values</a></h3>
<p>As long as the enum has the <code>drop</code> ability, you can overwrite the value of an enum with a new value
of the same type just as you might with other values in Move.</p>
<pre><code class="language-move">module a::m {
    public enum X has drop {
        A(u64),
        B(u64),
    }

    public fun overwrite_enum(x: &amp;mut X) {
        *x = X::A(10);
    }
}
</code></pre>
<pre><code class="language-move">let mut x = X::B(20);
overwrite_enum(&amp;mut x);
assert!(x == X::A(10));
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="constants.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="constants.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/switcher.js"></script>


    </div>
    </body>
</html>
