<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Index Syntax Methods - The Move Reference</title>


        <!-- Custom HTML head -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap" rel="stylesheet">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-B1E7R0BHX4"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-B1E7R0BHX4');
        </script>

        <meta name="description" content="The Move Language Reference maintained by the Move core team.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">The Move Reference</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">1.</strong> Modules</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Concepts</li><li class="chapter-item expanded "><a href="primitive-types.html"><strong aria-hidden="true">2.</strong> Primitive Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitive-types/integers.html"><strong aria-hidden="true">2.1.</strong> Integers</a></li><li class="chapter-item expanded "><a href="primitive-types/bool.html"><strong aria-hidden="true">2.2.</strong> Bool</a></li><li class="chapter-item expanded "><a href="primitive-types/address.html"><strong aria-hidden="true">2.3.</strong> Address</a></li><li class="chapter-item expanded "><a href="primitive-types/vector.html"><strong aria-hidden="true">2.4.</strong> Vector</a></li><li class="chapter-item expanded "><a href="primitive-types/references.html"><strong aria-hidden="true">2.5.</strong> References</a></li><li class="chapter-item expanded "><a href="primitive-types/tuples.html"><strong aria-hidden="true">2.6.</strong> Tuples and Unit</a></li></ol></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">3.</strong> Local Variables and Scopes</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">4.</strong> Equality</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">5.</strong> Abort and Assert</a></li><li class="chapter-item expanded "><a href="control-flow.html"><strong aria-hidden="true">6.</strong> Control Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="control-flow/conditionals.html"><strong aria-hidden="true">6.1.</strong> Conditional Expressions</a></li><li class="chapter-item expanded "><a href="control-flow/loops.html"><strong aria-hidden="true">6.2.</strong> Loops</a></li><li class="chapter-item expanded "><a href="control-flow/labeled-control-flow.html"><strong aria-hidden="true">6.3.</strong> Labeled Control FLow</a></li><li class="chapter-item expanded "><a href="control-flow/pattern-matching.html"><strong aria-hidden="true">6.4.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">7.</strong> Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functions/macros.html"><strong aria-hidden="true">7.1.</strong> Macro Functions</a></li></ol></li><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">8.</strong> Structs</a></li><li class="chapter-item expanded "><a href="enums.html"><strong aria-hidden="true">9.</strong> Enums</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">10.</strong> Constants</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">11.</strong> Generics</a></li><li class="chapter-item expanded "><a href="abilities.html"><strong aria-hidden="true">12.</strong> Type Abilities</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">13.</strong> Uses and Aliases</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Concepts</li><li class="chapter-item expanded "><a href="method-syntax.html"><strong aria-hidden="true">14.</strong> Method Syntax</a></li><li class="chapter-item expanded "><a href="index-syntax.html" class="active"><strong aria-hidden="true">15.</strong> Index Syntax Methods</a></li><li class="chapter-item expanded affix "><li class="part-title">Tooling</li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">16.</strong> Packages</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">17.</strong> Unit Tests</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">18.</strong> Coding Conventions</a></li><li class="chapter-item expanded affix "><li class="part-title">Deprecated</li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">19.</strong> Friends</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Move Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MystenLabs/move-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/move-language/move/edit/main/language/documentation/book/src/index-syntax.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="index-syntax"><a class="header" href="#index-syntax">Index Syntax</a></h1>
<p>Move provides syntax attributes to allow you to define operations that look and feel like native
Move code, lowering these operations into your user-provided definitions.</p>
<p>Our first syntax method, <code>index</code>, allows you to define a group of operations that can be used as
custom index accessors for your datatypes, such as accessing a matrix element as <code>m[i,j]</code>, by
annotating functions that should be used for these index operations. Moreover, these definitions are
bespoke per-type and available implicitly for any programmer using your type.</p>
<h2 id="overview-and-summary"><a class="header" href="#overview-and-summary">Overview and Summary</a></h2>
<p>To start, consider a <code>Matrix</code> type that uses a vector of vectors to represent its values. You can
write a small library using <code>index</code> syntax annotations on the <code>borrow</code> and <code>borrow_mut</code> functions as
follows:</p>
<pre><code class="language-move">module matrix {

    public struct Matrix&lt;T&gt; { v: vector&lt;vector&lt;T&gt;&gt; }

    #[syntax(index)]
    public fun borrow&lt;T&gt;(s: &amp;Matrix&lt;T&gt;, i: u64, j: u64): &amp;T {
        vector::borrow(vector::borrow(&amp;s.v, i), j)
    }

    #[syntax(index)]
    public fun borrow_mut&lt;T&gt;(s: &amp;mut Matrix&lt;T&gt;, i: u64, j: u64): &amp;mut T {
        vector::borrow_mut(vector::borrow_mut(&amp;mut s.v, i), j)
    }

    public fun make_matrix&lt;T&gt;(v: vector&lt;vector&lt;T&gt;&gt;):  Matrix&lt;T&gt; {
        Matrix { v }
    }

}
</code></pre>
<p>Now anyone using this <code>Matrix</code> type has access to index syntax for it:</p>
<pre><code class="language-move">let mut m = matrix::make_matrix(vector[
    vector[1, 0, 0],
    vector[0, 1, 0],
    vector[0, 0, 1],
]);

let mut i = 0;
while (i &lt; 3) {
    let mut j = 0;
    while (j &lt; 3) {
        if (i == j) {
            assert!(m[i, j] == 1, 1);
        } else {
            assert!(m[i, j] == 0, 0);
        };
        *(&amp;mut m[i,j]) = 2;
        j = j + 1;
    };
    i = i + 1;
}
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>As the example indicates, if you define a datatype and an associated index syntax method, anyone can
invoke that method by writing index syntax on a value of that type:</p>
<pre><code class="language-move">let mat = matrix::make_matrix(...);
let m_0_0 = mat[0, 0];
</code></pre>
<p>During compilation, the compiler translates these into the appropriate function invocations based on
the position and mutable usage of the expression:</p>
<pre><code class="language-move">let mut mat = matrix::make_matrix(...);

let m_0_0 = mat[0, 0];
// translates to `copy matrix::borrow(&amp;mat, 0, 0)`

let m_0_0 = &amp;mat[0, 0];
// translates to `matrix::borrow(&amp;mat, 0, 0)`

let m_0_0 = &amp;mut mat[0, 0];
// translates to `matrix::borrow_mut(&amp;mut mat, 0, 0)`
``

You can also intermix index expressions with field accesses:

```move
public struct V { v: vector&lt;u64&gt; }

public struct Vs { vs: vector&lt;V&gt; }

fun borrow_first(input: &amp;Vs): &amp;u64 {
    &amp;input.vs[0].v[0]
    // translates to `vector::borrow(&amp;vector::borrow(&amp;input.vs, 0).v, 0)`
}
</code></pre>
<h3 id="index-functions-take-flexible-arguments"><a class="header" href="#index-functions-take-flexible-arguments">Index Functions Take Flexible Arguments</a></h3>
<p>Note that, aside from the definition and type limitations described in the rest of this chapter,
Move places no restrictions on the values your index syntax method takes as parameters. This allows
you to implement intricate programmatic behavior when defining index syntax, such as a data
structure that takes a default value if the index is out of bounds:</p>
<pre><code class="language-move">#[syntax(index)]
public fun borrow_or_set&lt;Key: copy, Value: drop&gt;(
    input: &amp;mut MTable&lt;Key, Value&gt;,
    key: Key,
    default: Value
): &amp;mut Value {
    if (contains(input, key)) {
        borrow(input, key)
    } else {
        insert(input, key, default);
        borrow(input, key)
    }
}
</code></pre>
<p>Now, when you index into <code>MTable</code>, you must also provide a default value:</p>
<pre><code class="language-move">let string_key: String = ...;
let mut table: MTable&lt;String, u64&gt; = m_table::make_table();
let entry: &amp;mut u64 = &amp;mut table[string_key, 0];
</code></pre>
<p>This sort of extensible power allows you to write precise index interfaces for your types,
concretely enforcing bespoke behavior.</p>
<h2 id="defining-index-syntax-functions"><a class="header" href="#defining-index-syntax-functions">Defining Index Syntax Functions</a></h2>
<p>This powerful syntax form allows all of your user-defined datatypes to behave in this way, assuming
your definitions adhere to the following rules:</p>
<ol>
<li>The <code>#[syntax(index)]</code> attribute is added to the designated functions defined in the same module
as the subject type.</li>
<li>The designated functions have <code>public</code> visibility.</li>
<li>The functions take a reference type as its subject type (its first argument) and returns a
matching references type (<code>mut</code> if the subject was <code>mut</code>).</li>
<li>Each type has only a single mutable and single immutable definition.</li>
<li>Immutable and mutable versions have type agreement:
<ul>
<li>The subject types match, differing only in mutability.</li>
<li>The return types match the mutability of their subject types.</li>
<li>Type parameters, if present, have identical constraints between both versions.</li>
<li>All parameters beyond the subject type are identical.</li>
</ul>
</li>
</ol>
<p>The following content and additional examples describe these rules in greater detail.</p>
<h3 id="declaration"><a class="header" href="#declaration">Declaration</a></h3>
<p>To declare an index syntax method, add the <code>#[syntax(index)]</code> attribute above the relevant function
definition in the same module as the subject type's definition. This signals to the compiler that
the function is an index accessor for the specified type.</p>
<h4 id="immutable-accessor"><a class="header" href="#immutable-accessor">Immutable Accessor</a></h4>
<p>The immutable index syntax method is defined for read-only access. It takes an immutable reference
of the subject type and returns an immutable reference to the element type. The <code>borrow</code> function
defined in <code>std::vector</code> is an example of this:</p>
<pre><code class="language-move">#[syntax(index)]
public native fun borrow&lt;Element&gt;(v: &amp;vector&lt;Element&gt;, i: u64): &amp;Element;
</code></pre>
<h4 id="mutable-accessor"><a class="header" href="#mutable-accessor">Mutable Accessor</a></h4>
<p>The mutable index syntax method is the dual of the immutable one, allowing for both read and write
operations. It takes a mutable reference of the subject type and returns a mutable reference to the
element type. The <code>borrow_mut</code> function defined in <code>std::vector</code> is an example of this:</p>
<pre><code class="language-move">#[syntax(index)]
public native fun borrow_mut&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, i: u64): &amp;mut Element;
</code></pre>
<h4 id="visibility"><a class="header" href="#visibility">Visibility</a></h4>
<p>To ensure that indexing functions are available anywhere the type is used, all index syntax methods
must have public visibility. This ensures ergonomic usage of indexing across modules and packages in
Move.</p>
<h4 id="no-duplicates"><a class="header" href="#no-duplicates">No Duplicates</a></h4>
<p>In addition to the above requirements, we restrict each subject base type to defining a single index
syntax method for immutable references and a single index syntax method for mutable references. For
example, you cannot define a specialized version for a polymorphic type:</p>
<pre><code class="language-move">#[syntax(index)]
public fun borrow_matrix_u64(s: &amp;Matrix&lt;u64&gt;, i: u64, j: u64): &amp;u64 { ... }

#[syntax(index)]
public fun borrow_matrix&lt;T&gt;(s: &amp;Matrix&lt;T&gt;, i: u64, j: u64): &amp;T { ... }
    // ERROR! Matrix already has a definition
    // for its immutable index syntax method
</code></pre>
<p>This ensures that you can always tell which method is being invoked, without the need to inspect
type instantiation.</p>
<h3 id="type-constraints"><a class="header" href="#type-constraints">Type Constraints</a></h3>
<p>By default, an index syntax method has the following type constraints:</p>
<p><strong>Its subject type (first argument) must be a reference to a single type defined in the same module
as the marked function.</strong> This means that you cannot define index syntax methods for tuples, type
parameters, or values:</p>
<pre><code class="language-move">#[syntax(index)]
public fun borrow_fst(x: &amp;(u64, u64), ...): &amp;u64 { ... }
    // ERROR because the subject type is a tuple

#[syntax(index)]
public fun borrow_tyarg&lt;T&gt;(x: &amp;T, ...): &amp;T { ... }
    // ERROR because the subject type is a type parameter

#[syntax(index)]
public fun borrow_value(x: Matrix&lt;u64&gt;, ...): &amp;u64 { ... }
    // ERROR because x is not a reference
</code></pre>
<p><strong>The subject type must match mutability with the return type.</strong> This restriction allows you to
clarify the expected behavior when borrowing an indexed expression as <code>&amp;vec[i]</code> versus
<code>&amp;mut vec[i]</code>. The Move compiler uses the mutability marker to determine which borrow form to call
to produce a reference of the appropriate mutability. As a result, we disallow index syntax methods
whose subject and return mutability differ:</p>
<pre><code class="language-move">#[syntax(index)]
public fun borrow_imm(x: &amp;mut Matrix&lt;u64&gt;, ...): &amp;u64 { ... }
    // ERROR! incompatible mutability
    // expected a mutable reference '&amp;mut' return type
</code></pre>
<h3 id="type-compatibility"><a class="header" href="#type-compatibility">Type Compatibility</a></h3>
<p>When defining an immutable and mutable index syntax method pair, they are subject to a number of
compatibility constraints:</p>
<ol>
<li>They must take the same number of type parameters, those type parameters must have the same
constraints.</li>
<li>Type parameters must be used the same <em>by position</em>, not name.</li>
<li>Their subject types must match exactly except for the mutability.</li>
<li>Their return types must match exactly except for the mutability.</li>
<li>All other parameter types must match exactly.</li>
</ol>
<p>These constraints are to ensure that index syntax behaves identically regardless of being in a
mutable or immutable position.</p>
<p>To illustrate some of these errors, recall the previous <code>Matrix</code> definition:</p>
<pre><code class="language-move">#[syntax(index)]
public fun borrow&lt;T&gt;(s: &amp;Matrix&lt;T&gt;, i: u64, j: u64): &amp;T {
    vector::borrow(vector::borrow(&amp;s.v, i), j)
}
</code></pre>
<p>All of the following are type-incompatible definitions of the mutable version:</p>
<pre><code class="language-move">#[syntax(index)]
public fun borrow_mut&lt;T: drop&gt;(s: &amp;mut Matrix&lt;T&gt;, i: u64, j: u64): &amp;mut T { ... }
    // ERROR! `T` has `drop` here, but no in the immutable version

#[syntax(index)]
public fun borrow_mut(s: &amp;mut Matrix&lt;u64&gt;, i: u64, j: u64): &amp;mut u64 { ... }
    // ERROR! This takes a different number of type parameters

#[syntax(index)]
public fun borrow_mut&lt;T, U&gt;(s: &amp;mut Matrix&lt;U&gt;, i: u64, j: u64): &amp;mut U { ... }
    // ERROR! This takes a different number of type parameters

#[syntax(index)]
public fun borrow_mut&lt;U&gt;(s: &amp;mut Matrix&lt;U&gt;, i_j: (u64, u64)): &amp;mut U { ... }
    // ERROR! This takes a different number of arguments

#[syntax(index)]
public fun borrow_mut&lt;U&gt;(s: &amp;mut Matrix&lt;U&gt;, i: u64, j: u32): &amp;mut U { ... }
    // ERROR! `j` is a different type
</code></pre>
<p>Again, the goal here is to make the usage across the immutable and mutable versions consistent. This
allows index syntax methods to work without changing out the behavior or constraints based on
mutable versus immutable usage, ultimately ensuring a consistent interface to program against.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="method-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="packages.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="method-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="packages.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/switcher.js"></script>


    </div>
    </body>
</html>
