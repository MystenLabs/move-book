<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Move Reference</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap" rel="stylesheet">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-B1E7R0BHX4"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-B1E7R0BHX4');
        </script>

        <meta name="description" content="The Move Language Reference maintained by the Move core team.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">The Move Reference</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">1.</strong> Modules</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Concepts</li><li class="chapter-item expanded "><a href="primitive-types.html"><strong aria-hidden="true">2.</strong> Primitive Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitive-types/integers.html"><strong aria-hidden="true">2.1.</strong> Integers</a></li><li class="chapter-item expanded "><a href="primitive-types/bool.html"><strong aria-hidden="true">2.2.</strong> Bool</a></li><li class="chapter-item expanded "><a href="primitive-types/address.html"><strong aria-hidden="true">2.3.</strong> Address</a></li><li class="chapter-item expanded "><a href="primitive-types/vector.html"><strong aria-hidden="true">2.4.</strong> Vector</a></li><li class="chapter-item expanded "><a href="primitive-types/references.html"><strong aria-hidden="true">2.5.</strong> References</a></li><li class="chapter-item expanded "><a href="primitive-types/tuples.html"><strong aria-hidden="true">2.6.</strong> Tuples and Unit</a></li></ol></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">3.</strong> Local Variables and Scopes</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">4.</strong> Equality</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">5.</strong> Abort and Assert</a></li><li class="chapter-item expanded "><a href="control-flow.html"><strong aria-hidden="true">6.</strong> Control Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="control-flow/conditionals.html"><strong aria-hidden="true">6.1.</strong> Conditional Expressions</a></li><li class="chapter-item expanded "><a href="control-flow/loops.html"><strong aria-hidden="true">6.2.</strong> Loops</a></li><li class="chapter-item expanded "><a href="control-flow/labeled-control-flow.html"><strong aria-hidden="true">6.3.</strong> Labeled Control FLow</a></li><li class="chapter-item expanded "><a href="control-flow/pattern-matching.html"><strong aria-hidden="true">6.4.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">7.</strong> Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functions/macros.html"><strong aria-hidden="true">7.1.</strong> Macro Functions</a></li></ol></li><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">8.</strong> Structs</a></li><li class="chapter-item expanded "><a href="enums.html"><strong aria-hidden="true">9.</strong> Enums</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">10.</strong> Constants</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">11.</strong> Generics</a></li><li class="chapter-item expanded "><a href="abilities.html"><strong aria-hidden="true">12.</strong> Type Abilities</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">13.</strong> Uses and Aliases</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Concepts</li><li class="chapter-item expanded "><a href="method-syntax.html"><strong aria-hidden="true">14.</strong> Method Syntax</a></li><li class="chapter-item expanded "><a href="index-syntax.html"><strong aria-hidden="true">15.</strong> Index Syntax Methods</a></li><li class="chapter-item expanded affix "><li class="part-title">Tooling</li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">16.</strong> Packages</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">17.</strong> Unit Tests</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">18.</strong> Coding Conventions</a></li><li class="chapter-item expanded affix "><li class="part-title">Deprecated</li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">19.</strong> Friends</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Move Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MystenLabs/move-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-move-reference"><a class="header" href="#the-move-reference">The Move Reference</a></h1>
<p>Welcome to Move, a next generation language for secure asset programming. Its primary use case is in
blockchain environments, where Move programs are used to construct state changes. Move allows
developers to write programs that flexibly manage and transfer assets, while providing the security
and protections against attacks on those assets. However, Move has been developed with use cases in
mind outside a blockchain context as well.</p>
<p>Move takes its cue from <a href="https://www.rust-lang.org/">Rust</a> by using resource types with move (hence
the name) semantics as an explicit representation of digital assets, such as currency.</p>
<!-- TODO do we have a pre-existing summary we can copy in here? -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p><strong>Modules</strong> are the core program unit that define types along with functions that operate on these
types. Struct types define the schema of Move's <a href="./abilities.html#key">storage</a>, and module functions
define the rules interacting with values of those types. While modules themselves are also stored in
storage, they are not accessible from within a Move program. In a blockchain environment, the
modules are stored on chain in a process typically referred to as &quot;publishing&quot;. After being
published, <a href="./functions.html#entry-modifier"><code>entry</code></a> and <a href="./functions.html#visibility"><code>public</code></a>
functions can be invoked according to the rules of that particular Move instance.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>A module has the following syntax:</p>
<pre><code class="language-text">module &lt;address&gt;::&lt;identifier&gt; {
    (&lt;use&gt; | &lt;type&gt; | &lt;function&gt; | &lt;constant&gt;)*
}
</code></pre>
<p>where <code>&lt;address&gt;</code> is a valid <a href="./primitive-types/address.html">address</a> specifying the module's
package.</p>
<p>For example:</p>
<pre><code class="language-move">module 0x42::test {
    public struct Example has copy, drop { i: u64 }

    use std::debug;

    const ONE: u64 = 1;

    public fun print(x: u64) {
        let sum = x + ONE;
        let example = Example { i: sum };
        debug::print(&amp;sum)
    }
}
</code></pre>
<h2 id="names"><a class="header" href="#names">Names</a></h2>
<p>The <code>module test_addr::test</code> part specifies that the module <code>test</code> will be published under the
numerical <a href="./primitive-types/address.html">address</a> value assigned for the name <code>test_addr</code> in the
<a href="./packages.html">package settings</a>.</p>
<p>Modules should normally be declared using <a href="./primitive-types/address.html">named addresses</a> (as
opposed to using the numerical value directly). For example:</p>
<pre><code class="language-move">module test_addr::test {
    public struct Example has copy, drop { a: address }

    friend test_addr::another_test;

    public fun print() {
        let example = Example { a: @test_addr };
        debug::print(&amp;example)
    }
}
</code></pre>
<p>These named addresses commonly match the name of the <a href="./packages.html">package</a>.</p>
<p>Because named addresses only exist at the source language level and during compilation, named
addresses will be fully substituted for their value at the bytecode level. For example if we had the
following code:</p>
<pre><code class="language-move">fun example() {
    my_addr::m::foo(@my_addr);
}
</code></pre>
<p>and we compiled it with <code>my_addr</code> set to <code>0xC0FFEE</code>, then it would be operationally equivalent to
the following:</p>
<pre><code class="language-move">fun example() {
    0xC0FFEE::m::foo(@0xC0FFEE);
}
</code></pre>
<p>While at the source level these two different accesses are equivalent, it is a best practice to
always use the named address and not the numerical value assigned to that address.</p>
<p>Module names can start with a lowercase letter from <code>a</code> to <code>z</code> or an uppercase letter from <code>A</code> to
<code>Z</code>. After the first character, module names can contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>,
letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<pre><code class="language-move">module a::my_module {}
module a::foo_bar_42 {}
</code></pre>
<p>Typically, module names start with a lowercase letter. A module named <code>my_module</code> should be stored
in a source file named <code>my_module.move</code>.</p>
<h2 id="members"><a class="header" href="#members">Members</a></h2>
<p>All members inside a <code>module</code> block can appear in any order. Fundamentally, a module is a collection
of <a href="./structs.html"><code>types</code></a> and <a href="./functions.html"><code>functions</code></a>. The <a href="./uses.html"><code>use</code></a> keyword refers
to members from other modules. The <a href="./constants.html"><code>const</code></a> keyword defines constants that can be
used in the functions of a module.</p>
<p>The <a href="./friends.html"><code>friend</code></a> syntax is a deprecated concept for specifying a list of trusted
modules. The concept has been superseded by <a href="./functions.html#visibility"><code>public(package)</code></a></p>
<!-- TODO member access rules -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<p>The primitive types are the basic building blocks of the language.</p>
<p>These primitive types can be used on their own or can be used be used to build more complex,
user-defined types, e.g. in a <a href="./structs.html"><code>struct</code></a>.</p>
<ul>
<li><a href="./primitive-types/integers.html">Integers</a></li>
<li><a href="./primitive-types/bool.html">Bool</a></li>
<li><a href="./primitive-types/address.html">Address</a></li>
<li><a href="./primitive-types/vector.html">Vector</a></li>
</ul>
<p>These primitive types are used in conjunction with other types</p>
<ul>
<li><a href="./primitive-types/references.html">References</a></li>
<li><a href="./primitive-types/tuples.html">Tuples and Unit</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integers"><a class="header" href="#integers">Integers</a></h1>
<p>Move supports six unsigned integer types: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, and <code>u256</code>. Values of
these types range from 0 to a maximum that depends on the size of the type.</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Value Range</th></tr></thead><tbody>
<tr><td>Unsigned 8-bit integer, <code>u8</code></td><td>0 to 2<sup>8</sup> - 1</td></tr>
<tr><td>Unsigned 16-bit integer, <code>u16</code></td><td>0 to 2<sup>16</sup> - 1</td></tr>
<tr><td>Unsigned 32-bit integer, <code>u32</code></td><td>0 to 2<sup>32</sup> - 1</td></tr>
<tr><td>Unsigned 64-bit integer, <code>u64</code></td><td>0 to 2<sup>64</sup> - 1</td></tr>
<tr><td>Unsigned 128-bit integer, <code>u128</code></td><td>0 to 2<sup>128</sup> - 1</td></tr>
<tr><td>Unsigned 256-bit integer, <code>u256</code></td><td>0 to 2<sup>256</sup> - 1</td></tr>
</tbody></table>
</div>
<h2 id="literals"><a class="header" href="#literals">Literals</a></h2>
<p>Literal values for these types are specified either as a sequence of digits (e.g.,<code>112</code>) or as hex
literals, e.g., <code>0xFF</code>. The type of the literal can optionally be added as a suffix, e.g., <code>112u8</code>.
If the type is not specified, the compiler will try to infer the type from the context where the
literal is used. If the type cannot be inferred, it is assumed to be <code>u64</code>.</p>
<p>Number literals can be separated by underscores for grouping and readability. (e.g.,<code>1_234_5678</code>,
<code>1_000u128</code>, <code>0xAB_CD_12_35</code>).</p>
<p>If a literal is too large for its specified (or inferred) size range, an error is reported.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><code class="language-move">// literals with explicit annotations;
let explicit_u8 = 1u8;
let explicit_u16 = 1u16;
let explicit_u32 = 1u32;
let explicit_u64 = 2u64;
let explicit_u128 = 3u128;
let explicit_u256 = 1u256;
let explicit_u64_underscored = 154_322_973u64;

// literals with simple inference
let simple_u8: u8 = 1;
let simple_u16: u16 = 1;
let simple_u32: u32 = 1;
let simple_u64: u64 = 2;
let simple_u128: u128 = 3;
let simple_u256: u256 = 1;

// literals with more complex inference
let complex_u8 = 1; // inferred: u8
// right hand argument to shift must be u8
let _unused = 10 &lt;&lt; complex_u8;

let x: u8 = 38;
let complex_u8 = 2; // inferred: u8
// arguments to `+` must have the same type
let _unused = x + complex_u8;

let complex_u128 = 133_876; // inferred: u128
// inferred from function argument type
function_that_takes_u128(complex_u128);

// literals can be written in hex
let hex_u8: u8 = 0x1;
let hex_u16: u16 = 0x1BAE;
let hex_u32: u32 = 0xDEAD80;
let hex_u64: u64 = 0xCAFE;
let hex_u128: u128 = 0xDEADBEEF;
let hex_u256: u256 = 0x1123_456A_BCDE_F;
</code></pre>
<h2 id="operations"><a class="header" href="#operations">Operations</a></h2>
<h3 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h3>
<p>Each of these types supports the same set of checked arithmetic operations. For all of these
operations, both arguments (the left and right side operands) <em>must</em> be of the same type. If you
need to operate over values of different types, you will need to first perform a <a href="primitive-types/integers.html#casting">cast</a>.
Similarly, if you expect the result of the operation to be too large for the integer type, perform a
<a href="primitive-types/integers.html#casting">cast</a> to a larger size before performing the operation.</p>
<p>All arithmetic operations abort instead of behaving in a way that mathematical integers would not
(e.g., overflow, underflow, divide-by-zero).</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Operation</th><th>Aborts If</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>addition</td><td>Result is too large for the integer type</td></tr>
<tr><td><code>-</code></td><td>subtraction</td><td>Result is less than zero</td></tr>
<tr><td><code>*</code></td><td>multiplication</td><td>Result is too large for the integer type</td></tr>
<tr><td><code>%</code></td><td>modular division</td><td>The divisor is <code>0</code></td></tr>
<tr><td><code>/</code></td><td>truncating division</td><td>The divisor is <code>0</code></td></tr>
</tbody></table>
</div>
<h3 id="bitwise"><a class="header" href="#bitwise">Bitwise</a></h3>
<p>The integer types support the following bitwise operations that treat each number as a series of
individual bits, either 0 or 1, instead of as numerical integer values.</p>
<p>Bitwise operations do not abort.</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Operation</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&amp;</code></td><td>bitwise and</td><td>Performs a boolean and for each bit pairwise</td></tr>
<tr><td><code>|</code></td><td>bitwise or</td><td>Performs a boolean or for each bit pairwise</td></tr>
<tr><td><code>^</code></td><td>bitwise xor</td><td>Performs a boolean exclusive or for each bit pairwise</td></tr>
</tbody></table>
</div>
<h3 id="bit-shifts"><a class="header" href="#bit-shifts">Bit Shifts</a></h3>
<p>Similar to the bitwise operations, each integer type supports bit shifts. But unlike the other
operations, the righthand side operand (how many bits to shift by) must <em>always</em> be a <code>u8</code> and need
not match the left side operand (the number you are shifting).</p>
<p>Bit shifts can abort if the number of bits to shift by is greater than or equal to <code>8</code>, <code>16</code>, <code>32</code>,
<code>64</code>, <code>128</code> or <code>256</code> for <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code> and <code>u256</code> respectively.</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Operation</th><th>Aborts if</th></tr></thead><tbody>
<tr><td><code>&lt;&lt;</code></td><td>shift left</td><td>Number of bits to shift by is greater than the size of the integer type</td></tr>
<tr><td><code>&gt;&gt;</code></td><td>shift right</td><td>Number of bits to shift by is greater than the size of the integer type</td></tr>
</tbody></table>
</div>
<h3 id="comparisons"><a class="header" href="#comparisons">Comparisons</a></h3>
<p>Integer types are the <em>only</em> types in Move that can use the comparison operators. Both arguments
need to be of the same type. If you need to compare integers of different types, you must
<a href="primitive-types/integers.html#casting">cast</a> one of them first.</p>
<p>Comparison operations do not abort.</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Operation</th></tr></thead><tbody>
<tr><td><code>&lt;</code></td><td>less than</td></tr>
<tr><td><code>&gt;</code></td><td>greater than</td></tr>
<tr><td><code>&lt;=</code></td><td>less than or equal to</td></tr>
<tr><td><code>&gt;=</code></td><td>greater than or equal to</td></tr>
</tbody></table>
</div>
<h3 id="equality"><a class="header" href="#equality">Equality</a></h3>
<p>Like all types with <a href="primitive-types/../abilities.html"><code>drop</code></a>, all integer types support the
<a href="primitive-types/../equality.html">&quot;equal&quot;</a> and <a href="primitive-types/../equality.html">&quot;not equal&quot;</a> operations. Both arguments need to be of
the same type. If you need to compare integers of different types, you must <a href="primitive-types/integers.html#casting">cast</a> one of
them first.</p>
<p>Equality operations do not abort.</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Operation</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>equal</td></tr>
<tr><td><code>!=</code></td><td>not equal</td></tr>
</tbody></table>
</div>
<p>For more details see the section on <a href="primitive-types/../equality.html">equality</a></p>
<h2 id="casting"><a class="header" href="#casting">Casting</a></h2>
<p>Integer types of one size can be cast to integer types of another size. Integers are the only types
in Move that support casting.</p>
<p>Casts <em>do not</em> truncate. Casting aborts if the result is too large for the specified type.</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Operation</th><th>Aborts if</th></tr></thead><tbody>
<tr><td><code>(e as T)</code></td><td>Cast integer expression <code>e</code> into an integer type <code>T</code></td><td><code>e</code> is too large to represent as a <code>T</code></td></tr>
</tbody></table>
</div>
<p>Here, the type of <code>e</code> must be <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>128</code> or <code>256</code> and <code>T</code> must be <code>u8</code>, <code>u16</code>,
<code>u32</code>, <code>u64</code>, <code>u128</code>, or <code>u256</code>.</p>
<p>For example:</p>
<ul>
<li><code>(x as u8)</code></li>
<li><code>(y as u16)</code></li>
<li><code>(873u16 as u32)</code></li>
<li><code>(2u8 as u64)</code></li>
<li><code>(1 + 3 as u128)</code></li>
<li><code>(4/2 + 12345 as u256)</code></li>
</ul>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>As with the other scalar values built-in to the language, integer values are implicitly copyable,
meaning they can be copied without an explicit instruction such as
<a href="primitive-types/../variables.html#move-and-copy"><code>copy</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bool"><a class="header" href="#bool">Bool</a></h1>
<p><code>bool</code> is Move's primitive type for boolean <code>true</code> and <code>false</code> values.</p>
<h2 id="literals-1"><a class="header" href="#literals-1">Literals</a></h2>
<p>Literals for <code>bool</code> are either <code>true</code> or <code>false</code>.</p>
<h2 id="operations-1"><a class="header" href="#operations-1">Operations</a></h2>
<h3 id="logical"><a class="header" href="#logical">Logical</a></h3>
<p><code>bool</code> supports three logical operations:</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Description</th><th>Equivalent Expression</th></tr></thead><tbody>
<tr><td><code>&amp;&amp;</code></td><td>short-circuiting logical and</td><td><code>p &amp;&amp; q</code> is equivalent to <code>if (p) q else false</code></td></tr>
<tr><td><code>||</code></td><td>short-circuiting logical or</td><td><code>p || q</code> is equivalent to <code>if (p) true else q</code></td></tr>
<tr><td><code>!</code></td><td>logical negation</td><td><code>!p</code> is equivalent to <code>if (p) false else true</code></td></tr>
</tbody></table>
</div>
<h3 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h3>
<p><code>bool</code> values are used in several of Move's control-flow constructs:</p>
<ul>
<li><a href="primitive-types/../control-flow/conditionals.html"><code>if (bool) { ... }</code></a></li>
<li><a href="primitive-types/../control-flow/loops.html"><code>while (bool) { .. }</code></a></li>
<li><a href="primitive-types/../abort-and-assert.html"><code>assert!(bool, u64)</code></a></li>
</ul>
<h2 id="ownership-1"><a class="header" href="#ownership-1">Ownership</a></h2>
<p>As with the other scalar values built-in to the language, boolean values are implicitly copyable,
meaning they can be copied without an explicit instruction such as
<a href="primitive-types/../variables.html#move-and-copy"><code>copy</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="address"><a class="header" href="#address">Address</a></h1>
<p><code>address</code> is a built-in type in Move that is used to represent locations (sometimes called accounts)
in storage. An <code>address</code> value is a 256-bit (32 byte) identifier. Move uses addresses to
differentiate packages of <a href="primitive-types/../modules.html">modules</a>, where each package has its own address and
modules. Specific deployments of Move might also use the <code>address</code> value for
<a href="primitive-types/../abilities.html#key">storage</a> operations.</p>
<blockquote>
<p>For Sui, <code>address</code> is used to represent &quot;accounts&quot;, and also objects via strong type wrappers
(with <code>sui::object::UID</code> and <code>sui::object::ID</code>).</p>
</blockquote>
<p>Although an <code>address</code> is a 256 bit integer under the hood, Move addresses are intentionally
opaque---they cannot be created from integers, they do not support arithmetic operations, and they
cannot be modified. Specific deployments of Move might have <code>native</code> functions to enable some of
these operations (e.g., creating an <code>address</code> from bytes <code>vector&lt;u8&gt;</code>), but these are not part of
the Move language itself.</p>
<p>While there are runtime address values (values of type <code>address</code>), they <em>cannot</em> be used to access
modules at runtime.</p>
<h2 id="addresses-and-their-syntax"><a class="header" href="#addresses-and-their-syntax">Addresses and Their Syntax</a></h2>
<p>Addresses come in two flavors, named or numerical. The syntax for a named address follows the same
rules for any named identifier in Move. The syntax of a numerical address is not restricted to
hex-encoded values, and any valid <a href="primitive-types/./integers.html"><code>u256</code> numerical value</a> can be used as an address
value, e.g., <code>42</code>, <code>0xCAFE</code>, and <code>10_000</code> are all valid numerical address literals.</p>
<p>To distinguish when an address is being used in an expression context or not, the syntax when using
an address differs depending on the context where it's used:</p>
<ul>
<li>When an address is used as an expression, the address must be prefixed by the <code>@</code> character, i.e.,
<a href="primitive-types/./integers.html"><code>@&lt;numerical_value&gt;</code></a> or <code>@&lt;named_address_identifier&gt;</code>.</li>
<li>Outside of expression contexts, the address may be written without the leading <code>@</code> character,
i.e., <a href="primitive-types/./integers.html"><code>&lt;numerical_value&gt;</code></a> or <code>&lt;named_address_identifier&gt;</code>.</li>
</ul>
<p>In general, you can think of <code>@</code> as an operator that takes an address from being a namespace item to
being an expression item.</p>
<h2 id="named-addresses"><a class="header" href="#named-addresses">Named Addresses</a></h2>
<p>Named addresses are a feature that allow identifiers to be used in place of numerical values in any
spot where addresses are used, and not just at the value level. Named addresses are declared and
bound as top level elements (outside of modules and scripts) in Move packages, or passed as
arguments to the Move compiler.</p>
<p>Named addresses only exist at the source language level and will be fully substituted for their
value at the bytecode level. Because of this, modules and module members should be accessed through
the module's named address and not through the numerical value assigned to the named address during
compilation. So while <code>use my_addr::foo</code> is equivalent to <code>use 0x2::foo</code> (if <code>my_addr</code> is assigned
<code>0x2</code>), it is a best practice to always use the <code>my_addr</code> name.</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<pre><code class="language-move">// shorthand for
// 0x0000000000000000000000000000000000000000000000000000000000000001
let a1: address = @0x1;
// shorthand for
// 0x0000000000000000000000000000000000000000000000000000000000000042
let a2: address = @0x42;
// shorthand for
// 0x00000000000000000000000000000000000000000000000000000000DEADBEEF
let a3: address = @0xDEADBEEF;
// shorthand for
// 0x000000000000000000000000000000000000000000000000000000000000000A
let a4: address = @0x0000000000000000000000000000000A;
// Assigns `a5` the value of the named address `std`
let a5: address = @std;
// Any valid numerical value can be used as an address
let a6: address = @66;
let a7: address = @42_000;

module 66::some_module {   // Not in expression context, so no @ needed
    use 0x1::other_module; // Not in expression context so no @ needed
    use std::vector;       // Can use a named address as a namespace item
    ...
}

module std::other_module {  // Can use a named address when declaring a module
    ...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector"><a class="header" href="#vector">Vector</a></h1>
<p><code>vector&lt;T&gt;</code> is the only primitive collection type provided by Move. A <code>vector&lt;T&gt;</code> is a homogeneous
collection of <code>T</code>'s that can grow or shrink by pushing/popping values off the &quot;end&quot;.</p>
<p>A <code>vector&lt;T&gt;</code> can be instantiated with any type <code>T</code>. For example, <code>vector&lt;u64&gt;</code>, <code>vector&lt;address&gt;</code>,
<code>vector&lt;0x42::my_module::MyData&gt;</code>, and <code>vector&lt;vector&lt;u8&gt;&gt;</code> are all valid vector types.</p>
<h2 id="literals-2"><a class="header" href="#literals-2">Literals</a></h2>
<h3 id="general-vector-literals"><a class="header" href="#general-vector-literals">General <code>vector</code> Literals</a></h3>
<p>Vectors of any type can be created with <code>vector</code> literals.</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>vector[]</code></td><td><code>vector[]: vector&lt;T&gt;</code> where <code>T</code> is any single, non-reference type</td><td>An empty vector</td></tr>
<tr><td><code>vector[e1, ..., en]</code></td><td><code>vector[e1, ..., en]: vector&lt;T&gt;</code> where <code>e_i: T</code> s.t. <code>0 &lt; i &lt;= n</code> and <code>n &gt; 0</code></td><td>A vector with <code>n</code> elements (of length <code>n</code>)</td></tr>
</tbody></table>
</div>
<p>In these cases, the type of the <code>vector</code> is inferred, either from the element type or from the
vector's usage. If the type cannot be inferred, or simply for added clarity, the type can be
specified explicitly:</p>
<pre><code class="language-move">vector&lt;T&gt;[]: vector&lt;T&gt;
vector&lt;T&gt;[e1, ..., en]: vector&lt;T&gt;
</code></pre>
<h4 id="example-vector-literals"><a class="header" href="#example-vector-literals">Example Vector Literals</a></h4>
<pre><code class="language-move">(vector[]: vector&lt;bool&gt;);
(vector[0u8, 1u8, 2u8]: vector&lt;u8&gt;);
(vector&lt;u128&gt;[]: vector&lt;u128&gt;);
(vector&lt;address&gt;[@0x42, @0x100]: vector&lt;address&gt;);
</code></pre>
<h3 id="vectoru8-literals"><a class="header" href="#vectoru8-literals"><code>vector&lt;u8&gt;</code> literals</a></h3>
<p>A common use-case for vectors in Move is to represent &quot;byte arrays&quot;, which are represented with
<code>vector&lt;u8&gt;</code>. These values are often used for cryptographic purposes, such as a public key or a hash
result. These values are so common that specific syntax is provided to make the values more
readable, as opposed to having to use <code>vector[]</code> where each individual <code>u8</code> value is specified in
numeric form.</p>
<p>There are currently two supported types of <code>vector&lt;u8&gt;</code> literals, <em>byte strings</em> and <em>hex strings</em>.</p>
<h4 id="byte-strings"><a class="header" href="#byte-strings">Byte Strings</a></h4>
<p>Byte strings are quoted string literals prefixed by a <code>b</code>, e.g. <code>b&quot;Hello!\n&quot;</code>.</p>
<p>These are ASCII encoded strings that allow for escape sequences. Currently, the supported escape
sequences are:</p>
<div class="table-wrapper"><table><thead><tr><th>Escape Sequence</th><th>Description</th></tr></thead><tbody>
<tr><td><code>\n</code></td><td>New line (or Line feed)</td></tr>
<tr><td><code>\r</code></td><td>Carriage return</td></tr>
<tr><td><code>\t</code></td><td>Tab</td></tr>
<tr><td><code>\\</code></td><td>Backslash</td></tr>
<tr><td><code>\0</code></td><td>Null</td></tr>
<tr><td><code>\&quot;</code></td><td>Quote</td></tr>
<tr><td><code>\xHH</code></td><td>Hex escape, inserts the hex byte sequence <code>HH</code></td></tr>
</tbody></table>
</div>
<h4 id="hex-strings"><a class="header" href="#hex-strings">Hex Strings</a></h4>
<p>Hex strings are quoted string literals prefixed by a <code>x</code>, e.g. <code>x&quot;48656C6C6F210A&quot;</code>.</p>
<p>Each byte pair, ranging from <code>00</code> to <code>FF</code>, is interpreted as hex encoded <code>u8</code> value. So each byte
pair corresponds to a single entry in the resulting <code>vector&lt;u8&gt;</code>.</p>
<h4 id="example-string-literals"><a class="header" href="#example-string-literals">Example String Literals</a></h4>
<pre><code class="language-move">fun byte_and_hex_strings() {
    assert!(b&quot;&quot; == x&quot;&quot;, 0);
    assert!(b&quot;Hello!\n&quot; == x&quot;48656C6C6F210A&quot;, 1);
    assert!(b&quot;\x48\x65\x6C\x6C\x6F\x21\x0A&quot; == x&quot;48656C6C6F210A&quot;, 2);
    assert!(
        b&quot;\&quot;Hello\tworld!\&quot;\n \r \\Null=\0&quot; ==
            x&quot;2248656C6C6F09776F726C6421220A200D205C4E756C6C3D00&quot;,
        3
    );
}
</code></pre>
<h2 id="operations-2"><a class="header" href="#operations-2">Operations</a></h2>
<p><code>vector</code> supports the following operations via the <code>std::vector</code> module in the Move standard
library:</p>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Description</th><th>Aborts?</th></tr></thead><tbody>
<tr><td><code>vector::empty&lt;T&gt;(): vector&lt;T&gt;</code></td><td>Create an empty vector that can store values of type <code>T</code></td><td>Never</td></tr>
<tr><td><code>vector::singleton&lt;T&gt;(t: T): vector&lt;T&gt;</code></td><td>Create a vector of size 1 containing <code>t</code></td><td>Never</td></tr>
<tr><td><code>vector::push_back&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, t: T)</code></td><td>Add <code>t</code> to the end of <code>v</code></td><td>Never</td></tr>
<tr><td><code>vector::pop_back&lt;T&gt;(v: &amp;mut vector&lt;T&gt;): T</code></td><td>Remove and return the last element in <code>v</code></td><td>If <code>v</code> is empty</td></tr>
<tr><td><code>vector::borrow&lt;T&gt;(v: &amp;vector&lt;T&gt;, i: u64): &amp;T</code></td><td>Return an immutable reference to the <code>T</code> at index <code>i</code></td><td>If <code>i</code> is not in bounds</td></tr>
<tr><td><code>vector::borrow_mut&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64): &amp;mut T</code></td><td>Return a mutable reference to the <code>T</code> at index <code>i</code></td><td>If <code>i</code> is not in bounds</td></tr>
<tr><td><code>vector::destroy_empty&lt;T&gt;(v: vector&lt;T&gt;)</code></td><td>Delete <code>v</code></td><td>If <code>v</code> is not empty</td></tr>
<tr><td><code>vector::append&lt;T&gt;(v1: &amp;mut vector&lt;T&gt;, v2: vector&lt;T&gt;)</code></td><td>Add the elements in <code>v2</code> to the end of <code>v1</code></td><td>Never</td></tr>
<tr><td><code>vector::contains&lt;T&gt;(v: &amp;vector&lt;T&gt;, e: &amp;T): bool</code></td><td>Return true if <code>e</code> is in the vector <code>v</code>. Otherwise, returns false</td><td>Never</td></tr>
<tr><td><code>vector::swap&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64, j: u64)</code></td><td>Swaps the elements at the <code>i</code>th and <code>j</code>th indices in the vector <code>v</code></td><td>If <code>i</code> or <code>j</code> is out of bounds</td></tr>
<tr><td><code>vector::reverse&lt;T&gt;(v: &amp;mut vector&lt;T&gt;)</code></td><td>Reverses the order of the elements in the vector <code>v</code> in place</td><td>Never</td></tr>
<tr><td><code>vector::index_of&lt;T&gt;(v: &amp;vector&lt;T&gt;, e: &amp;T): (bool, u64)</code></td><td>Return <code>(true, i)</code> if <code>e</code> is in the vector <code>v</code> at index <code>i</code>. Otherwise, returns <code>(false, 0)</code></td><td>Never</td></tr>
<tr><td><code>vector::remove&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64): T</code></td><td>Remove the <code>i</code>th element of the vector <code>v</code>, shifting all subsequent elements. This is O(n) and preserves ordering of elements in the vector</td><td>If <code>i</code> is out of bounds</td></tr>
<tr><td><code>vector::swap_remove&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64): T</code></td><td>Swap the <code>i</code>th element of the vector <code>v</code> with the last element and then pop the element, This is O(1), but does not preserve ordering of elements in the vector</td><td>If <code>i</code> is out of bounds</td></tr>
</tbody></table>
</div><!-- TODO we should just link out to generated stdlib docs? Maybe?  -->
<p>More operations may be added over time.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-move">use std::vector;

let mut v = vector::empty&lt;u64&gt;();
vector::push_back(&amp;mut v, 5);
vector::push_back(&amp;mut v, 6);

assert!(*vector::borrow(&amp;v, 0) == 5, 42);
assert!(*vector::borrow(&amp;v, 1) == 6, 42);
assert!(vector::pop_back(&amp;mut v) == 6, 42);
assert!(vector::pop_back(&amp;mut v) == 5, 42);
</code></pre>
<h2 id="destroying-and-copying-vectors"><a class="header" href="#destroying-and-copying-vectors">Destroying and copying <code>vector</code>s</a></h2>
<p>Some behaviors of <code>vector&lt;T&gt;</code> depend on the abilities of the element type, <code>T</code>. For example, vectors
containing elements that do not have <code>drop</code> cannot be implicitly discarded like <code>v</code> in the example
above--they must be explicitly destroyed with <code>vector::destroy_empty</code>.</p>
<p>Note that <code>vector::destroy_empty</code> will abort at runtime unless <code>vec</code> contains zero elements:</p>
<pre><code class="language-move">fun destroy_any_vector&lt;T&gt;(vec: vector&lt;T&gt;) {
    vector::destroy_empty(vec) // deleting this line will cause a compiler error
}
</code></pre>
<p>But no error would occur for dropping a vector that contains elements with <code>drop</code>:</p>
<pre><code class="language-move">fun destroy_droppable_vector&lt;T: drop&gt;(vec: vector&lt;T&gt;) {
    // valid!
    // nothing needs to be done explicitly to destroy the vector
}
</code></pre>
<p>Similarly, vectors cannot be copied unless the element type has <code>copy</code>. In other words, a
<code>vector&lt;T&gt;</code> has <code>copy</code> if and only if <code>T</code> has <code>copy</code>. Note that it will be implicitly copied if
needed:</p>
<pre><code class="language-move">let x = vector[10];
let y = x; // implicit copy
let z = x;
(y, z)
</code></pre>
<p>Keep in mind, copies of large vectors can be expensive. If this is a concern, annotating the
<code>intended</code> usage can prevent accidental copies. For example,</p>
<pre><code class="language-move">let x = vector[10];
let y = move x;
let z = x; // ERROR! x has been moved
(y, z)
</code></pre>
<p>For more details see the sections on <a href="primitive-types/../abilities.html">type abilities</a> and
<a href="primitive-types/../generics.html">generics</a>.</p>
<h2 id="ownership-2"><a class="header" href="#ownership-2">Ownership</a></h2>
<p>As mentioned <a href="primitive-types/vector.html#destroying-and-copying-vectors">above</a>, <code>vector</code> values can be copied only if the
elements can be copied. In that case, the copy can be done via a
<a href="primitive-types/../variables.html#move-and-copy"><code>copy</code></a> or a
<a href="primitive-types/./references.html#reading-and-writing-through-references">dereference <code>*</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>Move has two types of references: immutable <code>&amp;</code> and mutable <code>&amp;mut</code>. Immutable references are read
only, and cannot modify the underlying value (or any of its fields). Mutable references allow for
modifications via a write through that reference. Move's type system enforces an ownership
discipline that prevents reference errors.</p>
<h2 id="reference-operators"><a class="header" href="#reference-operators">Reference Operators</a></h2>
<p>Move provides operators for creating and extending references as well as converting a mutable
reference to an immutable one. Here and elsewhere, we use the notation <code>e: T</code> for &quot;expression <code>e</code>
has type <code>T</code>&quot;.</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&amp;e</code></td><td><code>&amp;T</code> where <code>e: T</code> and <code>T</code> is a non-reference type</td><td>Create an immutable reference to <code>e</code></td></tr>
<tr><td><code>&amp;mut e</code></td><td><code>&amp;mut T</code> where <code>e: T</code> and <code>T</code> is a non-reference type</td><td>Create a mutable reference to <code>e</code>.</td></tr>
<tr><td><code>&amp;e.f</code></td><td><code>&amp;T</code> where <code>e.f: T</code></td><td>Create an immutable reference to field <code>f</code> of struct <code>e</code>.</td></tr>
<tr><td><code>&amp;mut e.f</code></td><td><code>&amp;mut T</code> where <code>e.f: T</code></td><td>Create a mutable reference to field <code>f</code> of struct<code>e</code>.</td></tr>
<tr><td><code>freeze(e)</code></td><td><code>&amp;T</code> where <code>e: &amp;mut T</code></td><td>Convert the mutable reference <code>e</code> into an immutable reference.</td></tr>
</tbody></table>
</div>
<p>The <code>&amp;e.f</code> and <code>&amp;mut e.f</code> operators can be used both to create a new reference into a struct or to
extend an existing reference:</p>
<pre><code class="language-move">let s = S { f: 10 };
let f_ref1: &amp;u64 = &amp;s.f; // works
let s_ref: &amp;S = &amp;s;
let f_ref2: &amp;u64 = &amp;s_ref.f // also works
</code></pre>
<p>A reference expression with multiple fields works as long as both structs are in the same module:</p>
<pre><code class="language-move">public struct A { b: B }
public struct B { c : u64 }
fun f(a: &amp;A): &amp;u64 {
    &amp;a.b.c
}
</code></pre>
<p>Finally, note that references to references are not allowed:</p>
<pre><code class="language-move">let x = 7;
let y: &amp;u64 = &amp;x;
let z: &amp;&amp;u64 = &amp;y; // ERROR! will not compile
</code></pre>
<h2 id="reading-and-writing-through-references"><a class="header" href="#reading-and-writing-through-references">Reading and Writing Through References</a></h2>
<p>Both mutable and immutable references can be read to produce a copy of the referenced value.</p>
<p>Only mutable references can be written. A write <code>*x = v</code> discards the value previously stored in <code>x</code>
and updates it with <code>v</code>.</p>
<p>Both operations use the C-like <code>*</code> syntax. However, note that a read is an expression, whereas a
write is a mutation that must occur on the left hand side of an equals.</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>*e</code></td><td><code>T</code> where <code>e</code> is <code>&amp;T</code> or <code>&amp;mut T</code></td><td>Read the value pointed to by <code>e</code></td></tr>
<tr><td><code>*e1 = e2</code></td><td><code>()</code> where <code>e1: &amp;mut T</code> and <code>e2: T</code></td><td>Update the value in <code>e1</code> with <code>e2</code>.</td></tr>
</tbody></table>
</div>
<p>In order for a reference to be read, the underlying type must have the
<a href="primitive-types/../abilities.html"><code>copy</code> ability</a> as reading the reference creates a new copy of the value. This
rule prevents the copying of assets:</p>
<pre><code class="language-move">fun copy_coin_via_ref_bad(c: Coin) {
    let c_ref = &amp;c;
    let counterfeit: Coin = *c_ref; // not allowed!
    pay(c);
    pay(counterfeit);
}
</code></pre>
<p>Dually: in order for a reference to be written to, the underlying type must have the
<a href="primitive-types/../abilities.html"><code>drop</code> ability</a> as writing to the reference will discard (or &quot;drop&quot;) the old
value. This rule prevents the destruction of resource values:</p>
<pre><code class="language-move=">fun destroy_coin_via_ref_bad(mut ten_coins: Coin, c: Coin) {
    let ref = &amp;mut ten_coins;
    *ref = c; // ERROR! not allowed--would destroy 10 coins!
}
</code></pre>
<h2 id="freeze-inference"><a class="header" href="#freeze-inference"><code>freeze</code> inference</a></h2>
<p>A mutable reference can be used in a context where an immutable reference is expected:</p>
<pre><code class="language-move">let mut x = 7;
let y: &amp;u64 = &amp;mut x;
</code></pre>
<p>This works because the under the hood, the compiler inserts <code>freeze</code> instructions where they are
needed. Here are a few more examples of <code>freeze</code> inference in action:</p>
<pre><code class="language-move">fun takes_immut_returns_immut(x: &amp;u64): &amp;u64 { x }

// freeze inference on return value
fun takes_mut_returns_immut(x: &amp;mut u64): &amp;u64 { x }

fun expression_examples() {
    let mut x = 0;
    let mut y = 0;
    takes_immut_returns_immut(&amp;x); // no inference
    takes_immut_returns_immut(&amp;mut x); // inferred freeze(&amp;mut x)
    takes_mut_returns_immut(&amp;mut x); // no inference

    assert!(&amp;x == &amp;mut y, 42); // inferred freeze(&amp;mut y)
}

fun assignment_examples() {
    let x = 0;
    let y = 0;
    let imm_ref: &amp;u64 = &amp;x;

    imm_ref = &amp;x; // no inference
    imm_ref = &amp;mut y; // inferred freeze(&amp;mut y)
}
</code></pre>
<h3 id="subtyping"><a class="header" href="#subtyping">Subtyping</a></h3>
<p>With this <code>freeze</code> inference, the Move type checker can view <code>&amp;mut T</code> as a subtype of <code>&amp;T</code>. As shown
above, this means that anywhere for any expression where a <code>&amp;T</code> value is used, a <code>&amp;mut T</code> value can
also be used. This terminology is used in error messages to concisely indicate that a <code>&amp;mut T</code> was
needed where a <code>&amp;T</code> was supplied. For example</p>
<pre><code class="language-move">module a::example {
    fun read_and_assign(store: &amp;mut u64, new_value: &amp;u64) {
        *store = *new_value
    }

    fun subtype_examples() {
        let mut x: &amp;u64 = &amp;0;
        let mut y: &amp;mut u64 = &amp;mut 1;

        x = &amp;mut 1; // valid
        y = &amp;2; // ERROR! invalid!

        read_and_assign(y, x); // valid
        read_and_assign(x, y); // ERROR! invalid!
    }
}
</code></pre>
<p>will yield the following error messages</p>
<pre><code class="language-text">error:

     example.move:11:9 
    
 12          y = &amp;2; // invalid!
             ^ Invalid assignment to local 'y'
    
 12          y = &amp;2; // invalid!
                 -- The type: '&amp;{integer}'
    
  9          let mut y: &amp;mut u64 = &amp;mut 1;
                        -------- Is not a subtype of: '&amp;mut u64'
    

error:

     example.move:14:9 
    
 15          read_and_assign(x, y); // invalid!
             ^^^^^^^^^^^^^^^^^^^^^ Invalid call of 'a::example::read_and_assign'. Invalid argument for parameter 'store'
    
  8          let mut x: &amp;u64 = &amp;0;
                        ---- The type: '&amp;u64'
    
  3      fun read_and_assign(store: &amp;mut u64, new_value: &amp;u64) {
                                    -------- Is not a subtype of: '&amp;mut u64'
    
</code></pre>
<p>The only other types that currently have subtyping are <a href="primitive-types/./tuples.html">tuples</a></p>
<h2 id="ownership-3"><a class="header" href="#ownership-3">Ownership</a></h2>
<p>Both mutable and immutable references can always be copied and extended <em>even if there are existing
copies or extensions of the same reference</em>:</p>
<pre><code class="language-move">fun reference_copies(s: &amp;mut S) {
  let s_copy1 = s; // ok
  let s_extension = &amp;mut s.f; // also ok
  let s_copy2 = s; // still ok
  ...
}
</code></pre>
<p>This might be surprising for programmers familiar with Rust's ownership system, which would reject
the code above. Move's type system is more permissive in its treatment of
<a href="primitive-types/../variables.html#move-and-copy">copies</a>, but equally strict in ensuring unique ownership of mutable
references before writes.</p>
<h3 id="references-cannot-be-stored"><a class="header" href="#references-cannot-be-stored">References Cannot Be Stored</a></h3>
<p>References and tuples are the <em>only</em> types that cannot be stored as a field value of structs, which
also means that they cannot exist in storage or <a href="primitive-types/../abilities/object.html">objects</a>. All references
created during program execution will be destroyed when a Move program terminates; they are entirely
ephemeral. This also applies to all types without the <code>store</code> ability: any value of a non-<code>store</code>
type must be destroyed before the program terminates. <a href="primitive-types/../abilities.html">ability</a>, but note that
references and tuples go a step further by never being allowed in structs in the first place.</p>
<p>This is another difference between Move and Rust, which allows references to be stored inside of
structs.</p>
<p>One could imagine a fancier, more expressive, type system that would allow references to be stored
in structs. We could allow references inside of structs that do not have the <code>store</code>
<a href="primitive-types/../abilities.html">ability</a>, but the core difficulty is that Move has a fairly complex system for
tracking static reference safety. This aspect of the type system would also have to be extended to
support storing references inside of structs. In short, Move's reference safety system would have to
expand to support stored references, and it is something we are keeping an eye on as the language
evolves.</p>
<!-- TODO actually document a sketch of the borrow rules -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples-and-unit"><a class="header" href="#tuples-and-unit">Tuples and Unit</a></h1>
<p>Move does not fully support tuples as one might expect coming from another language with them as a
<a href="https://en.wikipedia.org/wiki/First-class_citizen">first-class value</a>. However, in order to support
multiple return values, Move has tuple-like expressions. These expressions do not result in a
concrete value at runtime (there are no tuples in the bytecode), and as a result they are very
limited:</p>
<ul>
<li>They can only appear in expressions (usually in the return position for a function).</li>
<li>They cannot be bound to local variables.</li>
<li>They cannot be bound to local variables.</li>
<li>They cannot be stored in structs.</li>
<li>Tuple types cannot be used to instantiate generics.</li>
</ul>
<p>Similarly, <a href="https://en.wikipedia.org/wiki/Unit_type">unit <code>()</code></a> is a type created by the Move source
language in order to be expression based. The unit value <code>()</code> does not result in any runtime value.
We can consider unit<code>()</code> to be an empty tuple, and any restrictions that apply to tuples also apply
to unit.</p>
<p>It might feel weird to have tuples in the language at all given these restrictions. But one of the
most common use cases for tuples in other languages is for functions to allow functions to return
multiple values. Some languages work around this by forcing the users to write structs that contain
the multiple return values. However in Move, you cannot put references inside of
<a href="primitive-types/../structs.html">structs</a>. This required Move to support multiple return values. These multiple
return values are all pushed on the stack at the bytecode level. At the source level, these multiple
return values are represented using tuples.</p>
<h2 id="literals-3"><a class="header" href="#literals-3">Literals</a></h2>
<p>Tuples are created by a comma separated list of expressions inside of parentheses.</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>()</code></td><td><code>(): ()</code></td><td>Unit, the empty tuple, or the tuple of arity 0</td></tr>
<tr><td><code>(e1, ..., en)</code></td><td><code>(e1, ..., en): (T1, ..., Tn)</code> where <code>e_i: Ti</code> s.t. <code>0 &lt; i &lt;= n</code> and <code>n &gt; 0</code></td><td>A <code>n</code>-tuple, a tuple of arity <code>n</code>, a tuple with <code>n</code> elements</td></tr>
</tbody></table>
</div>
<p>Note that <code>(e)</code> does not have type <code>(e): (t)</code>, in other words there is no tuple with one element. If
there is only a single element inside of the parentheses, the parentheses are only used for
disambiguation and do not carry any other special meaning.</p>
<p>Sometimes, tuples with two elements are called &quot;pairs&quot; and tuples with three elements are called
&quot;triples.&quot;</p>
<h3 id="examples-2"><a class="header" href="#examples-2">Examples</a></h3>
<pre><code class="language-move">module 0x42::example {
    // all 3 of these functions are equivalent

    // when no return type is provided, it is assumed to be `()`
    fun returns_unit_1() { }

    // there is an implicit () value in empty expression blocks
    fun returns_unit_2(): () { }

    // explicit version of `returns_unit_1` and `returns_unit_2`
    fun returns_unit_3(): () { () }


    fun returns_3_values(): (u64, bool, address) {
        (0, false, @0x42)
    }
    fun returns_4_values(x: &amp;u64): (&amp;u64, u8, u128, vector&lt;u8&gt;) {
        (x, 0, 1, b&quot;foobar&quot;)
    }
}
</code></pre>
<h2 id="operations-3"><a class="header" href="#operations-3">Operations</a></h2>
<p>The only operation that can be done on tuples currently is destructuring.</p>
<h3 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h3>
<p>For tuples of any size, they can be destructured in either a <code>let</code> binding or in an assignment.</p>
<p>For example:</p>
<pre><code class="language-move">module 0x42::example {
    // all 3 of these functions are equivalent
    fun returns_unit() {}
    fun returns_2_values(): (bool, bool) { (true, false) }
    fun returns_4_values(x: &amp;u64): (&amp;u64, u8, u128, vector&lt;u8&gt;) { (x, 0, 1, b&quot;foobar&quot;) }

    fun examples(cond: bool) {
        let () = ();
        let (mut x, mut y): (u8, u64) = (0, 1);
        let (mut a, mut b, mut c, mut d) = (@0x0, 0, false, b&quot;&quot;);

        () = ();
        (x, y) = if (cond) (1, 2) else (3, 4);
        (a, b, c, d) = (@0x1, 1, true, b&quot;1&quot;);
    }

    fun examples_with_function_calls() {
        let () = returns_unit();
        let (mut x, mut y): (bool, bool) = returns_2_values();
        let (mut a, mut b, mut c, mut d) = returns_4_values(&amp;0);

        () = returns_unit();
        (x, y) = returns_2_values();
        (a, b, c, d) = returns_4_values(&amp;1);
    }
}
</code></pre>
<p>For more details, see <a href="primitive-types/../variables.html">Move Variables</a>.</p>
<h2 id="subtyping-1"><a class="header" href="#subtyping-1">Subtyping</a></h2>
<p>Along with references, tuples are the only types that have
<a href="https://en.wikipedia.org/wiki/Subtyping">subtyping</a> in Move. Tuples have subtyping only in the
sense that subtype with references (in a covariant way).</p>
<p>For example:</p>
<pre><code class="language-move">let x: &amp;u64 = &amp;0;
let y: &amp;mut u64 = &amp;mut 1;

// (&amp;u64, &amp;mut u64) is a subtype of (&amp;u64, &amp;u64)
// since &amp;mut u64 is a subtype of &amp;u64
let (a, b): (&amp;u64, &amp;u64) = (x, y);

// (&amp;mut u64, &amp;mut u64) is a subtype of (&amp;u64, &amp;u64)
// since &amp;mut u64 is a subtype of &amp;u64
let (c, d): (&amp;u64, &amp;u64) = (y, y);

// ERROR! (&amp;u64, &amp;mut u64) is NOT a subtype of (&amp;mut u64, &amp;mut u64)
// since &amp;u64 is NOT a subtype of &amp;mut u64
let (e, f): (&amp;mut u64, &amp;mut u64) = (x, y);
</code></pre>
<h2 id="ownership-4"><a class="header" href="#ownership-4">Ownership</a></h2>
<p>As mentioned above, tuple values don't really exist at runtime. And currently they cannot be stored
into local variables because of this (but it is likely that this feature will come at some point in
the future). As such, tuples can only be moved currently, as copying them would require putting them
into a local variable first.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-variables-and-scope"><a class="header" href="#local-variables-and-scope">Local Variables and Scope</a></h1>
<p>Local variables in Move are lexically (statically) scoped. New variables are introduced with the
keyword <code>let</code>, which will shadow any previous local with the same name. Locals marked as <code>mut</code> are
mutable and can be updated both directly and via a mutable reference.</p>
<h2 id="declaring-local-variables"><a class="header" href="#declaring-local-variables">Declaring Local Variables</a></h2>
<h3 id="let-bindings"><a class="header" href="#let-bindings"><code>let</code> bindings</a></h3>
<p>Move programs use <code>let</code> to bind variable names to values:</p>
<pre><code class="language-move">let x = 1;
let y = x + x:
</code></pre>
<p><code>let</code> can also be used without binding a value to the local.</p>
<pre><code class="language-move">let x;
</code></pre>
<p>The local can then be assigned a value later.</p>
<pre><code class="language-move">let x;
if (cond) {
  x = 1
} else {
  x = 0
}
</code></pre>
<p>This can be very helpful when trying to extract a value from a loop when a default value cannot be
provided.</p>
<pre><code class="language-move">let x;
let cond = true;
let i = 0;
loop {
    let (res, cond) = foo(i);
    if (!cond) {
        x = res;
        break;
    };
    i = i + 1;
}
</code></pre>
<p>To modify a local variable <em>after</em> it is assigned, or to borrow it mutably <code>&amp;mut</code>, it must be
declared as <code>mut</code>.</p>
<pre><code class="language-move">let mut x = 0;
if (cond) x = x + 1;
foo(&amp;mut x);
</code></pre>
<p>For more details see the section on <a href="variables.html#assignments">assignments</a> below.</p>
<h3 id="variables-must-be-assigned-before-use"><a class="header" href="#variables-must-be-assigned-before-use">Variables must be assigned before use</a></h3>
<p>Move's type system prevents a local variable from being used before it has been assigned.</p>
<pre><code class="language-move">let x;
x + x // ERROR! x is used before being assigned
</code></pre>
<pre><code class="language-move">let x;
if (cond) x = 0;
x + x // ERROR! x does not have a value in all cases
</code></pre>
<pre><code class="language-move">let x;
while (cond) x = 0;
x + x // ERROR! x does not have a value in all cases
</code></pre>
<h3 id="valid-variable-names"><a class="header" href="#valid-variable-names">Valid variable names</a></h3>
<p>Variable names can contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, and digits <code>0</code>
to <code>9</code>. Variable names must start with either an underscore <code>_</code> or a letter <code>a</code> through <code>z</code>. They
<em>cannot</em> start with uppercase letters.</p>
<pre><code class="language-move">// all valid
let x = e;
let _x = e;
let _A = e;
let x0 = e;
let xA = e;
let foobar_123 = e;

// all invalid
let X = e; // ERROR!
let Foo = e; // ERROR!
</code></pre>
<h3 id="type-annotations"><a class="header" href="#type-annotations">Type annotations</a></h3>
<p>The type of a local variable can almost always be inferred by Move's type system. However, Move
allows explicit type annotations that can be useful for readability, clarity, or debuggability. The
syntax for adding a type annotation is:</p>
<pre><code class="language-move">let x: T = e; // &quot;Variable x of type T is initialized to expression e&quot;
</code></pre>
<p>Some examples of explicit type annotations:</p>
<pre><code class="language-move">module 0x42::example {

    public struct S { f: u64, g: u64 }

    fun annotated() {
        let u: u8 = 0;
        let b: vector&lt;u8&gt; = b&quot;hello&quot;;
        let a: address = @0x0;
        let (x, y): (&amp;u64, &amp;mut u64) = (&amp;0, &amp;mut 1);
        let S { f, g: f2 }: S = S { f: 0, g: 1 };
    }
}
</code></pre>
<p>Note that the type annotations must always be to the right of the pattern:</p>
<pre><code class="language-move">// ERROR! should be let (x, y): (&amp;u64, &amp;mut u64) = ...
let (x: &amp;u64, y: &amp;mut u64) = (&amp;0, &amp;mut 1);
</code></pre>
<h3 id="when-annotations-are-necessary"><a class="header" href="#when-annotations-are-necessary">When annotations are necessary</a></h3>
<p>In some cases, a local type annotation is required if the type system cannot infer the type. This
commonly occurs when the type argument for a generic type cannot be inferred. For example:</p>
<pre><code class="language-move">let _v1 = vector[]; // ERROR!
//        ^^^^^^^^ Could not infer this type. Try adding an annotation
let v2: vector&lt;u64&gt; = vector[]; // no error
</code></pre>
<p>In a rarer case, the type system might not be able to infer a type for divergent code (where all the
following code is unreachable). Both <a href="./functions.html#return-expression"><code>return</code></a> and
<a href="./abort-and-assert.html"><code>abort</code></a> are expressions and can have any type. A
<a href="./control-flow/loops.html"><code>loop</code></a> has type <code>()</code> if it has a <code>break</code> (or <code>T</code> if has a <code>break e</code> where
<code>e: T</code>), but if there is no break out of the <code>loop</code>, it could have any type. If these types cannot
be inferred, a type annotation is required. For example, this code:</p>
<pre><code class="language-move">let a: u8 = return ();
let b: bool = abort 0;
let c: signer = loop ();

let x = return (); // ERROR!
//  ^ Could not infer this type. Try adding an annotation
let y = abort 0; // ERROR!
//  ^ Could not infer this type. Try adding an annotation
let z = loop (); // ERROR!
//  ^ Could not infer this type. Try adding an annotation
</code></pre>
<p>Adding type annotations to this code will expose other errors about dead code or unused local
variables, but the example is still helpful for understanding this problem.</p>
<h3 id="multiple-declarations-with-tuples"><a class="header" href="#multiple-declarations-with-tuples">Multiple declarations with tuples</a></h3>
<p><code>let</code> can introduce more than one local at a time using tuples. The locals declared inside the
parenthesis are initialized to the corresponding values from the tuple.</p>
<pre><code class="language-move">let () = ();
let (x0, x1) = (0, 1);
let (y0, y1, y2) = (0, 1, 2);
let (z0, z1, z2, z3) = (0, 1, 2, 3);
</code></pre>
<p>The type of the expression must match the arity of the tuple pattern exactly.</p>
<pre><code class="language-move">let (x, y) = (0, 1, 2); // ERROR!
let (x, y, z, q) = (0, 1, 2); // ERROR!
</code></pre>
<p>You cannot declare more than one local with the same name in a single <code>let</code>.</p>
<pre><code class="language-move">let (x, x) = 0; // ERROR!
</code></pre>
<p>The mutability of the local variables declared can be mixed.</p>
<pre><code class="language-move">let (mut x, y) = (0, 1);
x = 1;
</code></pre>
<h3 id="multiple-declarations-with-structs"><a class="header" href="#multiple-declarations-with-structs">Multiple declarations with structs</a></h3>
<p><code>let</code> can also introduce more than one local variables at a time when destructuring (or matching against) a
struct. In this form, the <code>let</code> creates a set of local variables that are initialized to the values
of the fields from a struct. The syntax looks like this:</p>
<pre><code class="language-move">public struct T { f1: u64, f2: u64 }
</code></pre>
<pre><code class="language-move">let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
// local1: u64
// local2: u64
</code></pre>
<p>Similarly for positional structs</p>
<pre><code class="language-move">public struct P(u64, u64)
</code></pre>
<p>and</p>
<pre><code class="language-move">let P (local1, local2) = P ( 1, 2 );
// local1: u64
// local2: u64
</code></pre>
<p>Here is a more complicated example:</p>
<pre><code class="language-move">module 0x42::example {
    public struct X(u64)
    public struct Y { x1: X, x2: X }

    fun new_x(): X {
        X(1)
    }

    fun example() {
        let Y { x1: X(f), x2 } = Y { x1: new_x(), x2: new_x() };
        assert!(f + x2.f == 2, 42);

        let Y { x1: X(f1), x2: X(f2) } = Y { x1: new_x(), x2: new_x() };
        assert!(f1 + f2 == 2, 42);
    }
}
</code></pre>
<p>Fields of structs can serve double duty, identifying the field to bind <em>and</em> the name of the
variable. This is sometimes referred to as punning.</p>
<pre><code class="language-move">let Y { x1, x2 } = e;
</code></pre>
<p>is equivalent to:</p>
<pre><code class="language-move">let Y { x1: x1, x2: x2 } = e;
</code></pre>
<p>As shown with tuples, you cannot declare more than one local with the same name in a single <code>let</code>.</p>
<pre><code class="language-move">let Y { x1: x, x2: x } = e; // ERROR!
</code></pre>
<p>And as with tuples, the mutability of the local variables declared can be mixed.</p>
<pre><code class="language-move">let Y { x1: mut x1, x2 } = e;
</code></pre>
<p>Furthermore, the mutability of annotation can be applied to the punned fields. Giving the equivalent
example</p>
<pre><code class="language-move">let Y { mut x1, x2 } = e;
</code></pre>
<h3 id="destructuring-against-references"><a class="header" href="#destructuring-against-references">Destructuring against references</a></h3>
<p>In the examples above for structs, the bound value in the let was moved, destroying the struct value
and binding its fields.</p>
<pre><code class="language-move">public struct T { f1: u64, f2: u64 }
</code></pre>
<pre><code class="language-move">let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
// local1: u64
// local2: u64
</code></pre>
<p>In this scenario the struct value <code>T { f1: 1, f2: 2 }</code> no longer exists after the <code>let</code>.</p>
<p>If you wish instead to not move and destroy the struct value, you can borrow each of its fields. For
example:</p>
<pre><code class="language-move">let t = T { f1: 1, f2: 2 };
let T { f1: local1, f2: local2 } = &amp;t;
// local1: &amp;u64
// local2: &amp;u64
</code></pre>
<p>And similarly with mutable references:</p>
<pre><code class="language-move">let mut t = T { f1: 1, f2: 2 };
let T { f1: local1, f2: local2 } = &amp;mut t;
// local1: &amp;mut u64
// local2: &amp;mut u64
</code></pre>
<p>This behavior can also work with nested structs.</p>
<pre><code class="language-move">module 0x42::example {
    public struct X(u64)
    public struct Y { x1: X, x2: X }

    fun new_x(): X {
        X(1)
    }

    fun example() {
        let mut y = Y { x1: new_x(), x2: new_x() };

        let Y { x1: X(f), x2 } = &amp;y;
        assert!(*f + x2.f == 2, 42);

        let Y { x1: X(f1), x2: X(f2) } = &amp;mut y;
        *f1 = *f1 + 1;
        *f2 = *f2 + 1;
        assert!(*f1 + *f2 == 4, 42);
    }
}
</code></pre>
<h3 id="ignoring-values"><a class="header" href="#ignoring-values">Ignoring Values</a></h3>
<p>In <code>let</code> bindings, it is often helpful to ignore some values. Local variables that start with <code>_</code>
will be ignored and not introduce a new variable</p>
<pre><code class="language-move">fun three(): (u64, u64, u64) {
    (0, 1, 2)
}
</code></pre>
<pre><code class="language-move">let (x1, _, z1) = three();
let (x2, _y, z2) = three();
assert!(x1 + z1 == x2 + z2, 42);
</code></pre>
<p>This can be necessary at times as the compiler will warn on unused local variables</p>
<pre><code class="language-move">let (x1, y, z1) = three(); // WARNING!
//       ^ unused local 'y'
</code></pre>
<h3 id="general-let-grammar"><a class="header" href="#general-let-grammar">General <code>let</code> grammar</a></h3>
<p>All of the different structures in <code>let</code> can be combined! With that we arrive at this general
grammar for <code>let</code> statements:</p>
<blockquote>
<p><em>let-binding</em>  <strong>let</strong> <em>pattern-or-list</em> <em>type-annotation</em><sub><em>opt</em></sub> &gt;
<em>initializer</em><sub><em>opt</em></sub> &gt; <em>pattern-or-list</em>  <em>pattern</em> | <strong>(</strong> <em>pattern-list</em> <strong>)</strong> &gt;
<em>pattern-list</em>  <em>pattern</em> <strong>,</strong><sub><em>opt</em></sub> | <em>pattern</em> <strong>,</strong> <em>pattern-list</em> &gt;
<em>type-annotation</em>  <strong>:</strong> <em>type</em> <em>initializer</em>  <strong>=</strong> <em>expression</em></p>
</blockquote>
<p>The general term for the item that introduces the bindings is a <em>pattern</em>. The pattern serves to
both destructure data (possibly recursively) and introduce the bindings. The pattern grammar is as
follows:</p>
<blockquote>
<p><em>pattern</em>  <em>local-variable</em> | <em>struct-type</em> <strong>{</strong> <em>field-binding-list</em> <strong>}</strong> &gt;
<em>field-binding-list</em>  <em>field-binding</em> <strong>,</strong><sub><em>opt</em></sub> | <em>field-binding</em> <strong>,</strong> &gt;
<em>field-binding-list</em> &gt; <em>field-binding</em>  <em>field</em> | <em>field</em> <strong>:</strong> <em>pattern</em></p>
</blockquote>
<p>A few concrete examples with this grammar applied:</p>
<pre><code class="language-move">    let (x, y): (u64, u64) = (0, 1);
//       ^                           local-variable
//       ^                           pattern
//          ^                        local-variable
//          ^                        pattern
//          ^                        pattern-list
//       ^^^^                        pattern-list
//      ^^^^^^                       pattern-or-list
//            ^^^^^^^^^^^^           type-annotation
//                         ^^^^^^^^  initializer
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding

    let Foo { f, g: x } = Foo { f: 0, g: 1 };
//      ^^^                                    struct-type
//            ^                                field
//            ^                                field-binding
//               ^                             field
//                  ^                          local-variable
//                  ^                          pattern
//               ^^^^                          field-binding
//            ^^^^^^^                          field-binding-list
//      ^^^^^^^^^^^^^^^                        pattern
//      ^^^^^^^^^^^^^^^                        pattern-or-list
//                      ^^^^^^^^^^^^^^^^^^^^   initializer
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding
</code></pre>
<h2 id="mutations"><a class="header" href="#mutations">Mutations</a></h2>
<h3 id="assignments"><a class="header" href="#assignments">Assignments</a></h3>
<p>After the local is introduced (either by <code>let</code> or as a function parameter), a <code>mut</code> local can be
modified via an assignment:</p>
<pre><code class="language-move">x = e
</code></pre>
<p>Unlike <code>let</code> bindings, assignments are expressions. In some languages, assignments return the value
that was assigned, but in Move, the type of any assignment is always <code>()</code>.</p>
<pre><code class="language-move">(x = e: ())
</code></pre>
<p>Practically, assignments being expressions means that they can be used without adding a new
expression block with braces (<code>{</code>...<code>}</code>).</p>
<pre><code class="language-move">let x;
if (cond) x = 1 else x = 2;
</code></pre>
<p>The assignment uses the similar pattern syntax scheme as <code>let</code> bindings, but with absence of <code>mut</code>:</p>
<pre><code class="language-move">module 0x42::example {
    public struct X { f: u64 }

    fun new_x(): X {
        X { f: 1 }
    }

    // Note: this example will complain about unused variables and assignments.
    fun example() {
       let (mut x, mut y, mut f, mut g) = (0, 0, 0, 0);

       (X { f }, X { f: x }) = (new_x(), new_x());
       assert!(f + x == 2, 42);

       (x, y, f, _, g) = (0, 0, 0, 0, 0);
    }
}
</code></pre>
<p>Note that a local variable can only have one type, so the type of the local cannot change between
assignments.</p>
<pre><code class="language-move">let mut x;
x = 0;
x = false; // ERROR!
</code></pre>
<h3 id="mutating-through-a-reference"><a class="header" href="#mutating-through-a-reference">Mutating through a reference</a></h3>
<p>In addition to directly modifying a local with assignment, a <code>mut</code> local can be modified via a
mutable reference <code>&amp;mut</code>.</p>
<pre><code class="language-move">let mut x = 0;
let r = &amp;mut x;
*r = 1;
assert!(x == 1, 42);
</code></pre>
<p>This is particularly useful if either:</p>
<p>(1) You want to modify different variables depending on some condition.</p>
<pre><code class="language-move">let mut x = 0;
let mut y = 1;
let r = if (cond) &amp;mut x else &amp;mut y;
*r = *r + 1;
</code></pre>
<p>(2) You want another function to modify your local value.</p>
<pre><code class="language-move">let mut x = 0;
modify_ref(&amp;mut x);
</code></pre>
<p>This sort of modification is how you modify structs and vectors!</p>
<pre><code class="language-move">let mut v = vector[];
vector::push_back(&amp;mut v, 100);
assert!(*vector::borrow(&amp;v, 0) == 100, 42);
</code></pre>
<p>For more details, see <a href="./primitive-types/references.html">Move references</a>.</p>
<h2 id="scopes"><a class="header" href="#scopes">Scopes</a></h2>
<p>Any local declared with <code>let</code> is available for any subsequent expression, <em>within that scope</em>.
Scopes are declared with expression blocks, <code>{</code>...<code>}</code>.</p>
<p>Locals cannot be used outside of the declared scope.</p>
<pre><code class="language-move">let x = 0;
{
    let y = 1;
};
x + y // ERROR!
//  ^ unbound local 'y'
</code></pre>
<p>But, locals from an outer scope <em>can</em> be used in a nested scope.</p>
<pre><code class="language-move">{
    let x = 0;
    {
        let y = x + 1; // valid
    }
}
</code></pre>
<p>Locals can be mutated in any scope where they are accessible. That mutation survives with the local,
regardless of the scope that performed the mutation.</p>
<pre><code class="language-move">let mut x = 0;
x = x + 1;
assert!(x == 1, 42);
{
    x = x + 1;
    assert!(x == 2, 42);
};
assert!(x == 2, 42);
</code></pre>
<h3 id="expression-blocks"><a class="header" href="#expression-blocks">Expression Blocks</a></h3>
<p>An expression block is a series of statements separated by semicolons (<code>;</code>). The resulting value of
an expression block is the value of the last expression in the block.</p>
<pre><code class="language-move">{ let x = 1; let y = 1; x + y }
</code></pre>
<p>In this example, the result of the block is <code>x + y</code>.</p>
<p>A statement can be either a <code>let</code> declaration or an expression. Remember that assignments (<code>x = e</code>)
are expressions of type <code>()</code>.</p>
<pre><code class="language-move">{ let x; let y = 1; x = 1; x + y }
</code></pre>
<p>Function calls are another common expression of type <code>()</code>. Function calls that modify data are
commonly used as statements.</p>
<pre><code class="language-move">{ let v = vector[]; vector::push_back(&amp;mut v, 1); v }
</code></pre>
<p>This is not just limited to <code>()</code> types---any expression can be used as a statement in a sequence!</p>
<pre><code class="language-move">{
    let x = 0;
    x + 1; // value is discarded
    x + 2; // value is discarded
    b&quot;hello&quot;; // value is discarded
}
</code></pre>
<p>But! If the expression contains a resource (a value without the <code>drop</code> <a href="./abilities.html">ability</a>),
you will get an error. This is because Move's type system guarantees that any value that is dropped
has the <code>drop</code> <a href="./abilities.html">ability</a>. (Ownership must be transferred or the value must be
explicitly destroyed within its declaring module.)</p>
<pre><code class="language-move">{
    let x = 0;
    Coin { value: x }; // ERROR!
//  ^^^^^^^^^^^^^^^^^ unused value without the `drop` ability
    x
}
</code></pre>
<p>If a final expression is not present in a block---that is, if there is a trailing semicolon <code>;</code>,
there is an implicit <a href="https://en.wikipedia.org/wiki/Unit_type">unit <code>()</code> value</a>. Similarly, if the
expression block is empty, there is an implicit unit <code>()</code> value.</p>
<p>Both are equivalent</p>
<pre><code class="language-move">{ x = x + 1; 1 / x; }
</code></pre>
<pre><code class="language-move">{ x = x + 1; 1 / x; () }
</code></pre>
<p>Similarly both are equivalent</p>
<pre><code class="language-move">{ }
</code></pre>
<pre><code class="language-move">{ () }
</code></pre>
<p>An expression block is itself an expression and can be used anyplace an expression is used. (Note:
The body of a function is also an expression block, but the function body cannot be replaced by
another expression.)</p>
<pre><code class="language-move">let my_vector: vector&lt;vector&lt;u8&gt;&gt; = {
    let mut v = vector[];
    vector::push_back(&amp;mut v, b&quot;hello&quot;);
    vector::push_back(&amp;mut v, b&quot;goodbye&quot;);
    v
};
</code></pre>
<p>(The type annotation is not needed in this example and only added for clarity.)</p>
<h3 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h3>
<p>If a <code>let</code> introduces a local variable with a name already in scope, that previous variable can no
longer be accessed for the rest of this scope. This is called <em>shadowing</em>.</p>
<pre><code class="language-move">let x = 0;
assert!(x == 0, 42);

let x = 1; // x is shadowed
assert!(x == 1, 42);
</code></pre>
<p>When a local is shadowed, it does not need to retain the same type as before.</p>
<pre><code class="language-move">let x = 0;
assert!(x == 0, 42);

let x = b&quot;hello&quot;; // x is shadowed
assert!(x == b&quot;hello&quot;, 42);
</code></pre>
<p>After a local is shadowed, the value stored in the local still exists, but will no longer be
accessible. This is important to keep in mind with values of types without the
<a href="./abilities.html"><code>drop</code> ability</a>, as ownership of the value must be transferred by the end of the
function.</p>
<pre><code class="language-move">module 0x42::example {
    public struct Coin has store { value: u64 }

    fun unused_coin(): Coin {
        let x = Coin { value: 0 }; // ERROR!
//          ^ This local still contains a value without the `drop` ability
        x.value = 1;
        let x = Coin { value: 10 };
        x
//      ^ Invalid return
    }
}
</code></pre>
<p>When a local is shadowed inside a scope, the shadowing only remains for that scope. The shadowing is
gone once that scope ends.</p>
<pre><code class="language-move">let x = 0;
{
    let x = 1;
    assert!(x == 1, 42);
};
assert!(x == 0, 42);
</code></pre>
<p>Remember, locals can change type when they are shadowed.</p>
<pre><code class="language-move">let x = 0;
{
    let x = b&quot;hello&quot;;
    assert!(x = b&quot;hello&quot;, 42);
};
assert!(x == 0, 42);
</code></pre>
<h2 id="move-and-copy"><a class="header" href="#move-and-copy">Move and Copy</a></h2>
<p>All local variables in Move can be used in two ways, either by <code>move</code> or <code>copy</code>. If one or the other
is not specified, the Move compiler is able to infer whether a <code>copy</code> or a <code>move</code> should be used.
This means that in all of the examples above, a <code>move</code> or a <code>copy</code> would be inserted by the
compiler. A local variable cannot be used without the use of <code>move</code> or <code>copy</code>.</p>
<p><code>copy</code> will likely feel the most familiar coming from other programming languages, as it creates a
new copy of the value inside of the variable to use in that expression. With <code>copy</code>, the local
variable can be used more than once.</p>
<pre><code class="language-move">let x = 0;
let y = copy x + 1;
let z = copy x + 2;
</code></pre>
<p>Any value with the <code>copy</code> <a href="./abilities.html">ability</a> can be copied in this way, and will be copied
implicitly unless a <code>move</code> is specified.</p>
<p><code>move</code> takes the value out of the local variable <em>without</em> copying the data. After a <code>move</code> occurs,
the local variable is unavailable, even if the value's type has the <code>copy</code>
<a href="./abilities.html">ability</a>.</p>
<pre><code class="language-move">let x = 1;
let y = move x + 1;
//      ------ Local was moved here
let z = move x + 2; // Error!
//      ^^^^^^ Invalid usage of local 'x'
y + z
</code></pre>
<h3 id="safety"><a class="header" href="#safety">Safety</a></h3>
<p>Move's type system will prevent a value from being used after it is moved. This is the same safety
check described in <a href="variables.html#let-bindings"><code>let</code> declaration</a> that prevents local variables from being used
before it is assigned a value.</p>
<!-- For more information, see TODO future section on ownership and move semantics. -->
<h3 id="inference"><a class="header" href="#inference">Inference</a></h3>
<p>As mentioned above, the Move compiler will infer a <code>copy</code> or <code>move</code> if one is not indicated. The
algorithm for doing so is quite simple:</p>
<ul>
<li>Any value with the <code>copy</code> <a href="./abilities.html">ability</a> is given a <code>copy</code>.</li>
<li>Any reference (both mutable <code>&amp;mut</code> and immutable <code>&amp;</code>) is given a <code>copy</code>.
<ul>
<li>Except under special circumstances where it is made a <code>move</code> for predictable borrow checker
errors. This will happen once the reference is no longer used.</li>
</ul>
</li>
<li>Any other value is given a <code>move</code>.</li>
</ul>
<p>Given the structs</p>
<pre><code class="language-move">public struct Foo has copy, drop, store { f: u64 }
public struct Coin has store { value: u64 }
</code></pre>
<p>we have the following example</p>
<pre><code class="language-move">let s = b&quot;hello&quot;;
let foo = Foo { f: 0 };
let coin = Coin { value: 0 };
let coins = vector[Coin { value: 0 }, Coin { value: 0 }];

let s2 = s; // copy
let foo2 = foo; // copy
let coin2 = coin; // move
let coins2 = coin; // move

let x = 0;
let b = false;
let addr = @0x42;
let x_ref = &amp;x;
let coin_ref = &amp;mut coin2;

let x2 = x; // copy
let b2 = b; // copy
let addr2 = @0x42; // copy
let x_ref2 = x_ref; // copy
let coin_ref2 = coin_ref; // copy
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="equality-1"><a class="header" href="#equality-1">Equality</a></h1>
<p>Move supports two equality operations <code>==</code> and <code>!=</code></p>
<h2 id="operations-4"><a class="header" href="#operations-4">Operations</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Operation</th><th>Description</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>equal</td><td>Returns <code>true</code> if the two operands have the same value, <code>false</code> otherwise</td></tr>
<tr><td><code>!=</code></td><td>not equal</td><td>Returns <code>true</code> if the two operands have different values, <code>false</code> otherwise</td></tr>
</tbody></table>
</div>
<h3 id="typing"><a class="header" href="#typing">Typing</a></h3>
<p>Both the equal (<code>==</code>) and not-equal (<code>!=</code>) operations only work if both operands are the same type</p>
<pre><code class="language-move">0 == 0; // `true`
1u128 == 2u128; // `false`
b&quot;hello&quot; != x&quot;00&quot;; // `true`
</code></pre>
<p>Equality and non-equality also work over <em>all</em> user defined types!</p>
<pre><code class="language-move=">module 0x42::example {
    public struct S has copy, drop { f: u64, s: vector&lt;u8&gt; }

    fun always_true(): bool {
        let s = S { f: 0, s: b&quot;&quot; };
        s == s
    }

    fun always_false(): bool {
        let s = S { f: 0, s: b&quot;&quot; };
        s != s
    }
}
</code></pre>
<p>If the operands have different types, there is a type checking error</p>
<pre><code class="language-move">1u8 == 1u128; // ERROR!
//     ^^^^^ expected an argument of type 'u8'
b&quot;&quot; != 0; // ERROR!
//     ^ expected an argument of type 'vector&lt;u8&gt;'
</code></pre>
<h3 id="typing-with-references"><a class="header" href="#typing-with-references">Typing with references</a></h3>
<p>When comparing <a href="./primitive-types/references.html">references</a>, the type of the reference (immutable
or mutable) does not matter. This means that you can compare an immutable <code>&amp;</code> reference with a
mutable one <code>&amp;mut</code> of the same underlying type.</p>
<pre><code class="language-move">let i = &amp;0;
let m = &amp;mut 1;

i == m; // `false`
m == i; // `false`
m == m; // `true`
i == i; // `true`
</code></pre>
<p>The above is equivalent to applying an explicit freeze to each mutable reference where needed</p>
<pre><code class="language-move">let i = &amp;0;
let m = &amp;mut 1;

i == freeze(m); // `false`
freeze(m) == i; // `false`
m == m; // `true`
i == i; // `true`
</code></pre>
<p>But again, the underlying type must be the same type</p>
<pre><code class="language-move">let i = &amp;0;
let s = &amp;b&quot;&quot;;

i == s; // ERROR!
//   ^ expected an argument of type '&amp;u64'
</code></pre>
<h3 id="automatic-borrowing"><a class="header" href="#automatic-borrowing">Automatic Borrowing</a></h3>
<p>Starting in Move 2024 edition, the <code>==</code> and <code>!=</code> operators automatically borrow their operands if
one of the operands is a reference and the other is not. This means that the following code works
without any errors:</p>
<pre><code class="language-move">let r = &amp;0;

// In all cases, `0` is automatically borrowed as `&amp;0`
r == 0; // `true`
0 == r; // `true`
r != 0; // `false`
0 != r; // `false`
</code></pre>
<p>This automatic borrow is always an immutable borrow.</p>
<h2 id="restrictions"><a class="header" href="#restrictions">Restrictions</a></h2>
<p>Both <code>==</code> and <code>!=</code> consume the value when comparing them. As a result, the type system enforces that
the type must have <a href="./abilities.html"><code>drop</code></a>. Recall that without the
<a href="./abilities.html"><code>drop</code> ability</a>, ownership must be transferred by the end of the function, and such
values can only be explicitly destroyed within their declaring module. If these were used directly
with either equality <code>==</code> or non-equality <code>!=</code>, the value would be destroyed which would break
<a href="./abilities.html"><code>drop</code> ability</a> safety guarantees!</p>
<pre><code class="language-move=">module 0x42::example {
    public struct Coin has store { value: u64 }
    fun invalid(c1: Coin, c2: Coin) {
        c1 == c2 // ERROR!
//      ^^    ^^ These assets would be destroyed!
    }
}
</code></pre>
<p>But, a programmer can <em>always</em> borrow the value first instead of directly comparing the value, and
reference types have the <a href="./abilities.html"><code>drop</code> ability</a>. For example</p>
<pre><code class="language-move=">module 0x42::example {
    public struct Coin has store { value: u64 }
    fun swap_if_equal(c1: Coin, c2: Coin): (Coin, Coin) {
        let are_equal = &amp;c1 == c2; // valid, note `c2` is automatically borrowed
        if (are_equal) (c2, c1) else (c1, c2)
    }
}
</code></pre>
<h2 id="avoid-extra-copies"><a class="header" href="#avoid-extra-copies">Avoid Extra Copies</a></h2>
<p>While a programmer <em>can</em> compare any value whose type has <a href="./abilities.html"><code>drop</code></a>, a programmer
should often compare by reference to avoid expensive copies.</p>
<pre><code class="language-move=">let v1: vector&lt;u8&gt; = function_that_returns_vector();
let v2: vector&lt;u8&gt; = function_that_returns_vector();
assert!(copy v1 == copy v2, 42);
//      ^^^^       ^^^^
use_two_vectors(v1, v2);

let s1: Foo = function_that_returns_large_struct();
let s2: Foo = function_that_returns_large_struct();
assert!(copy s1 == copy s2, 42);
//      ^^^^       ^^^^
use_two_foos(s1, s2);
</code></pre>
<p>This code is perfectly acceptable (assuming <code>Foo</code> has <a href="./abilities.html"><code>drop</code></a>), just not efficient.
The highlighted copies can be removed and replaced with borrows</p>
<pre><code class="language-move=">let v1: vector&lt;u8&gt; = function_that_returns_vector();
let v2: vector&lt;u8&gt; = function_that_returns_vector();
assert!(&amp;v1 == &amp;v2, 42);
//      ^      ^
use_two_vectors(v1, v2);

let s1: Foo = function_that_returns_large_struct();
let s2: Foo = function_that_returns_large_struct();
assert!(&amp;s1 == &amp;s2, 42);
//      ^      ^
use_two_foos(s1, s2);
</code></pre>
<p>The efficiency of the <code>==</code> itself remains the same, but the <code>copy</code>s are removed and thus the program
is more efficient.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abort-and-assert"><a class="header" href="#abort-and-assert">Abort and Assert</a></h1>
<p><a href="./functions.html"><code>return</code></a> and <code>abort</code> are two control flow constructs that end execution, one for
the current function and one for the entire transaction.</p>
<p>More information on <a href="./functions.html#return-expression"><code>return</code> can be found in the linked section</a></p>
<h2 id="abort"><a class="header" href="#abort"><code>abort</code></a></h2>
<p><code>abort</code> is an expression that takes one argument: an <strong>abort code</strong> of type <code>u64</code>. For example:</p>
<pre><code class="language-move">abort 42
</code></pre>
<p>The <code>abort</code> expression halts execution the current function and reverts all changes made to state by
the current transaction (note though that this guarantee must be upheld by the adapter of the
specific deployment of Move). There is no mechanism for &quot;catching&quot; or otherwise handling an <code>abort</code>.</p>
<p>Luckily, in Move transactions are all or nothing, meaning any changes to storage are made all at
once only if the transaction succeeds. For Sui, this means no objects are modified.</p>
<p>Because of this transactional commitment of changes, after an abort there is no need to worry about
backing out changes. While this approach is lacking in flexibility, it is incredibly simple and
predictable.</p>
<p>Similar to <a href="./functions.html"><code>return</code></a>, <code>abort</code> is useful for exiting control flow when some
condition cannot be met.</p>
<p>In this example, the function will pop two items off of the vector, but will abort early if the
vector does not have two items</p>
<!-- // Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

module ref::abort_and_assert {

} -->
<pre><code class="language-move">use std::vector;

fun pop_twice&lt;T&gt;(v: &amp;mut vector&lt;T&gt;): (T, T) {
    if (vector::length(v) &lt; 2) abort 42;
    (vector::pop_back(v), vector::pop_back(v))
}
</code></pre>
<p>This is even more useful deep inside a control-flow construct. For example, this function checks
that all numbers in the vector are less than the specified <code>bound</code>. And aborts otherwise</p>
<pre><code class="language-move">use std::vector;
fun check_vec(v: &amp;vector&lt;u64&gt;, bound: u64) {
    let i = 0;
    let n = vector::length(v);
    while (i &lt; n) {
        let cur = *vector::borrow(v, i);
        if (cur &gt; bound) abort 42;
        i = i + 1;
    }
}
</code></pre>
<h3 id="assert"><a class="header" href="#assert"><code>assert</code></a></h3>
<p><code>assert</code> is a builtin, macro operation provided by the Move compiler. It takes two arguments, a
condition of type <code>bool</code> and a code of type <code>u64</code></p>
<pre><code class="language-move">assert!(condition: bool, code: u64)
</code></pre>
<p>Since the operation is a macro, it must be invoked with the <code>!</code>. This is to convey that the
arguments to <code>assert</code> are call-by-expression. In other words, <code>assert</code> is not a normal function and
does not exist at the bytecode level. It is replaced inside the compiler with</p>
<pre><code class="language-move">if (condition) () else abort code
</code></pre>
<p><code>assert</code> is more commonly used than just <code>abort</code> by itself. The <code>abort</code> examples above can be
rewritten using <code>assert</code></p>
<pre><code class="language-move">use std::vector;
fun pop_twice&lt;T&gt;(v: &amp;mut vector&lt;T&gt;): (T, T) {
    assert!(vector::length(v) &gt;= 2, 42); // Now uses 'assert'
    (vector::pop_back(v), vector::pop_back(v))
}
</code></pre>
<p>and</p>
<pre><code class="language-move">use std::vector;
fun check_vec(v: &amp;vector&lt;u64&gt;, bound: u64) {
    let i = 0;
    let n = vector::length(v);
    while (i &lt; n) {
        let cur = *vector::borrow(v, i);
        assert!(cur &lt;= bound, 42); // Now uses 'assert'
        i = i + 1;
    }
}
</code></pre>
<p>Note that because the operation is replaced with this <code>if-else</code>, the argument for the <code>code</code> is not
always evaluated. For example:</p>
<pre><code class="language-move">assert!(true, 1 / 0)
</code></pre>
<p>Will not result in an arithmetic error, it is equivalent to</p>
<pre><code class="language-move">if (true) () else (1 / 0)
</code></pre>
<p>So the arithmetic expression is never evaluated!</p>
<h3 id="abort-codes-in-the-move-vm"><a class="header" href="#abort-codes-in-the-move-vm">Abort codes in the Move VM</a></h3>
<p>When using <code>abort</code>, it is important to understand how the <code>u64</code> code will be used by the VM.</p>
<p>Normally, after successful execution, the Move VM, and the adapter for the specific deployment,
determine the changes made to storage.</p>
<p>If an <code>abort</code> is reached, the VM will instead indicate an error. Included in that error will be two
pieces of information:</p>
<ul>
<li>The module that produced the abort (package/address value and module name)</li>
<li>The abort code.</li>
</ul>
<p>For example</p>
<pre><code class="language-move">module 0x2::example {
    public fun aborts() {
        abort 42
    }
}

module 0x3::invoker {
    public fun always_aborts() {
        0x2::example::aborts()
    }
}
</code></pre>
<p>If a transaction, such as the function <code>always_aborts</code> above, calls <code>0x2::example::aborts</code>, the VM
would produce an error that indicated the module <code>0x2::example</code> and the code <code>42</code>.</p>
<p>This can be useful for having multiple aborts being grouped together inside a module.</p>
<p>In this example, the module has two separate error codes used in multiple functions</p>
<pre><code class="language-move">module 0x42::example {

    use std::vector;

    const EEmptyVector: u64 = 0;
    const EIndexOutOfBounds: u64 = 1;

    // move i to j, move j to k, move k to i
    public fun rotate_three&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64, j: u64, k: u64) {
        let n = vector::length(v);
        assert!(n &gt; 0, EEmptyVector);
        assert!(i &lt; n, EIndexOutOfBounds);
        assert!(j &lt; n, EIndexOutOfBounds);
        assert!(k &lt; n, EIndexOutOfBounds);

        vector::swap(v, i, k);
        vector::swap(v, j, k);
    }

    public fun remove_twice&lt;T&gt;(v: &amp;mut vector&lt;T&gt;, i: u64, j: u64): (T, T) {
        let n = vector::length(v);
        assert!(n &gt; 0, EEmptyVector);
        assert!(i &lt; n, EIndexOutOfBounds);
        assert!(j &lt; n, EIndexOutOfBounds);
        assert!(i &gt; j, EIndexOutOfBounds);

        (vector::remove&lt;T&gt;(v, i), vector::remove&lt;T&gt;(v, j))
    }
}
</code></pre>
<h2 id="the-type-of-abort"><a class="header" href="#the-type-of-abort">The type of <code>abort</code></a></h2>
<p>The <code>abort i</code> expression can have any type! This is because both constructs break from the normal
control flow, so they never need to evaluate to the value of that type.</p>
<p>The following are not useful, but they will type check</p>
<pre><code class="language-move">let y: address = abort 0;
</code></pre>
<p>This behavior can be helpful in situations where you have a branching instruction that produces a
value on some branches, but not all. For example:</p>
<pre><code class="language-move">let b =
    if (x == 0) false
    else if (x == 1) true
    else abort 42;
//       ^^^^^^^^ `abort 42` has type `bool`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow-1"><a class="header" href="#control-flow-1">Control Flow</a></h1>
<p>Move offers multiple constructs for control flow based on
<a href="./primitive-types/bool.html">boolean expressions</a>, including common programming constructs such as
<code>if</code> expressions and <code>while</code> and <code>for</code> loops, along with advanced control flow structures including
labels for loops and escapable named blocks. It also supports more more complex constructs based on
structural pattern matching.</p>
<ul>
<li><a href="./control-flow/conditionals.html">Conditional Expressions</a></li>
<li><a href="./control-flow/pattern-matching.html">Pattern Matching</a></li>
<li><a href="./control-flow/loops.html">Loops</a></li>
<li><a href="./control-flow/labeled-control-flow.html">Labeled Control FLow</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-if-expressions"><a class="header" href="#conditional-if-expressions">Conditional <code>if</code> Expressions</a></h1>
<p>An <code>if</code> expression specifies that some code should only be evaluated if a certain condition is true.
For example:</p>
<pre><code class="language-move">if (x &gt; 5) x = x - 5
</code></pre>
<p>The condition must be an expression of type <code>bool</code>.</p>
<p>An <code>if</code> expression can optionally include an <code>else</code> clause to specify another expression to evaluate
when the condition is false.</p>
<pre><code class="language-move">if (y &lt;= 10) y = y + 1 else y = 10
</code></pre>
<p>Either the &quot;true&quot; branch or the &quot;false&quot; branch will be evaluated, but not both. Either branch can be
a single expression or an expression block.</p>
<p>The conditional expressions may produce values so that the <code>if</code> expression has a result.</p>
<pre><code class="language-move">let z = if (x &lt; 100) x else 100;
</code></pre>
<p>The expressions in the true and false branches must have compatible types. For example:</p>
<pre><code class="language-move=">// x and y must be u64 integers
let maximum: u64 = if (x &gt; y) x else y;

// ERROR! branches different types
let z = if (maximum &lt; 10) 10u8 else 100u64;

// ERROR! branches different types, as default false-branch is () not u64
if (maximum &gt;= 10) maximum;
</code></pre>
<p>If the <code>else</code> clause is not specified, the false branch defaults to the unit value. The following
are equivalent:</p>
<pre><code class="language-move">if (condition) true_branch // implied default: else ()
if (condition) true_branch else ()
</code></pre>
<p>Commonly, <code>if</code> expressions are used in conjunction with
<a href="control-flow/../variables.html#expression-blocks">expression blocks</a>.</p>
<pre><code class="language-move">let maximum = if (x &gt; y) x else y;
if (maximum &lt; 10) {
    x = x + 10;
    y = y + 10;
} else if (x &gt;= 10 &amp;&amp; y &gt;= 10) {
    x = x - 10;
    y = y - 10;
}
</code></pre>
<h2 id="grammar-for-conditionals"><a class="header" href="#grammar-for-conditionals">Grammar for Conditionals</a></h2>
<blockquote>
<p><em>if-expression</em>  <strong>if (</strong> <em>expression</em> <strong>)</strong> <em>expression</em> <em>else-clause</em><sub><em>opt</em></sub> &gt;
<em>else-clause</em>  <strong>else</strong> <em>expression</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loop-constructs-in-move"><a class="header" href="#loop-constructs-in-move">Loop Constructs in Move</a></h1>
<p>Many programs require iteration over values, and Move provides <code>while</code> and <code>loop</code> forms to allow you
to write code in these situations. In addition, you can also modify control flow of these loops
during execution by using <code>break</code> (to exit the loop) and <code>continue</code> (to skip the remainder of this
iteration and return to the top of the control flow structure).</p>
<h2 id="while-loops"><a class="header" href="#while-loops"><code>while</code> Loops</a></h2>
<p>The <code>while</code> construct repeats the body (an expression of type unit) until the condition (an
expression of type <code>bool</code>) evaluates to <code>false</code>.</p>
<p>Here is an example of simple <code>while</code> loop that computes the sum of the numbers from <code>1</code> to <code>n</code>:</p>
<pre><code class="language-move">fun sum(n: u64): u64 {
    let mut sum = 0;
    let mut i = 1;
    while (i &lt;= n) {
        sum = sum + i;
        i = i + 1
    };

    sum
}
</code></pre>
<p>Infinite <code>while</code> loops are also allowed:</p>
<pre><code class="language-move">fun foo() {
    while (true) { }
}
</code></pre>
<h3 id="using-break-inside-of-while-loops"><a class="header" href="#using-break-inside-of-while-loops">Using <code>break</code> Inside of <code>while</code> Loops</a></h3>
<p>In Move, <code>while</code> loops can use <code>break</code> to exit early. For example, suppose we were looking for the
position of a value in a vector, and would like to <code>break</code> if we find it:</p>
<pre><code class="language-move">fun find_position(values: &amp;vector&lt;u64&gt;, target_value: u64): Option&lt;u64&gt; {
    let size = vector::length(values);
    let mut i = 0;
    let mut found = false;

    while (i &lt; size) {
        if (vector::borrow(values, i) == &amp;target_value) {
            found = true;
            break
        };
        i = i + 1
    };

    if (found) {
        Option::Some(i)
    } else {
        Option::None
    }
}
</code></pre>
<p>Here, if the borrowed vector value is equal to our target value, we set the <code>found</code> flag to <code>true</code>
and then call <code>break</code>, which will cause the program to exit the loop.</p>
<p>Finally, note that <code>break</code> for <code>while</code> loops cannot take a value: <code>while</code> loops always return the
unit type <code>()</code> and thus <code>break</code> does, too.</p>
<h3 id="using-continue-inside-of-while-loops"><a class="header" href="#using-continue-inside-of-while-loops">Using <code>continue</code> Inside of <code>while</code> Loops</a></h3>
<p>Similar to <code>break</code>, Move's <code>while</code> loops can invoke <code>continue</code> to skip over part of the loop body.
This allows us to skip part of a computation if a condition is not met, such as in the following
example:</p>
<pre><code class="language-move">fun sum_even(values: &amp;vector&lt;u64&gt;): u64 {
    let size = vector::length(values);
    let mut i = 0;
    let mut even_sum = 0;

    while (i &lt; size) {
        let number = *vector::borrow(values, i);
        i = i + 1;
        if (number % 2 == 1) continue;
        even_sum = even_sum + number;
    };
    even_sum
}
</code></pre>
<p>This code will iterate over the provided vector. For each entry, if that entry is an even number, it
will add it to the <code>even_sum</code>. If it is not, however, it will call <code>continue</code>, skipping the sum
operation and returning to the <code>while</code> loop conditional check.</p>
<h2 id="loop-expressions"><a class="header" href="#loop-expressions"><code>loop</code> Expressions</a></h2>
<p>The <code>loop</code> expression repeats the loop body (an expression with type <code>()</code>) until it hits a <code>break</code>:</p>
<pre><code class="language-move">fun sum(n: u64): u64 {
    let mut sum = 0;
    let mut i = 1;

    loop {
       i = i + 1;
       if (i &gt;= n) break;
       sum = sum + i;
    };

    sum
}
</code></pre>
<p>Without a <code>break</code>, the loop will continue forever. In the example below, the program will run
forever because the <code>loop</code> does not have a <code>break</code>:</p>
<pre><code class="language-move">fun foo() {
    let mut i = 0;
    loop { i = i + 1 }
}
</code></pre>
<p>Here is an example that uses <code>loop</code> to write the <code>sum</code> function:</p>
<pre><code class="language-move">fun sum(n: u64): u64 {
    let sum = 0;
    let i = 0;
    loop {
        i = i + 1;
        if (i &gt; n) break;
        sum = sum + i
    };

    sum
}
</code></pre>
<h3 id="using-break-with-values-in-loop"><a class="header" href="#using-break-with-values-in-loop">Using <code>break</code> with Values in <code>loop</code></a></h3>
<p>Unlike <code>while</code> loops, which always return <code>()</code>, a <code>loop</code> may return a value using <code>break</code>. In doing
so, the overall <code>loop</code> expression evaluates to a value of that type. For example, we can rewrite
<code>find_position</code> from above using <code>loop</code> and <code>break</code>, immediately returning the index if we find it:</p>
<pre><code class="language-move">fun find_position(values: &amp;vector&lt;u64&gt;, target_value: u64): Option&lt;u64&gt; {
    let size = vector::length(values);
    let mut i = 0;

    loop {
        if (vector::borrow(values, i) == &amp;target_value) {
            break Option::Some(i)
        } else if (i &gt;= size) {
            break Option::None
        };
        i = i + 1;
    }
}
</code></pre>
<p>This loop will break with an option result, and, as the last expression in the function body, will
produce that value as the final function result.</p>
<h3 id="using-continue-inside-of-loop-expressions"><a class="header" href="#using-continue-inside-of-loop-expressions">Using <code>continue</code> Inside of <code>loop</code> Expressions</a></h3>
<p>As you might expect, <code>continue</code> can also be used inside a <code>loop</code>. Here is the previous <code>sum_even</code>
function rewritten using <code>loop</code> with <code>break </code>and<code> continue</code> instead of <code>while</code>.</p>
<pre><code class="language-move">fun sum_even(values: &amp;vector&lt;u64&gt;): u64 {
    let size = vector::length(values);
    let mut i = 0;
    let mut even_sum = 0;

    loop {
        if (i &gt;= size) break;
        let number = *vector::borrow(values, i);
        i = i + 1;
        if (number % 2 == 1) continue;
        even_sum = even_sum + number;
    };
    even_sum
}
</code></pre>
<h2 id="the-type-of-while-and-loop"><a class="header" href="#the-type-of-while-and-loop">The Type of <code>while</code> and <code>loop</code></a></h2>
<p>In Move, loops are typed expressions. A <code>while</code> expression always has type <code>()</code>.</p>
<pre><code class="language-move">let () = while (i &lt; 10) { i = i + 1 };
</code></pre>
<p>If a <code>loop</code> contains a <code>break</code>, the expression has the type of the break. A break with no value has
the unit type <code>()</code>.</p>
<pre><code class="language-move">(loop { if (i &lt; 10) i = i + 1 else break }: ());
let () = loop { if (i &lt; 10) i = i + 1 else break };

let x: u64 = loop { if (i &lt; 10) i = i + 1 else break 5 };
let x: u64 = loop { if (i &lt; 10) { i = i + 1; continue} else break 5 };
</code></pre>
<p>In addition, if a loop contains multiple breaks, they must all return the same type:</p>
<pre><code class="language-move">// invalid -- first break returns (), second returns 5
let x: u64 = loop { if (i &lt; 10) break else break 5 };
</code></pre>
<p>If <code>loop</code> does not have a <code>break</code>, <code>loop</code> can have any type much like <code>return</code>, <code>abort</code>, <code>break</code>,
and <code>continue</code>.</p>
<pre><code class="language-move">(loop (): u64);
(loop (): address);
(loop (): &amp;vector&lt;vector&lt;u8&gt;&gt;);
</code></pre>
<p>If you need even more-precise control flow, such as breaking out of nested loops, the next chapter
presents the use of labeled control flow in Move.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="labeled-control-flow"><a class="header" href="#labeled-control-flow">Labeled Control Flow</a></h1>
<p>Move supports labeled control flow when writing both loops and blocks of code, allowing you
to <code>break</code> and <code>continue</code> loops and <code>return</code> from blocks (which can be particularly helpful in the
presence of macros).</p>
<h2 id="loops"><a class="header" href="#loops">Loops</a></h2>
<p>Loops allow you to define and transfer control to specific labels in a function. For example, we can
nest two loops and use <code>break</code> and <code>continue</code> with those labels to precisely specify control flow.
You can prefix any <code>loop</code> or <code>while</code> form with a <code>'label:</code> form to allow breaking or continuing
directly there.</p>
<p>To demonstrate this behavior, consider a function that takes nested vectors of numbers (i.e.,
<code>vector&lt;vector&lt;u64&gt;&gt;</code>) to sum against some threshold, which behaves as follows:</p>
<ul>
<li>If the sum of all the numbers are under the threshold, return that sum.</li>
<li>If adding a number to the current sum would surpass the threshold, return the current sum.</li>
</ul>
<p>We can write this by iterating over the vector of vectors as nested loops and labelling the outer
one. If any addition in the inner loop would push us over the threshold, we can use <code>break</code> with the
outer label to escape both loops at once:</p>
<pre><code class="language-move">fun sum_until_threshold(input: &amp;vector&lt;vector&lt;u64&gt;&gt;, threshold: u64): u64 {
    let mut sum = 0;
    let mut i = 0;
    let input_size = input.length();

    'outer: loop {
        // breaks to outer since it is the closest enclosing loop
        if (i &gt;= input_size) break sum;

        let vec = &amp;input[i];
        let size = vec.length();
        let mut j = 0;

        while (j &lt; size) {
            let v_entry = vec[j];
            if (sum + v_entry &lt; threshold) {
                sum = sum + v_entry;
            } else {
                // the next element we saw would break the threshold,
                // so we return the current sum
                break 'outer sum
            };
            j = j + 1;
        };
        i = i + 1;
    }
}
</code></pre>
<p>These sorts of labels can also be used with a nested loop form, providing precise control in larger
bodies of code. For example, if we were processing a large table where each entry required iteration
that might see us continuing the inner or outer loop, we could express that code using labels:</p>
<pre><code class="language-move">let x = 'outer: loop {
    ...
    'inner: while (cond) {
        ...
        if (cond0) { break 'outer value };
        ...
        if (cond1) { continue 'inner }
        else if (cond2) { continue 'outer }
        ...
    }
        ...
};
</code></pre>
<h2 id="labeled-blocks"><a class="header" href="#labeled-blocks">Labeled Blocks</a></h2>
<p>Labeled blocks allow you to write Move programs that contain intra-function non-local control flow,
including inside of macro lambdas and returning values:</p>
<pre><code class="language-move">fun named_return(n: u64): vector&lt;u8&gt; {
    let x = 'a: {
        if (n % 2 == 0) {
            return 'a b&quot;even&quot;
        };
        b&quot;odd&quot;
    };
    x
}
</code></pre>
<p>In this simple example, the program checks if the input <code>n</code> is even. If it is, the program leaves
the block labeled <code>'a:</code> with the value <code>b&quot;even&quot;</code>. If not, the code continues, ending the block
labeled <code>'a:</code> with the value <code>b&quot;odd&quot;</code>. At the end, we set <code>x</code> to the value and then return it.</p>
<p>This control flow feature works across macro bodies as well. For example, suppose we wanted to write
a function to find the first even number in a vector, and that we have some macro <code>for_ref</code> that
iterates the vector elements in a loop:</p>
<pre><code class="language-move">macro fun for_ref&lt;$T&gt;($vs: &amp;vector&lt;$T&gt;, $f: |&amp;$T|) {
    let vs = $vs;
    let mut i = 0;
    let end = vs.length();
    while (i &lt; end) {
        $f(vs.borrow(i));
        i = i + 1;
    }
}
</code></pre>
<p>Using <code>for_ref</code> and a label, we can write a lambda expression to pass <code>for_ref</code> that will escape the
loop, returning the first even number it finds:</p>
<pre><code class="language-move">fun find_first_even(vs: vector&lt;u64&gt;): Option&lt;u64&gt; {
    'result: {
        for_ref!(&amp;vs, |n| if (*n % 2 == 0) { return 'result option::some(*n)});
        option::none()
    }
}
</code></pre>
<p>This function will iterate <code>vs</code> until it finds an even number, and return that (or return
<code>option::none()</code> if no even number exists). This makes named labels a powerful tool for interacting
with control flow macros such as <code>for!</code>, allowing you to customize iteration behavior in those
contexts.</p>
<h2 id="restrictions-1"><a class="header" href="#restrictions-1">Restrictions</a></h2>
<p>To clarify program behavior, you may only use <code>break</code> and <code>continue</code> with loop labels, while
<code>return</code> will only work with block labels. To this end, the following programs produce errors:</p>
<pre><code>fun bad_loop() {
    'name: loop {
        return 'name 5
            // ^^^^^ Invalid usage of 'return' with a loop block label
    }
}

fun bad_block() {
    'name: {
        continue 'name;
              // ^^^^^ Invalid usage of 'break' with a loop block label
        break 'name;
           // ^^^^^ Invalid usage of 'break' with a loop block label
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<p>A <code>match</code> expression is a powerful control structure that allows you to compare a value against a
series of patterns and then execute code based on which pattern matches first. Patterns can be
anything from simple literals to complex, nested struct and enum definitions. As opposed to <code>if</code>
expressions, which change control flow based on a <code>bool</code>-typed test expression, a <code>match</code> expression
operates over a value of any type and selects one of many arms.</p>
<p>A <code>match</code> expression can match Move values as well as mutable or immutable references, binding
sub-patterns accordingly.</p>
<p>For example:</p>
<pre><code class="language-move">fun run(x: u64): u64 {
    match (x) {
        1 =&gt; 2,
        2 =&gt; 3,
        x =&gt; x,
    }
}

run(1); // returns 2
run(2); // returns 3
run(3); // returns 3
run(0); // returns 0
</code></pre>
<h2 id="match-syntax"><a class="header" href="#match-syntax"><code>match</code> Syntax</a></h2>
<p>A <code>match</code> takes an expression and a non-empty series of <em>match arms</em> delimited by commas.</p>
<p>Each match arm consists of a pattern (<code>p</code>), an optional guard (<code>if (g)</code> where <code>g</code> is an expression
of type <code>bool</code>), an arrow (<code>=&gt;</code>), and an arm expression (<code>e</code>) to execute when the pattern matches.
For example,</p>
<pre><code class="language-move">match (expression) {
    pattern1 if (guard_expression) =&gt; expression1,
    pattern2 =&gt; expression2,
    pattern3 =&gt; { expression3, expression4, ... },
}
</code></pre>
<p>Match arms are checked in order from top to bottom, and the first pattern that matches (with a guard
expression, if present, that evaluates to <code>true</code>) will be executed.</p>
<p>Note that the series of match arms within a <code>match</code> must be exhaustive, meaning that every possible
value of the type being matched must be covered by one of the patterns in the <code>match</code>. If the series
of match arms is not exhaustive, the compiler will raise an error.</p>
<h2 id="pattern-syntax"><a class="header" href="#pattern-syntax">Pattern Syntax</a></h2>
<p>A pattern is matched by a value if the value is equal to the pattern, and where variables and
wildcards (e.g., <code>x</code>, <code>y</code>, <code>_</code>, or <code>..</code>) are &quot;equal&quot; to anything.</p>
<p>Patterns are used to match values. Patterns can be</p>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Description</th></tr></thead><tbody>
<tr><td>Literal</td><td>A literal value, such as <code>1</code>, <code>true</code>, <code>@0x1</code></td></tr>
<tr><td>Constant</td><td>A constant value, e.g., <code>MyConstant</code></td></tr>
<tr><td>Variable</td><td>A variable, e.g., <code>x</code>, <code>y</code>, <code>z</code></td></tr>
<tr><td>Wildcard</td><td>A wildcard, e.g., <code>_</code></td></tr>
<tr><td>Constructor</td><td>A constructor pattern, e.g., <code>MyStruct { x, y }</code>, <code>MyEnum::Variant(x)</code></td></tr>
<tr><td>At-pattern</td><td>An at-pattern, e.g., <code>x @ MyEnum::Variant(..)</code></td></tr>
<tr><td>Or-pattern</td><td>An or-pattern, e.g., <code>MyEnum::Variant(..) \| MyEnum::OtherVariant(..)</code></td></tr>
<tr><td>Multi-arity wildcard</td><td>A multi-arity wildcard, e.g., <code>MyEnum::Variant(..)</code></td></tr>
<tr><td>Mutable-binding</td><td>A mutable-binding pattern, e.g., <code>mut x</code></td></tr>
</tbody></table>
</div>
<p>Patterns in Move have the following grammar:</p>
<pre><code class="language-bnf">pattern = &lt;literal&gt;
        | &lt;constant&gt;
        | &lt;variable&gt;
        | _
        | C { &lt;variable&gt; : inner-pattern [&quot;,&quot; &lt;variable&gt; : inner-pattern]* } // where C is a struct or enum variant
        | C ( inner-pattern [&quot;,&quot; inner-pattern]* ... )                       // where C is a struct or enum variant
        | C                                                                  // where C is an enum variant
        | &lt;variable&gt; @ top-level-pattern
        | pattern | pattern
        | mut &lt;variable&gt;
inner-pattern = pattern
              | ..     // multi-arity wildcard
</code></pre>
<p>Some examples of patterns are:</p>
<pre><code class="language-move">// literal pattern
1

// constant pattern
MyConstant

// variable pattern
x

// wildcard pattern
_

// constructor pattern that matches `MyEnum::Variant` with the fields `1` and `true`
MyEnum::Variant(1, true)

// constructor pattern that matches `MyEnum::Variant` with the fields `1` and binds the second field's value to `x`
MyEnum::Variant(1, x)

// multi-arity wildcard pattern that matches multiple fields within the `MyEnum::Variant` variant
MyEnum::Variant(..)

// constructor pattern that matches the `x` field of `MyStruct` and binds the `y` field to `other_variable`
MyStruct { x, y: other_variable }

// at-pattern that matches `MyEnum::Variant` and binds the entire value to `x`
x @ MyEnum::Variant(..)

// or-pattern that matches either `MyEnum::Variant` or `MyEnum::OtherVariant`
MyEnum::Variant(..) | MyEnum::OtherVariant(..)

// same as the above or-pattern, but with explicit wildcards
MyEnum::Variant(_, _) | MyEnum::OtherVariant(_, _)

// or-pattern that matches either `MyEnum::Variant` or `MyEnum::OtherVariant` and binds the u64 field to `x`
MyEnum::Variant(x, _) | MyEnum::OtherVariant(_, x)

// constructor pattern that matches `OtherEnum::V` and if the inner `MyEnum` is `MyEnum::Variant`
OtherEnum::V(MyEnum::Variant(..))
</code></pre>
<h3 id="patterns-and-variables"><a class="header" href="#patterns-and-variables">Patterns and Variables</a></h3>
<p>Patterns that contain variables bind them to the match subject or subject subcomponent being
matched. These variables can then be used either in any match guard expressions, or on the
right-hand side of the match arm. For example:</p>
<pre><code class="language-move">public struct Wrapper(u64)

fun add_under_wrapper_unless_equal(wrapper: Wrapper, x: u64): u64 {
    match (wrapper) {
        Wrapper(y) if (y == x) =&gt; Wrapper(y),
        Wrapper(y) =&gt; y + x,
    }
}
add_under_wrapper_unless_equal(Wrapper(1), 2); // returns Wrapper(3)
add_under_wrapper_unless_equal(Wrapper(2), 3); // returns Wrapper(5)
add_under_wrapper_unless_equal(Wrapper(3), 3); // returns Wrapper(3)
</code></pre>
<h3 id="combining-patterns"><a class="header" href="#combining-patterns">Combining Patterns</a></h3>
<p>Patterns can be nested, but patterns can also be combined using the or operator (<code>|</code>). For example,
<code>p1 | p2</code> succeeds if either pattern <code>p1</code> or <code>p2</code> matches the subject. This pattern can occur
anywhere -- either as a top-level pattern or a sub-pattern within another pattern.</p>
<pre><code class="language-move">public enum MyEnum has drop {
    Variant(u64, bool),
    OtherVariant(bool, u64),
}

fun test_or_pattern(x: u64): u64 {
    match (x) {
        MyEnum::Variant(1 | 2 | 3, true) | MyEnum::OtherVariant(true, 1 | 2 | 3) =&gt; 1,
        MyEnum::Variant(8, true) | MyEnum::OtherVariant(_, 6 | 7) =&gt; 2,
        _ =&gt; 3,
    }
}

test_or_pattern(MyEnum::Variant(3, true)); // returns 1
test_or_pattern(MyEnum::OtherVariant(true, 2)); // returns 1
test_or_pattern(MyEnum::Variant(8, true)); // returns 2
test_or_pattern(MyEnum::OtherVariant(false, 7)); // returns 2
test_or_pattern(MyEnum::OtherVariant(false, 80)); // returns 3
</code></pre>
<h3 id="restrictions-on-some-patterns"><a class="header" href="#restrictions-on-some-patterns">Restrictions on Some Patterns</a></h3>
<p>The <code>mut</code> and <code>..</code> patterns also have specific conditions placed on when, where, and how they can be
used, as detailed in <a href="control-flow/pattern-matching.html#limitations-on-specific-patterns">Limitations on Specific Patterns</a>. At a
high level, the <code>mut</code> modifier can only be used on variable patterns, and the <code>..</code> pattern can only
be used once within a constructor pattern -- and not as a top-level pattern.</p>
<p>The following is an <em>invalid</em> usage of the <code>..</code> pattern because it is used as a top-level pattern:</p>
<pre><code class="language-move">match (x) {
    .. =&gt; 1,
    // ERROR: `..` pattern can only be used within a constructor pattern
}

match (x) {
    MyStruct(.., ..) =&gt; 1,
    // ERROR:    ^^  `..` pattern can only be used once within a constructor pattern
}
</code></pre>
<h3 id="pattern-typing"><a class="header" href="#pattern-typing">Pattern Typing</a></h3>
<p>Patterns are not expressions, but they are nevertheless typed. This means that the type of a pattern
must match the type of the value it matches. For example, the pattern <code>1</code> has an integer type, the
pattern <code>MyEnum::Variant(1, true)</code> has type <code>MyEnum</code>, the pattern <code>MyStruct { x, y }</code> has type
<code>MyStruct</code>, and <code>OtherStruct&lt;bool&gt; { x: true, y: 1}</code> has type <code>OtherStruct&lt;bool&gt;</code>. If you try to
match on an expression that differs from the type of the pattern in the match, this will result in a
type error. For example:</p>
<pre><code class="language-move">match (1) {
    // The `true` literal pattern is of type `bool` so this is a type error.
    true =&gt; 1,
    // TYPE ERROR: expected type u64, found bool
    _ =&gt; 2,
}
</code></pre>
<p>Similarly, the following would also result in a type error because <code>MyEnum</code> and <code>MyStruct</code> are
different types:</p>
<pre><code class="language-move">match (MyStruct { x: 0, y: 0 }) {
    MyEnum::Variant(..) =&gt; 1,
    // TYPE ERROR: expected type MyEnum, found MyStruct
}
</code></pre>
<h2 id="matching"><a class="header" href="#matching">Matching</a></h2>
<p>Prior to delving into the specifics of pattern matching and what it means for a value to &quot;match&quot; a
pattern, let's examine a few examples to provide an intuition for the concept.</p>
<pre><code class="language-move">fun test_lit(x: u64): u8 {
    match (x) {
        1 =&gt; 2,
        2 =&gt; 3,
        _ =&gt; 4,
    }
}
test_lit(1); // returns 2
test_lit(2); // returns 3
test_lit(3); // returns 4
test_lit(10); // returns 4

fun test_var(x: u64): u64 {
    match (x) {
        y =&gt; y,
    }
}
test_var(1); // returns 1
test_var(2); // returns 2
test_var(3); // returns 3
...

const MyConstant: u64 = 10;
fun test_constant(x: u64): u64 {
    match (x) {
        MyConstant =&gt; 1,
        _ =&gt; 2,
    }
}
test_constant(MyConstant); // returns 1
test_constant(10); // returns 1
test_constant(20); // returns 2

fun test_or_pattern(x: u64): u64 {
    match (x) {
        1 | 2 | 3 =&gt; 1,
        4 | 5 | 6 =&gt; 2,
        _ =&gt; 3,
    }
}
test_or_pattern(3); // returns 1
test_or_pattern(5); // returns 2
test_or_pattern(70); // returns 3

fun test_or_at_pattern(x: u64): u64 {
    match (x) {
        x @ (1 | 2 | 3) =&gt; x + 1,
        y @ (4 | 5 | 6) =&gt; y + 2,
        z =&gt; z + 3,
    }
}
test_or_pattern(2); // returns 3
test_or_pattern(5); // returns 7
test_or_pattern(70); // returns 73
</code></pre>
<p>The most important thing to note from these examples is that a pattern matches a value if the value
is equal to the pattern, and wildcard/variable patterns match anything. This is true for literals,
variables, and constants. For example, in the <code>test_lit</code> function, the value <code>1</code> matches the pattern
<code>1</code>, the value <code>2</code> matches the pattern <code>2</code>, and the value <code>3</code> matches the wildcard <code>_</code>. Similarly,
in the <code>test_var</code> function, both the value <code>1</code> and the value <code>2</code> matches the pattern <code>y</code>.</p>
<p>A variable <code>x</code> matches (or &quot;equals&quot;) any value, and a wildcard <code>_</code> matches any value (but only one
value). Or-patterns are like a logical OR, where a value matches the pattern if it matches any of
patterns in the or-pattern so <code>p1 | p2 | p3</code> should be read &quot;matches p1, or p2, or p3&quot;.</p>
<h3 id="matching-constructors"><a class="header" href="#matching-constructors">Matching Constructors</a></h3>
<p>Pattern matching includes the concept of constructor patterns. These patterns allow you to inspect
and access deep within both structs and enums, and are one of the most powerful parts of pattern
matching. Constructor patterns, coupled with variable bindings, allow you to match on values by
their structure, and pull out the parts of the value you care about for usage on the right-hand side
of the match arm.</p>
<p>Take the following:</p>
<pre><code class="language-move">fun f(x: MyEnum) {
    match (x) {
        MyEnum::Variant(1, true) =&gt; 1,
        MyEnum::OtherVariant(_, 3) =&gt; 2,
        MyEnum::Variant(..) =&gt; 3,
        MyEnum::OtherVariant(..) =&gt; 4,
}
f(MyEnum::Variant(1, true)); // returns 1
f(MyEnum::Variant(2, true)); // returns 3
f(MyEnum::OtherVariant(false, 3)); // returns 2
f(MyEnum::OtherVariant(true, 3)); // returns 2
f(MyEnum::OtherVariant(true, 2)); // returns 4
</code></pre>
<p>This is saying that &quot;if <code>x</code> is <code>MyEnum::Variant</code> with the fields <code>1</code> and <code>true</code>, then return <code>1</code>. If
it is <code>MyEnum::OtherVariant</code> with any value for the first field, and <code>3</code> for the second, then return
<code>2</code>. If it is <code>MyEnum::Variant</code> with any fields, then return <code>3</code>. Finally, if it is
<code>MyEnum::OtherVariant</code> with any fields, then return <code>4</code>&quot;.</p>
<p>You can also nest patterns. So, if you wanted to match either 1, 2, or 10, instead of just matching
1 in the previous <code>MyEnum::Variant</code>, you could do so with an or-pattern:</p>
<pre><code class="language-move">fun f(x: MyEnum) {
    match (x) {
        MyEnum::Variant(1 | 2 | 10, true) =&gt; 1,
        MyEnum::OtherVariant(_, 3) =&gt; 2,
        MyEnum::Variant(..) =&gt; 3,
        MyEnum::OtherVariant(..) =&gt; 4,
}
f(MyEnum::Variant(1, true)); // returns 1
f(MyEnum::Variant(2, true)); // returns 1
f(MyEnum::Variant(10, true)); // returns 1
f(MyEnum::Variant(10, false)); // returns 3
</code></pre>
<h3 id="ability-constraints"><a class="header" href="#ability-constraints">Ability Constraints</a></h3>
<p>Additionally, match bindings are subject to the same ability restrictions as other aspects of Move.
In particular, the compiler will signal an error if you try to match a value (not-reference) without
<code>drop</code> using a wildcard, as the wildcard expects to drop the value. Similarly, if you bind a
non-<code>drop</code> value using a binder, it must be used in the right-hand side of the match arm. In
addition, if you fully destruct that value, you have unpacked it, matching the semantics of
<a href="control-flow/../structs.html#destroying-structs-via-pattern-matching">non-<code>drop</code> struct unpacking</a>. See the
<a href="control-flow/../abilities.html#drop">abilities section on <code>drop</code></a> for more details about the <code>drop</code> capability.</p>
<pre><code class="language-move">public struct NonDrop(u64)

fun drop_nondrop(x: NonDrop) {
    match (x) {
        NonDrop(1) =&gt; 1,
        _ =&gt; 2
        // ERROR: cannot wildcard match on a non-droppable value
    }
}

fun destructure_nondrop(x: NonDrop) {
    match (x) {
        NonDrop(1) =&gt; 1,
        NonDrop(_) =&gt; 2
        // OK!
    }
}

fun use_nondrop(x: NonDrop): NonDrop {
    match (x) {
        NonDrop(1) =&gt; NonDrop(8),
        x =&gt; x
    }
}
</code></pre>
<h2 id="exhaustiveness"><a class="header" href="#exhaustiveness">Exhaustiveness</a></h2>
<p>The <code>match</code> expression in Move must be <em>exhaustive</em>: every possible value of the type being matched
must be covered by one of the patterns in one of the match's arms. If the series of match arms is
not exhaustive, the compiler will raise an error. Note that any arm with a guard expression does not
contribute to match exhaustion, as it might fail to match at runtime.</p>
<p>As an example, a match on a <code>u8</code> is exhaustive only if it matches on <em>every</em> number from 0 to 255
inclusive, unless there is a wildcard or variable pattern present. Similarly, a match on a <code>bool</code>
would need to match on both <code>true</code> and <code>false</code>, unless there is a wildcard or variable pattern
present.</p>
<p>For structs, because there is only one type of constructor for the type, only one constructor needs
to be matched, but the fields within the struct need to be matched exhaustively as well. Conversely,
enums may define multiple variants, and each variant must be matched (including any sub-fields) for
the match to be considered exhaustive.</p>
<p>Because underscores and variables are wildcards that match anything, they count as matching all
values of the type they are matching on in that position. Additionally, the multi-arity wildcard
pattern <code>..</code> can be used to match on multiple values within a struct or enum variant.</p>
<p>To see some examples of <em>non-exhaustive</em> matches, consider the following:</p>
<pre><code class="language-move">public enum MyEnum {
    Variant(u64, bool),
    OtherVariant(bool, u64),
}

public struct Pair&lt;T&gt;(T, T)

fun f(x: MyEnum): u8 {
    match (x) {
        MyEnum::Variant(1, true) =&gt; 1,
        MyEnum::Variant(_, _) =&gt; 1,
        MyEnum::OtherVariant(_, 3) =&gt; 2,
        // ERROR: not exhaustive as the value `MyEnum::OtherVariant(_, 4)` is not matched.
    }
}

fun match_pair_bool(x: Pair&lt;bool&gt;): u8 {
    match (x) {
        Pair(true, true) =&gt; 1,
        Pair(true, false) =&gt; 1,
        Pair(false, false) =&gt; 1,
        // ERROR: not exhaustive as the value `Pair(false, true)` is not matched.
    }
}
</code></pre>
<p>These examples can then be made exhaustive by adding a wildcard pattern to the end of the match arm,
or by fully matching on the remaining values:</p>
<pre><code class="language-move">fun f(x: MyEnum): u8 {
    match (x) {
        MyEnum::Variant(1, true) =&gt; 1,
        MyEnum::Variant(_, _) =&gt; 1,
        MyEnum::OtherVariant(_, 3) =&gt; 2,
        // Now exhaustive since this will match all values of MyEnum::OtherVariant
        MyEnum::OtherVariant(..) =&gt; 2,

    }
}

fun match_pair_bool(x: Pair&lt;bool&gt;): u8 {
    match (x) {
        Pair(true, true) =&gt; 1,
        Pair(true, false) =&gt; 1,
        Pair(false, false) =&gt; 1,
        // Now exhaustive since this will match all values of Pair&lt;bool&gt;
        Pair(false, true) =&gt; 1,
    }
}
</code></pre>
<h2 id="guards"><a class="header" href="#guards">Guards</a></h2>
<p>As previously mentioned, you can add a guard to a match arm by adding an <code>if</code> clause after the
pattern. This guard will run <em>after</em> the pattern has been matched but <em>before</em> the expression on the
right hand side of the arrow is evaluated. If the guard expression evaluates to <code>true</code> then the
expression on the right hand side of the arrow will be evaluated, if it evaluates to <code>false</code> then it
will be considered a failed match and the next match arm in the <code>match</code> expression will be checked.</p>
<pre><code class="language-move">fun match_with_guard(x: u64): u64 {
    match (x) {
        1 if (false) =&gt; 1,
        1 =&gt; 2,
        _ =&gt; 3,
    }
}

match_with_guard(1); // returns 2
match_with_guard(0); // returns 3
</code></pre>
<p>Guard expressions can reference variables bound in the pattern during evaluation. However, note that
<em>variables are only available as immutable reference in guards</em> regardless of the pattern being
matched -- even if there are mutability specifiers on the variable or if the pattern is being
matched by value.</p>
<pre><code class="language-move">fun incr(x: &amp;mut u64) {
    *x = *x + 1;
}

fun match_with_guard_incr(x: u64): u64 {
    match (x) {
        x if ({ incr(&amp;mut x); x == 1 }) =&gt; 1,
        // ERROR:    ^^^ invalid borrow of immutable value
        _ =&gt; 2,
    }
}

fun match_with_guard_incr2(x: &amp;mut u64): u64 {
    match (x) {
        x if ({ incr(&amp;mut x); x == 1 }) =&gt; 1,
        // ERROR:    ^^^ invalid borrow of immutable value
        _ =&gt; 2,
    }
}
</code></pre>
<p>Additionally, it is important to note any match arms that have guard expressions will not be
considered either for exhaustivity purposes because the compiler has no way of evaluating the guard
expression statically.</p>
<h2 id="limitations-on-specific-patterns"><a class="header" href="#limitations-on-specific-patterns">Limitations on Specific Patterns</a></h2>
<p>There are some restrictions on when the <code>..</code> and <code>mut</code> pattern modifiers can be used in a pattern.</p>
<h3 id="mutability-usage"><a class="header" href="#mutability-usage">Mutability Usage</a></h3>
<p>A <code>mut</code> modifier can be placed on a variable pattern to specify that the <em>variable</em> is to be mutated
in the right-hand expression of the match arm. Note that since the <code>mut</code> modifier only signifies
that the variable is to be mutated, not the underlying data, this can be used on all types of match
(by value, immutable reference, and mutable reference).</p>
<p>Note that the <code>mut</code> modifier can only be applied to variables, and not other types of patterns.</p>
<pre><code class="language-move">public struct MyStruct(u64)

fun top_level_mut(x: MyStruct) {
    match (x) {
        mut MyStruct(y) =&gt; 1,
        // ERROR: cannot use mut on a non-variable pattern
    }
}

fun mut_on_immut(x: &amp;MyStruct): u64 {
    match (x) {
        MyStruct(mut y) =&gt; {
            y = &amp;(*y + 1);
            *y
        }
    }
}

fun mut_on_value(x: MyStruct): u64 {
    match (x) {
        MyStruct(mut y) =&gt;  {
            *y = *y + 1;
            *y
        },
    }
}

fun mut_on_mut(x: &amp;mut MyStruct): u64 {
    match (x) {
        MyStruct(mut y) =&gt;  {
            *y = *y + 1;
            *y
        },
    }
}

let mut x = MyStruct(1);

mut_on_mut(&amp;mut x); // returns 2
x.0; // returns 2

mut_on_immut(&amp;x); // returns 3
x.0; // returns 2

mut_on_value(x); // returns 3
</code></pre>
<h3 id="-usage"><a class="header" href="#-usage"><code>..</code> Usage</a></h3>
<p>The <code>..</code> pattern can only be used within a constructor pattern as a wildcard that matches any number
of fields -- the<br />
the compiler expands the <code>..</code> to inserting <code>_</code> in any missing fields in the constructor pattern (if
any). So <code>MyStruct(_, _, _)</code> is the same as <code>MyStruct(..)</code>, <code>MyStruct(1, _, _)</code> is the same as
<code>MyStruct(1, ..)</code>. Because of this, there are some restrictions on how, and where the <code>..</code> pattern
can be used:</p>
<ul>
<li>It can only be used <strong>once</strong> within the constructor pattern;</li>
<li>In positional arguments it can be used at the beginning, middle, or end of the patterns within the
constructor;</li>
<li>In named arguments it can only be used at the end of the patterns within the constructor;</li>
</ul>
<pre><code class="language-move">public struct MyStruct(u64, u64, u64, u64) has drop;

public struct MyStruct2 {
    x: u64,
    y: u64,
    z: u64,
    w: u64,
}

fun wild_match(x: MyStruct) {
    match (x) {
        MyStruct(.., 1) =&gt; 1,
        // OK! The `..` pattern can be used at the begining of the constructor pattern
        MyStruct(1, ..) =&gt; 2,
        // OK! The `..` pattern can be used at the end of the constructor pattern
        MyStruct(1, .., 1) =&gt; 3,
        // OK! The `..` pattern can be used at the middle of the constructor pattern
        MyStruct(1, .., 1, 1) =&gt; 4,
        MyStruct(..) =&gt; 5,
    }
}

fun wild_match2(x: MyStruct2) {
    match (x) {
        MyStruct2 { x: 1, .. } =&gt; 1,
        MyStruct2 { x: 1, w: 2 .. } =&gt; 2,
        MyStruct2 { .. } =&gt; 3,
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are declared inside of modules and define the logic and behavior of the module. Functions
can be reused, either being called from other functions or as entry points for execution.</p>
<h2 id="declaration"><a class="header" href="#declaration">Declaration</a></h2>
<p>Functions are declared with the <code>fun</code> keyword followed by the function name, type parameters,
parameters, a return type, and finally the function body.</p>
<pre><code class="language-text">&lt;visibility&gt;? &lt;entry&gt;? &lt;macro&gt;? fun &lt;identifier&gt;&lt;[type_parameters: constraint],*&gt;([identifier: type],*): &lt;return_type&gt; &lt;function_body&gt;
</code></pre>
<p>For example</p>
<pre><code class="language-move">fun foo&lt;T1, T2&gt;(x: u64, y: T1, z: T2): (T2, T1, u64) { (z, y, x) }
</code></pre>
<h3 id="visibility"><a class="header" href="#visibility">Visibility</a></h3>
<p>Module functions, by default, can only be called within the same module. These internal (sometimes
called private) functions cannot be called from other modules or as entry points.</p>
<pre><code class="language-move">module a::m {
    fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module b::other {
    fun calls_m_foo(): u64 {
        a::m::foo() // ERROR!
//      ^^^^^^^^^^^ 'foo' is internal to 'a::m'
    }
}
</code></pre>
<p>To allow access from other modules, the function must be declared <code>public</code> or <code>public(package)</code>.
Tangential to visibility, an <a href="functions.html#entry-modifier"><code>entry</code></a> function can be called as an entry point for
execution.</p>
<h4 id="public-visibility"><a class="header" href="#public-visibility"><code>public</code> visibility</a></h4>
<p>A <code>public</code> function can be called by <em>any</em> function defined in <em>any</em> module. As shown in the
following example, a <code>public</code> function can be called by:</p>
<ul>
<li>other functions defined in the same module,</li>
<li>functions defined in another module, or</li>
<li>as an entry point for execution.</li>
</ul>
<pre><code class="language-move">module a::m {
    public fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module b::other {
    fun calls_m_foo(): u64 {
        a::m::foo() // valid
    }
}
</code></pre>
<p>Fore more details on the entry point to execution see <a href="functions.html#entry-modifier">the section below</a>.</p>
<h4 id="publicpackage-visibility"><a class="header" href="#publicpackage-visibility"><code>public(package)</code> visibility</a></h4>
<p>The <code>public(package)</code> visibility modifier is a more restricted form of the <code>public</code> modifier to give
more control about where a function can be used. A <code>public(package)</code> function can be called by:</p>
<ul>
<li>other functions defined in the same module, or</li>
<li>other functions defined in the same package (the same address)</li>
</ul>
<pre><code class="language-move">module a::m {
    public(package) fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module a::n {
    fun calls_m_foo(): u64 {
        a::m::foo() // valid, also in `a`
    }
}

module b::other {
    fun calls_m_foo(): u64 {
        b::m::foo() // ERROR!
//      ^^^^^^^^^^^ 'foo' can only be called from a module in `a`
    }
}
</code></pre>
<h4 id="deprecated-publicfriend-visibility"><a class="header" href="#deprecated-publicfriend-visibility">DEPRECATED <code>public(friend)</code> visibility</a></h4>
<p>Before the addition of <code>public(package)</code>, <code>public(friend)</code> was used to allow limited public access
to functions in the same package, but where the list of allowed modules had to be explicitly
enumerated by the callee's module. see <a href="./friends.html">Friends</a> for more details.</p>
<h3 id="entry-modifier"><a class="header" href="#entry-modifier"><code>entry</code> modifier</a></h3>
<p>In addition to <code>public</code> functions, you might have some functions in your modules that you want to
use as the entry point to execution. The <code>entry</code> modifier is designed to allow module functions to
initiate execution, without having to expose the functionality to other modules.</p>
<p>Essentially, the combination of <code>public</code> and <code>entry</code> functions define the &quot;main&quot; functions of a
module, and they specify where Move programs can start executing.</p>
<p>Keep in mind though, an <code>entry</code> function <em>can</em> still be called by other Move functions. So while
they <em>can</em> serve as the start of a Move program, they aren't restricted to that case.</p>
<p>For example:</p>
<pre><code class="language-move">module a::m {
    entry fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid!
}

module a::n {
    fun calls_m_foo(): u64 {
        a::m::foo() // ERROR!
//      ^^^^^^^^^^^ 'foo' is internal to 'a::m'
    }
}
</code></pre>
<p><code>entry</code> functions may have restrictions on their parameters and return types. Although, these
restrictions are specific to each individual deployment of Move.</p>
<p><a href="https://docs.sui.io/concepts/sui-move-concepts/entry-functions">The documentation for <code>entry</code> functions on Sui can be found here.</a>.</p>
<p>To enable easier testing, <code>entry</code> functions can be called from
<a href="./unit-testing.html"><code>#[test]</code> and <code>#[test_only]</code></a> contexts.</p>
<pre><code class="language-move">module a::m {
    entry fun foo(): u64 { 0 }
}
module a::m_test {
    #[test]
    fun my_test(): u64 { a::m::foo() } // valid!
    #[test_only]
    fun my_test_helper(): u64 { a::m::foo() } // valid!
}
</code></pre>
<h3 id="macro-modifier"><a class="header" href="#macro-modifier"><code>macro</code> modifier</a></h3>
<p>Unlike normal functions, <code>macro</code> functions do not exist at runtime. Instead, these functions are
substituted inline at each call site during compilation. These <code>macro</code> functions leverage this
compilation process to provide functionality beyond standard functions, such as accepting
higher-order <em>lambda</em>-style functions as arguments. These lambda arguments, also expanded during
compilation, allow you to pass parts of the function body to the macro as arguments. For instance,
consider the following simple loop macro, where the loop body is supplied as a lambda:</p>
<pre><code class="language-move">macro fun ntimes($n: u64, $body: |u64| -&gt; ()) {
    let n = $n;
    let mut i = 0;
    while (i &lt; n) {
        $body(i);
        i = i + 1;
    }
}

fun example() {
    let mut sum = 0;
    ntimes!(10, |x| sum = sum + x );
}
</code></pre>
<p>See the chapter on <a href="./macros.html">macros</a> for more information.</p>
<h3 id="name"><a class="header" href="#name">Name</a></h3>
<p>Function names can start with letters <code>a</code> to <code>z</code>. After the first character, function names can
contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<pre><code class="language-move">fun fOO() {}
fun bar_42() {}
fun bAZ_19() {}
</code></pre>
<h3 id="type-parameters"><a class="header" href="#type-parameters">Type Parameters</a></h3>
<p>After the name, functions can have type parameters</p>
<pre><code class="language-move">fun id&lt;T&gt;(x: T): T { x }
fun example&lt;T1: copy, T2&gt;(x: T1, y: T2): (T1, T1, T2) { (copy x, x, y) }
</code></pre>
<p>For more details, see <a href="./generics.html">Move generics</a>.</p>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<p>Functions parameters are declared with a local variable name followed by a type annotation</p>
<pre><code class="language-move">fun add(x: u64, y: u64): u64 { x + y }
</code></pre>
<p>We read this as <code>x</code> has type <code>u64</code></p>
<p>A function does not have to have any parameters at all.</p>
<pre><code class="language-move">fun useless() { }
</code></pre>
<p>This is very common for functions that create new or empty data structures</p>
<pre><code class="language-move">module a::example {
  public struct Counter { count: u64 }

  fun new_counter(): Counter {
      Counter { count: 0 }
  }
}
</code></pre>
<h3 id="return-type"><a class="header" href="#return-type">Return type</a></h3>
<p>After the parameters, a function specifies its return type.</p>
<pre><code class="language-move">fun zero(): u64 { 0 }
</code></pre>
<p>Here <code>: u64</code> indicates that the function's return type is <code>u64</code>.</p>
<p>Using <a href="./primitive-types/tuples.html">tuples</a>, a function can return multiple values:</p>
<pre><code class="language-move">fun one_two_three(): (u64, u64, u64) { (0, 1, 2) }
</code></pre>
<p>If no return type is specified, the function has an implicit return type of unit <code>()</code>. These
functions are equivalent:</p>
<pre><code class="language-move">fun just_unit(): () { () }
fun just_unit() { () }
fun just_unit() { }
</code></pre>
<p>As mentioned in the <a href="./primitive-types/tuples.html">tuples section</a>, these tuple &quot;values&quot; do not exist
as runtime values. This means that a function that returns unit <code>()</code> does not return any value
during execution.</p>
<h3 id="function-body"><a class="header" href="#function-body">Function body</a></h3>
<p>A function's body is an expression block. The return value of the function is the last value in the
sequence</p>
<pre><code class="language-move">fun example(): u64 {
    let x = 0;
    x = x + 1;
    x // returns 'x'
}
</code></pre>
<p>See <a href="functions.html#returning-values">the section below for more information on returns</a></p>
<p>For more information on expression blocks, see <a href="./variables.html">Move variables</a>.</p>
<h3 id="native-functions"><a class="header" href="#native-functions">Native Functions</a></h3>
<p>Some functions do not have a body specified, and instead have the body provided by the VM. These
functions are marked <code>native</code>.</p>
<p>Without modifying the VM source code, a programmer cannot add new native functions. Furthermore, it
is the intent that <code>native</code> functions are used for either standard library code or for functionality
needed for the given Move environment.</p>
<p>Most <code>native</code> functions you will likely see are in standard library code, such as <code>vector</code></p>
<pre><code class="language-move">module std::vector {
    native public fun length&lt;Element&gt;(v: &amp;vector&lt;Element&gt;): u64;
    ...
}
</code></pre>
<h2 id="calling"><a class="header" href="#calling">Calling</a></h2>
<p>When calling a function, the name can be specified either through an alias or fully qualified</p>
<pre><code class="language-move">module a::example {
    public fun zero(): u64 { 0 }
}

module b::other {
    use a::example::{Self, zero};
    fun call_zero() {
        // With the `use` above all of these calls are equivalent
        a::example::zero();
        example::zero();
        zero();
    }
}
</code></pre>
<p>When calling a function, an argument must be given for every parameter.</p>
<pre><code class="language-move">module a::example {
    public fun takes_none(): u64 { 0 }
    public fun takes_one(x: u64): u64 { x }
    public fun takes_two(x: u64, y: u64): u64 { x + y }
    public fun takes_three(x: u64, y: u64, z: u64): u64 { x + y + z }
}

module b::other {
    fun call_all() {
        a::example::takes_none();
        a::example::takes_one(0);
        a::example::takes_two(0, 1);
        a::example::takes_three(0, 1, 2);
    }
}
</code></pre>
<p>Type arguments can be either specified or inferred. Both calls are equivalent.</p>
<pre><code class="language-move">module aexample {
    public fun id&lt;T&gt;(x: T): T { x }
}

module b::other {
    fun call_all() {
        a::example::id(0);
        a::example::id&lt;u64&gt;(0);
    }
}
</code></pre>
<p>For more details, see <a href="./generics.html">Move generics</a>.</p>
<h2 id="returning-values"><a class="header" href="#returning-values">Returning values</a></h2>
<p>The result of a function, its &quot;return value&quot;, is the final value of its function body. For example</p>
<pre><code class="language-move">fun add(x: u64, y: u64): u64 {
    x + y
}
</code></pre>
<p>The return value here is the result of <code>x + y</code>.</p>
<p><a href="functions.html#function-body">As mentioned above</a>, the function's body is an <a href="./variables.html">expression block</a>.
The expression block can sequence various statements, and the final expression in the block will be
be the value of that block</p>
<pre><code class="language-move">fun double_and_add(x: u64, y: u64): u64 {
    let double_x = x * 2;
    let double_y = y * 2;
    double_x + double_y
}
</code></pre>
<p>The return value here is the result of <code>double_x + double_y</code></p>
<h3 id="return-expression"><a class="header" href="#return-expression"><code>return</code> expression</a></h3>
<p>A function implicitly returns the value that its body evaluates to. However, functions can also use
the explicit <code>return</code> expression:</p>
<pre><code class="language-move">fun f1(): u64 { return 0 }
fun f2(): u64 { 0 }
</code></pre>
<p>These two functions are equivalent. In this slightly more involved example, the function subtracts
two <code>u64</code> values, but returns early with <code>0</code> if the second value is too large:</p>
<pre><code class="language-move">fun safe_sub(x: u64, y: u64): u64 {
    if (y &gt; x) return 0;
    x - y
}
</code></pre>
<p>Note that the body of this function could also have been written as <code>if (y &gt; x) 0 else x - y</code>.</p>
<p>However <code>return</code> really shines is in exiting deep within other control flow constructs. In this
example, the function iterates through a vector to find the index of a given value:</p>
<pre><code class="language-move">use std::vector;
use std::option::{Self, Option};
fun index_of&lt;T&gt;(v: &amp;vector&lt;T&gt;, target: &amp;T): Option&lt;u64&gt; {
    let i = 0;
    let n = vector::length(v);
    while (i &lt; n) {
        if (vector::borrow(v, i) == target) return option::some(i);
        i = i + 1
    };

    option::none()
}
</code></pre>
<p>Using <code>return</code> without an argument is shorthand for <code>return ()</code>. That is, the following two
functions are equivalent:</p>
<pre><code class="language-move">fun foo() { return }
fun foo() { return () }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macro-functions"><a class="header" href="#macro-functions">Macro Functions</a></h1>
<p>Macro functions are a way of defining functions that are expanded during compilation at each call
site. The arguments of the macro are not evaluated eagerly like a normal function, and instead are
substituted by expression. In addition, the caller can supply code to the macro via
<a href="functions/macros.html#lambdas">lambdas</a>.</p>
<p>These expression substitution mechanics make <code>macro</code> functions similar
<a href="https://en.wikipedia.org/wiki/Macro_(computer_science)">to macros found in other programming languages</a>;
however, they are more constrained in Move than you might expect from other languages. The
parameters and return values of <code>macro</code> functions are still typed--though this can be partially
relaxed with the <a href="functions/../generics.html#_-type"><code>_</code> type</a>. The upside of this restriction however, is that
<code>macro</code> functions can be used anywhere a normal function can be used, which is notably helpful with
<a href="functions/../method-syntax.html">method syntax</a>.</p>
<p>A more extensive
<a href="https://en.wikipedia.org/wiki/Macro_(computer_science)#Syntactic_macros">syntactic macro</a> system
may come in the future.</p>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<p><code>macro</code> functions have a similar syntax to normal functions. However, all type parameter names and
all parameter names must start with a <code>$</code>. Note that <code>_</code> can still be used by itself, but not as a
prefix, and <code>$_</code> must be used instead.</p>
<pre><code class="language-text">&lt;visibility&gt;? macro fun &lt;identifier&gt;&lt;[$type_parameters: constraint],*&gt;([$identifier: type],*): &lt;return_type&gt; &lt;function_body&gt;
</code></pre>
<p>For example, the following <code>macro</code> function takes a vector and a lambda, and applies the lambda to
each element of the vector to construct a new vector.</p>
<pre><code class="language-move">macro fun map&lt;$T, $U&gt;($v: vector&lt;$T&gt;, $f: |$T| -&gt; $U): vector&lt;$U&gt; {
    let mut v = $v;
    v.reverse();
    let mut i = 0;
    let mut result = vector[];
    while (!v.is_empty()) {
        result.push_back($f(v.pop_back()));
        i = i + 1;
    };
    result
}
</code></pre>
<p>The <code>$</code> is there to indicate that the parameters (both type and value parameters) do not behave like
their normal, non-macro counterparts. For type parameters, they can be instantiated with any type
(even a reference type <code>&amp;</code> or <code>&amp;mut</code>), and they will satisfy any constraint. Similarly for
parameters, they will not be evaluated eagerly, and instead the argument expression will be
substituted at each usage.</p>
<h2 id="lambdas"><a class="header" href="#lambdas">Lambdas</a></h2>
<p>Lambdas are a new type of expression that can only be used with <code>macro</code>s. These are used to pass
code from the caller into the body of the <code>macro</code>. While the substition is done at compile time,
they are used similarly to <a href="https://en.wikipedia.org/wiki/Anonymous_function">anonymous functions</a>,
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">lambdas</a>, or
<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closures</a> in other languages.</p>
<p>As seen in the example above (<code>$f: |$T| -&gt; $U</code>), lambda types are defined with the syntax</p>
<pre><code class="language-text">|&lt;type&gt;,*| (-&gt; &lt;type&gt;)?
</code></pre>
<p>A few examples</p>
<pre><code class="language-move">|u64, u64| -&gt; u128 // a lambda that takes two u64s and returns a u128
|&amp;mut vector&lt;u8&gt;| -&gt; &amp;mut u8 // a lambda that takes a &amp;mut vector&lt;u8&gt; and returns a &amp;mut u8
</code></pre>
<p>If the return type is not annotated, it is unit <code>()</code> by default.</p>
<pre><code class="language-move">// the following are euiqvalent
|&amp;mut vector&lt;u8&gt;, u64|
|&amp;mut vector&lt;u8&gt;, u64| -&gt; ()
</code></pre>
<p>Lambda expressions are then defined at the call site of the <code>macro</code> with the syntax</p>
<pre><code class="language-text">|(&lt;identifier&gt; (: &lt;type&gt;)?),*| &lt;expression&gt;
|(&lt;identifier&gt; (: &lt;type&gt;)?),*| -&gt; &lt;type&gt; { &lt;expression&gt; }
</code></pre>
<p>Note that if the return type is annotated, the body of the lambda must be enclosed in <code>{}</code>.</p>
<p>Using the <code>map</code> macro defined above</p>
<pre><code class="language-move">let v = vector[1, 2, 3];
let doubled: vector&lt;u64&gt; = map!(v, |x| 2 * x);
let bytes: vector&lt;vector&lt;u8&gt;&gt; = map!(v, |x| std::bcs::to_bytes(&amp;x));
</code></pre>
<p>And with type annotations</p>
<pre><code class="language-move">let doubled: vector&lt;u64&gt; = map!(v, |x: u64| 2 * x); // return type annotation optional
let bytes: vector&lt;vector&lt;u8&gt;&gt; = map!(v, |x: u64| -&gt; vector&lt;u8&gt; { std::bcs::to_bytes(&amp;x) });
</code></pre>
<h3 id="capturing"><a class="header" href="#capturing">Capturing</a></h3>
<p>Lambda expressions can also refer to variables in the scope where the lambda is defined. This is
sometimes called &quot;capturing&quot;.</p>
<pre><code class="language-move">let res = foo();
let incremented = map!(vector[1, 2, 3], |x| x + res);
</code></pre>
<p>Any variable can be captured, including mutable and immutable references.</p>
<p>See the <a href="functions/macros.html#iterating-over-a-vector">Examples</a> section for more complicated usages.</p>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p>Currently, lambdas can only be used directly in the call of a <code>macro</code> function. They cannot be bound
to a variable. For example, the following is code will produce an error:</p>
<pre><code class="language-move">let f = |x| 2 * x;
//      ^^^^^^^^^ Error! Lambdas must be used directly in 'macro' calls
let doubled: vector&lt;u64&gt; = map!(vector[1, 2, 3], f);
</code></pre>
<h2 id="typing-1"><a class="header" href="#typing-1">Typing</a></h2>
<p>Like normal functions, <code>macro</code> functions are typed--the types of the parameters and return value
must be annotated. However, the body of the function is not type checked until the macro is
expanded. This means that not all usages of a given macro may be valid. For example</p>
<pre><code class="language-move">macro fun add_one&lt;$T&gt;($x: $T): $T {
    $x + 1
}
</code></pre>
<p>The above macro will not type check if <code>$T</code> is not a primitive integer type.</p>
<p>This can be particularly useful in conjunction with <a href="functions/../method-syntax.html">method syntax</a>, where the
function is not resolved until after the macro is expanded.</p>
<pre><code class="language-move">macro fun call_foo&lt;$T, $U&gt;($x: $T): &amp;$U {
    $x.foo()
}
</code></pre>
<p>This macro will only expand succesfully if <code>$T</code> has a method <code>foo</code> that returns a reference <code>&amp;$U</code>.
As described in the <a href="functions/macros.html#hygiene">hygiene</a> section, <code>foo</code> will be resolved based on the scope where
<code>call_foo</code> was defined--not where it was expanded.</p>
<h3 id="type-parameters-1"><a class="header" href="#type-parameters-1">Type Parameters</a></h3>
<p>Type parameters can be instantiated with any type, including reference types <code>&amp;</code> and <code>&amp;mut</code>. They
can also be instantiated with <a href="functions/../primitive-types/tuple.html">tuple types</a>, though the utility of this
is limited currently since tuples cannot be bound to a variable.</p>
<p>This relaxation forces the constraints of a type parameter to be satisfied at the call site in a way
that does not normally occur. It is generally recommended however to add all necessary constraints
to a type parameter. For example</p>
<pre><code class="language-move">public struct NoAbilities()
public struct CopyBox&lt;T: copy&gt; has copy, drop { value: T }
macro fun make_box&lt;$T&gt;($x: $T): CopyBox&lt;$T&gt; {
    CopyBox { value: $x }
}
</code></pre>
<p>This macro will expand only if <code>$T</code> is instantiated with a type with the <code>copy</code> ability.</p>
<pre><code class="language-move">make_box!(1); // Valid!
make_box!(NoAbilities()); // Error! 'NoAbilities' does not have the copy ability
</code></pre>
<p>The suggested declaration of <code>make_box</code> would be to add the <code>copy</code> constraint to the type parameter.
This then communicates to the caller that the type must have the <code>copy</code> ability.</p>
<pre><code class="language-move">macro fun make_box&lt;$T: copy&gt;($x: $T): CopyBox&lt;$T&gt; {
    CopyBox { value: $x }
}
</code></pre>
<p>One might reasonably ask then, why have this relaxation if the recommendation is not to use it? The
constraints on type parameters simply cannot be enforced in all cases because the bodies are not
checked until expansion. In the following example, the <code>copy</code> constraint on <code>$T</code> is not necessary in
the signature, but is necessary in the body.</p>
<pre><code class="language-move">macro fun read_ref&lt;$T&gt;($r: &amp;$T): $T {
    *$r
}
</code></pre>
<p>If however, you want to have an extremely relaxed type signature, it is instead recommended to use
the <a href="functions/macros.html#_-type"><code>_</code> type</a>.</p>
<h3 id="_-type"><a class="header" href="#_-type"><code>_</code> Type</a></h3>
<p>Normally, the <a href="functions/../generics.html#_-type"><code>_</code> placeholder type</a> is used in expressions to allow for
partial annotations of type arguments. However, with <code>macro</code> functions, the <code>_</code> type can be used in
place of type parameters to relax the signature for any type. This should increase the ergonomics of
declaring &quot;generic&quot; <code>macro</code> functions.</p>
<p>For example, we could take any combination of integers and add them together.</p>
<pre><code class="language-move">macro fun add($x: _, $y: _, $z: _): u256 {
    ($x as u256) + ($y as u256) + ($z as u256)
}
</code></pre>
<p>Additionally, the <code>_</code> type can be instantiated <em>multiple</em> times with different types. For example</p>
<pre><code class="language-move">public struct Box&lt;T&gt; has copy, drop, store { value: T }
macro fun create_two($f: |_| -&gt; Box&lt;_&gt;): (Box&lt;u8&gt;, Box&lt;u16&gt;) {
    ($f(0u8), $f(0u16))
}
</code></pre>
<p>If we declared the function with type parameters instead, the types would have to unify to a common
type, which is not possible in this case.</p>
<pre><code class="language-move">macro fun create_two&lt;$T&gt;($f: |$T| -&gt; Box&lt;$T&gt;): (Box&lt;u8&gt;, Box&lt;u16&gt;) {
    ($f(0u8), $f(0u16))
    //           ^^^^ Error! expected `u8` but found `u16`
}
...
let (a, b) = create_two!(|value| Box { value });
</code></pre>
<p>In this case, <code>$T</code> must be instantiated with a single type, but inference finds that <code>$T</code> must be
bound to both <code>u8</code> and <code>u16</code>.</p>
<p>There is a tradeoff however, as the <code>_</code> type conveys less meaning and intention for the caller.
Consider <code>map</code> macro from above redeclared with <code>_</code> instead of <code>$T</code> and <code>$U</code>.</p>
<pre><code class="language-move">macro fun map($v: vector&lt;_&gt;, $f: |_| -&gt; _): vector&lt;_&gt; {
</code></pre>
<p>There is no longer any indication of behavior of <code>$f</code> at the type level. The caller must gain
understanding from comments or the body of the macro.</p>
<h2 id="expansion-and-substitution"><a class="header" href="#expansion-and-substitution">Expansion and Substitution</a></h2>
<p>The body of the <code>macro</code> is substituted into the call site at compile time. Each parameter is
replaced by the <em>expression</em>, not the value, of its argument. For lambdas, additional local
variables can have values bound within the context of the <code>macro</code> body.</p>
<p>Taking a very simple example</p>
<pre><code class="language-move">macro fun apply($f: |u64| -&gt; u64, $x: u64): u64 {
    $f($x)
}
</code></pre>
<p>With the call site</p>
<pre><code class="language-move">let incremented = apply!(|x| x + 1, 5);
</code></pre>
<p>This will roughly be expanded to</p>
<pre><code class="language-move">let incremented = {
    let x = { 5 };
    { x + 1 }
};
</code></pre>
<p>Again, the value of <code>x</code> is not substituted, but the expression <code>5</code> is. This might mean that an
argument is evaluated multiple times, or not at all, depending on the body of the <code>macro</code>.</p>
<pre><code class="language-move">macro fun dup($f: |u64, u64| -&gt; u64, $x: u64): u64 {
    $f($x, $x)
}
</code></pre>
<pre><code class="language-move">let sum = dup!(|x, y| x + y, foo());
</code></pre>
<p>is expanded to</p>
<pre><code class="language-move">let sum = {
    let x = { foo() };
    let y = { foo() };
    { x + y }
};
</code></pre>
<p>Note that <code>foo()</code> will be called twice. Which would not happen if <code>dup</code> were a normal function.</p>
<p>It is often recommended to create predictable evaluation behavior by binding arguments to local
variables.</p>
<pre><code class="language-move">macro fun dup($f: |u64, u64| -&gt; u64, $x: u64): u64 {
    let a = $x;
    $f(a, a)
}
</code></pre>
<p>Now that same call site will expand to</p>
<pre><code class="language-move">let sum = {
    let a = { foo() };
    {
        let x = { a };
        let y = { a };
        { x + y }
    }
};
</code></pre>
<h3 id="hygiene"><a class="header" href="#hygiene">Hygiene</a></h3>
<p>In the example above, the <code>dup</code> macro had a local variable <code>a</code> that was used to bind the argument
<code>$x</code>. You might ask, what would happen if the variable was instead named <code>x</code>? Would that conflict
with the <code>x</code> in the lambda?</p>
<p>The short answer is, no. <code>macro</code> functions are
<a href="https://en.wikipedia.org/wiki/Hygienic_macro">hygienic</a>, meaning that the expansion of <code>macro</code>s and
lambdas will not accidentally capture variables from another scope.</p>
<p>The compiler does this by associating a unique number with each scope. When the <code>macro</code> is expanded,
the macro body gets its own scope. Additionally, the arguments are rescoped on each usage.</p>
<p>Modifying the <code>dup</code> macro to use <code>x</code> instead of <code>a</code></p>
<pre><code class="language-move">macro fun dup($f: |u64, u64| -&gt; u64, $x: u64): u64 {
    let a = $x;
    $f(a, a)
}
</code></pre>
<p>The expansion of the call site</p>
<pre><code class="language-move">// let sum = dup!(|x, y| x + y, foo());
let sum = {
    let x#1 = { foo() };
    {
        let x#2 = { x#1 };
        let y#2 = { x#1 };
        { x#2 + y#2 }
    }
};
</code></pre>
<p>This is an approximation of the compiler's internal representation, some details are omitted for the
simplicity of this example.</p>
<p>And each usage of an argument is rescoped so that the different usages do not conflict.</p>
<pre><code class="language-move">macro fun apply_twice($f: |u64| -&gt; u64, $x: u64): u64 {
    $f($x) + $f($x)
}
</code></pre>
<pre><code class="language-move">let result = apply_twice!(|x| x + 1, { let x = 5; x });
</code></pre>
<p>Expands to</p>
<pre><code class="language-move">let result = {
    {
        let x#1 = { let x#2 = { 5 }; x#2 };
        { x#1 + x#1 }
    }
    +
    {
        let x#3 = { let x#4 = { 5 }; x#4 };
        { x#3 + x#3 }
    }
};
</code></pre>
<p>Similar to variable hygiene, <a href="functions/../method-syntax.html">method resolution</a> is also scoped to the macro
definition. For example</p>
<pre><code class="language-move">public struct S { f: u64, g: u64 }

fun f(s: &amp;S): u64 {
    s.f
}
fun g(s: &amp;S): u64 {
    s.g
}

use fun f as foo;
macro fun call_foo($s: &amp;S): u64 {
    let s = $s;
    s.foo()
}
</code></pre>
<p>The method call <code>foo</code> will in this case always resolve to the function <code>f</code>, even if <code>call_foo</code> is
used in a scope where <code>foo</code> is bound to a different function, such as <code>g</code>.</p>
<pre><code class="language-move">fun example(s: &amp;S): u64 {
    use fun g as foo;
    call_foo!(s) // expands to 'f(s)', not 'g(s)'
}
</code></pre>
<p>Due to this though, unused <code>use fun</code> declarations might not get warnings in modules with <code>macro</code>
functions.</p>
<h3 id="control-flow-2"><a class="header" href="#control-flow-2">Control Flow</a></h3>
<p>Similar to variable hygiene, control flow constructs are also always scoped to where they are
defined, not to where they are expanded.</p>
<pre><code class="language-move">macro fun maybe_div($x: u64, $y: u64): u64 {
    let x = $x;
    let y = $y;
    if (y == 0) return 0;
    x / y
}
</code></pre>
<p>At the call site, <code>return</code> will always return from the <code>macro</code> body, not from the caller.</p>
<pre><code class="language-move">let result: vector&lt;u64&gt; = vector[maybe_div!(10, 0)];
</code></pre>
<p>Will expand to</p>
<pre><code class="language-move">let result: vector&lt;u64&gt; = vector['a: {
    let x = { 10 };
    let y = { 0 };
    if (y == 0) return 'a 0;
    x / y
}];
</code></pre>
<p>Where <code>return 'a 0</code> will return to the block <code>'a: { ... }</code> and not to the caller's body. See the
section on <a href="functions/../control-flow/labeled-control-flow.html">labeled control flow</a> for more details.</p>
<p>Similarly, <code>return</code> in a lambda will return from the lambda, not from the <code>macro</code> body and not from
the outer function.</p>
<pre><code class="language-move">macro fun apply($f: |u64| -&gt; u64, $x: u64): u64 {
    $f($x)
}
</code></pre>
<p>and</p>
<pre><code class="language-move">let result = apply!(|x| { if (x == 0) return 0; x + 1 }, 100);
</code></pre>
<p>will expand to</p>
<pre><code class="language-move">let result = {
    let x = { 100 };
    'a: {
        if (x == 0) return 'a 0;
        x + 1
    }
};
</code></pre>
<p>In addition to returning from the lambda, a label can be used to return to the outer function. In
the <code>vector::any</code> macro, a <code>return</code> with a label is used to return from the entire <code>macro</code> early</p>
<pre><code class="language-move">public macro fun any&lt;$T&gt;($v: &amp;vector&lt;$T&gt;, $f: |&amp;$T| -&gt; bool): bool {
    let v = $v;
    'any: {
        v.do_ref!(|e| if ($f(e)) return 'any true);
        false
    }
}
</code></pre>
<p>The <code>return 'any true</code> exits from the &quot;loop&quot; early when the condition is met. Otherwise, the macro
&quot;returns&quot; <code>false</code>.</p>
<h3 id="method-syntax"><a class="header" href="#method-syntax">Method Syntax</a></h3>
<p>When applicable, <code>macro</code> functions can be called using <a href="functions/../method-syntax.html">method syntax</a>. When
using method syntax, the evaluation of the arguments will change in that the first argument (the
&quot;receiver&quot; of the method) will be evaluated outside of the macro expansion. This example is
contrived, but will concisely demonstrate the behavior.</p>
<pre><code class="language-move">public struct S() has copy, drop;
public fun foo(): S { abort 0 }
public macro fun maybe_s($s: S, $cond: bool): S {
    if ($cond) $s
    else S()
}
</code></pre>
<p>Even though <code>foo()</code> will abort, its return type can be used to start a method call.</p>
<p><code>$s</code> will not be evaluated if <code>$cond</code> is <code>false</code>, and under a normal non-method call, an argument of
<code>foo()</code> would not be evaluated and would not abort. The following example demonstrates <code>$s</code> not
being evaluated with an argument of <code>foo()</code>.</p>
<pre><code class="language-move">maybe_s!(foo(), false) // does not abort
</code></pre>
<p>It becomes more clear as to why it does not abort when looking at the expanded form</p>
<pre><code class="language-move">if (false) foo()
else S()
</code></pre>
<p>However, when using method syntax, the first argument is evaluated before the macro is expanded. So
the same argument of <code>foo()</code> for <code>$s</code> will now be evaluated and will abort.</p>
<pre><code class="language-move">foo().maybe_s!(false) // aborts
</code></pre>
<p>We can see this more clearly when looking the expanded form</p>
<pre><code class="language-move">let tmp = foo(); // aborts
if (false) tmp
else S()
</code></pre>
<p>Conceptually, the receiver for a method call is bound to a temporary variable before the macro is
expanded, which forces the evaluation and thus the abort.</p>
<h3 id="parameter-limitations"><a class="header" href="#parameter-limitations">Parameter Limitations</a></h3>
<p>The parameters of a <code>macro</code> function must always be used as expressions. They cannot be used in
sutations where the argument might be re-interpreted. For example, the following is not allowed</p>
<pre><code class="language-move">macro fun no($x: _): _ {
    $x.f
}
</code></pre>
<p>The reason is that if the argument <code>$x</code> was not a reference, it would be borrowed first, which would
could re-interpret the argument. To get around this limitation, you should bind the argument to a
local variable.</p>
<pre><code class="language-move">macro fun yes($x: _): _ {
    let x = $x;
    x.f
}
</code></pre>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="lazy-arguments-assert_eq"><a class="header" href="#lazy-arguments-assert_eq">Lazy arguments: assert_eq</a></h3>
<pre><code class="language-move">macro fun assert_eq&lt;$T&gt;($left: $T, $right: $T, $code: u64) {
    let left = $left;
    let right = $right;
    if (left != right) {
        std::debug::print(&amp;b&quot;assertion failed.\n left: &quot;);
        std::debug::print(&amp;left);
        std::debug::print(&amp;b&quot;\n does not equal right: &quot;);
        std::debug::print(&amp;right);
        abort $code;
    }
}
</code></pre>
<p>In this case the argument to <code>$code</code> is not evaluated unless the assertion fails.</p>
<pre><code class="language-move">assert_eq!(vector[true, false], vector[true, false], 1 / 0); // division by zero is not evaluated
</code></pre>
<h3 id="any-integer-square-root"><a class="header" href="#any-integer-square-root">Any integer square root</a></h3>
<p>This macro calculates the integer square root for any integer type, besides <code>u256</code>.</p>
<p><code>$T</code> is the type of the input and <code>$bitsize</code> is the number of bits in that type, for example <code>u8</code>
has 8 bits. <code>$U</code> should be set to the next larger integer type, for example <code>u16</code> for <code>u8</code>.</p>
<p>In this <code>macro</code>, the type of the integer literals are <code>1</code> and <code>0</code> are annotated, e.g. <code>(1: $U)</code>
allowing for the type of the literal to differ with each call. Similarly, <code>as</code> can be used with the
type parameters <code>$T</code> and <code>$U</code>. This macro will then only successfully expand if <code>$T</code> and <code>$U</code> are
instantiated with the integer types.</p>
<pre><code class="language-move">macro fun num_sqrt&lt;$T, $U&gt;($x: $T, $bitsize: u8): $T {
    let x = $x;
    let mut bit = (1: $U) &lt;&lt; $bitsize;
    let mut res = (0: $U);
    let mut x = x as $U;

    while (bit != 0) {
        if (x &gt;= res + bit) {
            x = x - (res + bit);
            res = (res &gt;&gt; 1) + bit;
        } else {
            res = res &gt;&gt; 1;
        };
        bit = bit &gt;&gt; 2;
    };

    res as $T
}
</code></pre>
<h3 id="iterating-over-a-vector"><a class="header" href="#iterating-over-a-vector">Iterating over a vector</a></h3>
<p>The two <code>macro</code>s iterate over a vector, immutably and mutably respectively.</p>
<pre><code class="language-move">macro fun for_imm&lt;$T&gt;($v: &amp;vector&lt;$T&gt;, $f: |&amp;$T|) {
    let v = $v;
    let n = v.length();
    let mut i = 0;
    while (i &lt; n) {
        $f(&amp;v[i]);
        i = i + 1;
    }
}

macro fun for_mut&lt;$T&gt;($v: &amp;mut vector&lt;$T&gt;, $f: |&amp;mut $T|) {
    let v = $v;
    let n = v.length();
    let mut i = 0;
    while (i &lt; n) {
        $f(&amp;mut v[i]);
        i = i + 1;
    }
}
</code></pre>
<p>A few examples of usage</p>
<pre><code class="language-move">fun imm_examples(v: &amp;vector&lt;u64&gt;) {
    // print all elements
    for_imm!(v, |x| std::debug::print(x));

    // sum all elements
    let mut sum = 0;
    for_imm!(v, |x| sum = sum + x);

    // find the max element
    let mut max = 0;
    for_imm!(v, |x| if (x &gt; max) max = x);
}

fun mut_examples(v: &amp;mut vector&lt;u64&gt;) {
    // increment each element
    for_mut!(v, |x| *x = *x + 1);

    // set each element to the previous value, and the first to last value
    let mut prev = v[v.length() - 1];
    for_mut!(v, |x| {
        let tmp = *x;
        *x = prev;
        prev = tmp;
    });

    // set the max element to 0
    let mut max = &amp;mut 0;
    for_mut!(v, |x| if (*x &gt; *max) max = x);
    *max = 0;
}
</code></pre>
<h3 id="non-loop-lambda-usage"><a class="header" href="#non-loop-lambda-usage">Non-loop lambda usage</a></h3>
<p>Lambdas do not need to be used in loops, and are often useful for conditionally applying code.</p>
<pre><code class="language-move">macro fun inspect&lt;$T&gt;($opt: &amp;Option&lt;$T&gt;, $f: |&amp;$T|) {
    let opt = $opt;
    if (opt.is_some()) $f(opt.borrow())
}

macro fun is_some_and&lt;$T&gt;($opt: &amp;Option&lt;$T&gt;, $f: |&amp;$T| -&gt; bool): bool {
    let opt = $opt;
    if (opt.is_some()) $f(opt.borrow())
    else false
}

macro fun map&lt;$T, $U&gt;($opt: Option&lt;$T&gt;, $f: |$T| -&gt; $U): Option&lt;$U&gt; {
    let opt = $opt;
    if (opt.is_some()) {
        option::some($f(opt.destroy_some()))
    } else {
        opt.destroy_none();
        option::none()
    }
}
</code></pre>
<p>And some examples of usage</p>
<pre><code class="language-move">fun examples(opt: Option&lt;u64&gt;) {
    // print the value if it exists
    inspect!(&amp;opt, |x| std::debug::print(x));

    // check if the value is 0
    let is_zero = is_some_and!(&amp;opt, |x| *x == 0);

    // upcast the u64 to a u256
    let str_opt = map!(opt, |x| x as u256);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-and-resources"><a class="header" href="#structs-and-resources">Structs and Resources</a></h1>
<p>A <em>struct</em> is a user-defined data structure containing typed fields. Structs can store any
non-reference, non-tuple type, including other structs.</p>
<p>Structs can be used to define all &quot;asset&quot; values or unrestricted values, where the operations
performed on those values can be controlled by the struct's <a href="./abilities.html">abilities</a>. By default,
structs are linear and ephemeral. By this we mean that they: cannot be copied, cannot be dropped,
and cannot be stored in storage. This means that all values have to have ownership transferred
(linear) and the values must be dealt with by the end of the program's execution (ephemeral). We can
relax this behavior by giving the struct <a href="./abilities.html">abilities</a> which allow values to be copied
or dropped and also to be stored in storage or to define storage schemas.</p>
<h2 id="defining-structs"><a class="header" href="#defining-structs">Defining Structs</a></h2>
<p>Structs must be defined inside a module, and the struct's fields can either be named or positional:</p>
<pre><code class="language-move">module a::m {
    public struct Foo { x: u64, y: bool }
    public struct Bar {}
    public struct Baz { foo: Foo, }
    //                          ^ note: it is fine to have a trailing comma

    public struct PosFoo(u64, bool)
    public struct PosBar()
    public struct PosBaz(Foo)
}
</code></pre>
<p>Structs cannot be recursive, so the following definitions are invalid:</p>
<pre><code class="language-move">public struct Foo { x: Foo }
//                     ^ ERROR! recursive definition

public struct A { b: B }
public struct B { a: A }
//                   ^ ERROR! recursive definition

public struct D(D)
//              ^ ERROR! recursive definition
</code></pre>
<h3 id="visibility-1"><a class="header" href="#visibility-1">Visibility</a></h3>
<p>As you may have noticed, all structs are declared as <code>public</code>. This means that the type of the
struct can be referred to from any other module. However, the fields of the struct, and the ability
to create or destroy the struct, are still internal to the module that defines the struct.</p>
<p>In the future, we plan on adding to declare structs as <code>public(package)</code> or as internal, much like
<a href="./functions.html#visibility">functions</a>.</p>
<h3 id="abilities"><a class="header" href="#abilities">Abilities</a></h3>
<p>As mentioned above: by default, a struct declaration is linear and ephemeral. So to allow the value
to be used in these ways (e.g., copied, dropped, stored in an <a href="./abilities/object.html">object</a>, or
used to define a storable <a href="./abilities/object.html">object</a>), structs can be granted
<a href="./abilities.html">abilities</a> by annotating them with <code>has &lt;ability&gt;</code>:</p>
<pre><code class="language-move">module a::m {
    public struct Foo has copy, drop { x: u64, y: bool }
}
</code></pre>
<p>The ability declaration can occur either before or after the struct's fields. However, only one or
the other can be used, and not both. If declared after the struct's fields, the ability declaration
must be terminated with a semicolon:</p>
<pre><code class="language-move">module a::m {
    public struct PreNamedAbilities has copy, drop { x: u64, y: bool }
    public struct PostNamedAbilities { x: u64, y: bool } has copy, drop;
    public struct PostNamedAbilitiesInvalid { x: u64, y: bool } has copy, drop
    //                                                                        ^ ERROR! missing semicolon

    public struct NamedInvalidAbilities has copy { x: u64, y: bool } has drop;
    //                                                               ^ ERROR! duplicate ability declaration

    public struct PrePositionalAbilities has copy, drop (u64, bool)
    public struct PostPositionalAbilities (u64, bool) has copy, drop;
    public struct PostPositionalAbilitiesInvalid (u64, bool) has copy, drop
    //                                                                     ^ ERROR! missing semicolon
    public struct InvalidAbilities has copy (u64, bool) has drop;
    //                                                  ^ ERROR! duplicate ability declaration
}
</code></pre>
<p>For more details, see the section on
<a href="./abilities.html#annotating-structs-and-enums">annotating a struct's abilities</a>.</p>
<h3 id="naming"><a class="header" href="#naming">Naming</a></h3>
<p>Structs must start with a capital letter <code>A</code> to <code>Z</code>. After the first letter, struct names can
contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<pre><code class="language-move">public struct Foo {}
public struct BAR {}
public struct B_a_z_4_2 {}
public struct P_o_s_Foo()
</code></pre>
<p>This naming restriction of starting with <code>A</code> to <code>Z</code> is in place to give room for future language
features. It may or may not be removed later.</p>
<h2 id="using-structs"><a class="header" href="#using-structs">Using Structs</a></h2>
<h3 id="creating-structs"><a class="header" href="#creating-structs">Creating Structs</a></h3>
<p>Values of a struct type can be created (or &quot;packed&quot;) by indicating the struct name, followed by
value for each field.</p>
<p>For a struct with named fields, the order of the fields does not matter, but the field name needs to
be provided. For a struct with positional fields, the order of the fields must match the order of
the fields in the struct definition, and it must be created using <code>()</code> instead of <code>{}</code> to enclose
the parameters.</p>
<pre><code class="language-move">module a::m {
    public struct Foo has drop { x: u64, y: bool }
    public struct Baz has drop { foo: Foo }
    public struct Positional(u64, bool) has drop;

    fun example() {
        let foo = Foo { x: 0, y: false };
        let baz = Baz { foo: foo };
        // Note: positional struct values are created using parentheses and
        // based on position instead of name.
        let pos = Positional(0, false);
        let pos_invalid = Positional(false, 0);
        //                           ^ ERROR! Fields are out of order and the types don't match.
    }
}
</code></pre>
<p>For structs with named fields, you can use the following shorthand if you have a local variable with
the same name as the field:</p>
<pre><code class="language-move">let baz = Baz { foo: foo };
// is equivalent to
let baz = Baz { foo };
</code></pre>
<p>This is sometimes called &quot;field name punning&quot;.</p>
<h3 id="destroying-structs-via-pattern-matching"><a class="header" href="#destroying-structs-via-pattern-matching">Destroying Structs via Pattern Matching</a></h3>
<p>Struct values can be destroyed by binding or assigning them in patterns using similar syntax to
constructing them.</p>
<pre><code class="language-move">module a::m {
    public struct Foo { x: u64, y: bool }
    public struct Bar(Foo)
    public struct Baz {}
    public struct Qux()

    fun example_destroy_foo() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y: foo_y } = foo;
        //        ^ shorthand for `x: x`

        // two new bindings
        //   x: u64 = 3
        //   foo_y: bool = false
    }

    fun example_destroy_foo_wildcard() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y: _ } = foo;

        // only one new binding since y was bound to a wildcard
        //   x: u64 = 3
    }

    fun example_destroy_foo_assignment() {
        let x: u64;
        let y: bool;
        Foo { x, y } = Foo { x: 3, y: false };

        // mutating existing variables x and y
        //   x = 3, y = false
    }

    fun example_foo_ref() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y } = &amp;foo;

        // two new bindings
        //   x: &amp;u64
        //   y: &amp;bool
    }

    fun example_foo_ref_mut() {
        let foo = Foo { x: 3, y: false };
        let Foo { x, y } = &amp;mut foo;

        // two new bindings
        //   x: &amp;mut u64
        //   y: &amp;mut bool
    }

    fun example_destroy_bar() {
        let bar = Bar(Foo { x: 3, y: false });
        let Bar(Foo { x, y }) = bar;
        //            ^ nested pattern

        // two new bindings
        //   x: u64 = 3
        //   y: bool = false
    }

    fun example_destroy_baz() {
        let baz = Baz {};
        let Baz {} = baz;
    }

    fun example_destroy_qux() {
        let qux = Qux();
        let Qux() = qux;
    }
}
</code></pre>
<h3 id="accessing-struct-fields"><a class="header" href="#accessing-struct-fields">Accessing Struct Fields</a></h3>
<p>Fields of a struct can be accessed using the dot operator <code>.</code>.</p>
<p>For structs with named fields, the fields can be accessed by their name:</p>
<pre><code class="language-move">public struct Foo { x: u64, y: bool }
let foo = Foo { x: 3, y: true };
let x = foo.x;  // x == 3
let y = foo.y;  // y == true
</code></pre>
<p>For positional structs, fields can be accessed by their position in the struct definition:</p>
<pre><code class="language-move">public struct PosFoo(u64, bool)
let pos_foo = PosFoo(3, true);
let x = pos_foo.0;  // x == 3
let y = pos_foo.1;  // y == true
</code></pre>
<p>Accessing struct fields without borrowing or copying them is subject to the field's ability
constraints. For more details see the sections on
<a href="structs.html#borrowing-structs-and-fields">borrowing structs and fields</a> and
<a href="structs.html#reading-and-writing-fields">reading and writing fields</a> for more information.</p>
<h3 id="borrowing-structs-and-fields"><a class="header" href="#borrowing-structs-and-fields">Borrowing Structs and Fields</a></h3>
<p>The <code>&amp;</code> and <code>&amp;mut</code> operator can be used to create references to structs or fields. These examples
include some optional type annotations (e.g., <code>: &amp;Foo</code>) to demonstrate the type of operations.</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let foo_ref: &amp;Foo = &amp;foo;
let y: bool = foo_ref.y;         // reading a field via a reference to the struct
let x_ref: &amp;u64 = &amp;foo.x;        // borrowing a field by extending a reference to the struct

let x_ref_mut: &amp;mut u64 = &amp;mut foo.x;
*x_ref_mut = 42;            // modifying a field via a mutable reference
</code></pre>
<p>It is possible to borrow inner fields of nested structs:</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let bar = Bar(foo);

let x_ref = &amp;bar.0.x;
</code></pre>
<p>You can also borrow a field via a reference to a struct:</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let foo_ref = &amp;foo;
let x_ref = &amp;foo_ref.x;
// this has the same effect as let x_ref = &amp;foo.x
</code></pre>
<h3 id="reading-and-writing-fields"><a class="header" href="#reading-and-writing-fields">Reading and Writing Fields</a></h3>
<p>If you need to read and copy a field's value, you can then dereference the borrowed field:</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let bar = Bar(copy foo);
let x: u64 = *&amp;foo.x;
let y: bool = *&amp;foo.y;
let foo2: Foo = *&amp;bar.0;
</code></pre>
<p>More canonically, the dot operator can be used to read fields of a struct without any borrowing. As
is true with
<a href="./primitive-types/references.html#reading-and-writing-through-references">dereferencing</a>, the field
type must have the <code>copy</code> <a href="./abilities.html">ability</a>.</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let x = foo.x;  // x == 3
let y = foo.y;  // y == true
</code></pre>
<p>Dot operators can be chained to access nested fields:</p>
<pre><code class="language-move">let bar = Bar(Foo { x: 3, y: true });
let x = baz.0.x; // x = 3;
</code></pre>
<p>However, this is not permitted for fields that contain non-primitive types, such a vector or another
struct:</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let bar = Bar(foo);
let foo2: Foo = *&amp;bar.0;
let foo3: Foo = bar.0; // error! must add an explicit copy with *&amp;
</code></pre>
<p>We can mutably borrow a field to a struct to assign it a new value:</p>
<pre><code class="language-move">let mut foo = Foo { x: 3, y: true };
*&amp;mut foo.x = 42;     // foo = Foo { x: 42, y: true }
*&amp;mut foo.y = !foo.y; // foo = Foo { x: 42, y: false }
let mut bar = Bar(foo);               // bar = Bar(Foo { x: 42, y: false })
*&amp;mut bar.0.x = 52;                   // bar = Bar(Foo { x: 52, y: false })
*&amp;mut bar.0 = Foo { x: 62, y: true }; // bar = Bar(Foo { x: 62, y: true })
</code></pre>
<p>Similar to dereferencing, we can instead directly use the dot operator to modify a field. And in
both cases, the field type must have the <code>drop</code> <a href="./abilities.html">ability</a>.</p>
<pre><code class="language-move">let mut foo = Foo { x: 3, y: true };
foo.x = 42;     // foo = Foo { x: 42, y: true }
foo.y = !foo.y; // foo = Foo { x: 42, y: false }
let mut bar = Bar(foo);         // bar = Bar(Foo { x: 42, y: false })
bar.0.x = 52;                   // bar = Bar(Foo { x: 52, y: false })
bar.0 = Foo { x: 62, y: true }; // bar = Bar(Foo { x: 62, y: true })
</code></pre>
<p>The dot syntax for assignment also works via a reference to a struct:</p>
<pre><code class="language-move">let foo = Foo { x: 3, y: true };
let foo_ref = &amp;mut foo;
foo_ref.x = foo_ref.x + 1;
</code></pre>
<h2 id="privileged-struct-operations"><a class="header" href="#privileged-struct-operations">Privileged Struct Operations</a></h2>
<p>Most struct operations on a struct type <code>T</code> can only be performed inside the module that declares
<code>T</code>:</p>
<ul>
<li>Struct types can only be created (&quot;packed&quot;), destroyed (&quot;unpacked&quot;) inside the module that defines
the struct.</li>
<li>The fields of a struct are only accessible inside the module that defines the struct.</li>
</ul>
<p>Following these rules, if you want to modify your struct outside the module, you will need to
provide public APIs for them. The end of the chapter contains some examples of this.</p>
<p>However as stated <a href="structs.html#visibility">in the visibility section above</a>, struct <em>types</em> are always visible
to another module</p>
<pre><code class="language-move">module a::m {
    public struct Foo has drop { x: u64 }

    public fun new_foo(): Foo {
        Foo { x: 42 }
    }
}

module a::n {
    use a::m::Foo;

    public struct Wrapper has drop {
        foo: Foo
        //   ^ valid the type is public

    }

    fun f1(foo: Foo) {
        let x = foo.x;
        //      ^ ERROR! cannot access fields of `Foo` outside of `a::m`
    }

    fun f2() {
        let foo_wrapper = Wrapper { foo: m::new_foo() };
        //                               ^ valid the function is public
    }
}

</code></pre>
<h2 id="ownership-5"><a class="header" href="#ownership-5">Ownership</a></h2>
<p>As mentioned above in <a href="structs.html#defining-structs">Defining Structs</a>, structs are by default linear and
ephemeral. This means they cannot be copied or dropped. This property can be very useful when
modeling real world assets like money, as you do not want money to be duplicated or get lost in
circulation.</p>
<pre><code class="language-move">module a::m {
    public struct Foo { x: u64 }

    public fun copying() {
        let foo = Foo { x: 100 };
        let foo_copy = copy foo; // ERROR! 'copy'-ing requires the 'copy' ability
        let foo_ref = &amp;foo;
        let another_copy = *foo_ref // ERROR! dereference requires the 'copy' ability
    }

    public fun destroying_1() {
        let foo = Foo { x: 100 };

        // error! when the function returns, foo still contains a value.
        // This destruction requires the 'drop' ability
    }

    public fun destroying_2(f: &amp;mut Foo) {
        *f = Foo { x: 100 } // error!
                            // destroying the old value via a write requires the 'drop' ability
    }
}
</code></pre>
<p>To fix the example <code>fun destroying_1</code>, you would need to manually &quot;unpack&quot; the value:</p>
<pre><code class="language-move">module a::m {
    public struct Foo { x: u64 }

    public fun destroying_1_fixed() {
        let foo = Foo { x: 100 };
        let Foo { x: _ } = foo;
    }
}
</code></pre>
<p>Recall that you are only able to deconstruct a struct within the module in which it is defined. This
can be leveraged to enforce certain invariants in a system, for example, conservation of money.</p>
<p>If on the other hand, your struct does not represent something valuable, you can add the abilities
<code>copy</code> and <code>drop</code> to get a struct value that might feel more familiar from other programming
languages:</p>
<pre><code class="language-move">module a::m {
    public struct Foo has copy, drop { x: u64 }

    public fun run() {
        let foo = Foo { x: 100 };
        let foo_copy = foo;
        //             ^ this code copies foo,
        //             whereas `let x = move foo` would move foo

        let x = foo.x;            // x = 100
        let x_copy = foo_copy.x;  // x = 100

        // both foo and foo_copy are implicitly discarded when the function returns
    }
}
</code></pre>
<h2 id="storage"><a class="header" href="#storage">Storage</a></h2>
<p>Structs can be used to define storage schemas, but the details are different per deployment of Move.
See the documentation for the <a href="./abilities.html#key"><code>key</code> ability</a> and
<a href="./abilities/object.html">Sui objects</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerations"><a class="header" href="#enumerations">Enumerations</a></h1>
<p>An <em>enum</em> is a user-defined data structure containing one or more <em>variants</em>. Each variant can
optionally contain typed fields. The number, and types of these fields can differ for each variant
in the enumeration. Fields in enums can store any non-reference, non-tuple type, including other
structs or enums.</p>
<p>As a simple example, consider the following enum definition in Move:</p>
<pre><code class="language-move">public enum Action {
    Stop,
    Pause { duration: u32 },
    MoveTo { x: u64, y: u64 },
    Jump(u64),
}
</code></pre>
<p>This declares an enum <code>Action</code> that represents different actions that can be taken by a game -- you
can <code>Stop</code>, <code>Pause</code> for a given duration, <code>MoveTo</code> a specific location, or <code>Jump</code> to a specific
height.</p>
<p>Similar to structs, enums can have <a href="./abilities.html">abilities</a> that control what operations can be
performed on them. It is important to note however that enums cannot have the <code>key</code> ability since
they cannot be top-level objects.</p>
<h2 id="defining-enums"><a class="header" href="#defining-enums">Defining Enums</a></h2>
<p>Enums must be defined in a module, an enum must contain at least one variant, and each variant of an
enum can either have no fields, positional fields, or named fields. Here are some examples of each:</p>
<pre><code class="language-move">module a::m {
    public enum Foo has drop {
        VariantWithNoFields,
        //                 ^ note: it is fine to have a trailing comma after variant declarations
    }
    public enum Bar has copy, drop {
        VariantWithPositionalFields(u64, bool),
    }
    public enum Baz has drop {
        VariantWithNamedFields { x: u64, y: bool, z: Bar },
    }
}
</code></pre>
<p>Enums cannot be recursive in any of their variants, so the following definitions of an enum are not
allowed because they would be recursive in at least one variant.</p>
<p>Incorrect:</p>
<pre><code class="language-move">module a::m {
    public enum Foo {
        Recursive(Foo),
        //        ^ error: recursive enum variant
    }
    public enum List {
        Nil,
        Cons { head: u64, tail: List },
        //                      ^ error: recursive enum variant
    }
    public enum BTree&lt;T&gt; {
        Leaf(T),
        Node { left: BTree&lt;T&gt;, right: BTree&lt;T&gt; },
        //           ^ error: recursive enum variant
    }

    // Mutually recursive enums are also not allowed
    public enum MutuallyRecursiveA {
        Base,
        Other(MutuallyRecursiveB),
        //    ^^^^^^^^^^^^^^^^^^ error: recursive enum variant
    }

    public enum MutuallyRecursiveB {
        Base,
        Other(MutuallyRecursiveA),
        //    ^^^^^^^^^^^^^^^^^^ error: recursive enum variant
    }
}
</code></pre>
<h2 id="visibility-2"><a class="header" href="#visibility-2">Visibility</a></h2>
<p>All enums are declared as <code>public</code>. This means that the type of the enum can be referred to from any
other module. However, the variants of the enum, the fields within each variant, and the ability to
create or destroy variants of the enum are internal to the module that defines the enum.</p>
<h3 id="abilities-1"><a class="header" href="#abilities-1">Abilities</a></h3>
<p>Just like with structs, by default an enum declaration is linear and ephemeral. To use an enum value
in a non-linear or non-ephemeral way -- i.e., copied, dropped, or stored in an
<a href="./abilities/object.html">object</a> -- you need to grant it additional <a href="./abilities.html">abilities</a> by
annotating them with <code>has &lt;ability&gt;</code>:</p>
<pre><code class="language-move">module a::m {
    public enum Foo has copy, drop {
        VariantWithNoFields,
    }
}
</code></pre>
<p>The ability declaration can occur either before or after the enum's variants, however only one or
the other can be used, and not both. If declared after the variants, the ability declaration must be
terminated with a semicolon:</p>
<pre><code class="language-move">module a::m {
    public enum PreNamedAbilities has copy, drop { Variant }
    public enum PostNamedAbilities { Variant } has copy, drop;
    public enum PostNamedAbilitiesInvalid { Variant } has copy, drop
    //                                                              ^ ERROR! missing semicolon

    public enum NamedInvalidAbilities has copy { Variant } has drop;
    //                                                     ^ ERROR! duplicate ability declaration
}
</code></pre>
<p>For more details, see the section on
<a href="./abilities.html#annotating-structs-and-enums">annotating abilities</a>.</p>
<h2 id="naming-1"><a class="header" href="#naming-1">Naming</a></h2>
<p>Enums and variants within enums must start with a capital letter <code>A</code> to <code>Z</code>. After the first letter,
enum names can contain underscores <code>_</code>, lowercase letters <code>a</code> to <code>z</code>, uppercase letters <code>A</code> to <code>Z</code>,
or digits <code>0</code> to <code>9</code>.</p>
<pre><code class="language-move">public enum Foo { Variant }
public enum BAR { Variant }
public enum B_a_z_4_2 { V_a_riant_0 }
</code></pre>
<p>This naming restriction of starting with <code>A</code> to <code>Z</code> is in place to give room for future language
features.</p>
<h2 id="using-enums"><a class="header" href="#using-enums">Using Enums</a></h2>
<h3 id="creating-enum-variants"><a class="header" href="#creating-enum-variants">Creating Enum Variants</a></h3>
<p>Values of an enum type can be created (or &quot;packed&quot;) by indicating a variant of the enum, followed by
a value for each field in the variant. The variant name must always be qualified by the enum's name.</p>
<p>Similarly to structs, for a variant with named fields, the order of the fields does not matter but
the field names need to be provided. For a variant with positional fields, the order of the fields
matters and the order of the fields must match the order in the variant declaration. It must also be
created using <code>()</code> instead of <code>{}</code>. If the variant has no fields, the variant name is sufficient and
no <code>()</code> or <code>{}</code> needs to be used.</p>
<pre><code class="language-move">module a::m {
    public enum Action has drop {
        Stop,
        Pause { duration: u32 },
        MoveTo { x: u64, y: u64 },
        Jump(u64),
    }
    public enum Other has drop {
        Stop(u64),
    }

    fun example() {
        // Note: The `Stop` variant of `Action` doesn't have fields so no parentheses or curlies are needed.
        let stop = Action::Stop;
        let pause = Action::Pause { duration: 10 };
        let move_to = Action::MoveTo { x: 10, y: 20 };
        let jump = Action::Jump(10);
        // Note: The `Stop` variant of `Other` does have positional fields so we need to supply them.
        let other_stop = Other::Stop(10);
    }
}
</code></pre>
<p>For variants with named fields you can also use the shorthand syntax that you might be familiar with
from structs to create the variant:</p>
<pre><code class="language-move">let duration = 10;

let pause = Action::Pause { duration: duration };
// is equivalent to
let pause = Action::Pause { duration };
</code></pre>
<h3 id="pattern-matching-enum-variants-and-destructuring"><a class="header" href="#pattern-matching-enum-variants-and-destructuring">Pattern Matching Enum Variants and Destructuring</a></h3>
<p>Since enum values can take on different shapes, dot access to fields of variants is not allowed like
it is for struct fields. Instead, to access fields within a variant -- either by value, or immutable
or mutable reference -- you must use pattern matching.</p>
<p>You can pattern match on Move values by value, immutable reference, and mutable reference. When
pattern matching by value, the value is moved into the match arm. When pattern matching by
reference, the value is borrowed into the match arm (either immutably or mutably). We'll go through
a brief description of pattern matching using <code>match</code> here, but for more information on pattern
matching using <code>match</code> in Move see the <a href="./control-flow/pattern-matching.html">Pattern Matching</a>
section.</p>
<p>A <code>match</code> statement is used to pattern match on a Move value and consists of a number of <em>match
arms</em>. Each match arm consists of a pattern, an arrow <code>=&gt;</code>, and an expression, followed by a comma
<code>,</code>. The pattern can be a struct, enum variant, binding (<code>x</code>, <code>y</code>), wildcard (<code>_</code> or <code>..</code>), constant
(<code>ConstValue</code>), or literal value (<code>true</code>, <code>42</code>, and so on). The value is matched against each
pattern from the top-down, and will match the first pattern that structurally matches the value.
Once the value is matched, the expression on the right hand side of the <code>=&gt;</code> is executed.</p>
<p>Additionally, match arms can have optional <em>guards</em> that are checked after the pattern matches but
<em>before</em> the expression is executed. Guards are specified by the <code>if</code> keyword followed by an
expression that must evaluate to a boolean value before the <code>=&gt;</code>.</p>
<pre><code class="language-move">module a::m {
    public enum Action has drop {
        Stop,
        Pause { duration: u32 },
        MoveTo { x: u64, y: u64 },
        Jump(u64),
    }

    public struct GameState {
        // Fields containing a game state
        character_x: u64,
        character_y: u64,
        character_height: u64,
        // ...
    }

    fun perform_action(stat: &amp;mut GameState, action: Action) {
        match (action) {
            // Handle the `Stop` variant
            Action::Stop =&gt; state.stop(),
            // Handle the `Pause` variant
            // If the duration is 0, do nothing
            Action::Pause { duration: 0 } =&gt; (),
            Action::Pause { duration } =&gt; state.pause(duration),
            // Handle the `MoveTo` variant
            Action::MoveTo { x, y } =&gt; state.move_to(x, y),
            // Handle the `Jump` variant
            // if the game disallows jumps then do nothing
            Action::Jump(_) if (state.jumps_not_allowed()) =&gt; (),
            // otherwise, jump to the specified height
            Action::Jump(height) =&gt; state.jump(height),
        }
    }
}

</code></pre>
<p>To see how to pattern match on an enum to update values within it mutably, let's take the following
example of a simple enum that has two variants, each with a single field. We can then write two
functions, one that only increments the value of the first variant, and another that only increments
the value of the second variant:</p>
<pre><code class="language-move">module a::m {
    public enum SimpleEnum {
        Variant1(u64),
        Variant2(u64),
    }

    public fun incr_enum_variant1(simple_enum: &amp;mut SimpleEnum) {
        match (simple_enum) {
            SimpleEnum::Variant1(mut value) =&gt; *value += 1,
            _ =&gt; (),
        }
    }

    public fun incr_enum_variant2(simple_enum: &amp;mut SimpleEnum) {
        match (simple_enum) {
            SimpleEnum::Variant2(mut value) =&gt; *value += 1,
            _ =&gt; (),
        }
    }
}

</code></pre>
<p>Now, if we have a value of <code>SimpleEnum</code> we can use the functions to increment the value of this
variant:</p>
<pre><code class="language-move">let mut x = SimpleEnum::Variant1(10);
incr_enum_variant1(&amp;mut x);
assert!(x == SimpleEnum::Variant1(11));
// Doesn't increment since it increments a different variant
incr_enum_variant2(&amp;mut x);
assert!(x == SimpleEnum::Variant1(11));
</code></pre>
<p>When pattern matching on a Move value that does not have the <code>drop</code> ability, the value must be
consumed or destructured in each match arm. If the value is not consumed or destructured in a match
arm, the compiler will raise an error. This is to ensure that all possible values are handled in the
match statement.</p>
<p>As an example, consider the following code:</p>
<pre><code class="language-move">module a::m {
    public enum X { Variant { x: u64 } }

    public fun bad(x: X) {
        match (x) {
            _ =&gt; (),
           // ^ ERROR! value of type `X` is not consumed or destructured in this match arm
        }
    }
}
</code></pre>
<p>To properly handle this, you will need to destructure <code>X</code> and all its variants in the match's
arm(s):</p>
<pre><code class="language-move">module a::m {
    public enum X { Variant { x: u64 } }

    public fun good(x: X) {
        match (x) {
            // OK! Compiles since the value is destructured
            X::Variant { x: _ } =&gt; (),
        }
    }
}
</code></pre>
<h3 id="overwriting-to-enum-values"><a class="header" href="#overwriting-to-enum-values">Overwriting to Enum Values</a></h3>
<p>As long as the enum has the <code>drop</code> ability, you can overwrite the value of an enum with a new value
of the same type just as you might with other values in Move.</p>
<pre><code class="language-move">module a::m {
    public enum X has drop {
        A(u64),
        B(u64),
    }

    public fun overwrite_enum(x: &amp;mut X) {
        *x = X::A(10);
    }
}
</code></pre>
<pre><code class="language-move">let mut x = X::B(20);
overwrite_enum(&amp;mut x);
assert!(x == X::A(10));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<p>Constants are a way of giving a name to shared, static values inside of a <code>module</code>.</p>
<p>The constant's value must be known at compilation. The constant's value is stored in the compiled
module. And each time the constant is used, a new copy of that value is made.</p>
<h2 id="declaration-1"><a class="header" href="#declaration-1">Declaration</a></h2>
<p>Constant declarations begin with the <code>const</code> keyword, followed by a name, a type, and a value.</p>
<pre><code class="language-text">const &lt;name&gt;: &lt;type&gt; = &lt;expression&gt;;
</code></pre>
<p>For example</p>
<pre><code class="language-move">module a::example {
    const MY_ADDRESS: address = @a;

    public fun permissioned(addr: address) {
        assert!(addr == MY_ADDRESS, 0);
    }
}
</code></pre>
<h2 id="naming-2"><a class="header" href="#naming-2">Naming</a></h2>
<p>Constants must start with a capital letter <code>A</code> to <code>Z</code>. After the first letter, constant names can
contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<pre><code class="language-move">const FLAG: bool = false;
const EMyErrorCode: u64 = 0;
const ADDRESS_42: address = @0x42;
</code></pre>
<p>Even though you can use letters <code>a</code> to <code>z</code> in a constant. The
<a href="./coding-conventions.html">general style guidelines</a> are to use just uppercase letters <code>A</code> to <code>Z</code>,
with underscores <code>_</code> between each word. For error codes, we use <code>E</code> as a prefix and then upper camel
case (also known as Pascal case) for the rest of the name, as seen in <code>EMyErrorCode</code>.</p>
<p>The current naming restriction of starting with <code>A</code> to <code>Z</code> is in place to give room for future
language features.</p>
<h2 id="visibility-3"><a class="header" href="#visibility-3">Visibility</a></h2>
<p><code>public</code> or <code>public(package)</code> constants are not currently supported. <code>const</code> values can be used only
in the declaring module. However, as a convenience, they can be used across modules in
<a href="./unit-testing.html">unit tests attributes</a>.</p>
<h2 id="valid-expressions"><a class="header" href="#valid-expressions">Valid Expressions</a></h2>
<p>Currently, constants are limited to the primitive types <code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>,
<code>u256</code>, <code>address</code>, and <code>vector&lt;T&gt;</code>, where <code>T</code> is the valid type for a constant.</p>
<h3 id="values"><a class="header" href="#values">Values</a></h3>
<p>Commonly, <code>const</code>s are assigned a simple value, or literal, of their type. For example</p>
<pre><code class="language-move">const MY_BOOL: bool = false;
const MY_ADDRESS: address = @0x70DD;
const BYTES: vector&lt;u8&gt; = b&quot;hello world&quot;;
const HEX_BYTES: vector&lt;u8&gt; = x&quot;DEADBEEF&quot;;
</code></pre>
<h3 id="complex-expressions"><a class="header" href="#complex-expressions">Complex Expressions</a></h3>
<p>In addition to literals, constants can include more complex expressions, as long as the compiler is
able to reduce the expression to a value at compile time.</p>
<p>Currently, equality operations, all boolean operations, all bitwise operations, and all arithmetic
operations can be used.</p>
<pre><code class="language-move">const RULE: bool = true &amp;&amp; false;
const CAP: u64 = 10 * 100 + 1;
const SHIFTY: u8 = {
    (1 &lt;&lt; 1) * (1 &lt;&lt; 2) * (1 &lt;&lt; 3) * (1 &lt;&lt; 4)
};
const HALF_MAX: u128 = 340282366920938463463374607431768211455 / 2;
const REM: u256 =
    57896044618658097711785492504343953926634992332820282019728792003956564819968 % 654321;
const EQUAL: bool = 1 == 1;
</code></pre>
<p>If the operation would result in a runtime exception, the compiler will give an error that it is
unable to generate the constant's value</p>
<pre><code class="language-move">const DIV_BY_ZERO: u64 = 1 / 0; // ERROR!
const SHIFT_BY_A_LOT: u64 = 1 &lt;&lt; 100; // ERROR!
const NEGATIVE_U64: u64 = 0 - 1; // ERROR!
</code></pre>
<p>Additionally, constants can refer to other constants within the same module.</p>
<pre><code class="language-move">const BASE: u8 = 4;
const SQUARE: u8 = BASE * BASE;
</code></pre>
<p>Note though, that any cycle in the constant definitions results in an error.</p>
<pre><code class="language-move">const A: u16 = B + 1;
const B: u16 = A + 1; // ERROR!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Generics can be used to define functions and structs over different input data types. This language
feature is sometimes referred to as parametric polymorphism. In Move, we will often use the term
generics interchangeably with <em>type parameters</em> and <em>type arguments</em>.</p>
<p>Generics are commonly used in library code, such as in <a href="./primitive-types/vector.html">vector</a>, to
declare code that works over any possible type (that satisfies the specified constraints). This sort
of parameterization allows you to reuse the same implementation across multiple types and
situations.</p>
<h2 id="declaring-type-parameters"><a class="header" href="#declaring-type-parameters">Declaring Type Parameters</a></h2>
<p>Both functions and structs can take a list of type parameters in their signatures, enclosed by a
pair of angle brackets <code>&lt;...&gt;</code>.</p>
<h3 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h3>
<p>Type parameters for functions are placed after the function name and before the (value) parameter
list. The following code defines a generic identity function that takes a value of any type and
returns that value unchanged.</p>
<pre><code class="language-move">fun id&lt;T&gt;(x: T): T {
    // this type annotation is unnecessary but valid
    (x: T)
}
</code></pre>
<p>Once defined, the type parameter <code>T</code> can be used in parameter types, return types, and inside the
function body.</p>
<h3 id="generic-structs"><a class="header" href="#generic-structs">Generic Structs</a></h3>
<p>Type parameters for structs are placed after the struct name, and can be used to name the types of
the fields.</p>
<pre><code class="language-move">public struct Foo&lt;T&gt; has copy, drop { x: T }

public struct Bar&lt;T1, T2&gt; has copy, drop {
    x: T1,
    y: vector&lt;T2&gt;,
}
</code></pre>
<p>Note that <a href="generics.html#unused-type-parameters">type parameters do not have to be used</a></p>
<h2 id="type-arguments"><a class="header" href="#type-arguments">Type Arguments</a></h2>
<h3 id="calling-generic-functions"><a class="header" href="#calling-generic-functions">Calling Generic Functions</a></h3>
<p>When calling a generic function, one can specify the type arguments for the function's type
parameters in a list enclosed by a pair of angle brackets.</p>
<pre><code class="language-move">fun foo() {
    let x = id&lt;bool&gt;(true);
}
</code></pre>
<p>If you do not specify the type arguments, Move's <a href="generics.html#type-inference">type inference</a> will supply them
for you.</p>
<h3 id="using-generic-structs"><a class="header" href="#using-generic-structs">Using Generic Structs</a></h3>
<p>Similarly, one can attach a list of type arguments for the struct's type parameters when
constructing or destructing values of generic types.</p>
<pre><code class="language-move">fun foo() {
    // type arguments on construction
    let foo = Foo&lt;bool&gt; { x: true };
    let bar = Bar&lt;u64, u8&gt; { x: 0, y: vector&lt;u8&gt;[] };

    // type arguments on destruction
    let Foo&lt;bool&gt; { x } = foo;
    let Bar&lt;u64, u8&gt; { x, y } = bar;
}
</code></pre>
<p>In any case if you do not specify the type arguments, Move's <a href="generics.html#type-inference">type inference</a> will
supply them for you.</p>
<h3 id="type-argument-mismatch"><a class="header" href="#type-argument-mismatch">Type Argument Mismatch</a></h3>
<p>If you specify the type arguments and they conflict with the actual values supplied, an error will
be given:</p>
<pre><code class="language-move">fun foo() {
    let x = id&lt;u64&gt;(true); // ERROR! true is not a u64
}
</code></pre>
<p>and similarly:</p>
<pre><code class="language-move">fun foo() {
    let foo = Foo&lt;bool&gt; { x: 0 }; // ERROR! 0 is not a bool
    let Foo&lt;address&gt; { x } = foo; // ERROR! bool is incompatible with address
}
</code></pre>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>In most cases, the Move compiler will be able to infer the type arguments so you don't have to write
them down explicitly. Here's what the examples above would look like if we omit the type arguments:</p>
<pre><code class="language-move">fun foo() {
    let x = id(true);
    //        ^ &lt;bool&gt; is inferred

    let foo = Foo { x: true };
    //           ^ &lt;bool&gt; is inferred

    let Foo { x } = foo;
    //     ^ &lt;bool&gt; is inferred
}
</code></pre>
<p>Note: when the compiler is unable to infer the types, you'll need annotate them manually. A common
scenario is to call a function with type parameters appearing only at return positions.</p>
<pre><code class="language-move">module a::m {

    fun foo() {
        let v = vector[]; // ERROR!
        //            ^ The compiler cannot figure out the element type, since it is never used

        let v = vector&lt;u64&gt;[];
        //            ^~~~~ Must annotate manually in this case.
    }
}
</code></pre>
<p>Note that these cases are a bit contrived since the <code>vector[]</code> is never used, ad as such, Move's
type inference cannot infer the type.</p>
<p>However, the compiler will be able to infer the type if that value is used later in that function:</p>
<pre><code class="language-move">module a::m {
    fun foo() {
        let v = vector[];
        //            ^ &lt;u64&gt; is inferred
        vector::push_back(&amp;mut v, 42);
        //               ^ &lt;u64&gt; is inferred
    }
}
</code></pre>
<h3 id="_-type-1"><a class="header" href="#_-type-1"><code>_</code> Type</a></h3>
<p>In some cases, you might want to explicitly annotate some of the type arguments, but let the
compiler infer the others. The <code>_</code> type serves as such a placeholder for the compiler to infer the
type.</p>
<pre><code class="language-move">let bar = Bar&lt;u64, _&gt; { x: 0, y: vector[b&quot;hello&quot;] };
//                 ^ vector&lt;u8&gt; is inferred
</code></pre>
<p>The placeholder <code>_</code> may only appear in expressions and macro function definitions, not signatures.
This means you cannot use <code>_</code> as part of the definition of a function parameter, function return
type, constant definition type, and datatype field.</p>
<h2 id="integers-1"><a class="header" href="#integers-1">Integers</a></h2>
<p>In Move, the integer types <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, and <code>u256</code> are all distinct types.
However, each one of these types can be created with the same numerical value syntax. In other
words, if a type suffix is not provided, the compiler will infer the integer type based on the usage
of the value.</p>
<pre><code class="language-move">let x8: u8 = 0;
let x16: u16 = 0;
let x32: u32 = 0;
let x64: u64 = 0;
let x128: u128 = 0;
let x256: u256 = 0;
</code></pre>
<p>If the value is not used in a context that requires a specific integer type, <code>u64</code> is taken as a
default.</p>
<pre><code class="language-move">let x = 0;
//      ^ u64 is used by default
</code></pre>
<p>If the value however is too large for the inferred type, an error will be given</p>
<pre><code class="language-move">let i: u8 = 256; // ERROR!
//          ^^^ too large for u8
let x = 340282366920938463463374607431768211454;
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ too large for u64
</code></pre>
<p>In cases where the number is too large, you might need to annotate it explicitly</p>
<pre><code class="language-move">let x = 340282366920938463463374607431768211454u128;
//                                             ^^^^ valid!
</code></pre>
<h2 id="unused-type-parameters"><a class="header" href="#unused-type-parameters">Unused Type Parameters</a></h2>
<p>For a struct definition, an unused type parameter is one that does not appear in any field defined
in the struct, but is checked statically at compile time. Move allows unused type parameters so the
following struct definition is valid:</p>
<pre><code class="language-move">public struct Foo&lt;T&gt; {
    foo: u64
}
</code></pre>
<p>This can be convenient when modeling certain concepts. Here is an example:</p>
<pre><code class="language-move">module a::m {
    // Currency Specifiers
    public struct A {}
    public struct B {}

    // A generic coin type that can be instantiated using a currency
    // specifier type.
    //   e.g. Coin&lt;A&gt;, Coin&lt;B&gt; etc.
    public struct Coin&lt;Currency&gt; has store {
        value: u64
    }

    // Write code generically about all currencies
    public fun mint_generic&lt;Currency&gt;(value: u64): Coin&lt;Currency&gt; {
        Coin { value }
    }

    // Write code concretely about one currency
    public fun mint_a(value: u64): Coin&lt;A&gt; {
        mint_generic(value)
    }
    public fun mint_b(value: u64): Coin&lt;B&gt; {
        mint_generic(value)
    }
}
</code></pre>
<p>In this example, <code>Coin&lt;Currency&gt;</code> is generic on the <code>Currency</code> type parameter, which specifies the
currency of the coin and allows code to be written either generically on any currency or concretely
on a specific currency. This generality applies even when the <code>Currency</code> type parameter does not
appear in any of the fields defined in <code>Coin</code>.</p>
<h3 id="phantom-type-parameters"><a class="header" href="#phantom-type-parameters">Phantom Type Parameters</a></h3>
<p>In the example above, although <code>struct Coin</code> asks for the <code>store</code> ability, neither <code>Coin&lt;A&gt;</code> nor
<code>Coin&lt;B&gt;</code> will have the <code>store</code> ability. This is because of the rules for
<a href="./abilities.html#conditional-abilities-and-generic-types">Conditional Abilities and Generic Types</a>
and the fact that <code>A</code> and <code>B</code> don't have the <code>store</code> ability, despite the fact that they are not
even used in the body of <code>struct Coin</code>. This might cause some unpleasant consequences. For example,
we are unable to put <code>Coin&lt;A&gt;</code> into a wallet in storage.</p>
<p>One possible solution would be to add spurious ability annotations to <code>A</code> and <code>B</code> (i.e.,
<code>public struct Currency1 has store {}</code>). But, this might lead to bugs or security vulnerabilities
because it weakens the types with unnecessary ability declarations. For example, we would never
expect a value in the storage to have a field in type <code>A</code>, but this would be possible with the
spurious <code>store</code> ability. Moreover, the spurious annotations would be infectious, requiring many
functions generic on the unused type parameter to also include the necessary constraints.</p>
<p>Phantom type parameters solve this problem. Unused type parameters can be marked as <em>phantom</em> type
parameters, which do not participate in the ability derivation for structs. In this way, arguments
to phantom type parameters are not considered when deriving the abilities for generic types, thus
avoiding the need for spurious ability annotations. For this relaxed rule to be sound, Move's type
system guarantees that a parameter declared as <code>phantom</code> is either not used at all in the struct
definition, or it is only used as an argument to type parameters also declared as <code>phantom</code>.</p>
<h4 id="declaration-2"><a class="header" href="#declaration-2">Declaration</a></h4>
<p>In a struct definition a type parameter can be declared as phantom by adding the <code>phantom</code> keyword
before its declaration.</p>
<pre><code class="language-move">public struct Coin&lt;phantom Currency&gt; has store {
    value: u64
}
</code></pre>
<p>If a type parameter is declared as phantom we say it is a phantom type parameter. When defining a
struct, Move's type checker ensures that every phantom type parameter is either not used inside the
struct definition or it is only used as an argument to a phantom type parameter.</p>
<pre><code class="language-move">public struct S1&lt;phantom T1, T2&gt; { f: u64 }
//               ^^^^^^^ valid, T1 does not appear inside the struct definition

public struct S2&lt;phantom T1, T2&gt; { f: S1&lt;T1, T2&gt; }
//               ^^^^^^^ valid, T1 appears in phantom position
</code></pre>
<p>The following code shows examples of violations of the rule:</p>
<pre><code class="language-move">public struct S1&lt;phantom T&gt; { f: T }
//               ^^^^^^^ ERROR!  ^ Not a phantom position

public struct S2&lt;T&gt; { f: T }
public struct S3&lt;phantom T&gt; { f: S2&lt;T&gt; }
//               ^^^^^^^ ERROR!     ^ Not a phantom position
</code></pre>
<p>More formally, if a type is used as an argument to a phantom type parameter we say the type appears
in <em>phantom position</em>. With this definition in place, the rule for the correct use of phantom
parameters can be specified as follows: <strong>A phantom type parameter can only appear in phantom
position</strong>.</p>
<p>Note that specifying <code>phantom</code> is not required, but the compiler will warn if a type parameter could
be <code>phantom</code> but was not marked as such.</p>
<h4 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h4>
<p>When instantiating a struct, the arguments to phantom parameters are excluded when deriving the
struct abilities. For example, consider the following code:</p>
<pre><code class="language-move">public struct S&lt;T1, phantom T2&gt; has copy { f: T1 }
public struct NoCopy {}
public struct HasCopy has copy {}
</code></pre>
<p>Consider now the type <code>S&lt;HasCopy, NoCopy&gt;</code>. Since <code>S</code> is defined with <code>copy</code> and all non-phantom
arguments have <code>copy</code> then <code>S&lt;HasCopy, NoCopy&gt;</code> also has <code>copy</code>.</p>
<h4 id="phantom-type-parameters-with-ability-constraints"><a class="header" href="#phantom-type-parameters-with-ability-constraints">Phantom Type Parameters with Ability Constraints</a></h4>
<p>Ability constraints and phantom type parameters are orthogonal features in the sense that phantom
parameters can be declared with ability constraints.</p>
<pre><code class="language-move">public struct S&lt;phantom T: copy&gt; {}
</code></pre>
<p>When instantiating a phantom type parameter with an ability constraint, the type argument has to
satisfy that constraint, even though the parameter is phantom. The usual restrictions apply and <code>T</code>
can only be instantiated with arguments having <code>copy</code>.</p>
<h2 id="constraints"><a class="header" href="#constraints">Constraints</a></h2>
<p>In the examples above, we have demonstrated how one can use type parameters to define &quot;unknown&quot;
types that can be plugged in by callers at a later time. This however means the type system has
little information about the type and has to perform checks in a very conservative way. In some
sense, the type system must assume the worst case scenario for an unconstrained generic--a type with
no <a href="./abilities.html">abilities</a>.</p>
<p>Constraints offer a way to specify what properties these unknown types have so the type system can
allow operations that would otherwise be unsafe.</p>
<h3 id="declaring-constraints"><a class="header" href="#declaring-constraints">Declaring Constraints</a></h3>
<p>Constraints can be imposed on type parameters using the following syntax.</p>
<pre><code class="language-move">// T is the name of the type parameter
T: &lt;ability&gt; (+ &lt;ability&gt;)*
</code></pre>
<p>The <code>&lt;ability&gt;</code> can be any of the four <a href="./abilities.html">abilities</a>, and a type parameter can be
constrained with multiple abilities at once. So all of the following would be valid type parameter
declarations:</p>
<pre><code class="language-move">T: copy
T: copy + drop
T: copy + drop + store + key
</code></pre>
<h3 id="verifying-constraints"><a class="header" href="#verifying-constraints">Verifying Constraints</a></h3>
<p>Constraints are checked at instantiation sites</p>
<pre><code class="language-move">public struct Foo&lt;T: copy&gt; { x: T }

public struct Bar { x: Foo&lt;u8&gt; }
//                         ^^ valid, u8 has `copy`

public struct Baz&lt;T&gt; { x: Foo&lt;T&gt; }
//                            ^ ERROR! T does not have 'copy'
</code></pre>
<p>And similarly for functions</p>
<pre><code class="language-move">fun unsafe_consume&lt;T&gt;(x: T) {
    // ERROR! x does not have 'drop'
}

fun consume&lt;T: drop&gt;(x: T) {
    // valid, x will be dropped automatically
}

public struct NoAbilities {}

fun foo() {
    let r = NoAbilities {};
    consume&lt;NoAbilities&gt;(NoAbilities);
    //      ^^^^^^^^^^^ ERROR! NoAbilities does not have 'drop'
}
</code></pre>
<p>And some similar examples, but with <code>copy</code></p>
<pre><code class="language-move">fun unsafe_double&lt;T&gt;(x: T) {
    (copy x, x)
    // ERROR! T does not have 'copy'
}

fun double&lt;T: copy&gt;(x: T) {
    (copy x, x) // valid, T has 'copy'
}

public struct NoAbilities {}

fun foo(): (NoAbilities, NoAbilities) {
    let r = NoAbilities {};
    double&lt;NoAbilities&gt;(r)
    //     ^ ERROR! NoAbilities does not have 'copy'
}
</code></pre>
<p>For more information, see the abilities section on
<a href="./abilities.html#conditional-abilities-and-generic-types">conditional abilities and generic types</a>.</p>
<h2 id="limitations-on-recursions"><a class="header" href="#limitations-on-recursions">Limitations on Recursions</a></h2>
<h3 id="recursive-structs"><a class="header" href="#recursive-structs">Recursive Structs</a></h3>
<p>Generic structs can not contain fields of the same type, either directly or indirectly, even with
different type arguments. All of the following struct definitions are invalid:</p>
<pre><code class="language-move">public struct Foo&lt;T&gt; {
    x: Foo&lt;u64&gt; // ERROR! 'Foo' containing 'Foo'
}

public struct Bar&lt;T&gt; {
    x: Bar&lt;T&gt; // ERROR! 'Bar' containing 'Bar'
}

// ERROR! 'A' and 'B' forming a cycle, which is not allowed either.
public struct A&lt;T&gt; {
    x: B&lt;T, u64&gt;
}

public struct B&lt;T1, T2&gt; {
    x: A&lt;T1&gt;
    y: A&lt;T2&gt;
}
</code></pre>
<h3 id="advanced-topic-type-level-recursions"><a class="header" href="#advanced-topic-type-level-recursions">Advanced Topic: Type-level Recursions</a></h3>
<p>Move allows generic functions to be called recursively. However, when used in combination with
generic structs, this could create an infinite number of types in certain cases, and allowing this
means adding unnecessary complexity to the compiler, vm and other language components. Therefore,
such recursions are forbidden.</p>
<p>This restriction might be relaxed in the future, but for now, the following examples should give you
an idea of what is allowed and what is not.</p>
<pre><code class="language-move">module a::m {
    public struct A&lt;T&gt; {}

    // Finitely many types -- allowed.
    // foo&lt;T&gt; -&gt; foo&lt;T&gt; -&gt; foo&lt;T&gt; -&gt; ... is valid
    fun foo&lt;T&gt;() {
        foo&lt;T&gt;();
    }

    // Finitely many types -- allowed.
    // foo&lt;T&gt; -&gt; foo&lt;A&lt;u64&gt;&gt; -&gt; foo&lt;A&lt;u64&gt;&gt; -&gt; ... is valid
    fun foo&lt;T&gt;() {
        foo&lt;A&lt;u64&gt;&gt;();
    }
}
</code></pre>
<p>Not allowed:</p>
<pre><code class="language-move">module a::m {
    public struct A&lt;T&gt; {}

    // Infinitely many types -- NOT allowed.
    // error!
    // foo&lt;T&gt; -&gt; foo&lt;A&lt;T&gt;&gt; -&gt; foo&lt;A&lt;A&lt;T&gt;&gt;&gt; -&gt; ...
    fun foo&lt;T&gt;() {
        foo&lt;Foo&lt;T&gt;&gt;();
    }
}
</code></pre>
<p>And similarly, not allowed:</p>
<pre><code class="language-move">module a::n {
    public struct A&lt;T&gt; {}

    // Infinitely many types -- NOT allowed.
    // error!
    // foo&lt;T1, T2&gt; -&gt; bar&lt;T2, T1&gt; -&gt; foo&lt;T2, A&lt;T1&gt;&gt;
    //   -&gt; bar&lt;A&lt;T1&gt;, T2&gt; -&gt; foo&lt;A&lt;T1&gt;, A&lt;T2&gt;&gt;
    //   -&gt; bar&lt;A&lt;T2&gt;, A&lt;T1&gt;&gt; -&gt; foo&lt;A&lt;T2&gt;, A&lt;A&lt;T1&gt;&gt;&gt;
    //   -&gt; ...
    fun foo&lt;T1, T2&gt;() {
        bar&lt;T2, T1&gt;();
    }

    fun bar&lt;T1, T2&gt; {
        foo&lt;T1, A&lt;T2&gt;&gt;();
    }
}
</code></pre>
<p>Note, the check for type level recursions is based on a conservative analysis on the call sites and
does NOT take control flow or runtime values into account.</p>
<pre><code class="language-move">module a::m {
    public struct A&lt;T&gt; {}

    // Infinitely many types -- NOT allowed.
    // error!
    fun foo&lt;T&gt;(n: u64) {
        if (n &gt; 0) foo&lt;A&lt;T&gt;&gt;(n - 1);
    }
}
</code></pre>
<p>The function in the example above will technically terminate for any given input and therefore only
creating finitely many types, but it is still considered invalid by Move's type system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abilities-2"><a class="header" href="#abilities-2">Abilities</a></h1>
<p>Abilities are a typing feature in Move that control what actions are permissible for values of a
given type. This system grants fine grained control over the &quot;linear&quot; typing behavior of values, as
well as if and how values are used in storage (as defined by the specific deployment of Move, e.g.
the notion of storage for the blockchain). This is implemented by gating access to certain bytecode
instructions so that for a value to be used with the bytecode instruction, it must have the ability
required (if one is required at allnot every instruction is gated by an ability).</p>
<p>For Sui, <code>key</code> is used to signify an <a href="./abilities/object.html">object</a>. Objects are the basic unit of
storage where each object has a unique, 32-byte ID. <code>store</code> is then used to both indicate what data
can be stored inside of an object, and is also used to indicate what types can be transferred
outside of their defining module.</p>
<!-- TODO future section on detailed walk through maybe. We have some examples at the end but it might be helpful to explain why we have precisely this set of abilities

If you are already somewhat familiar with abilities from writing Move programs, but are still confused as to what is going on, it might be helpful to skip to the [motivating walkthrough](#motivating-walkthrough) section to get an idea of what the system is setup in the way that it is. -->
<h2 id="the-four-abilities"><a class="header" href="#the-four-abilities">The Four Abilities</a></h2>
<p>The four abilities are:</p>
<ul>
<li><a href="abilities.html#copy"><code>copy</code></a>
<ul>
<li>Allows values of types with this ability to be copied.</li>
</ul>
</li>
<li><a href="abilities.html#drop"><code>drop</code></a>
<ul>
<li>Allows values of types with this ability to be popped/dropped.</li>
</ul>
</li>
<li><a href="abilities.html#store"><code>store</code></a>
<ul>
<li>Allows values of types with this ability to exist inside a value in storage.</li>
<li>For Sui, <code>store</code> controls what data can be stored inside of an <a href="./abilities/object.html">object</a>.
<code>store</code> also controls what types can be transferred outside of their defining module.</li>
</ul>
</li>
<li><a href="abilities.html#key"><code>key</code></a>
<ul>
<li>Allows the type to serve as a &quot;key&quot; for storage. Ostensibly this means the value can be a
top-level value in storage; in other words, it does not need to be contained in another value to
be in storage.</li>
<li>For Sui, <code>key</code> is used to signify an <a href="./abilities/object.html">object</a>.</li>
</ul>
</li>
</ul>
<h3 id="copy"><a class="header" href="#copy"><code>copy</code></a></h3>
<p>The <code>copy</code> ability allows values of types with that ability to be copied. It gates the ability to
copy values out of local variables with the <a href="./variables.html#move-and-copy"><code>copy</code></a> operator and to
copy values via references with
<a href="./primitive-types/references.html#reading-and-writing-through-references">dereference <code>*e</code></a>.</p>
<p>If a value has <code>copy</code>, all values contained inside of that value have <code>copy</code>.</p>
<h3 id="drop"><a class="header" href="#drop"><code>drop</code></a></h3>
<p>The <code>drop</code> ability allows values of types with that ability to be dropped. By dropped, we mean that
value is not transferred and is effectively destroyed as the Move program executes. As such, this
ability gates the ability to ignore values in a multitude of locations, including:</p>
<ul>
<li>not using the value in a local variable or parameter</li>
<li>not using the value in a <a href="./variables.html#expression-blocks">sequence via <code>;</code></a></li>
<li>overwriting values in variables in <a href="./variables.html#assignments">assignments</a></li>
<li>overwriting values via references when
<a href="./primitive-types/references.html#reading-and-writing-through-references">writing <code>*e1 = e2</code></a>.</li>
</ul>
<p>If a value has <code>drop</code>, all values contained inside of that value have <code>drop</code>.</p>
<h3 id="store"><a class="header" href="#store"><code>store</code></a></h3>
<p>The <code>store</code> ability allows values of types with this ability to exist inside of a value in storage,
<em>but</em> not necessarily as a top-level value in storage. This is the only ability that does not
directly gate an operation. Instead it gates the existence in storage when used in tandem with
<code>key</code>.</p>
<p>If a value has <code>store</code>, all values contained inside of that value have <code>store</code>.</p>
<p>For Sui, <code>store</code> serves double duty. It controls what values can appear inside of an
<a href="./abilities/object.html">object</a>, and what objects can be
<a href="./abilities/object.html#transfer-rules">transferred</a> outside of their defining module.</p>
<h3 id="key"><a class="header" href="#key"><code>key</code></a></h3>
<p>The <code>key</code> ability allows the type to serve as a key for storage operations as defined by the
deployment of Move. While it is specific per Move instance, it serves to gates all storage
operations, so in order for a type to be used with storage primitives, the type must have the <code>key</code>
ability.</p>
<p>If a value has <code>key</code>, all values contained inside of that value have <code>store</code>. This is the only
ability with this sort of asymmetry.</p>
<p>For Sui, <code>key</code> is used to signify an <a href="./abilities/object.html">object</a>.</p>
<h2 id="builtin-types"><a class="header" href="#builtin-types">Builtin Types</a></h2>
<p>All primitive, builtin types have <code>copy</code>, <code>drop</code>, and <code>store</code>.</p>
<ul>
<li><code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>u256</code>, and <code>address</code> all have <code>copy</code>, <code>drop</code>, and
<code>store</code>.</li>
<li><code>vector&lt;T&gt;</code> may have <code>copy</code>, <code>drop</code>, and <code>store</code> depending on the abilities of <code>T</code>.
<ul>
<li>See <a href="abilities.html#conditional-abilities-and-generic-types">Conditional Abilities and Generic Types</a> for more
details.</li>
</ul>
</li>
<li>Immutable references <code>&amp;</code> and mutable references <code>&amp;mut</code> both have <code>copy</code> and <code>drop</code>.
<ul>
<li>This refers to copying and dropping the reference itself, not what they refer to.</li>
<li>References cannot appear in global storage, hence they do not have <code>store</code>.</li>
</ul>
</li>
</ul>
<p>Note that none of the primitive types have <code>key</code>, meaning none of them can be used directly with
storage operations.</p>
<h2 id="annotating-structs-and-enums"><a class="header" href="#annotating-structs-and-enums">Annotating Structs and Enums</a></h2>
<p>To declare that a <code>struct</code> or <code>enum</code> has an ability, it is declared with <code>has &lt;ability&gt;</code> after the
datatype name and either before or after the fields/variants. For example:</p>
<pre><code class="language-move">public struct Ignorable has drop { f: u64 }
public struct Pair has copy, drop, store { x: u64, y: u64 }
public struct MyVec(vector&lt;u64&gt;) has copy, drop, store;

public enum IgnorableEnum has drop { Variant }
public enum PairEnum has copy, drop, store { Variant }
public enum MyVecEnum { Variant } has copy, drop, store;
</code></pre>
<p>In this case: <code>Ignorable*</code> has the <code>drop</code> ability. <code>Pair*</code> and <code>MyVec*</code> both have <code>copy</code>, <code>drop</code>,
and <code>store</code>.</p>
<p>All of these abilities have strong guarantees over these gated operations. The operation can be
performed on the value only if it has that ability; even if the value is deeply nested inside of
some other collection!</p>
<p>As such: when declaring a structs abilities, certain requirements are placed on the fields. All
fields must satisfy these constraints. These rules are necessary so that structs satisfy the
reachability rules for the abilities given above. If a struct is declared with the ability...</p>
<ul>
<li><code>copy</code>, all fields must have <code>copy</code>.</li>
<li><code>drop</code>, all fields must have <code>drop</code>.</li>
<li><code>store</code>, all fields must have <code>store</code>.</li>
<li><code>key</code>, all fields must have <code>store</code>.
<ul>
<li><code>key</code> is the only ability currently that doesnt require itself.</li>
</ul>
</li>
</ul>
<p>An enum can have any of these abilities with the exception of <code>key</code>, which enums cannot have because
they cannot be top-level values (objects) in storage. The same rules apply to fields of enum
variants as they do for struct fields though. In particular, if an enum is declared with the
ability...</p>
<ul>
<li><code>copy</code>, all fields of all variants must have <code>copy</code>.</li>
<li><code>drop</code>, all fields of all variants must have <code>drop</code>.</li>
<li><code>store</code>, all fields of all variants must have <code>store</code>.</li>
<li><code>key</code>, is not allowed on enums as previously mentioned.</li>
</ul>
<p>For example:</p>
<pre><code class="language-move">// A struct without any abilities
public struct NoAbilities {}

public struct WantsCopy has copy {
    f: NoAbilities, // ERROR 'NoAbilities' does not have 'copy'
}

public enum WantsCopyEnum has copy {
    Variant1
    Variant2(NoAbilities), // ERROR 'NoAbilities' does not have 'copy'
}
</code></pre>
<p>and similarly:</p>
<pre><code class="language-move">// A struct without any abilities
public struct NoAbilities {}

public struct MyData has key {
    f: NoAbilities, // Error 'NoAbilities' does not have 'store'
}

public struct MyDataEnum has store {
    Variant1,
    Variant2(NoAbilities), // Error 'NoAbilities' does not have 'store'
}
</code></pre>
<h2 id="conditional-abilities-and-generic-types"><a class="header" href="#conditional-abilities-and-generic-types">Conditional Abilities and Generic Types</a></h2>
<p>When abilities are annotated on a generic type, not all instances of that type are guaranteed to
have that ability. Consider this struct declaration:</p>
<pre><code class="language-move">// public struct Cup&lt;T&gt; has copy, drop, store, key { item: T }
</code></pre>
<p>It might be very helpful if <code>Cup</code> could hold any type, regardless of its abilities. The type system
can <em>see</em> the type parameter, so it should be able to remove abilities from <code>Cup</code> if it <em>sees</em> a
type parameter that would violate the guarantees for that ability.</p>
<p>This behavior might sound a bit confusing at first, but it might be more understandable if we think
about collection types. We could consider the builtin type <code>vector</code> to have the following type
declaration:</p>
<pre><code class="language-move">vector&lt;T&gt; has copy, drop, store;
</code></pre>
<p>We want <code>vector</code>s to work with any type. We don't want separate <code>vector</code> types for different
abilities. So what are the rules we would want? Precisely the same that we would want with the field
rules above. So, it would be safe to copy a <code>vector</code> value only if the inner elements can be copied.
It would be safe to ignore a <code>vector</code> value only if the inner elements can be ignored/dropped. And,
it would be safe to put a <code>vector</code> in storage only if the inner elements can be in storage.</p>
<p>To have this extra expressiveness, a type might not have all the abilities it was declared with
depending on the instantiation of that type; instead, the abilities a type will have depends on both
its declaration <strong>and</strong> its type arguments. For any type, type parameters are pessimistically
assumed to be used inside of the struct, so the abilities are only granted if the type parameters
meet the requirements described above for fields. Taking <code>Cup</code> from above as an example:</p>
<ul>
<li><code>Cup</code> has the ability <code>copy</code> only if <code>T</code> has <code>copy</code>.</li>
<li>It has <code>drop</code> only if <code>T</code> has <code>drop</code>.</li>
<li>It has <code>store</code> only if <code>T</code> has <code>store</code>.</li>
<li>It has <code>key</code> only if <code>T</code> has <code>store</code>.</li>
</ul>
<p>Here are examples for this conditional system for each ability:</p>
<h3 id="example-conditional-copy"><a class="header" href="#example-conditional-copy">Example: conditional <code>copy</code></a></h3>
<pre><code class="language-move">public struct NoAbilities {}
public struct S has copy, drop { f: bool }
public struct Cup&lt;T&gt; has copy, drop, store { item: T }

fun example(c_x: Cup&lt;u64&gt;, c_s: Cup&lt;S&gt;) {
    // Valid, 'Cup&lt;u64&gt;' has 'copy' because 'u64' has 'copy'
    let c_x2 = copy c_x;
    // Valid, 'Cup&lt;S&gt;' has 'copy' because 'S' has 'copy'
    let c_s2 = copy c_s;
}

fun invalid(c_account: Cup&lt;signer&gt;, c_n: Cup&lt;NoAbilities&gt;) {
    // Invalid, 'Cup&lt;signer&gt;' does not have 'copy'.
    // Even though 'Cup' was declared with copy, the instance does not have 'copy'
    // because 'signer' does not have 'copy'
    let c_account2 = copy c_account;
    // Invalid, 'Cup&lt;NoAbilities&gt;' does not have 'copy'
    // because 'NoAbilities' does not have 'copy'
    let c_n2 = copy c_n;
}
</code></pre>
<h3 id="example-conditional-drop"><a class="header" href="#example-conditional-drop">Example: conditional <code>drop</code></a></h3>
<pre><code class="language-move">public struct NoAbilities {}
public struct S has copy, drop { f: bool }
public struct Cup&lt;T&gt; has copy, drop, store { item: T }

fun unused() {
    Cup&lt;bool&gt; { item: true }; // Valid, 'Cup&lt;bool&gt;' has 'drop'
    Cup&lt;S&gt; { item: S { f: false }}; // Valid, 'Cup&lt;S&gt;' has 'drop'
}

fun left_in_local(c_account: Cup&lt;signer&gt;): u64 {
    let c_b = Cup&lt;bool&gt; { item: true };
    let c_s = Cup&lt;S&gt; { item: S { f: false }};
    // Valid return: 'c_account', 'c_b', and 'c_s' have values
    // but 'Cup&lt;signer&gt;', 'Cup&lt;bool&gt;', and 'Cup&lt;S&gt;' have 'drop'
    0
}

fun invalid_unused() {
    // Invalid, Cannot ignore 'Cup&lt;NoAbilities&gt;' because it does not have 'drop'.
    // Even though 'Cup' was declared with 'drop', the instance does not have 'drop'
    // because 'NoAbilities' does not have 'drop'
    Cup&lt;NoAbilities&gt; { item: NoAbilities {} };
}

fun invalid_left_in_local(): u64 {
    let n = Cup&lt;NoAbilities&gt; { item: NoAbilities {} };
    // Invalid return: 'c_n' has a value
    // and 'Cup&lt;NoAbilities&gt;' does not have 'drop'
    0
}
</code></pre>
<h3 id="example-conditional-store"><a class="header" href="#example-conditional-store">Example: conditional <code>store</code></a></h3>
<pre><code class="language-move">public struct Cup&lt;T&gt; has copy, drop, store { item: T }

// 'MyInnerData is declared with 'store' so all fields need 'store'
struct MyInnerData has store {
    yes: Cup&lt;u64&gt;, // Valid, 'Cup&lt;u64&gt;' has 'store'
    // no: Cup&lt;signer&gt;, Invalid, 'Cup&lt;signer&gt;' does not have 'store'
}

// 'MyData' is declared with 'key' so all fields need 'store'
struct MyData has key {
    yes: Cup&lt;u64&gt;, // Valid, 'Cup&lt;u64&gt;' has 'store'
    inner: Cup&lt;MyInnerData&gt;, // Valid, 'Cup&lt;MyInnerData&gt;' has 'store'
    // no: Cup&lt;signer&gt;, Invalid, 'Cup&lt;signer&gt;' does not have 'store'
}
</code></pre>
<h3 id="example-conditional-key"><a class="header" href="#example-conditional-key">Example: conditional <code>key</code></a></h3>
<pre><code class="language-move">public struct NoAbilities {}
public struct MyData&lt;T&gt; has key { f: T }

fun valid(addr: address) acquires MyData {
    // Valid, 'MyData&lt;u64&gt;' has 'key'
    transfer(addr, MyData&lt;u64&gt; { f: 0 });
}

fun invalid(addr: address) {
   // Invalid, 'MyData&lt;NoAbilities&gt;' does not have 'key'
   transfer(addr, MyData&lt;NoAbilities&gt; { f: NoAbilities {} })
   // Invalid, 'MyData&lt;NoAbilities&gt;' does not have 'key'
   borrow&lt;NoAbilities&gt;(addr);
   // Invalid, 'MyData&lt;NoAbilities&gt;' does not have 'key'
   borrow_mut&lt;NoAbilities&gt;(addr);
}

// Mock storage operation
native public fun transfer&lt;T: key&gt;(addr: address, value: T);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uses-and-aliases"><a class="header" href="#uses-and-aliases">Uses and Aliases</a></h1>
<p>The <code>use</code> syntax can be used to create aliases to members in other modules. <code>use</code> can be used to
create aliases that last either for the entire module, or for a given expression block scope.</p>
<h2 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h2>
<p>There are several different syntax cases for <code>use</code>. Starting with the most simple, we have the
following for creating aliases to other modules</p>
<pre><code class="language-move">use &lt;address&gt;::&lt;module name&gt;;
use &lt;address&gt;::&lt;module name&gt; as &lt;module alias name&gt;;
</code></pre>
<p>For example</p>
<pre><code class="language-move">use std::vector;
use std::option as o;
</code></pre>
<p><code>use std::vector;</code> introduces an alias <code>vector</code> for <code>std::vector</code>. This means that anywhere you
would want to use the module name <code>std::vector</code> (assuming this <code>use</code> is in scope), you could use
<code>vector</code> instead. <code>use std::vector;</code> is equivalent to <code>use std::vector as vector;</code></p>
<p>Similarly <code>use std::option as o;</code> would let you use <code>o</code> instead of <code>std::option</code></p>
<pre><code class="language-move">use std::vector;
use std::option as o;

fun new_vec(): vector&lt;o::Option&lt;u8&gt;&gt; {
    let mut v = vector[];
    vector::push_back(&amp;mut v, o::some(0));
    vector::push_back(&amp;mut v, o::none());
    v
}
</code></pre>
<p>If you want to import a specific module member (such as a function or struct). You can use the
following syntax.</p>
<pre><code class="language-move">use &lt;address&gt;::&lt;module name&gt;::&lt;module member&gt;;
use &lt;address&gt;::&lt;module name&gt;::&lt;module member&gt; as &lt;member alias&gt;;
</code></pre>
<p>For example</p>
<pre><code class="language-move">use std::vector::push_back;
use std::option::some as s;
</code></pre>
<p>This would let you use the function <code>std::vector::push_back</code> without full qualification. Similarly
for <code>std::option::some</code> with <code>s</code>. Instead you could use <code>push_back</code> and <code>s</code> respectively. Again,
<code>use std::vector::push_back;</code> is equivalent to <code>use std::vector::push_back as push_back;</code></p>
<pre><code class="language-move">use std::vector::push_back;
use std::option::some as s;

fun new_vec(): vector&lt;std::option::Option&lt;u8&gt;&gt; {
    let mut v = vector[];
    vector::push_back(&amp;mut v, s(0));
    vector::push_back(&amp;mut v, std::option::none());
    v
}
</code></pre>
<h3 id="multiple-aliases"><a class="header" href="#multiple-aliases">Multiple Aliases</a></h3>
<p>If you want to add aliases for multiple module members at once, you can do so with the following
syntax</p>
<pre><code class="language-move">use &lt;address&gt;::&lt;module name&gt;::{&lt;module member&gt;, &lt;module member&gt; as &lt;member alias&gt; ... };
</code></pre>
<p>For example</p>
<pre><code class="language-move">use std::vector::push_back;
use std::option::{some as s, none as n};

fun new_vec(): vector&lt;std::option::Option&lt;u8&gt;&gt; {
    let mut v = vector[];
    push_back(&amp;mut v, s(0));
    push_back(&amp;mut v, n());
    v
}
</code></pre>
<h3 id="self-aliases"><a class="header" href="#self-aliases">Self aliases</a></h3>
<p>If you need to add an alias to the Module itself in addition to module members, you can do that in a
single <code>use</code> using <code>Self</code>. <code>Self</code> is a member of sorts that refers to the module.</p>
<pre><code class="language-move">use std::option::{Self, some, none};
</code></pre>
<p>For clarity, all of the following are equivalent:</p>
<pre><code class="language-move">use std::option;
use std::option as option;
use std::option::Self;
use std::option::Self as option;
use std::option::{Self};
use std::option::{Self as option};
</code></pre>
<h3 id="multiple-aliases-for-the-same-definition"><a class="header" href="#multiple-aliases-for-the-same-definition">Multiple Aliases for the Same Definition</a></h3>
<p>If needed, you can have as many aliases for any item as you like</p>
<pre><code class="language-move">use std::vector::push_back;
use std::option::{Option, some, none};

fun new_vec(): vector&lt;Option&lt;u8&gt;&gt; {
    let mut v = vector[];
    push_back(&amp;mut v, some(0));
    push_back(&amp;mut v, none());
    v
}
</code></pre>
<h3 id="nested-imports"><a class="header" href="#nested-imports">Nested imports</a></h3>
<p>In Move, you can also import multiple names with the same <code>use</code> declaration. This brings all
provided names into scope:</p>
<pre><code class="language-move">use std::{
    vector::{Self as vec, push_back},
    string::{String, Self as str}
};

fun example(s: &amp;mut String) {
    let mut v = vec::empty();
    push_back(&amp;mut v, 0);
    push_back(&amp;mut v, 10);
    str::append_utf8(s, v);
}
</code></pre>
<h2 id="inside-a-module"><a class="header" href="#inside-a-module">Inside a <code>module</code></a></h2>
<p>Inside of a <code>module</code> all <code>use</code> declarations are usable regardless of the order of declaration.</p>
<pre><code class="language-move">module a::example {
    use std::vector;

    fun new_vec(): vector&lt;Option&lt;u8&gt;&gt; {
        let mut v = vector[];
        vector::push_back(&amp;mut v, 0);
        vector::push_back(&amp;mut v, 10);
        v
    }

    use std::option::{Option, some, none};
}
</code></pre>
<p>The aliases declared by <code>use</code> in the module usable within that module.</p>
<p>Additionally, the aliases introduced cannot conflict with other module members. See
<a href="uses.html#uniqueness">Uniqueness</a> for more details</p>
<h2 id="inside-an-expression"><a class="header" href="#inside-an-expression">Inside an expression</a></h2>
<p>You can add <code>use</code> declarations to the beginning of any expression block</p>
<pre><code class="language-move">module a::example {
    fun new_vec(): vector&lt;Option&lt;u8&gt;&gt; {
        use std::vector::push_back;
        use std::option::{Option, some, none};

        let mut v = vector[];
        push_back(&amp;mut v, some(0));
        push_back(&amp;mut v, none());
        v
    }
}
</code></pre>
<p>As with <code>let</code>, the aliases introduced by <code>use</code> in an expression block are removed at the end of that
block.</p>
<pre><code class="language-move">module a::example {
    fun new_vec(): vector&lt;Option&lt;u8&gt;&gt; {
        let result = {
            use std::vector::push_back;
            use std::option::{Option, some, none};

            let mut v = vector[];
            push_back(&amp;mut v, some(0));
            push_back(&amp;mut v, none());
            v
        };
        result
    }
}
</code></pre>
<p>Attempting to use the alias after the block ends will result in an error</p>
<pre><code class="language-move">    fun new_vec(): vector&lt;Option&lt;u8&gt;&gt; {
        let mut result = {
            use std::vector::push_back;
            use std::option::{Option, some, none};

            let mut v = vector[];
            push_back(&amp;mut v, some(0));
            v
        };
        push_back(&amp;mut result, std::option::none());
        // ^^^^^^ ERROR! unbound function 'push_back'
        result
    }
</code></pre>
<p>Any <code>use</code> must be the first item in the block. If the <code>use</code> comes after any expression or <code>let</code>, it
will result in a parsing error</p>
<pre><code class="language-move">{
    let mut v = vector[];
    use std::vector; // ERROR!
}
</code></pre>
<p>This allows you to shorten your import blocks in many situations. Note that these imports, as the
previous ones, are all subject to the naming and uniqueness rules described in the following
sections.</p>
<h2 id="naming-rules"><a class="header" href="#naming-rules">Naming rules</a></h2>
<p>Aliases must follow the same rules as other module members. This means that aliases to structs (and
constants) must start with <code>A</code> to <code>Z</code></p>
<pre><code class="language-move">module a::data {
    public struct S {}
    const FLAG: bool = false;
    public fun foo() {}
}
module a::example {
    use a::data::{
        S as s, // ERROR!
        FLAG as fLAG, // ERROR!
        foo as FOO,  // valid
        foo as bar, // valid
    };
}
</code></pre>
<h2 id="uniqueness"><a class="header" href="#uniqueness">Uniqueness</a></h2>
<p>Inside a given scope, all aliases introduced by <code>use</code> declarations must be unique.</p>
<p>For a module, this means aliases introduced by <code>use</code> cannot overlap</p>
<pre><code class="language-move">module a::example {
    use std::option::{none as foo, some as foo}; // ERROR!
    //                                     ^^^ duplicate 'foo'

    use std::option::none as bar;

    use std::option::some as bar; // ERROR!
    //                       ^^^ duplicate 'bar'

}
</code></pre>
<p>And, they cannot overlap with any of the module's other members</p>
<pre><code class="language-move">module a::data {
    public struct S {}
}
module example {
    use a::data::S;

    public struct S { value: u64 } // ERROR!
    //            ^ conflicts with alias 'S' above
}
}
</code></pre>
<p>Inside of an expression block, they cannot overlap with each other, but they can
<a href="uses.html#shadowing">shadow</a> other aliases or names from an outer scope</p>
<h2 id="shadowing-1"><a class="header" href="#shadowing-1">Shadowing</a></h2>
<p><code>use</code> aliases inside of an expression block can shadow names (module members or aliases) from the
outer scope. As with shadowing of locals, the shadowing ends at the end of the expression block;</p>
<pre><code class="language-move">module a::example {

    public struct WrappedVector { vec: vector&lt;u64&gt; }

    public fun empty(): WrappedVector {
        WrappedVector { vec: std::vector::empty() }
    }

    public fun push_back(v: &amp;mut WrappedVector, value: u64) {
        std::vector::push_back(&amp;mut v.vec, value);
    }

    fun example1(): WrappedVector {
        use std::vector::push_back;
        // 'push_back' now refers to std::vector::push_back
        let mut vec = vector[];
        push_back(&amp;mut vec, 0);
        push_back(&amp;mut vec, 1);
        push_back(&amp;mut vec, 10);
        WrappedVector { vec }
    }

    fun example2(): WrappedVector {
        let vec = {
            use std::vector::push_back;
            // 'push_back' now refers to std::vector::push_back

            let mut v = vector[];
            push_back(&amp;mut v, 0);
            push_back(&amp;mut v, 1);
            v
        };
        // 'push_back' now refers to Self::push_back
        let mut res = WrappedVector { vec };
        push_back(&amp;mut res, 10);
        res
    }
}
</code></pre>
<h2 id="unused-use-or-alias"><a class="header" href="#unused-use-or-alias">Unused Use or Alias</a></h2>
<p>An unused <code>use</code> will result in a warning</p>
<pre><code class="language-move">module a::example {
    use std::option::{some, none}; // Warning!
    //                      ^^^^ unused alias 'none'

    public fun example(): std::option::Option&lt;u8&gt; {
        some(0)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<p>As a syntactic convenience, some functions in Move can be called as &quot;methods&quot; on a value. This is done
by using the <code>.</code> operator to call the function, where the value on the left-hand side of the <code>.</code> is
the first argument to the function (sometimes called the receiver). The type of that value
statically determines which function is called. This is an important difference from some other
languages, where this syntax might indicate a dynamic call, where the function to be called is
determined at runtime. In Move, all function calls are statically determined.</p>
<p>In short, this syntax exists to make it easier to call functions without having to create an alias
with <code>use</code>, and without having to explicitly borrow the first argument to the function.
Additionally, this can make code more readable, as it reduces the amount of boilerplate needed to
call a function and makes it easier to chain function calls.</p>
<h2 id="syntax-3"><a class="header" href="#syntax-3">Syntax</a></h2>
<p>The syntax for calling a method is as follows:</p>
<pre><code class="language-text">&lt;expression&gt; . &lt;identifier&gt; &lt;[type_arguments],*&gt; ( &lt;arguments&gt; )
</code></pre>
<p>For example</p>
<pre><code class="language-move">coin.value();
*nums.borrow_mut(i) = 5;
</code></pre>
<h2 id="method-resolution"><a class="header" href="#method-resolution">Method Resolution</a></h2>
<p>When a method is called, the compiler will statically determine which function is called based on
the type of the receiver (the argument on the left-hand side of the <code>.</code>). The compiler maintains a
mapping from type and method name to the module and function name that should be called. This
mapping is created form the <code>use fun</code> aliases that are currently in scope, and from the appropriate
functions in the receiver type's defining module. In all cases, the receiver type is the first
argument to the function, whether by-value or by-reference.</p>
<p>In this section, when we say a method &quot;resolves&quot; to a function, we mean that the compiler will
statically replace the method with a normal <a href="./functions.html">function</a> call. For example if we have
<code>x.foo(e)</code> with <code>foo</code> resolving to <code>a::m::foo</code>, the compiler will replace <code>x.foo(e)</code> with
<code>a::m::foo(x, e)</code>, potentially <a href="method-syntax.html#automatic-borrowing">automatically borrowing</a> <code>x</code>.</p>
<h3 id="functions-in-the-defining-module"><a class="header" href="#functions-in-the-defining-module">Functions in the Defining Module</a></h3>
<p>In a types defining module, the compiler will automatically create a method alias for any function
declaration for its types when the type is the first argument in the function. For example,</p>
<pre><code class="language-move">module a::m {
    public struct X() has copy, drop, store;
    public fun foo(x: &amp;X) { ... }
    public fun bar(flag: bool, x: &amp;X) { ... }
}
</code></pre>
<p>The function <code>foo</code> can be called as a method on a value of type <code>X</code>. However, not the first argument
(and one is not created for <code>bool</code> since <code>bool</code> is not defined in that module). For example,</p>
<pre><code class="language-move">fun example(x: a::m::X) {
    x.foo(); // valid
    // x.bar(true); ERROR!
}
</code></pre>
<h3 id="use-fun-aliases"><a class="header" href="#use-fun-aliases"><code>use fun</code> Aliases</a></h3>
<p>Like a traditional <a href="uses.html"><code>use</code></a>, a <code>use fun</code> statement creates an alias local to its current
scope. This could be for the current module or the current expression block. However, the alias is
associated to a type.</p>
<p>The syntax for a <code>use fun</code> statement is as follows:</p>
<pre><code class="language-move">use fun &lt;function&gt; as &lt;type&gt;.&lt;method alias&gt;;
</code></pre>
<p>This creates an alias for the <code>&lt;function&gt;</code>, which the <code>&lt;type&gt;</code> can receive as <code>&lt;method alias&gt;</code>.</p>
<p>For example</p>
<pre><code class="language-move">module a::cup {
    public struct Cup&lt;T&gt;(T) has copy, drop, store;

    public fun cup_borrow&lt;T&gt;(c: &amp;Cup&lt;T&gt;): &amp;T {
        &amp;c.0
    }

    public fun cup_value&lt;T&gt;(c: Cup&lt;T&gt;): T {
        let Cup(t) = c;
        t
    }

    public fun cup_swap&lt;T: drop&gt;(c: &amp;mut Cup&lt;T&gt;, t: T) {
        c.0 = t;
    }
}
</code></pre>
<p>We can now create <code>use fun</code> aliases to these functions</p>
<pre><code class="language-move">module b::example {
    use fun a::cup::cup_borrow as Cup.borrow;
    use fun a::cup::cup_value as Cup.value;
    use fun a::cup::cup_swap as Cup.set;

    fun example(c: &amp;mut Cup&lt;u64&gt;) {
        let _ = c.borrow(); // resolves to a::cup::cup_borrow
        let v = c.value(); // resolves to a::cup::cup_value
        c.set(v * 2); // resolves to a::cup::cup_swap
    }
}
</code></pre>
<p>Note that the <code>&lt;function&gt;</code> in the <code>use fun</code> does not have to be a fully resolved path, and an alias
can be used instead, so the declarations in the above example could equivalently be written as</p>
<pre><code class="language-move">    use a::cup::{Self, cup_swap};

    use fun cup::cup_borrow as Cup.borrow;
    use fun cup::cup_value as Cup.value;
    use fun cup_swap as Cup.set;
</code></pre>
<p>While these examples are cute for renaming the functions in the current module, the feature is
perhaps more useful for declaring methods on types from other modules. For example, if we wanted to
add a new utility to <code>Cup</code>, we could do so with a <code>use fun</code> alias and still use method syntax</p>
<pre><code class="language-move">module b::example {

    fun double(c: &amp;Cup&lt;u64&gt;): Cup&lt;u64&gt; {
        let v = c.value();
        Cup::new(v * 2)
    }

}
</code></pre>
<p>Normally, we would be stuck having to call it as <code>double(&amp;c)</code> because <code>b::example</code> did not define
<code>Cup</code>, but instead we can use a <code>use fun</code> alias</p>
<pre><code class="language-move">    fun double_double(c: Cup&lt;u64&gt;): (Cup&lt;u64&gt;, Cup&lt;u64&gt;) {
        use fun b::example::double as Cup.dub;
        (c.dub(), c.dub()) // resolves to b::example::double in both calls
    }
</code></pre>
<p>While <code>use fun</code> can be made in any scope, the target <code>&lt;function&gt;</code> of the <code>use fun</code> must have a first
argument that is the same as the <code>&lt;type&gt;</code>.</p>
<pre><code class="language-move">public struct X() has copy, drop, store;

fun new(): X { X() }
fun flag(flag: bool): u8 { if (flag) 1 else 0 }

use fun new as X.new; // ERROR!
use fun flag as X.flag; // ERROR!
// Neither `new` nor `flag` has first argument of type `X`
</code></pre>
<p>But any first argument of the <code>&lt;type&gt;</code> can be used, including references and mutable references</p>
<pre><code class="language-move">public struct X() has copy, drop, store;

public fun by_val(_: X) {}
public fun by_ref(_: &amp;X) {}
public fun by_mut(_: &amp;mut X) {}

// All 3 valid, in any scope
use fun by_val as X.v;
use fun by_ref as X.r;
use fun by_mut as X.m;
</code></pre>
<p>Note for generics, the methods are associated for <em>all</em> instances of the generic type. You cannot
overload the method to resolve to different functions depending on the instantiation.</p>
<pre><code class="language-move">public struct Cup&lt;T&gt;(T) has copy, drop, store;

public fun value&lt;T: copy&gt;(c: &amp;Cup&lt;T&gt;): T {
    c.0
}

use fun value as Cup&lt;bool&gt;.flag; // ERROR!
use fun value as Cup&lt;u64&gt;.num; // ERROR!
// In both cases, `use fun` aliases cannot be generic, they must work for all instances of the type
</code></pre>
<h3 id="public-use-fun-aliases"><a class="header" href="#public-use-fun-aliases"><code>public use fun</code> Aliases</a></h3>
<p>Unlike a traditional <a href="uses.html"><code>use</code></a>, the <code>use fun</code> statement can be made <code>public</code>, which allows it
to be used outside of its declared scope. A <code>use fun</code> can be made <code>public</code> if it is declared in the
module that defines the receivers type, much like the method aliases that are
<a href="method-syntax.html#functions-in-the-defining-module">automatically created</a> for functions in the defining module. Or
conversely, one can think that an implicit <code>public use fun</code> is created automatically for every
function in the defining module that has a first argument of the receiver type (if it is defined in
that module). Both of these views are equivalent.</p>
<pre><code class="language-move">module a::cup {
    public struct Cup&lt;T&gt;(T) has copy, drop, store;

    public use fun cup_borrow as Cup.borrow;
    public fun cup_borrow&lt;T&gt;(c: &amp;Cup&lt;T&gt;): &amp;T {
        &amp;c.0
    }
}
</code></pre>
<p>In this example, a public method alias is created for <code>a::cup::Cup.borrow</code> and
<code>a::cup::Cup.cup_borrow</code>. Both resolve to <code>a::cup::cup_borrow</code>. And both are &quot;public&quot; in the sense
that they can be used outside of <code>a::cup</code>, without an additional <code>use</code> or <code>use fun</code>.</p>
<pre><code class="language-move">module b::example {

    fun example&lt;T: drop&gt;(c: a::cup::Cup&lt;u64&gt;) {
        c.borrow(); // resolves to a::cup::cup_borrow
        c.cup_borrow(); // resolves to a::cup::cup_borrow
    }
}
</code></pre>
<p>The <code>public use fun</code> declarations thus serve as a way of renaming a function if you want to give it
a cleaner name for use with method syntax. This is especially helpful if you have a module with
multiple types, and similarly named functions for each type.</p>
<pre><code class="language-move">module a::shapes {

    public struct Rectangle { base: u64, height: u64 }
    public struct Box { base: u64, height: u64, depth: u64 }

    // Rectangle and Box can have methods with the same name

    public use fun rectangle_base as Rectangle.base;
    public fun rectangle_base(rectangle: &amp;Rectangle): u64 {
        rectangle.base
    }

    public use fun box_base as Box.base;
    public fun box_base(box: &amp;Box): u64 {
        box.base
    }

}
</code></pre>
<p>Another use for <code>public use fun</code> is adding methods to types from other modules. This can be helpful
in conjunction with functions spread out across a single package.</p>
<pre><code class="language-move">module a::cup {
    public struct Cup&lt;T&gt;(T) has copy, drop, store;

    public fun new&lt;T&gt;(t: T): Cup&lt;T&gt; { Cup(t) }
    public fun borrow&lt;T&gt;(c: &amp;Cup&lt;T&gt;): &amp;T {
        &amp;c.0
    }
    // `public use fun` to a function defined in another module
    public use fun a::utils::split as Cup.split;
}

module a::utils {
    use a::m::{Self, Cup};

    public fun split&lt;u64&gt;(c: Cup&lt;u64&gt;): (Cup&lt;u64&gt;, Cup&lt;u64&gt;) {
        let Cup(t) = c;
        let half = t / 2;
        let rem = if (t &gt; 0) t - half else 0;
        (cup::new(half), cup::new(rem))
    }

}
</code></pre>
<p>And note that this <code>public use fun</code> does not create a circular dependency, as the <code>use fun</code> is not
present after the module is compiled--all methods are resolved statically.</p>
<h3 id="interactions-with-use-aliases"><a class="header" href="#interactions-with-use-aliases">Interactions with <code>use</code> Aliases</a></h3>
<p>A small detail to note is that method aliases respect normal <code>use</code> aliases.</p>
<pre><code class="language-move">module a::cup {
    public struct Cup&lt;T&gt;(T) has copy, drop, store;

    public fun cup_borrow&lt;T&gt;(c: &amp;Cup&lt;T&gt;): &amp;T {
        &amp;c.0
    }
}

module b::other {
    use a::cup::{Cup, cup_borrow as borrow};

    fun example(c: &amp;Cup&lt;u64&gt;) {
        c.borrow(); // resolves to a::cup::cup_borrow
    }
}
</code></pre>
<p>A helpful way to think about this is that <code>use</code> creates an implicit <code>use fun</code> alias for the function
whenever it can. In this case the <code>use a::cup::cup_borrow as borrow</code> creates an implicit
<code>use fun a::cup::cup_borrow as Cup.borrow</code> because it would be a valid <code>use fun</code> alias. Both views
are equivalent. This line of reasoning can inform how specific methods will resolve with shadowing.
See the cases in <a href="method-syntax.html#scoping">Scoping</a> for more details.</p>
<h3 id="scoping"><a class="header" href="#scoping">Scoping</a></h3>
<p>If not <code>public</code>, a <code>use fun</code> alias is local to its scope, much like a normal <a href="uses.html"><code>use</code></a>. For
example</p>
<pre><code class="language-move">module a::m {
    public struct X() has copy, drop, store;
    public fun foo(_: &amp;X) {}
    public fun bar(_: &amp;X) {}
}

module b::other {
    use a::m::X;

    use fun a::m::foo as X.f;

    fun example(x: &amp;X) {
        x.f(); // resolves to a::m::foo
        {
            use a::m::bar as f;
            x.f(); // resolves to a::m::bar
        };
        x.f(); // still resolves to a::m::foo
        {
            use fun a::m::bar as X.f;
            x.f(); // resolves to a::m::bar
        }
    }
</code></pre>
<h2 id="automatic-borrowing-1"><a class="header" href="#automatic-borrowing-1">Automatic Borrowing</a></h2>
<p>When resolving a method, the compiler will automatically borrow the receiver if the function expects
a reference. For example</p>
<pre><code class="language-move">module a::m {
    public struct X() has copy, drop;
    public fun by_val(_: X) {}
    public fun by_ref(_: &amp;X) {}
    public fun by_mut(_: &amp;mut X) {}

    fun example(mut x: X) {
        x.by_ref(); // resolves to a::m::by_ref(&amp;x)
        x.by_mut(); // resolves to a::m::by_mut(&amp;mut x)
    }
}
</code></pre>
<p>In these examples, <code>x</code> was automatically borrowed to <code>&amp;x</code> and <code>&amp;mut x</code> respectively. This will also
work through field access</p>
<pre><code class="language-move">module a::m {
    public struct X() has copy, drop;
    public fun by_val(_: X) {}
    public fun by_ref(_: &amp;X) {}
    public fun by_mut(_: &amp;mut X) {}

    public struct Y has drop { x: X }

    fun example(mut y: Y) {
        y.x.by_ref(); // resolves to a::m::by_ref(&amp;y.x)
        y.x.by_mut(); // resolves to a::m::by_mut(&amp;mut y.x)
    }
}
</code></pre>
<p>Note that in both examples, the local variable had to be labeled as <a href="./variables.html"><code>mut</code></a> to allow
for the <code>&amp;mut</code> borrow. Without this, there would be an error saying that <code>x</code> (or <code>y</code> in the second
example) is not mutable.</p>
<p>Keep in mind that without a reference, normal rules for variable and field access come into play.
Meaning a value might be moved or copied if it is not borrowed.</p>
<pre><code class="language-move">module a::m {
    public struct X() has copy, drop;
    public fun by_val(_: X) {}
    public fun by_ref(_: &amp;X) {}
    public fun by_mut(_: &amp;mut X) {}

    public struct Y has drop { x: X }
    public fun drop_y(y: Y) { y }

    fun example(y: Y) {
        y.x.by_val(); // copies `y.x` since `by_val` is by-value and `X` has `copy`
        y.drop_y(); // moves `y` since `drop_y` is by-value and `Y` does _not_ have `copy`
    }
}
</code></pre>
<h2 id="chaining"><a class="header" href="#chaining">Chaining</a></h2>
<p>Method calls can be chained, because any expression can be the receiver of the method.</p>
<pre><code class="language-move">module a::shapes {
    public struct Point has copy, drop, store { x: u64, y: u64 }
    public struct Line has copy, drop, store { start: Point, end: Point }

    public fun x(p: &amp;Point): u64 { p.x }
    public fun y(p: &amp;Point): u64 { p.y }

    public fun start(l: &amp;Line): &amp;Point { &amp;l.start }
    public fun end(l: &amp;Line): &amp;Point { &amp;l.end }

}

module b::example {
    use a::shapes::Line;

    public fun x_values(l: Line): (u64, u64) {
        (l.start().x(), l.end().x())
    }

}
</code></pre>
<p>In this example for <code>l.start().x()</code>, the compiler first resolves <code>l.start()</code> to
<code>a::shapes::start(&amp;l)</code>. Then <code>.x()</code> is resolved to <code>a::shapes::x(a::shapes::start(&amp;l))</code>. Similarly
for <code>l.end().x()</code>. Keep in mind, this feature is not &quot;special&quot;--the left-hand side of the <code>.</code> can be
any expression, and the compiler will resolve the method call as normal. We simply draw attention to
this sort of &quot;chaining&quot; because it is a common practice to increase readability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index-syntax"><a class="header" href="#index-syntax">Index Syntax</a></h1>
<p>Move provides syntax attributes to allow you to define operations that look and feel like native
Move code, lowering these operations into your user-provided definitions.</p>
<p>Our first syntax method, <code>index</code>, allows you to define a group of operations that can be used as
custom index accessors for your datatypes, such as accessing a matrix element as <code>m[i,j]</code>, by
annotating functions that should be used for these index operations. Moreover, these definitions are
bespoke per-type and available implicitly for any programmer using your type.</p>
<h2 id="overview-and-summary"><a class="header" href="#overview-and-summary">Overview and Summary</a></h2>
<p>To start, consider a <code>Matrix</code> type that uses a vector of vectors to represent its values. You can
write a small library using <code>index</code> syntax annotations on the <code>borrow</code> and <code>borrow_mut</code> functions as
follows:</p>
<pre><code class="language-move">module matrix {

    public struct Matrix&lt;T&gt; { v: vector&lt;vector&lt;T&gt;&gt; }

    #[syntax(index)]
    public fun borrow&lt;T&gt;(s: &amp;Matrix&lt;T&gt;, i: u64, j: u64): &amp;T {
        vector::borrow(vector::borrow(&amp;s.v, i), j)
    }

    #[syntax(index)]
    public fun borrow_mut&lt;T&gt;(s: &amp;mut Matrix&lt;T&gt;, i: u64, j: u64): &amp;mut T {
        vector::borrow_mut(vector::borrow_mut(&amp;mut s.v, i), j)
    }

    public fun make_matrix&lt;T&gt;(v: vector&lt;vector&lt;T&gt;&gt;):  Matrix&lt;T&gt; {
        Matrix { v }
    }

}
</code></pre>
<p>Now anyone using this <code>Matrix</code> type has access to index syntax for it:</p>
<pre><code class="language-move">let mut m = matrix::make_matrix(vector[
    vector[1, 0, 0],
    vector[0, 1, 0],
    vector[0, 0, 1],
]);

let mut i = 0;
while (i &lt; 3) {
    let mut j = 0;
    while (j &lt; 3) {
        if (i == j) {
            assert!(m[i, j] == 1, 1);
        } else {
            assert!(m[i, j] == 0, 0);
        };
        *(&amp;mut m[i,j]) = 2;
        j = j + 1;
    };
    i = i + 1;
}
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>As the example indicates, if you define a datatype and an associated index syntax method, anyone can
invoke that method by writing index syntax on a value of that type:</p>
<pre><code class="language-move">let mat = matrix::make_matrix(...);
let m_0_0 = mat[0, 0];
</code></pre>
<p>During compilation, the compiler translates these into the appropriate function invocations based on
the position and mutable usage of the expression:</p>
<pre><code class="language-move">let mut mat = matrix::make_matrix(...);

let m_0_0 = mat[0, 0];
// translates to `copy matrix::borrow(&amp;mat, 0, 0)`

let m_0_0 = &amp;mat[0, 0];
// translates to `matrix::borrow(&amp;mat, 0, 0)`

let m_0_0 = &amp;mut mat[0, 0];
// translates to `matrix::borrow_mut(&amp;mut mat, 0, 0)`
``

You can also intermix index expressions with field accesses:

```move
public struct V { v: vector&lt;u64&gt; }

public struct Vs { vs: vector&lt;V&gt; }

fun borrow_first(input: &amp;Vs): &amp;u64 {
    &amp;input.vs[0].v[0]
    // translates to `vector::borrow(&amp;vector::borrow(&amp;input.vs, 0).v, 0)`
}
</code></pre>
<h3 id="index-functions-take-flexible-arguments"><a class="header" href="#index-functions-take-flexible-arguments">Index Functions Take Flexible Arguments</a></h3>
<p>Note that, aside from the definition and type limitations described in the rest of this chapter,
Move places no restrictions on the values your index syntax method takes as parameters. This allows
you to implement intricate programmatic behavior when defining index syntax, such as a data
structure that takes a default value if the index is out of bounds:</p>
<pre><code class="language-move">#[syntax(index)]
public fun borrow_or_set&lt;Key: copy, Value: drop&gt;(
    input: &amp;mut MTable&lt;Key, Value&gt;,
    key: Key,
    default: Value
): &amp;mut Value {
    if (contains(input, key)) {
        borrow(input, key)
    } else {
        insert(input, key, default);
        borrow(input, key)
    }
}
</code></pre>
<p>Now, when you index into <code>MTable</code>, you must also provide a default value:</p>
<pre><code class="language-move">let string_key: String = ...;
let mut table: MTable&lt;String, u64&gt; = m_table::make_table();
let entry: &amp;mut u64 = &amp;mut table[string_key, 0];
</code></pre>
<p>This sort of extensible power allows you to write precise index interfaces for your types,
concretely enforcing bespoke behavior.</p>
<h2 id="defining-index-syntax-functions"><a class="header" href="#defining-index-syntax-functions">Defining Index Syntax Functions</a></h2>
<p>This powerful syntax form allows all of your user-defined datatypes to behave in this way, assuming
your definitions adhere to the following rules:</p>
<ol>
<li>The <code>#[syntax(index)]</code> attribute is added to the designated functions defined in the same module
as the subject type.</li>
<li>The designated functions have <code>public</code> visibility.</li>
<li>The functions take a reference type as its subject type (its first argument) and returns a
matching references type (<code>mut</code> if the subject was <code>mut</code>).</li>
<li>Each type has only a single mutable and single immutable definition.</li>
<li>Immutable and mutable versions have type agreement:
<ul>
<li>The subject types match, differing only in mutability.</li>
<li>The return types match the mutability of their subject types.</li>
<li>Type parameters, if present, have identical constraints between both versions.</li>
<li>All parameters beyond the subject type are identical.</li>
</ul>
</li>
</ol>
<p>The following content and additional examples describe these rules in greater detail.</p>
<h3 id="declaration-3"><a class="header" href="#declaration-3">Declaration</a></h3>
<p>To declare an index syntax method, add the <code>#[syntax(index)]</code> attribute above the relevant function
definition in the same module as the subject type's definition. This signals to the compiler that
the function is an index accessor for the specified type.</p>
<h4 id="immutable-accessor"><a class="header" href="#immutable-accessor">Immutable Accessor</a></h4>
<p>The immutable index syntax method is defined for read-only access. It takes an immutable reference
of the subject type and returns an immutable reference to the element type. The <code>borrow</code> function
defined in <code>std::vector</code> is an example of this:</p>
<pre><code class="language-move">#[syntax(index)]
public native fun borrow&lt;Element&gt;(v: &amp;vector&lt;Element&gt;, i: u64): &amp;Element;
</code></pre>
<h4 id="mutable-accessor"><a class="header" href="#mutable-accessor">Mutable Accessor</a></h4>
<p>The mutable index syntax method is the dual of the immutable one, allowing for both read and write
operations. It takes a mutable reference of the subject type and returns a mutable reference to the
element type. The <code>borrow_mut</code> function defined in <code>std::vector</code> is an example of this:</p>
<pre><code class="language-move">#[syntax(index)]
public native fun borrow_mut&lt;Element&gt;(v: &amp;mut vector&lt;Element&gt;, i: u64): &amp;mut Element;
</code></pre>
<h4 id="visibility-4"><a class="header" href="#visibility-4">Visibility</a></h4>
<p>To ensure that indexing functions are available anywhere the type is used, all index syntax methods
must have public visibility. This ensures ergonomic usage of indexing across modules and packages in
Move.</p>
<h4 id="no-duplicates"><a class="header" href="#no-duplicates">No Duplicates</a></h4>
<p>In addition to the above requirements, we restrict each subject base type to defining a single index
syntax method for immutable references and a single index syntax method for mutable references. For
example, you cannot define a specialized version for a polymorphic type:</p>
<pre><code class="language-move">#[syntax(index)]
public fun borrow_matrix_u64(s: &amp;Matrix&lt;u64&gt;, i: u64, j: u64): &amp;u64 { ... }

#[syntax(index)]
public fun borrow_matrix&lt;T&gt;(s: &amp;Matrix&lt;T&gt;, i: u64, j: u64): &amp;T { ... }
    // ERROR! Matrix already has a definition
    // for its immutable index syntax method
</code></pre>
<p>This ensures that you can always tell which method is being invoked, without the need to inspect
type instantiation.</p>
<h3 id="type-constraints"><a class="header" href="#type-constraints">Type Constraints</a></h3>
<p>By default, an index syntax method has the following type constraints:</p>
<p><strong>Its subject type (first argument) must be a reference to a single type defined in the same module
as the marked function.</strong> This means that you cannot define index syntax methods for tuples, type
parameters, or values:</p>
<pre><code class="language-move">#[syntax(index)]
public fun borrow_fst(x: &amp;(u64, u64), ...): &amp;u64 { ... }
    // ERROR because the subject type is a tuple

#[syntax(index)]
public fun borrow_tyarg&lt;T&gt;(x: &amp;T, ...): &amp;T { ... }
    // ERROR because the subject type is a type parameter

#[syntax(index)]
public fun borrow_value(x: Matrix&lt;u64&gt;, ...): &amp;u64 { ... }
    // ERROR because x is not a reference
</code></pre>
<p><strong>The subject type must match mutability with the return type.</strong> This restriction allows you to
clarify the expected behavior when borrowing an indexed expression as <code>&amp;vec[i]</code> versus
<code>&amp;mut vec[i]</code>. The Move compiler uses the mutability marker to determine which borrow form to call
to produce a reference of the appropriate mutability. As a result, we disallow index syntax methods
whose subject and return mutability differ:</p>
<pre><code class="language-move">#[syntax(index)]
public fun borrow_imm(x: &amp;mut Matrix&lt;u64&gt;, ...): &amp;u64 { ... }
    // ERROR! incompatible mutability
    // expected a mutable reference '&amp;mut' return type
</code></pre>
<h3 id="type-compatibility"><a class="header" href="#type-compatibility">Type Compatibility</a></h3>
<p>When defining an immutable and mutable index syntax method pair, they are subject to a number of
compatibility constraints:</p>
<ol>
<li>They must take the same number of type parameters, those type parameters must have the same
constraints.</li>
<li>Type parameters must be used the same <em>by position</em>, not name.</li>
<li>Their subject types must match exactly except for the mutability.</li>
<li>Their return types must match exactly except for the mutability.</li>
<li>All other parameter types must match exactly.</li>
</ol>
<p>These constraints are to ensure that index syntax behaves identically regardless of being in a
mutable or immutable position.</p>
<p>To illustrate some of these errors, recall the previous <code>Matrix</code> definition:</p>
<pre><code class="language-move">#[syntax(index)]
public fun borrow&lt;T&gt;(s: &amp;Matrix&lt;T&gt;, i: u64, j: u64): &amp;T {
    vector::borrow(vector::borrow(&amp;s.v, i), j)
}
</code></pre>
<p>All of the following are type-incompatible definitions of the mutable version:</p>
<pre><code class="language-move">#[syntax(index)]
public fun borrow_mut&lt;T: drop&gt;(s: &amp;mut Matrix&lt;T&gt;, i: u64, j: u64): &amp;mut T { ... }
    // ERROR! `T` has `drop` here, but no in the immutable version

#[syntax(index)]
public fun borrow_mut(s: &amp;mut Matrix&lt;u64&gt;, i: u64, j: u64): &amp;mut u64 { ... }
    // ERROR! This takes a different number of type parameters

#[syntax(index)]
public fun borrow_mut&lt;T, U&gt;(s: &amp;mut Matrix&lt;U&gt;, i: u64, j: u64): &amp;mut U { ... }
    // ERROR! This takes a different number of type parameters

#[syntax(index)]
public fun borrow_mut&lt;U&gt;(s: &amp;mut Matrix&lt;U&gt;, i_j: (u64, u64)): &amp;mut U { ... }
    // ERROR! This takes a different number of arguments

#[syntax(index)]
public fun borrow_mut&lt;U&gt;(s: &amp;mut Matrix&lt;U&gt;, i: u64, j: u32): &amp;mut U { ... }
    // ERROR! `j` is a different type
</code></pre>
<p>Again, the goal here is to make the usage across the immutable and mutable versions consistent. This
allows index syntax methods to work without changing out the behavior or constraints based on
mutable versus immutable usage, ultimately ensuring a consistent interface to program against.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages"><a class="header" href="#packages">Packages</a></h1>
<p>Packages allow Move programmers to more easily re-use code and share it across projects. The Move
package system allows programmers to easily:</p>
<ul>
<li>Define a package containing Move code;</li>
<li>Parameterize a package by <a href="./primitive-types/address.html">named addresses</a>;</li>
<li>Import and use packages in other Move code and instantiate named addresses;</li>
<li>Build packages and generate associated compilation artifacts from packages; and</li>
<li>Work with a common interface around compiled Move artifacts.</li>
</ul>
<h2 id="package-layout-and-manifest-syntax"><a class="header" href="#package-layout-and-manifest-syntax">Package Layout and Manifest Syntax</a></h2>
<p>A Move package source directory contains a <code>Move.toml</code> package manifest file, a generated
<code>Move.lock</code> file, and a set of subdirectories:</p>
<pre><code class="language-plaintext">a_move_package
 Move.toml      (required)
 Move.lock      (generated)
 sources        (required)
 doc_templates  (optional)
 examples       (optional, test &amp; dev mode)
 tests          (optional, test mode)
</code></pre>
<p>The directories and files labeled &quot;required&quot; must be present for a directory to be considered a Move
package and built. Optional directories may be present, and if so, they will be included in the
compilation process depending on the mode used to build the package. For instance, when built in
&quot;dev&quot; or &quot;test&quot; modes, the <code>tests</code> and <code>examples</code> directories will also be included.</p>
<p>Going through each of these in turn:</p>
<ol>
<li>The <a href="packages.html#movetoml"><code>Move.toml</code></a> file is the package manifest and is required for a directory to be
considered a Move package. This file contains metadata about the package, such as name,
dependencies, and so on.</li>
<li>The <a href="packages.html#movelock"><code>Move.lock</code></a> file is generated by the Move CLI and contains the fixed build
versions of the package and its dependencies. It is used to ensure consistent versions are used
across different builds and that changes in dependencies are apparent as a change in this file.</li>
<li>The <code>sources</code> directory is required and contains the Move modules that make up the package.
Modules in this directory will always be included in the compilation process.</li>
<li>The <code>doc_templates</code> directory can contain documentation templates that will be used when
generating documentation for the package.</li>
<li>The <code>examples</code> directory can hold additional code to be used only for development and/or
tutorials, this will not be included when compiled outside of <code>test</code> or <code>dev</code> modes.</li>
<li>The <code>tests</code> directory can contain Move modules that are only included when compiled in <code>test</code>
mode or when <a href="./unit-testing.html">Move unit tests</a> are run.</li>
</ol>
<h3 id="movetoml"><a class="header" href="#movetoml">Move.toml</a></h3>
<p>The Move package manifest is defined within the <code>Move.toml</code> file and has the following syntax.
Optional fields are marked with <code>*</code>, <code>+</code> denotes one or more elements:</p>
<pre><code class="language-ini">[package]
name = &lt;string&gt;
edition* = &lt;string&gt;      # e.g., &quot;2024.alpha&quot; to use the Move 2024 edition,
                         # currently in alpha. Will default to the latest stable edition if not specified.
license* = &lt;string&gt;              # e.g., &quot;MIT&quot;, &quot;GPL&quot;, &quot;Apache 2.0&quot;
authors* = [&lt;string&gt;,+]  # e.g., [&quot;Joe Smith (joesmith@noemail.com)&quot;, &quot;John Snow (johnsnow@noemail.com)&quot;]

# Additional fields may be added to this section by external tools. E.g., on Sui the following sections are added:
published-at* = &quot;&lt;hex-address&gt;&quot; # The address that the package is published at. Should be set after the first publication.

[dependencies] # (Optional section) Paths to dependencies
# One or more lines declaring dependencies in the following format

# ##### Local Dependencies #####
# For local dependencies use `local = path`. Path is relative to the package root
# Local = { local = &quot;../path/to&quot; }
# To resolve a version conflict and force a specific version for dependency
# override you can use `override = true`
# Override = { local = &quot;../conflicting/version&quot;, override = true }
# To instantiate address values in a dependency, use `addr_subst`
&lt;string&gt; = {
    local = &lt;string&gt;,
    override* = &lt;bool&gt;,
    addr_subst* = { (&lt;string&gt; = (&lt;string&gt; | &quot;&lt;hex_address&gt;&quot;))+ }
}

# ##### Git Dependencies #####
# For remote import, use the `{ git = &quot;...&quot;, subdir = &quot;...&quot;, rev = &quot;...&quot; }`.
# Revision must be supplied, it can be a branch, a tag, or a commit hash.
# If no `subdir` is specified, the root of the repository is used.
# MyRemotePackage = { git = &quot;https://some.remote/host.git&quot;, subdir = &quot;remote/path&quot;, rev = &quot;main&quot; }
&lt;string&gt; = {
    git = &lt;URL ending in .git&gt;,
    subdir=&lt;path to dir containing Move.toml inside git repo&gt;,
    rev=&lt;git commit hash&gt;,
    override* = &lt;bool&gt;,
    addr_subst* = { (&lt;string&gt; = (&lt;string&gt; | &quot;&lt;hex_address&gt;&quot;))+ }
}

[addresses]  # (Optional section) Declares named addresses in this package
# One or more lines declaring named addresses in the following format
# Addresses that match the name of the package must be set to `&quot;0x0&quot;` or they will be unable to be published.
&lt;addr_name&gt; = &quot;_&quot; | &quot;&lt;hex_address&gt;&quot; # e.g., std = &quot;_&quot; or my_addr = &quot;0xC0FFEECAFE&quot;

# Named addresses will be accessible in Move as `@name`. They're also exported:
# for example, `std = &quot;0x1&quot;` is exported by the Standard Library.
# alice = &quot;0xA11CE&quot;

[dev-dependencies] # (Optional section) Same as [dependencies] section, but only included in &quot;dev&quot; and &quot;test&quot; modes
# The dev-dependencies section allows overriding dependencies for `--test` and
# `--dev` modes. You can e.g., introduce test-only dependencies here.
# Local = { local = &quot;../path/to/dev-build&quot; }
&lt;string&gt; = {
    local = &lt;string&gt;,
    override* = &lt;bool&gt;,
    addr_subst* = { (&lt;string&gt; = (&lt;string&gt; | &quot;&lt;hex_address&gt;&quot;))+ }
}
&lt;string&gt; = {
    git = &lt;URL ending in .git&gt;,
    subdir=&lt;path to dir containing Move.toml inside git repo&gt;,
    rev=&lt;git commit hash&gt;,
    override* = &lt;bool&gt;,
    addr_subst* = { (&lt;string&gt; = (&lt;string&gt; | &quot;&lt;hex_address&gt;&quot;))+ }
}

[dev-addresses] # (Optional section) Same as [addresses] section, but only included in &quot;dev&quot; and &quot;test&quot; modes
# The dev-addresses section allows overwriting named addresses for the `--test`
# and `--dev` modes.
&lt;addr_name&gt; = &quot;&lt;hex_address&gt;&quot; # e.g., alice = &quot;0xB0B&quot;
</code></pre>
<p>An example of a minimal package manifest:</p>
<pre><code class="language-ini">[package]
name = &quot;AName&quot;
</code></pre>
<p>An example of a more standard package manifest that also includes the Move standard library and
instantiates the named address <code>std</code> from the <code>LocalDep</code> package with the address value <code>0x1</code>:</p>
<pre><code class="language-ini">[package]
name = &quot;AName&quot;
license = &quot;Apache 2.0&quot;

[addresses]
address_to_be_filled_in = &quot;_&quot;
specified_address = &quot;0xB0B&quot;

[dependencies]
# Local dependency
LocalDep = { local = &quot;projects/move-awesomeness&quot;, addr_subst = { &quot;std&quot; = &quot;0x1&quot; } }
# Git dependency
MoveStdlib = { git = &quot;https://github.com/MystenLabs/sui.git&quot;, subdir = &quot;crates/sui-framework/packages/move-stdlib&quot;, rev = &quot;framework/mainnet&quot; }

[dev-addresses] # For use when developing this module
address_to_be_filled_in = &quot;0x101010101&quot;
</code></pre>
<p>Most of the sections in the package manifest are self explanatory, but named addresses can be a bit
difficult to understand so we examine them in more detail in
<a href="packages.html#named-addresses-during-compilation">Named Addresses During Compilation</a>.</p>
<h2 id="named-addresses-during-compilation"><a class="header" href="#named-addresses-during-compilation">Named Addresses During Compilation</a></h2>
<p>Recall that Move has <a href="./primitive-types/address.html">named addresses</a> and that named addresses cannot
be declared in Move. Instead they are declared at the package level: in the manifest file
(<code>Move.toml</code>) for a Move package you declare named addresses in the package, instantiate other named
addresses, and rename named addresses from other packages within the Move package system.</p>
<p>Let's go through each of these actions, and how they are performed in the package's manifest
one-by-one:</p>
<h3 id="declaring-named-addresses"><a class="header" href="#declaring-named-addresses">Declaring Named Addresses</a></h3>
<p>Let's say we have a Move module in <code>example_pkg/sources/A.move</code> as follows:</p>
<pre><code class="language-move">module named_addr::a {
    public fun x(): address { @named_addr }
}
</code></pre>
<p>We could in <code>example_pkg/Move.toml</code> declare the named address <code>named_addr</code> in two different ways.
The first:</p>
<pre><code class="language-ini">[package]
name = &quot;example_pkg&quot;
...
[addresses]
named_addr = &quot;_&quot;
</code></pre>
<p>Declares <code>named_addr</code> as a named address in the package <code>example_pkg</code> and that <em>this address can be
any valid address value</em>. In particular, an importing package can pick the value of the named
address <code>named_addr</code> to be any address it wishes. Intuitively you can think of this as
parameterizing the package <code>example_pkg</code> by the named address <code>named_addr</code>, and the package can then
be instantiated later on by an importing package.</p>
<p><code>named_addr</code> can also be declared as:</p>
<pre><code class="language-ini">[package]
name = &quot;example_pkg&quot;
...
[addresses]
named_addr = &quot;0xCAFE&quot;
</code></pre>
<p>which states that the named address <code>named_addr</code> is exactly <code>0xCAFE</code> and cannot be changed. This is
useful so other importing packages can use this named address without needing to worry about the
exact value assigned to it.</p>
<p>With these two different declaration methods, there are two ways that information about named
addresses can flow in the package graph:</p>
<ul>
<li>The former (&quot;unassigned named addresses&quot;) allows named address values to flow from the importation
site to the declaration site.</li>
<li>The latter (&quot;assigned named addresses&quot;) allows named address values to flow from the declaration
site upwards in the package graph to usage sites.</li>
</ul>
<p>With these two methods for flowing named address information throughout the package graph the rules
around scoping and renaming become important to understand.</p>
<h2 id="scope-and-renaming-of-named-addresses"><a class="header" href="#scope-and-renaming-of-named-addresses">Scope and Renaming of Named Addresses</a></h2>
<p>A named address <code>N</code> in a package <code>P</code> is in scope if:</p>
<ol>
<li><code>P</code> declares a named address <code>N</code>; or</li>
<li>A package in one of <code>P</code>'s transitive dependencies declares the named address <code>N</code> and there is a
dependency path in the package graph between between <code>P</code> and the declaring package of <code>N</code> with no
renaming of <code>N</code>.</li>
</ol>
<p>Additionally, every named address in a package is exported. Because of this and the above scoping
rules each package can be viewed as coming with a set of named addresses that will be brought into
scope when the package is imported, e.g., if you import <code>example_pkg</code>, that import will also bring
the <code>named_addr</code> named address into scope. Because of this, if <code>P</code> imports two packages <code>P1</code> and
<code>P2</code> both of which declare a named address <code>N</code> an issue arises in <code>P</code>: which &quot;<code>N</code>&quot; is meant when <code>N</code>
is referred to in <code>P</code>? The one from <code>P1</code> or <code>P2</code>? To prevent this ambiguity around which package a
named address is coming from, we enforce that the sets of scopes introduced by all dependencies in a
package are disjoint, and provide a way to <em>rename named addresses</em> when the package that brings
them into scope is imported.</p>
<p>Renaming a named address when importing can be done as follows in our <code>P</code>, <code>P1</code>, and <code>P2</code> example
above:</p>
<pre><code class="language-ini">[package]
name = &quot;P&quot;
...
[dependencies]
P1 = { local = &quot;some_path_to_P1&quot;, addr_subst = { &quot;P1N&quot; = &quot;N&quot; } }
P2 = { local = &quot;some_path_to_P2&quot;  }
</code></pre>
<p>With this renaming <code>N</code> refers to the <code>N</code> from <code>P2</code> and <code>P1N</code> will refer to <code>N</code> coming from <code>P1</code>:</p>
<pre><code class="language-move">module N::A {
    public fun x(): address { @P1N }
}
</code></pre>
<p>It is important to note that <em>renaming is not local</em>: once a named address <code>N</code> has been renamed to
<code>N2</code> in a package <code>P</code> all packages that import <code>P</code> will not see <code>N</code> but only <code>N2</code> unless <code>N</code> is
reintroduced from outside of <code>P</code>. This is why rule (2) in the scoping rules at the start of this
section specifies a &quot;dependency path in the package graph between between <code>P</code> and the declaring
package of <code>N</code> with no renaming of <code>N</code>.&quot;</p>
<h3 id="instantiating-named-addresses"><a class="header" href="#instantiating-named-addresses">Instantiating Named Addresses</a></h3>
<p>Named addresses can be instantiated multiple times across the package graph as long as it is always
with the same value. It is an error if the same named address (regardless of renaming) is
instantiated with differing values across the package graph.</p>
<p>A Move package can only be compiled if all named addresses resolve to a value. This presents issues
if the package wishes to expose an uninstantiated named address. This is what the <code>[dev-addresses]</code>
section solves in part. This section can set values for named addresses, but cannot introduce any
named addresses. Additionally, only the <code>[dev-addresses]</code> in the root package are included in <code>dev</code>
mode. For example a root package with the following manifest would not compile outside of <code>dev</code> mode
since <code>named_addr</code> would be uninstantiated:</p>
<pre><code class="language-ini">[package]
name = &quot;example_pkg&quot;
...
[addresses]
named_addr = &quot;_&quot;

[dev-addresses]
named_addr = &quot;0xC0FFEE&quot;
</code></pre>
<h2 id="usage-and-artifacts"><a class="header" href="#usage-and-artifacts">Usage and Artifacts</a></h2>
<p>The Move package system comes with a command line option as part of the CLI:
<code>sui move &lt;command&gt; &lt;command_flags&gt;</code>. Unless a particular path is provided, all package commands
will run in the current enclosing Move package. The full list of commands and flags for the Move CLI
can be found by running <code>sui move --help</code>.</p>
<h3 id="artifacts"><a class="header" href="#artifacts">Artifacts</a></h3>
<p>A package can be compiled using CLI commands. This will create a <code>build</code> directory containing
build-related artifacts (including bytecode binaries, source maps, and documentation). The general
layout of the <code>build</code> directory is as follows:</p>
<pre><code class="language-plaintext">a_move_package
 BuildInfo.yaml
 bytecode_modules
  dependencies
   &lt;dep_pkg_name&gt;
    *.mv
  ...
    &lt;dep_pkg_name&gt;
     *.mv
 ...
  *.mv
 docs
  dependencies
   &lt;dep_pkg_name&gt;
    *.md
  ...
    &lt;dep_pkg_name&gt;
     *.md
 ...
  *.md
 source_maps
  dependencies
   &lt;dep_pkg_name&gt;
    *.mvsm
  ...
    &lt;dep_pkg_name&gt;
     *.mvsm
 ...
  *.mvsm
 sources
  ...
   *.move
   dependencies
    &lt;dep_pkg_name&gt;
     *.move
   ...
     &lt;dep_pkg_name&gt;
      *.move
  ...
   *.move
</code></pre>
<h2 id="movelock"><a class="header" href="#movelock">Move.lock</a></h2>
<p>The <code>Move.lock</code> file is generated at the root of the Move package when the package is built. The
<code>Move.lock</code> file contains information about your package and its build configuration, and acts as a
communication layer between the Move compiler and other tools, like chain-specific command line
interfaces and third-party package managers.</p>
<p>Like the <code>Move.toml</code> file, the <code>Move.lock</code> file is a text-based TOML file. Unlike the package
manifest however, the <code>Move.lock</code> file is not intended for you to edit directly. Processes on the
toolchain, like the Move compiler, access and edit the file to read and append relevant information
to it. You also must not move the file from the root, as it needs to be at the same level as the
<code>Move.toml</code> manifest in the package.</p>
<p>If you are using source control for your package, it's recommended practice to check in the
<code>Move.lock</code> file that corresponds with your desired built or published package. This ensures that
every build of your package is an exact replica of the original, and that changes to the build will
be apparent as changes to the <code>Move.lock</code> file.</p>
<p>The <code>Move.lock</code> file is a TOML file that currently contains the following fields.</p>
<p><strong>Note</strong>: other fields may be added to the lock file either in the future, or by third-party package
package managers as well.</p>
<h3 id="the-move-section"><a class="header" href="#the-move-section">The <code>[move]</code> Section</a></h3>
<p>This section contains the core information needed in the lockfile:</p>
<ul>
<li>The version of the lockfile (needed for backwards compatibility checking, and versioning lockfile
changes in the future).</li>
<li>The hash of the <code>Move.toml</code> file that was used to generate this lock file.</li>
<li>The hash of the <code>Move.lock</code> file of all dependencies. If no dependencies are present, this will be
an empty string.</li>
<li>The list of dependencies.</li>
</ul>
<pre><code class="language-ini">[move]
version = &lt;string&gt; # Lock file version, used for backwards compatibility checking.
manifest_digest = &lt;hash&gt; # Sha3-256 hash of the Move.toml file that was used to generate this lock file.
deps_digest = &lt;hash&gt; # Sha3-256 hash of the Move.lock file of all dependencies. If no dependencies are present, this will be an empty string.
dependencies = { (name = &lt;string&gt;)* } # List of dependencies. Not present if there are no dependencies.
</code></pre>
<h3 id="the-movepackage-sections"><a class="header" href="#the-movepackage-sections">The <code>[move.package]</code> Sections</a></h3>
<p>After the Move compiler resolves each of the dependencies for the package it writes the location of
the dependency to the <code>Move.lock</code> file. If a dependency failed to resolve, the compiler will not
write the <code>Move.lock</code> file and the build fails. If all dependencies resolve, the <code>Move.lock</code> file
contains the locations (local and remote) of all of the package's transitive dependencies. These
will be stored in the <code>Move.lock</code> file in the following format:</p>
<pre><code class="language-ini"># ...

[[move.package]]
name = &quot;A&quot;
source = { git = &quot;https://github.com/b/c.git&quot;, subdir = &quot;e/f&quot;, rev = &quot;a1b2c3&quot; }

[[move.package]]
name = &quot;B&quot;
source = { local = &quot;../local-dep&quot; }
</code></pre>
<h3 id="the-movetoolchain-version-section"><a class="header" href="#the-movetoolchain-version-section">The <code>[move.toolchain-version]</code> Section</a></h3>
<p>As mentioned above, additional fields may be added to the lock file by external tools. For example,
the Sui package manager adds toolchain version information to the lock file that can then be used
for on-chain source verification:</p>
<pre><code class="language-ini"># ...

[move.toolchain-version]
compiler-version = &lt;string&gt; # The version of the Move compiler used to build the package, e.g. &quot;1.21.0&quot;
edition = &lt;string&gt; # The edition of the Move language used to build the package, e.g. &quot;2024.alpha&quot;
flavor = &lt;string&gt; # The flavor of the Move compiler used to build the package, e.g. &quot;sui&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h1>
<p>Unit testing for Move uses three annotations in the Move source language:</p>
<ul>
<li><code>#[test]</code> marks a function as a test;</li>
<li><code>#[expected_failure]</code> marks that a test is expected to fail;</li>
<li><code>#[test_only]</code> marks a module or module member (<a href="./uses.html"><code>use</code></a>, <a href="./functions.html">function</a>,
<a href="./structs.html">struct</a>, or <a href="./constants.html">constant</a>) as code to be included for testing only.</li>
</ul>
<p>These annotations can be placed on any appropriate form with any visibility. Whenever a module or
module member is annotated as <code>#[test_only]</code> or <code>#[test]</code>, it will not be included in the compiled
bytecode unless it is compiled for testing.</p>
<h2 id="test-annotations"><a class="header" href="#test-annotations">Test Annotations</a></h2>
<p>The <code>#[test]</code> annotation can only be placed on a function with no parameters. This annotation marks
the function as a test to be run by the unit testing harness.</p>
<pre><code class="language-move">#[test] // OK
fun this_is_a_test() { ... }

#[test] // Will fail to compile since the test takes an argument
fun this_is_not_correct(arg: u64) { ... }
</code></pre>
<p>A test can also be annotated as an <code>#[expected_failure]</code>. This annotation marks that the test is
expected to raise an error. There are a number of options that can be used with the
<code>#[expected_failure]</code> annotation to ensure only a failure with the specified condition is marked as
passing, these options are detailed in <a href="unit-testing.html#expected-failures">Expected Failures</a>. Only functions that
have the <code>#[test]</code> annotation can also be annotated as an #<code>[expected_failure]</code>.</p>
<p>Some simple examples of using the <code>#[expected_failure]</code> annotation are shown below:</p>
<pre><code class="language-move">#[test]
#[expected_failure]
public fun this_test_will_abort_and_pass() { abort 1 }

#[test]
#[expected_failure]
public fun test_will_error_and_pass() { 1/0; }

#[test] // Will pass since test fails with the expected abort code constant.
#[expected_failure(abort_code = ENotFound)] // ENotFound is a constant defined in the module
public fun test_will_error_and_pass_abort_code() { abort ENotFound }

#[test] // Will fail since test fails with a different error than expected.
#[expected_failure(abort_code = my_module::ENotFound)]
public fun test_will_error_and_fail() { 1/0; }

#[test, expected_failure] // Can have multiple in one attribute. This test will pass.
public fun this_other_test_will_abort_and_pass() { abort 1 }
</code></pre>
<blockquote>
<p><strong>Note</strong>: <code>#[test]</code> and <code>#[test_only]</code> functions can also call
<a href="./functions.html#entry-modifier"><code>entry</code></a> functions, regardless of their visibility.</p>
</blockquote>
<h2 id="expected-failures"><a class="header" href="#expected-failures">Expected Failures</a></h2>
<p>There are a number of different ways that you can use the <code>#[expected_failure]</code> annotation to
specify different types of error conditions. These are:</p>
<h3 id="1-expected_failureabort_code--constant"><a class="header" href="#1-expected_failureabort_code--constant">1. <code>#[expected_failure(abort_code = &lt;constant&gt;)]</code></a></h3>
<p>This will pass if the test aborts with the specified constant value in the module that defines the
constant and fail otherwise. This is the recommended way of testing for expected test failures.</p>
<blockquote>
<p><strong>Note</strong>: You can reference constants outside of the current module or package in
<code>expected_failure</code> annotations.</p>
</blockquote>
<pre><code class="language-move">module pkg_addr::other_module {
    const ENotFound: u64 = 1;
    public fun will_abort() {
        abort ENotFound
    }
}

module pkg_addr::my_module {
    use pkg_addr::other_module;
    const ENotFound: u64 = 1;

    #[test]
    #[expected_failure(abort_code = ENotFound)]
    fun test_will_abort_and_pass() { abort ENotFound }

    #[test]
    #[expected_failure(abort_code = other_module::ENotFound)]
    fun test_will_abort_and_pass() { other_module::will_abort() }

    // FAIL: Will not pass since we are expecting the constant from the wrong module.
    #[test]
    #[expected_failure(abort_code = ENotFound)]
    fun test_will_abort_and_pass() { other_module::will_abort() }
}
</code></pre>
<h3 id="2-expected_failurearithmetic_error-location--location"><a class="header" href="#2-expected_failurearithmetic_error-location--location">2. <code>#[expected_failure(arithmetic_error, location = &lt;location&gt;)]</code></a></h3>
<p>This specifies that the test is expected to fail with an arithmetic error (e.g., integer overflow,
division by zero, etc) at the specified location. The <code>&lt;location&gt;</code> must be a valid path to a module
location, e.g., <code>Self</code>, or <code>my_package::my_module</code>.</p>
<pre><code class="language-move">module pkg_addr::other_module {
    public fun will_arith_error() { 1/0; }
}

module pkg_addr::my_module {
    use pkg_addr::other_module;
    #[test]
    #[expected_failure(arithmetic_error, location = Self)]
    fun test_will_arith_error_and_pass1() { 1/0; }

    #[test]
    #[expected_failure(arithmetic_error, location = pkg_addr::other_module)]
    fun test_will_arith_error_and_pass2() { other_module::will_arith_error() }

    // FAIL: Will fail since the location we expect it the fail at is different from where the test actually failed.
    #[test]
    #[expected_failure(arithmetic_error, location = Self)]
    fun test_will_arith_error_and_fail() { other_module::will_arith_error() }
}
</code></pre>
<h3 id="3-expected_failureout_of_gas-location--location"><a class="header" href="#3-expected_failureout_of_gas-location--location">3. <code>#[expected_failure(out_of_gas, location = &lt;location&gt;)]</code></a></h3>
<p>This specifies that the test is expected to fail with an out of gas error at the specified location.
The <code>&lt;location&gt;</code> must be a valid path to a module location, e.g., <code>Self</code>, or
<code>my_package::my_module</code>.</p>
<pre><code class="language-move">module pkg_addr::other_module {
    public fun will_oog() { loop {} }
}

module pkg_addr::my_module {
    use pkg_addr::other_module;
    #[test]
    #[expected_failure(out_of_gas, location = Self)]
    fun test_will_oog_and_pass1() { loop {} }

    #[test]
    #[expected_failure(arithmetic_error, location = pkg_addr::other_module)]
    fun test_will_oog_and_pass2() { other_module::will_oog() }

    // FAIL: Will fail since the location we expect it the fail at is different from where
    // the test actually failed.
    #[test]
    #[expected_failure(out_of_gas, location = Self)]
    fun test_will_oog_and_fail() { other_module::will_oog() }
}
</code></pre>
<h3 id="4-expected_failurevector_error-minor_status--u64_opt-location--location"><a class="header" href="#4-expected_failurevector_error-minor_status--u64_opt-location--location">4. <code>#[expected_failure(vector_error, minor_status = &lt;u64_opt&gt;, location = &lt;location&gt;)]</code></a></h3>
<p>This specifies that the test is expected to fail with a vector error at the specified location with
the given <code>minor_status</code> (if provided). The <code>&lt;location&gt;</code> must be a valid path to a module module
location, e.g., <code>Self</code>, or <code>my_package::my_module</code>. The <code>&lt;u64_opt&gt;</code> is an optional parameter that
specifies the minor status of the vector error. If it is not specified, the test will pass if the
test fails with any minor status. If it is specified, the test will only pass if the test fails with
a vector error with the specified minor status.</p>
<pre><code class="language-move">module pkg_addr::other_module {
    public fun vector_borrow_empty() {
        &amp;vector&lt;u64&gt;[][1];
    }
}

module pkg_addr::my_module {
    #[test]
    #[expected_failure(vector_error, location = Self)]
    fun vector_abort_same_module() {
        vector::borrow(&amp;vector&lt;u64&gt;[], 1);
    }

    #[test]
    #[expected_failure(vector_error, location = pkg_addr::other_module)]
    fun vector_abort_same_module() {
        other_module::vector_borrow_empty();
    }

    // Can specify minor statues (i.e., vector-specific error codes) to expect.
    #[test]
    #[expected_failure(vector_error, minor_status = 1, location = Self)]
    fun native_abort_good_right_code() {
        vector::borrow(&amp;vector&lt;u64&gt;[], 1);
    }

    // FAIL: correct error, but wrong location.
    #[test]
    #[expected_failure(vector_error, location = pkg_addr::other_module)]
    fun vector_abort_same_module() {
        other_module::vector_borrow_empty();
    }

    // FAIL: correct error and location but the minor status differs so this test will fail.
    #[test]
    #[expected_failure(vector_error, minor_status = 0, location = Self)]
    fun vector_abort_wrong_minor_code() {
        vector::borrow(&amp;vector&lt;u64&gt;[], 1);
    }
}
</code></pre>
<h3 id="5-expected_failure"><a class="header" href="#5-expected_failure">5. <code>#[expected_failure]</code></a></h3>
<p>This will pass if the test aborts with <em>any</em> error code. You should be <strong><em>incredibly careful</em></strong>
using this to annotate expected tests failures, and always prefer one of the ways described above
instead. Examples of these types of annotations are:</p>
<pre><code class="language-move">#[test]
#[expected_failure]
fun test_will_abort_and_pass1() { abort 1 }

#[test]
#[expected_failure]
fun test_will_arith_error_and_pass2() { 1/0; }
</code></pre>
<h2 id="test-only-annotations"><a class="header" href="#test-only-annotations">Test Only Annotations</a></h2>
<p>A module and any of its members can be declared as test only. If an item is annotated as
<code>#[test_only]</code> the item will only be included in the compiled Move bytecode when compiled in test
mode. Additionally, when compiled outside of test mode, any non-test <code>use</code>s of a <code>#[test_only]</code>
module will raise an error during compilation.</p>
<blockquote>
<p><strong>Note</strong>: functions that are annotated with <code>#[test_only]</code> will only be available to be called
from test code, but they themselves are not tests and will not be run as tests by the unit testing
framework.</p>
</blockquote>
<pre><code class="language-move">#[test_only] // test only attributes can be attached to modules
module abc { ... }

#[test_only] // test only attributes can be attached to constants
const MY_ADDR: address = @0x1;

#[test_only] // .. to uses
use pkg_addr::some_other_module;

#[test_only] // .. to structs
public struct SomeStruct { ... }

#[test_only] // .. and functions. Can only be called from test code, but this is _not_ a test!
fun test_only_function(...) { ... }
</code></pre>
<h2 id="running-unit-tests"><a class="header" href="#running-unit-tests">Running Unit Tests</a></h2>
<p>Unit tests for a Move package can be run with the <a href="./packages.html"><code>sui move test</code> command</a>.</p>
<p>When running tests, every test will either <code>PASS</code>, <code>FAIL</code>, or <code>TIMEOUT</code>. If a test case fails, the
location of the failure along with the function name that caused the failure will be reported if
possible. You can see an example of this below.</p>
<p>A test will be marked as timing out if it exceeds the maximum number of instructions that can be
executed for any single test. This bound can be changed using the options below. Additionally, while
the result of a test is always deterministic, tests are run in parallel by default, so the ordering
of test results in a test run is non-deterministic unless running with only one thread, which can be
configured via an option.</p>
<p>These aforementioned options are two among many that can fine-tune testing and help debug failing
tests. To see all available options, and a description of what each one does, pass the <code>--help</code> flag
to the <code>sui move test</code> command:</p>
<pre><code>$ sui move test --help
</code></pre>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>A simple module using some of the unit testing features is shown in the following example:</p>
<p>First create an empty package and change directory into it:</p>
<pre><code class="language-bash">$ sui move new test_example; cd test_example
</code></pre>
<p>Next add the following module under the <code>sources</code> directory:</p>
<pre><code class="language-move">// filename: sources/my_module.move
module test_example::my_module {

    public struct Wrapper(u64)

    const ECoinIsZero: u64 = 0;

    public fun make_sure_non_zero_coin(coin: Wrapper): Wrapper {
        assert!(coin.0 &gt; 0, ECoinIsZero);
        coin
    }

    #[test]
    fun make_sure_non_zero_coin_passes() {
        let coin = Wrapper(1);
        let Wrapper(_) = make_sure_non_zero_coin(coin);
    }

    #[test]
    // Or #[expected_failure] if we don't care about the abort code
    #[expected_failure(abort_code = ECoinIsZero)]
    fun make_sure_zero_coin_fails() {
        let coin = Wrapper(0);
        let Wrapper(_) = make_sure_non_zero_coin(coin);
    }

    #[test_only] // test only helper function
    fun make_coin_zero(coin: &amp;mut Wrapper) {
        coin.0 = 0;
    }

    #[test]
    #[expected_failure(abort_code = ECoinIsZero)]
    fun make_sure_zero_coin_fails2() {
        let mut coin = Wrapper(10);
        coin.make_coin_zero();
        let Wrapper(_) = make_sure_non_zero_coin(coin);
    }
}
</code></pre>
<h3 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h3>
<p>You can then run these tests with the <code>move test</code> command:</p>
<pre><code class="language-bash">$ sui move test
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING test_example
Running Move unit tests
[ PASS    ] 0x0::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x0::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x0::my_module::make_sure_zero_coin_fails2
Test result: OK. Total tests: 3; passed: 3; failed: 0
</code></pre>
<h3 id="using-test-flags"><a class="header" href="#using-test-flags">Using Test Flags</a></h3>
<h4 id="passing-specific-tests-to-run"><a class="header" href="#passing-specific-tests-to-run">Passing specific tests to run</a></h4>
<p>You can run a specific test, or a set of tests with <code>sui move test &lt;str&gt;</code>. This will only run tests
whose fully qualified name contains <code>&lt;str&gt;</code>. For example if we wanted to only run tests with
<code>&quot;non_zero&quot;</code> in their name:</p>
<pre><code class="language-bash">$ sui move test non_zero
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING test_example
Running Move unit tests
[ PASS    ] 0x0::my_module::make_sure_non_zero_coin_passes
Test result: OK. Total tests: 1; passed: 1; failed: 0
</code></pre>
<h4 id="-i-bound-or---gas_used-bound"><a class="header" href="#-i-bound-or---gas_used-bound"><code>-i &lt;bound&gt;</code> or <code>--gas_used &lt;bound&gt;</code></a></h4>
<p>This bounds the amount of gas that can be consumed for any one test to <code>&lt;bound&gt;</code>:</p>
<pre><code class="language-bash">$ sui move test -i 0
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING test_example
Running Move unit tests
[ TIMEOUT ] 0x0::my_module::make_sure_non_zero_coin_passes
[ FAIL    ] 0x0::my_module::make_sure_zero_coin_fails
[ FAIL    ] 0x0::my_module::make_sure_zero_coin_fails2

Test failures:

Failures in 0x0::my_module:

 make_sure_non_zero_coin_passes 
 Test timed out



 make_sure_zero_coin_fails 
 error[E11001]: test failure
     ./sources/my_module.move:22:27
    
 21      fun make_sure_zero_coin_fails() {
             ------------------------- In this function in 0x0::my_module
 22          let coin = MyCoin(0);
                               ^ Test did not error as expected. Expected test to abort with code 0 &lt;SNIP&gt;





 make_sure_zero_coin_fails2 
 error[E11001]: test failure
     ./sources/my_module.move:34:31
    
 33      fun make_sure_zero_coin_fails2() {
             -------------------------- In this function in 0x0::my_module
 34          let mut coin = MyCoin(10);
                                   ^^ Test did not error as expected. Expected test to abort with code 0 &lt;SNIP&gt;




Test result: FAILED. Total tests: 3; passed: 0; failed: 3
</code></pre>
<h4 id="-s-or---statistics"><a class="header" href="#-s-or---statistics"><code>-s</code> or <code>--statistics</code></a></h4>
<p>With these flags you can gather statistics about the tests run and report the runtime and gas used
for each test. You can additionally add <code>csv</code> (<code>sui move test -s csv</code>) to get the gas usage in a csv
output format. For example, if we wanted to see the statistics for the tests in the example above:</p>
<pre><code class="language-bash">$ sui move test -s
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING test_example
Running Move unit tests
[ PASS    ] 0x0::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x0::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x0::my_module::make_sure_zero_coin_fails2

Test Statistics:


                   Test Name                        Time             Gas Used          

 0x0::my_module::make_sure_non_zero_coin_passes    0.001                 1             

 0x0::my_module::make_sure_zero_coin_fails         0.001                 1             

 0x0::my_module::make_sure_zero_coin_fails2        0.001                 1             


Test result: OK. Total tests: 3; passed: 3; failed: 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>See <a href="https://docs.sui.io/concepts/sui-move-concepts/conventions">Sui's Coding Conventions for Move</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deprecated-friends"><a class="header" href="#deprecated-friends">DEPRECATED: Friends</a></h1>
<p>NOTE: this feature has been superseded by <a href="./functions.html#visibility"><code>public(package)</code></a>.</p>
<p>The <code>friend</code> syntax was used to declare modules that are trusted by the current module. A trusted
module is allowed to call any function defined in the current module that have the <code>public(friend)</code>
visibility. For details on function visibilities, refer to the <em>Visibility</em> section in
<a href="./functions.html">Functions</a>.</p>
<h2 id="friend-declaration"><a class="header" href="#friend-declaration">Friend declaration</a></h2>
<p>A module can declare other modules as friends via friend declaration statements, in the format of</p>
<ul>
<li>
<p><code>friend &lt;address::name&gt;</code>  friend declaration using fully qualified module name like the example
below, or</p>
<pre><code class="language-move">module 0x42::a {
    friend 0x42::b;
}
</code></pre>
</li>
<li>
<p><code>friend &lt;module-name-alias&gt;</code>  friend declaration using a module name alias, where the module
alias is introduced via the <code>use</code> statement.</p>
<pre><code class="language-move">module 0x42::a {
    use 0x42::b;
    friend b;
}
</code></pre>
</li>
</ul>
<p>A module may have multiple friend declarations, and the union of all the friend modules forms the
friend list. In the example below, both <code>0x42::B</code> and <code>0x42::C</code> are considered as friends of
<code>0x42::A</code>.</p>
<pre><code class="language-move">module 0x42::a {

    friend 0x42::b;
    friend 0x42::c;
}
</code></pre>
<p>Unlike <code>use</code> statements, <code>friend</code> can only be declared in the module scope and not in the expression
block scope. <code>friend</code> declarations may be located anywhere a top-level construct (e.g., <code>use</code>,
<code>function</code>, <code>struct</code>, etc.) is allowed. However, for readability, it is advised to place friend
declarations near the beginning of the module definition.</p>
<h3 id="friend-declaration-rules"><a class="header" href="#friend-declaration-rules">Friend declaration rules</a></h3>
<p>Friend declarations are subject to the following rules:</p>
<ul>
<li>
<p>A module cannot declare itself as a friend.</p>
<pre><code class="language-move">module 0x42::m { friend Self; // ERROR! }
//                      ^^^^ Cannot declare the module itself as a friend

module 0x43::m { friend 0x43::M; // ERROR! }
//                      ^^^^^^^ Cannot declare the module itself as a friend
</code></pre>
</li>
<li>
<p>Friend modules must be known by the compiler</p>
<pre><code class="language-move">module 0x42::m { friend 0x42::nonexistent; // ERROR! }
//                      ^^^^^^^^^^^^^^^^^ Unbound module '0x42::nonexistent'
</code></pre>
</li>
<li>
<p>Friend modules must be within the same account address.</p>
<pre><code class="language-move">module 0x42::m {}

module 0x42::n { friend 0x42::m; // ERROR! }
//                      ^^^^^^^ Cannot declare modules out of the current address as a friend
</code></pre>
</li>
<li>
<p>Friends relationships cannot create cyclic module dependencies.</p>
<p>Cycles are not allowed in the friend relationships, e.g., the relation <code>0x2::a</code> friends <code>0x2::b</code>
friends <code>0x2::c</code> friends <code>0x2::a</code> is not allowed. More generally, declaring a friend module adds a
dependency upon the current module to the friend module (because the purpose is for the friend to
call functions in the current module). If that friend module is already used, either directly or
transitively, a cycle of dependencies would be created.</p>
<pre><code class="language-move">module 0x2::a {
    use 0x2::c;
    friend 0x2::b;

    public fun a() {
        c::c()
    }
}

module 0x2::b {
    friend 0x2::c; // ERROR!
//         ^^^^^^ This friend relationship creates a dependency cycle: '0x2::b' is a friend of '0x2::a' uses '0x2::c' is a friend of '0x2::b'
}

module 0x2::c {
    public fun c() {}
}
</code></pre>
</li>
<li>
<p>The friend list for a module cannot contain duplicates.</p>
<pre><code class="language-move">module 0x42::a {}

module 0x42::m {
    use 0x42::a as aliased_a;
    friend 0x42::A;
    friend aliased_a; // ERROR!
//         ^^^^^^^^^ Duplicate friend declaration '0x42::a'. Friend declarations in a module must be unique
}
</code></pre>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/switcher.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
