<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Move Book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="First book about Diem's Move programming language and Move VM. Move documentation, Move tutorials and language reference">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> The Move Language</a></li><li class="chapter-item expanded "><a href="introduction/foreword.html"><strong aria-hidden="true">2.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="introduction/getting-started.html"><strong aria-hidden="true">3.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="syntax-basics/index.html"><strong aria-hidden="true">4.</strong> Syntax Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax-basics/concept.html"><strong aria-hidden="true">4.1.</strong> Concept</a></li><li class="chapter-item expanded "><a href="syntax-basics/primitives.html"><strong aria-hidden="true">4.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="syntax-basics/comments.html"><strong aria-hidden="true">4.3.</strong> Comments</a></li><li class="chapter-item expanded "><a href="syntax-basics/expression-and-scope.html"><strong aria-hidden="true">4.4.</strong> Expression and Scope</a></li><li class="chapter-item expanded "><a href="syntax-basics/control-flow.html"><strong aria-hidden="true">4.5.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="syntax-basics/module.html"><strong aria-hidden="true">4.6.</strong> Module and Import</a></li><li class="chapter-item expanded "><a href="syntax-basics/constants.html"><strong aria-hidden="true">4.7.</strong> Constants</a></li><li class="chapter-item expanded "><a href="syntax-basics/function.html"><strong aria-hidden="true">4.8.</strong> Function</a></li></ol></li><li class="chapter-item expanded "><a href="advanced-topics/index.html"><strong aria-hidden="true">5.</strong> Advanced Topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced-topics/struct.html"><strong aria-hidden="true">5.1.</strong> Structures</a></li><li class="chapter-item expanded "><a href="advanced-topics/types-with-abilities.html"><strong aria-hidden="true">5.2.</strong> Types with Abilities</a></li><li class="chapter-item expanded "><a href="advanced-topics/ownership-and-references.html"><strong aria-hidden="true">5.3.</strong> Ownership and References</a></li><li class="chapter-item expanded "><a href="advanced-topics/understanding-generics.html"><strong aria-hidden="true">5.4.</strong> Understanding Generics</a></li><li class="chapter-item expanded "><a href="advanced-topics/managing-collections-with-vectors.html"><strong aria-hidden="true">5.5.</strong> Managing collections with Vectors</a></li></ol></li><li class="chapter-item expanded "><a href="resources/index.html"><strong aria-hidden="true">6.</strong> Programmable Resources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="resources/signer-type.html"><strong aria-hidden="true">6.1.</strong> Sender as Signer</a></li><li class="chapter-item expanded "><a href="resources/what-is-resource.html"><strong aria-hidden="true">6.2.</strong> What is Resource</a></li><li class="chapter-item expanded "><a href="resources/resource-by-example/index.html"><strong aria-hidden="true">6.3.</strong> Resource by Example</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="resources/resource-by-example/storing-new-resource.html"><strong aria-hidden="true">6.3.1.</strong> Create and Move</a></li><li class="chapter-item expanded "><a href="resources/resource-by-example/access-resource-with-borrow.html"><strong aria-hidden="true">6.3.2.</strong> Read and Modify</a></li><li class="chapter-item expanded "><a href="resources/resource-by-example/destroy-resource.html"><strong aria-hidden="true">6.3.3.</strong> Take and Destroy</a></li><li class="chapter-item expanded "><a href="resources/resource-by-example/furher-steps.html"><strong aria-hidden="true">6.3.4.</strong> Further Steps</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="tutorials/index.html"><strong aria-hidden="true">7.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/erc20.html"><strong aria-hidden="true">7.1.</strong> Writing ERC20 Token</a></li></ol></li><li class="chapter-item expanded "><a href="translations.html"><strong aria-hidden="true">8.</strong> Translations</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Move Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/damirka/move-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#the-move-programming-language" id="the-move-programming-language">The Move Programming Language</a></h1>
<p>Move is a safe and reliable language originally created by <a href="https://diem.com/">Diem</a>. You can read language white paper on <a href="https://diem-developers-components.netlify.app/papers/diem-move-a-language-with-programmable-resources/2020-05-26.pdf">Diem developers website</a>.</p>
<p>This book is a collection of all the information which I found and shaped into a single source of knowledge about Move language.</p>
<h1><a class="header" href="#foreword" id="foreword">Foreword</a></h1>
<p>When I wrote this book, there was no documentation (or other reference) on Move language and the goal I pursued was to give people a chance to see hidden gem of crypto world - the Move language. Currently, <a href="https://diem.github.io/move/introduction.html">there is a Move documentation</a> written by language developers. Yet I still think that flow given in this book is more intuitive and more friendly for a newcomer, I once was a newcomer too and Move is one tricky and interesting language some concepts of which might be mind-blowing.</p>
<p>I deeply love this language and hope you'll see why!</p>
<p>- Damir Shamanaev</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting started</a></h1>
<blockquote>
<p><strong>Warning:</strong> Content on this page is outdated and requires rework. Newer version of Move IDE will be published soon. For now I recommend you to use <a href="https://github.com/diem/move/tree/main/language/tools/move-cli">move-cli</a>.</p>
</blockquote>
<hr />
<p>As with any compiled language, you need a proper set of tools to compile, run and debug your Move applications. Since this language is created for blockchains and used only within them, running scripts off-chain is a non-trivial task: every module will require an environment, account handling and compile-publishing system.</p>
<p>To simpify development of Move modules I've created <a href="https://github.com/damirka/vscode-move-ide">Move IDE</a> extension for Visual Studio Code. This extension will help you cope with environment requirements. Use of this extension is highly recommended as it will handle the build/run environment for you, hence will let you focus on learning Move language instead of struggling with the CLI. This extension also includes Move syntax highlighting and executor to help debug your applications before going public.</p>
<h2><a class="header" href="#install-move-ide" id="install-move-ide">Install Move IDE</a></h2>
<p>To install it you'll need:</p>
<ol>
<li>VSCode (version 1.43.0 and above) - you can <a href="https://code.visualstudio.com/download">get it here</a>; if you already have one - proceed to the next step;</li>
<li>Move IDE - once VSCode is installed, follow <a href="https://marketplace.visualstudio.com/items?itemName=damirka.move-ide">this link</a> to install the newest version of IDE.</li>
</ol>
<h3><a class="header" href="#setup-environment" id="setup-environment">Setup environment</a></h3>
<p>Move IDE proposes a single way of organizing your directory structure. Create a new directory for your project and open it in VSCode. Then setup this directory structure:</p>
<pre><code>modules/   - directory for our modules
scripts/   - directory for transaction scripts
out/       - this directory will hold compiled sources
</code></pre>
<p>Also you'll need to create a file called <code>.mvconfig.json</code> which will configure your working environment. This is a sample for <code>libra</code>:</p>
<pre><code class="language-json">{
    &quot;network&quot;: &quot;libra&quot;,
    &quot;sender&quot;: &quot;0x1&quot;
}
</code></pre>
<p>Alternatively you can use <code>dfinance</code> as network:</p>
<pre><code class="language-json">{
    &quot;network&quot;: &quot;dfinance&quot;,
    &quot;sender&quot;: &quot;0x1&quot;
}
</code></pre>
<blockquote>
<p>dfinance uses bech32 'wallet1...' addresses, libra uses 16-byte '0x...' addresses. For local runs and experiments 0x1 address is enough - it's simple and short. Though when working with real blockchains in testnet or production environment you'll have to use correct address of the network you've chosen.</p>
</blockquote>
<h2><a class="header" href="#your-very-first-application-with-move" id="your-very-first-application-with-move">Your very first application with Move</a></h2>
<p>Move IDE allows you to run scripts in a testing environment. Let's see how it works by implementing <code>gimme_five()</code> function and running it inside VSCode.</p>
<h3><a class="header" href="#create-module" id="create-module">Create module</a></h3>
<p>Create new file called <code>hello_world.move</code> inside <code>modules/</code> directory of your project.</p>
<pre><code class="language-Move">// modules/hello_world.move
address 0x1 {
module HelloWorld {
    public fun gimme_five(): u8 {
        5
    }
}
}
</code></pre>
<blockquote>
<p>If you decided to use your own address (not <code>0x1</code>) - make sure you've changed 0x1 in this file and the one below</p>
</blockquote>
<h3><a class="header" href="#write-script" id="write-script">Write script</a></h3>
<p>Then create a script, let's call it <code>me.move</code> inside <code>scripts/</code> directory:</p>
<pre><code class="language-Move">// scripts/run_hello.move
script {
    use 0x1::HelloWorld;
    use 0x1::Debug;

    fun main() {
        let five = HelloWorld::gimme_five();

        Debug::print&lt;u8&gt;(&amp;five);
    }
}
</code></pre>
<p>Then, while keeping your script open follow these steps:</p>
<ol>
<li>Toggle VSCode's command palette by pressing <code>⌘+Shift+P</code> (on Mac) or <code>Ctrl+Shift+P</code> (on Linux/Windows)</li>
<li>Type: <code>&gt;Move: Run Script</code> and press enter or click when you see the right option.</li>
</ol>
<p>Voila! You should see the execution result - log message with '5' printed in debug. If you don't see this window, go through this part again.</p>
<p>Your directory structure should look like this:</p>
<pre><code>modules/
  hello_world.move
scripts/
  run_hello.move
out/
.mvconfig.json
</code></pre>
<blockquote>
<p>You can have as many modules as you want in your modules directory; all of them will be accessible in your scripts under address which you've specified in .mvconfig.json</p>
</blockquote>
<h1><a class="header" href="#syntax-basics" id="syntax-basics">Syntax Basics</a></h1>
<p>In this chapter you'll get to know Move language. We'll start with very simple and basic grammar rules and intensity will increase from one chapter to another. If you're a skilled developer this may seem too easy at first glance, but I do recommend you to take a closer look. If you're a beginner, then this part will give you everything you need to know about Move basics.</p>
<h1><a class="header" href="#concept" id="concept">Concept</a></h1>
<p>Unlike other blockchain languages (e.g. Solidity) Move proposes separation of <em>scripts</em> (or <em>transaction-as-script</em>) and <em>modules</em>. The former allows you to put more logic into your transactions and make them more flexible while saving your time and resources; and the latter allows developers to extend blockchain functionality or to implement custom <em>smart-contracts</em> with a variety of options.</p>
<p>In basics we'll start with scripts as they're pretty friendly for a newcomer, and then we'll get to modules.</p>
<h1><a class="header" href="#primitive-types" id="primitive-types">Primitive Types</a></h1>
<p>Move has few built-in primitive types to represent numbers, addresses and boolean values: integers (u8, u64, u128), <code>boolean</code> and <code>address</code>.</p>
<p>Move does not have string type or floating point numbers.</p>
<h2><a class="header" href="#integer-types" id="integer-types">Integer types</a></h2>
<p>Integers are represented by <code>u8</code>, <code>u64</code> and <code>u128</code>; Possible integer notations are:</p>
<pre><code class="language-Move">script {
    fun main() {
        // define empty variable, set value later
        let a: u8;
        a = 10;

        // define variable, set type
        let a: u64 = 10;

        // finally simple assignment
        let a = 10;

        // simple assignment with defined value type
        let a = 10u128;

        // in function calls or expressions you can use ints as constant values
        if (a &lt; 10) {};

        // or like this, with type
        if (a &lt; 10u8) {}; // usually you don't need to specify type
    }
}
</code></pre>
<h3><a class="header" href="#operator-as" id="operator-as">Operator <code>as</code></a></h3>
<p>When you need to compare values or when function argument requires integer of different size you can cast your integer variable to another size by using operator <code>as</code>:</p>
<pre><code class="language-Move">script {
    fun main() {
        let a: u8 = 10;
        let b: u64 = 100;

        // we can only compare same size integers
        if (a == (b as u8)) abort 11;
        if ((a as u64) == b) abort 11;
    }
}
</code></pre>
<h2><a class="header" href="#boolean" id="boolean">Boolean</a></h2>
<p>Boolean type is just the one you're used to. Two constant values: <code>false</code> and <code>true</code> - both can only mean one thing - a value of <code>bool</code> type.</p>
<pre><code class="language-Move">script {
    fun main() {
        // these are all the ways to do it
        let b : bool; b = true;
        let b : bool = true;
        let b = true;
        let b = false; // here's an example with false
    }
}
</code></pre>
<h2><a class="header" href="#address" id="address">Address</a></h2>
<p>Address is an identifier of sender (or wallet) in blockchain. The very basic operations which require address type are sending coins and importing modules.</p>
<pre><code class="language-Move">script {
    fun main() {
        let addr: address; // type identifier

        // in this book I'll use {{sender}} notation;
        // always replace `{{sender}}` in examples with VM specific address!!!
        addr = {{sender}};

        // in Diem's Move VM and Starcoin - 16-byte address in HEX
        addr = 0x...;

        // in dfinance's DVM - bech32 encoded address with `wallet1` prefix
        addr = wallet1....;
    }
}
</code></pre>
<h1><a class="header" href="#comments" id="comments">Comments</a></h1>
<p>If you feel like some places in your code require additional explanation, use <em>comments</em>. Comments are non-executable blocks or lines of text aimed to describe some pieces of the code.</p>
<h3><a class="header" href="#line-comments" id="line-comments">Line comments</a></h3>
<pre><code class="language-Move">script {
    fun main() {
        // this is a comment line
    }
}
</code></pre>
<p>You can use double-slash &quot;<em>//</em>&quot; to write line comments. Rules are simple - <strong>everything after</strong> &quot;<em>//</em>&quot; is considered a comment to the end of line. You can use line comments to leave short notes for other developers or to <em>comment out</em> some code to remove it from the execution chain.</p>
<pre><code class="language-Move">script {
    // let's add a note to everything!
    fun main() {
        let a = 10;
        // let b = 10 this line is commented and won't be executed
        let b = 5; // here comment is placed after code
        a + b // result is 15, not 10!
    }
}
</code></pre>
<h3><a class="header" href="#block-comments" id="block-comments">Block comments</a></h3>
<p>If you don't want to comment all the line contents, or if you want to comment out more than one line you can use block comments.</p>
<p>Block comment starts with slash-asterisk <em>/*</em> and includes all the text before first asterisk-slash <em>*/</em>. Block comment is not limited by one line and gives you power of making a note in absolutely any place in code.</p>
<pre><code class="language-Move">script {
    fun /* you can comment everywhere */ main() {
        /* here
           there
           everywhere */ let a = 10;
        let b = /* even here */ 10; /* and again */
        a + b
    }
    /* you can use it to remove certain expressions or definitions
    fun empty_commented_out() {

    }
    */
}
</code></pre>
<p>Of course this example is ridiculous! But it clearly shows the power of block comment. Feel free to comment anywhere!</p>
<!-- ### Documentation comments -->
<h1><a class="header" href="#expression-and-scope" id="expression-and-scope">Expression and Scope</a></h1>
<p>In programming languages expression is a unit of code which returns a value. A function call with return value is an expression - it returns value; an integer (or bool or address) literal is also an expression - it has the value of its integer type and so on.</p>
<blockquote>
<p>Expressions must be sequenced (separated) by a semicolon*</p>
</blockquote>
<p><em>* When you put a semicolon, 'internally' it's treated as <code>; (empty_expression)</code>. If you put any expression after semi, it will replace the empty one.</em></p>
<h3><a class="header" href="#empty-expression" id="empty-expression">Empty expression</a></h3>
<p>You probably will never use it directly but empty expression in Move (in this way it's similar to Rust) is marked with empty parentheses:</p>
<pre><code class="language-Move">script {
    fun empty() {
        () // this is an empty expression
    }
}
</code></pre>
<p>Empty expression can be omitted as it's automatically put by VM.</p>
<h3><a class="header" href="#literal-expressions" id="literal-expressions">Literal expressions</a></h3>
<p>Look at the code below. Every line contains an expression which ends with a semicolon. Last line has three expressions separated by semicolons.</p>
<pre><code class="language-Move">script {
    fun main() {
        10;
        10 + 5;
        true;
        true != false;
        0x1;
        1; 2; 3
    }
}
</code></pre>
<p>Good. You now know the simplest expressions there are. But why do we need them? And how to use it? It's time to know the <code>let</code> keyword.</p>
<h3><a class="header" href="#variables-and-let-keyword" id="variables-and-let-keyword">Variables and <code>let</code> keyword</a></h3>
<p>To store expression value inside a variable (to pass it somewhere) you have a keyword <code>let</code> (you've already seen it in <a href="syntax-basics//syntax-basics/primitives.html">primitives chapter</a>). It creates a new variable either empty (undefined) or with value of expression.</p>
<pre><code class="language-Move">script {
    fun main() {
        let a;
        let b = true;
        let c = 10;
        let d = 0x1;
        a = c;
    }
}
</code></pre>
<blockquote>
<p>Keyword <code>let</code> creates new variable inside <em>current scope</em> and optionally <em>initializes</em> this variable with value. Syntax for this expression is: <code>let &lt;VARIABLE&gt; : &lt;TYPE&gt;;</code> or <code>let &lt;VARIABLE&gt; = &lt;EXPRESSION&gt;</code>.</p>
</blockquote>
<p>After you've created and initialized variable you're able to <em>modify</em> or <em>access</em> its value by using a variable name. In example above variable <code>a</code> was initialized in the end of function and was <em>assigned</em> a value of variable <code>c</code>.</p>
<blockquote>
<p>Equality sign <code>=</code> is an assignment operator. It assigns right-hand-side expression to the left-hand-side variable. Example: <code>a = 10</code> - variable <code>a</code> is assigned an integer value of <code>10</code>.</p>
</blockquote>
<h3><a class="header" href="#operators-for-integer-types" id="operators-for-integer-types">Operators for integer types</a></h3>
<p>Move has a variety of operators to modify integer values. Here's a list:</p>
<table><thead><tr><th>Operator</th><th>Op</th><th>Types</th><th></th></tr></thead><tbody>
<tr><td>+</td><td>sum</td><td>uint</td><td>Sum LHS and RHS</td></tr>
<tr><td>-</td><td>sub</td><td>uint</td><td>Subtract RHS from LHS</td></tr>
<tr><td>/</td><td>div</td><td>uint</td><td>Divide LHS by RHS</td></tr>
<tr><td>*</td><td>mul</td><td>uint</td><td>Multiply LHS times RHS</td></tr>
<tr><td>%</td><td>mod</td><td>uint</td><td>Division remainder (LHS by RHS)</td></tr>
<tr><td>&lt;&lt;</td><td>lshift</td><td>uint</td><td>Left bit shift LHS by RHS</td></tr>
<tr><td>&gt;&gt;</td><td>rshift</td><td>uint</td><td>Right bit shift LHS by RHS</td></tr>
<tr><td>&amp;</td><td>and</td><td>uint</td><td>Bitwise AND</td></tr>
<tr><td>^</td><td>xor</td><td>uint</td><td>Bitwise XOR</td></tr>
<tr><td>|</td><td>or</td><td>uint</td><td>Bitwise OR</td></tr>
</tbody></table>
<p><em>LHS - left-hand-side expression, RHS - right-hand-side expression; uint: u8, u64, u128.</em></p>
<!--

### Comparison and boolean operators

To build a bool condition by comparing values you have these operators. All of them return `bool` value and require LHS and RHS types match.

| Operator | Op     | Types |                                |
|----------|--------|-------|--------------------------------|
| ==       | equal  | any   | Check if LHS equals RHS        |
|----------|--------|-------|--------------------------------|
| =<       | equal  | any   | Check if LHS equals RHS        |
|----------|--------|-------|--------------------------------|

-->
<h3><a class="header" href="#underscore-_-to-mark-unused" id="underscore-_-to-mark-unused">Underscore &quot;_&quot; to mark unused</a></h3>
<p>In Move every variable must be used (otherwise your code won't compile), hence you can't initialize one and leave it untouched. Though you have one way to mark variable as <em>intentionally unused</em> - by using underscore <code>_</code>.</p>
<p>You'll get an error if you try to compile this script:</p>
<pre><code class="language-Move">script {
    fun main() {
        let a = 1;
    }
}
</code></pre>
<p>The error:</p>
<pre><code>
    ┌── /scripts/script.move:3:13 ───
    │
 33 │         let a = 1;
    │             ^ Unused assignment or binding for local 'a'. Consider removing or replacing it with '_'
    │
</code></pre>
<p>Compiler message is pretty clear, so all you have to do in this case is put underscore instead:</p>
<pre><code class="language-Move">script {
    fun main() {
        let _ = 1;
    }
}
</code></pre>
<h3><a class="header" href="#shadowing" id="shadowing">Shadowing</a></h3>
<p>Move allows you to define the same variable twice with one limitation - it still needs to be used. In the example above only second <code>a</code> is used. The first one: <code>let a = 1</code> is actually unused as on the next line we <em>redefine</em> <code>a</code> while leaving the first one unused.</p>
<pre><code class="language-Move">script {
    fun main() {
        let a = 1;
        let a = 2;
        let _ = a;
    }
}
</code></pre>
<p>Though we still can make it work by using first one:</p>
<pre><code class="language-Move">script {
    fun main() {
        let a = 1;
        let a = a + 2; // though let here is unnecessary
        let _ = a;
    }
}
</code></pre>
<h2><a class="header" href="#block-expression" id="block-expression">Block expression</a></h2>
<p>A block is an expression; it's marked with <em>curly braces</em> - <code>{}</code>. Block can contain other expressions (and other blocks). Function body (as you can see by already familiar curly-braces) is also a block in some sense (with few limitations).</p>
<pre><code class="language-Move">script {
    fun block() {
        { };
        { { }; };
        true;
        {
            true;

            { 10; };
        };
        { { { 10; }; }; };
    }
}
</code></pre>
<h3><a class="header" href="#understanding-scopes" id="understanding-scopes">Understanding scopes</a></h3>
<p>Scope (as it's said in <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)">Wikipedia</a>) is a region of code where binding is valid. In other words - it's a part of code in which variable exists. In Move scope is a block of code surrounded by curly braces - basically a block.</p>
<blockquote>
<p>When defining block you actually define a scope.</p>
</blockquote>
<pre><code class="language-Move">script {
    fun scope_sample() {
        // this is a function scope
        {
            // this is a block scope inside function scope
            {
                // and this is a scope inside scope
                // inside functions scope... etc
            };
        };

        {
            // this is another block inside function scope
        };
    }
}
</code></pre>
<p>As you can see from comments in this sample, scopes are defined by blocks (or functions), they can be nested and there's no limit to how many scopes you can define.</p>
<h3><a class="header" href="#variable-lifetime-and-visibility" id="variable-lifetime-and-visibility">Variable lifetime and visibility</a></h3>
<p>Keyword let creates a variable - you already know that. Though you probably don't know that defined variable will live only inside the scope where it's defined (hence inside nested scopes); simply put - it's unaccessible outside its scope and dies right after this scope's end.</p>
<pre><code class="language-Move">script {
    fun let_scope_sample() {
        let a = 1; // we've defined variable A inside function scope

        {
            let b = 2; // variable B is inside block scope

            {
                // variables A and B are accessible inside
                // nested scopes
                let c = a + b;

            }; // in here C dies

            // we can't write this line
            // let d = c + b;
            // as variable C died with its scope

            // but we can define another C
            let c = b - 1;

        }; // variable C dies, so does C

        // this is impossible
        // let d = b + c;

        // we can define any variables we want
        // no name reservation happened
        let b = a + 1;
        let c = b + 1;

    } // function scope ended - a, b and c are dropped and no longer accessible
}
</code></pre>
<blockquote>
<p>Variable lives only within scope (or block) where it's defined. When its scope ends, the variable dies.</p>
</blockquote>
<h3><a class="header" href="#block-return-values" id="block-return-values">Block return values</a></h3>
<p>In the previous part you've learned that block is an expression but we didn't cover why it is an expression and what is the block's return value.</p>
<blockquote>
<p>Block can return a value, it's the value of the last expression inside this block if it's not followed by semicolon</p>
</blockquote>
<p>May sound hard, so I'll give you few examples:</p>
<pre><code class="language-Move">script {
    fun block_ret_sample() {

        // since block is an expression, we can
        // assign it's value to variable with let
        let a = {

            let c = 10;

            c * 1000  // no semicolon!
        }; // scope ended, variable a got value 10000

        let b = {
            a * 1000  // no semi!
        };

        // variable b got value 10000000

        {
            10; // see semi!
        }; // this block does not return a value

        let _ = a + b; // both a and b get their values from blocks
    }
}
</code></pre>
<blockquote>
<p>Last expression in scope (without semicolon) is the return value of this scope.</p>
</blockquote>
<h3><a class="header" href="#summary" id="summary">Summary</a></h3>
<p>Let's keynote the main points of this chapter.</p>
<ol>
<li>Every expression must end with semicolon unless it's the return value of block;</li>
<li>Keyword <code>let</code> creates new variable with value or right-hand-side expression which lives as long as the scope in which it's been created;</li>
<li>Block is an expression that may or may not have return value.</li>
</ol>
<p>How to control execution flow and how to use blocks for logic switches - on the next page.</p>
<h3><a class="header" href="#further-reading" id="further-reading">Further reading</a></h3>
<ul>
<li><a href="https://community.diem.com/t/odd-error-when-semi-is-put-after-break-or-continue/2868">Diem Community thread on empty expressions and semicolon</a></li>
</ul>
<h1><a class="header" href="#control-flow" id="control-flow">Control Flow</a></h1>
<p>Move is imperative language and like one it has <em>control flow</em> - a way to make choice whether to run block of code or to skip or to run another one instead.</p>
<!-- In Move you have two statme to control flow: by using loops (`while` and `loop`) or `if` expressions. -->
<p>In Move you have loops (<code>while</code> and <code>loop</code>) and <code>if</code> expressions.</p>
<h2><a class="header" href="#the-if-expression" id="the-if-expression">The <code>if</code> expression</a></h2>
<p><code>if</code> expression allows you to run a block of code if some condition is true, and to run another block instead if condition resulted in false.</p>
<pre><code class="language-Move">script {
    use 0x1::Debug;

    fun main() {

        let a = true;

        if (a) {
            Debug::print&lt;u8&gt;(&amp;0);
        } else {
            Debug::print&lt;u8&gt;(&amp;99);
        };
    }
}
</code></pre>
<p>In this example we've used <code>if</code> + <code>block</code> to print <code>0</code> if <code>a == true</code> and if a is <code>false</code> - then <code>99</code> is printed. Simple as that, if syntax is:</p>
<pre><code>if (&lt;bool_expression&gt;) &lt;expression&gt; else &lt;expression&gt;;
</code></pre>
<p><code>if</code> is an expression, and like all of them it must end with semicolon. This is also a reason to use it with <code>let</code> statement!</p>
<pre><code class="language-Move">script {
    use 0x1::Debug;

    fun main() {

        // try switching to false
        let a = true;
        let b = if (a) { // 1st branch
            10
        } else { // 2nd branch
            20
        };

        Debug::print&lt;u8&gt;(&amp;b);
    }
}
</code></pre>
<p>Now variable <code>b</code> will be assigned a different value depending on the <code>a</code> expression. But both of the branches in <code>if</code> must return the same type! Otherwise variable <code>b</code> will have an option to be of different kind (or undefined) and this is impossible in statically typed language. In compiler terms it's called <em>branch compatibility</em> - both of the branches must return compatible (same) type.</p>
<p><code>if</code> can be used in-solo - without <code>else</code>.</p>
<pre><code class="language-Move">script {
    use 0x1::Debug;

    fun main() {

        let a = true;

        // only one optional branch
        // if a = false, debug won't be called
        if (a) {
            Debug::print&lt;u8&gt;(&amp;10);
        };
    }
}
</code></pre>
<p>But keep in mind that <code>if</code> expression without <code>else</code> branch cannot be used in assignment as when condition is not met - alternative branch is not called and variable may be undefined which is, again, impossible.</p>
<h2><a class="header" href="#iterating-with-loops" id="iterating-with-loops">Iterating with loops</a></h2>
<p>There're two ways of defining loops in Move:</p>
<ol>
<li>Conditional loop with <code>while</code></li>
<li>Inifinite <code>loop</code></li>
</ol>
<h3><a class="header" href="#conditional-loop-with-while" id="conditional-loop-with-while">Conditional loop with <code>while</code></a></h3>
<p><code>while</code> is a way to define loop - expression which will be executed while some condition is true. So simply: code will be run over and over <em>while</em> condition is <code>true</code>. To implement condition usually an external variable (or counter) is used.</p>
<pre><code class="language-Move">script {
    fun main() {

        let i = 0; // define counter

        // iterate while i &lt; 5
        // on every iteration increase i
        // when i is 5, condition fails and loop exits
        while (i &lt; 5) {
            i = i + 1;
        };
    }
}
</code></pre>
<p>It's worth mentioning that <code>while</code> is an expression - just like <code>if</code> is, and it too requires a semicolon afterwards. Generic syntax for while loop is:</p>
<pre><code class="language-Move">while (&lt;bool_expression&gt;) &lt;expression&gt;;
</code></pre>
<p>Unlike <code>if</code>, <code>while</code> cannot return a value, so variable assignment (like we did with <code>if</code> expression) is impossible.</p>
<h3><a class="header" href="#unreachable-code" id="unreachable-code">Unreachable code</a></h3>
<p>To be reliable Move must be secure. This is why it obliges you to use all your variables and for the same reason it forbids having unreachable code. As digital assets are programmable, they can be used in code (you'll learn about it in <a href="syntax-basics//chapters/resource.html">resources chapter</a>), and placing them in unreachable areas may lead to inconvenience and their loss as the result.</p>
<p>This is why unreachable code is such a big issue. Now that is clear, we can proceed.</p>
<h3><a class="header" href="#infinite-loop" id="infinite-loop">Infinite <code>loop</code></a></h3>
<p>There is a way to define infinite loops. They're non-conditional and actually infinite (unless you force them to stop). Unfortunately the compiler cannot define whether a loop is infinite (in most of the cases) and cannot stop you from publishing code, execution of which will consume all given resources (in blockchain terms - gas). So it's on you to test your code properly when using them or just switch to conditional <code>while</code> as it's way more secure.</p>
<p>Infinite loops are defined with keyword <code>loop</code>.</p>
<pre><code class="language-Move">script {
    fun main() {
        let i = 0;

        loop {
            i = i + 1;
        };

        // UNREACHABLE CODE
        let _ = i;
    }
}
</code></pre>
<p>However this is possible (compiler will let you do this):</p>
<pre><code class="language-Move">script {
    fun main() {
        let i = 0;

        loop {
            if (i == 1) { // i never changed
                break // this statement breaks loop
            }
        };

        // actually unreachable
        0x1::Debug::print&lt;u8&gt;(&amp;i);
    }
}
</code></pre>
<p>It's a non-trivial task for the compiler to understand whether a loop is really infinite or not, so for now you and only you can help yourself avoid looping errors.</p>
<h3><a class="header" href="#control-loops-with-continue-and-break" id="control-loops-with-continue-and-break">Control loops with <code>continue</code> and <code>break</code></a></h3>
<p>Keywords <code>continue</code> and <code>break</code> allow you to skip one round or break iteration respectively. You can use both of them in both types of loops.</p>
<p>For example let's add two conditions into the <code>loop</code>. If <code>i</code> is even, we use <code>continue</code> to jump to the next iteration without going through code after <code>continue</code> call.</p>
<p>With <code>break</code> we stop iteration and exit loop.</p>
<pre><code class="language-Move">script {
    fun main() {
        let i = 0;

        loop {
            i = i + 1;

            if (i / 2 == 0) continue;
            if (i == 5) break;

            // assume we do something here
         };

        0x1::Debug::print&lt;u8&gt;(&amp;i);
    }
}
</code></pre>
<p>About semicolons. If <code>break</code> and <code>continue</code> are the last keywords in a block, you can't put a semicolon after them as any code after won't be executed. Somehow even semi can't be put. See this:</p>
<pre><code class="language-Move">script {
    fun main() {
        let i = 0;

        loop {
            i = i + 1;

            if (i == 5) {
                break; // will result in compiler error. correct is `break` without semi
                       // Error: Unreachable code
            };

            // same with continue here: no semi, never;
            if (true) {
                continue
            };

            // however you can put semi like this, because continue and break here
            // are single expressions, hence they &quot;end their own scope&quot;
            if (true) continue;
            if (i == 5) break;
        }
    }
}
</code></pre>
<h3><a class="header" href="#conditional-abort" id="conditional-abort">Conditional <code>abort</code></a></h3>
<p>Sometimes you need to abort execution of transaction when some condition has failed. For that case there's keyword <code>abort</code>.</p>
<pre><code class="language-Move">script {
    fun main(a: u8) {

        if (a != 10) {
            abort 0;
        }

        // code here won't be executed if a != 10
        // transaction aborted
    }
}
</code></pre>
<p>Keyword <code>abort</code> allows you to <em>abort</em> execution with an error code which is placed right after.</p>
<h3><a class="header" href="#use-assert-built-in" id="use-assert-built-in">Use <code>assert</code> built-in</a></h3>
<p>Built-in <code>assert!(&lt;bool expression&gt;, &lt;code&gt;)</code> method already wraps <code>abort</code> + condition and is accessible anywhere in code:</p>
<pre><code class="language-Move">script {

    fun main(a: u8) {
        assert!(a == 10, 0);

        // code here will be executed if (a == 10)
    }
}
</code></pre>
<p><code>assert()</code> will abort execution when condition is not met, or it will do nothing in the opposite case.</p>
<h1><a class="header" href="#module-and-import" id="module-and-import">Module and Import</a></h1>
<p>Module is a set of functions and types packed together which the developer publishes under his address. In the previous chapters we only used scripts, though script can only operate with published modules or standard library which itself is a set of modules published under <code>0x1</code> address.</p>
<blockquote>
<p>Module is published under its sender's address. Standard library is published under <code>0x1</code> address.</p>
</blockquote>
<blockquote>
<p>When publishing a module, none of its functions are executed. To use module - use scripts.</p>
</blockquote>
<p>Module starts with <code>module</code> keyword, which is followed by module name and curly braces - inside them module contents are placed.</p>
<pre><code class="language-Move">module Math {

    // module contents

    public fun sum(a: u64, b: u64): u64 {
        a + b
    }
}
</code></pre>
<blockquote>
<p>Module is the only way to publish code accessible for others; new types and resources can too only be defined within module context.</p>
</blockquote>
<p>By default your module will be compiled and published from your address. However if you need to use some modules locally (e.g. for testing or developing) or want to specify your address inside module file, use <code>address &lt;ADDR&gt; {}</code> syntax:</p>
<pre><code class="language-Move">address 0x1 {
module Math {
    // module contents

    public fun sum(a: u64, b: u64): u64 {
        a + b
    }
}
}
</code></pre>
<p><em>Like shown in example: best practice is to keep module line without indentation</em></p>
<h2><a class="header" href="#imports" id="imports">Imports</a></h2>
<p>Default context in Move is empty: the only types you can use are primitives (integers, bool and address), and the only thing you can do within empty context is operate these types and variables while being unable to do something meaningful or useful.</p>
<p>To change that you can import published modules (or standard library).</p>
<h3><a class="header" href="#direct-import" id="direct-import">Direct import</a></h3>
<p>You can use modules by their address directly in your code:</p>
<pre><code class="language-Move">script {
    fun main(a: u8) {
        0x1::Offer::create(a == 10, 1);
    }
}
</code></pre>
<p>In this example we've imported module <code>Offer</code> from address <code>0x1</code> (standard library) and used its method <code>assert(expr: bool, code: u8)</code>.</p>
<h3><a class="header" href="#keyword-use" id="keyword-use">Keyword use</a></h3>
<p>To make code shorter (remember that only 0x1 address is short, actual addresses are pretty long!) and to organize imports you can use keyword <code>use</code>:</p>
<pre><code class="language-Move">use &lt;Address&gt;::&lt;ModuleName&gt;;
</code></pre>
<p>Here <code>&lt;Address&gt;</code> is a publisher's address and <code>&lt;ModuleName&gt;</code> is a name of a module. Pretty simple. Same here, we'll import <code>Vector</code> module from <code>0x1</code>.</p>
<pre><code class="language-Move">use 0x1::Vector;
</code></pre>
<h3><a class="header" href="#accessing-modules-contents" id="accessing-modules-contents">Accessing module's contents</a></h3>
<p>To access imported module's methods (or types) use <code>::</code> notation. Simple as that - modules can only have one level of definitions so everything you define in the module (publicly) can be accessed via double colon.</p>
<pre><code class="language-Move">script {
    use 0x1::Vector;

    fun main() {
        // here we use method empty() of module Vector
        // the same way we'd access any other method of any other module
        let _ = Vector::empty&lt;u64&gt;();
    }
}
</code></pre>
<h3><a class="header" href="#import-in-script" id="import-in-script">Import in script</a></h3>
<p>In scripts imports must be placed inside <code>script {}</code> block:</p>
<pre><code class="language-Move">script {
    use 0x1::Vector;

    // in just the same way you can import any
    // other module(s). as many as you want!

    fun main() {
        let _ = Vector::empty&lt;u64&gt;();
    }
}
</code></pre>
<h3><a class="header" href="#import-in-module" id="import-in-module">Import in module</a></h3>
<p>Module imports must be specified inside <code>module {}</code> block:</p>
<pre><code class="language-Move">module Math {
    use 0x1::Vector;

    // the same way as in scripts
    // you are free to import any number of modules

    public fun empty_vec(): vector&lt;u64&gt; {
        Vector::empty&lt;u64&gt;();
    }
}
</code></pre>
<h3><a class="header" href="#member-import" id="member-import">Member import</a></h3>
<p>Import statement can be extended - you can specify which members of the module you want to import:</p>
<pre><code class="language-Move">script {
    // single member import
    use 0x1::Signer::address_of;

    // multi member import (mind braces)
    use 0x1::Vector::{
        empty,
        push_back
    };

    fun main(acc: &amp;signer) {
        // use functions without module access
        let vec = empty&lt;u8&gt;();
        push_back(&amp;mut vec, 10);

        // same here
        let _ = address_of(acc);
    }
}
</code></pre>
<h3><a class="header" href="#using-self-to-import-module-alongside-its-members" id="using-self-to-import-module-alongside-its-members">Using <code>Self</code> to import module alongside its members</a></h3>
<p>Small extension to member import syntax allows you to import whole module and its members. Use <code>Self</code> for module.</p>
<pre><code class="language-Move">script {
    use 0x1::Vector::{
        Self, // Self == Imported module
        empty
    };

    fun main() {
        // `empty` imported as `empty`
        let vec = empty&lt;u8&gt;();

        // Self means Vector
        Vector::push_back(&amp;mut vec, 10);
    }
}
</code></pre>
<h3><a class="header" href="#use-meets-as" id="use-meets-as">Use meets as</a></h3>
<p>To resolve naming conflicts (when 2 or more modules have same names) and to shorten you code you can change name of the imported module using keyword <code>as</code>.</p>
<p>Syntax:</p>
<pre><code class="language-Move">use &lt;Address&gt;::&lt;ModuleName&gt; as &lt;Alias&gt;;
</code></pre>
<p>In script:</p>
<pre><code class="language-Move">script {
    use 0x1::Vector as V; // V now means Vector

    fun main() {
        V::empty&lt;u64&gt;();
    }
}
</code></pre>
<p>The same in module:</p>
<pre><code class="language-Move">module Math {
    use 0x1::Vector as Vec;

    fun length(&amp;v: vector&lt;u8&gt;): u64 {
        Vec::length(&amp;v)
    }
}
</code></pre>
<p>For Self and <em>member import</em> (works in modules and scripts):</p>
<pre><code class="language-Move">script {
    use 0x1::Vector::{
        Self as V,
        empty as empty_vec
    };

    fun main() {
        // `empty` imported as `empty_vec`
        let vec = empty_vec&lt;u8&gt;();

        // Self as V = Vector
        V::push_back(&amp;mut vec, 10);
    }
}
</code></pre>
<h1><a class="header" href="#constants" id="constants">Constants</a></h1>
<p>You can define <em>module</em> or <em>script-level</em> constants. Once defined, constants cannot be changed, and they should be used to define some <em>constant</em> values for specific module (say, a role identifier or price for action) or script.</p>
<p>Constants can be defined as primitive types (integers, bool and address) and as a <code>vector</code>. They are accessed by their names and are local to script/module where they are defined.</p>
<blockquote>
<p>Accessing constant value from outside of its module is impossible</p>
</blockquote>
<pre><code class="language-Move">script {

    use 0x1::Debug;

    const RECEIVER : address = 0x999;

    fun main(account: &amp;signer) {
        Debug::print&lt;address&gt;(&amp;RECEIVER);

        // they can also be assigned to a variable

        let _ = RECEIVER;

        // but this code leads to compile error
        // RECEIVER = 0x800;
    }
}
</code></pre>
<p>Same usage in module:</p>
<pre><code class="language-Move">module M {

    const MAX : u64 = 100;

    // however you can pass constant outside using a function
    public fun get_max(): u64 {
        MAX
    }

    // or using
    public fun is_max(num: u64): bool {
        num == MAX
    }
}
</code></pre>
<h3><a class="header" href="#summary-1" id="summary-1">Summary</a></h3>
<p>What is important to know about constants:</p>
<ol>
<li>They are unchangeable once defined;</li>
<li>They are local to their module or script and cannot be used outside;</li>
<li>Usually they are used to define module-level constant value which serves some business purpose;</li>
<li>It is also possible to define constant as an expression (with curly braces) but syntax of this expression is very limited.</li>
</ol>
<h3><a class="header" href="#further-reading-1" id="further-reading-1">Further reading</a></h3>
<ul>
<li><a href="https://github.com/diem/diem/pull/4653">PR with constant syntax</a></li>
</ul>
<h1><a class="header" href="#function" id="function">Function</a></h1>
<p>Function is the only place of execution in Move. Function starts with the <code>fun</code> keyword which is followed by function name, parentheses for arguments and curly braces for body.</p>
<pre><code class="language-Move">fun function_name(arg1: u64, arg2: bool): u64 {
    // function body
}
</code></pre>
<p>You have already seen some in previous chapters. And now you will learn how to use them.</p>
<blockquote>
<p><strong>Note:</strong> in Move functions should be named in <em>snake_case</em> - lowercase with underscores as word separators.</p>
</blockquote>
<h2><a class="header" href="#function-in-script" id="function-in-script">Function in script</a></h2>
<p>Script block can contain only one function which is considered <em>main</em>. This function (possibly with arguments) will be executed as a transaction. It is very limited: it cannot return value and should be used to operate other functions in already published modules.</p>
<p>Here's an example of simple script which checks if address exists:</p>
<pre><code class="language-Move">script {
    use 0x1::Account;

    fun main(addr: address) {
        assert(Account::exists(addr), 1);
    }
}
</code></pre>
<p>This function can have arguments: in this case it is <code>addr</code> argument with type <code>address</code>, also it can operate imported modules.</p>
<blockquote>
<p><strong>Note:</strong> as there's only one function, you can call it any way you want. Though you may want to follow general programming concepts and call it <strong>main</strong></p>
</blockquote>
<h2><a class="header" href="#function-in-module" id="function-in-module">Function in module</a></h2>
<p>While script context is fairly limited, full potential of functions can only be seen in a module. Let's go through it again: module is a published set of functions and types (we'll get to it in the next chapter) which solves one or many tasks.</p>
<p>In this part we'll create a simple Math module which will provide users with a basic set of mathematical functions and a few helper methods. Most of this could be done without using a module, but our goal is education!</p>
<pre><code class="language-Move">module Math {
    fun zero(): u8 {
        0
    }
}
</code></pre>
<p>First step: we've defined a module named <code>Math</code> with one function in it: <code>zero()</code>, which returns 0 - a value of type <code>u8</code>. Remember <a href="syntax-basics//syntax-basics/expression-and-scope.html">expressions</a>? There's no semicolon after <code>0</code> as it is the <em>return value</em> of this function. Just like you would do with block. Yeah, function body is very similar to block.</p>
<h3><a class="header" href="#function-arguments" id="function-arguments">Function arguments</a></h3>
<p>This should be clear by now, but let's repeat. Function can take arguments (values passed into function). As many as needed. Every argument has 2 properties: name - its name within a function body, and type - just like any other variable in Move.</p>
<p>Function arguments - just like any other variables defined within a scope - live only within function body. When the function block ends, no variables remain.</p>
<pre><code class="language-Move">module Math {

    public fun sum(a: u64, b: u64): u64 {
        a + b
    }

    fun zero(): u8 {
        0
    }
}
</code></pre>
<p>What's new in our Math: function <code>sum(a,b)</code> which sums two <code>u64</code> values and returns a result - <code>u64</code> sum (type can't change).</p>
<p>Let's state few syntax rules:</p>
<ol>
<li>Arguments must have types and must be separated by comma</li>
<li>Function return value is placed after parentheses and must follow a colon</li>
</ol>
<p>Now how would we use this function in script? Through import!</p>
<pre><code class="language-Move">script {
    use 0x1::Math;  // used 0x1 here; could be your address
    use 0x1::Debug; // this one will be covered later!

    fun main(first_num: u64, second_num: u64) {

        // variables names don't have to match the function's ones
        let sum = Math::sum(first_num, second_num);

        Debug::print&lt;u64&gt;(&amp;sum);
    }
}
</code></pre>
<h3><a class="header" href="#keyword-return" id="keyword-return">Keyword <code>return</code></a></h3>
<p>Keyword <code>return</code> allows you to stop function execution and return value. It is supposed to be used with <code>if</code> condition, as that is the only way to make conditional switch in control flow.</p>
<pre><code class="language-Move">module M {

    public fun conditional_return(a: u8): bool {
        if (a == 10) {
            return true // semi is not put!
        };

        if (a &lt; 10) {
            true
        } else {
            false
        }
    }
}
</code></pre>
<h3><a class="header" href="#multiple-return-values" id="multiple-return-values">Multiple return values</a></h3>
<p>In previous examples we've experimented with functions with no return value or with single. But what if I told you that you can return multiple values of any type? Curious? Let's proceed!</p>
<p>To specify multiple return values you need to use parentheses:</p>
<pre><code class="language-Move">module Math {

    // ...

    public fun max(a: u8, b: u8): (u8, bool) {
        if (a &gt; b) {
            (a, false)
        } else if (a &lt; b) {
            (b, false)
        } else {
            (a, true)
        }
    }
}
</code></pre>
<p>This function takes two arguments: <code>a</code> and <code>b</code> and <em>returns two values</em>: first is the max value from two passed and second is a bool - whether numbers entered are equal. Take closer look at the syntax: instead of specifying single return argument we've added <em>parenteses</em> and have listed return argument types.</p>
<p>Now let's see how we can use the result of this function in another function in the script.</p>
<pre><code class="language-Move">script {
    use 0x1::Debug;
    use 0x1::Math;

    fun main(a: u8, b: u8)  {
        let (max, is_equal) = Math::max(99, 100);

        assert(is_equal, 1)

        Debug::print&lt;u8&gt;(&amp;max);
    }
}
</code></pre>
<p>In this example we've <em>destructed</em> a tuple: created two new variables with values and types of return values of function <em>max</em>. Order is preserved and variable <em>max</em> here gets type <em>u8</em> and now stores max value, whereas <em>is_equal</em> is a <em>bool</em>.</p>
<p>Two is not the limit - number of returned arguments is up to you, though you'll soon learn about structs and see alternative way to return complex data.</p>
<h3><a class="header" href="#function-visibility" id="function-visibility">Function visibility</a></h3>
<p>When defining a module you may want to make some functions accessible by other developers and some to remain hidden. This is when <em>function visibility modifiers</em> come to play.</p>
<p>By default every function defined in a module is private - it cannot be accessed in other modules or scripts. If you've been attentive, you may have noticed that some of the functions that we've defined in our Math module have keyword <code>public</code> before their definition:</p>
<pre><code class="language-Move">module Math {

    public fun sum(a: u64, b: u64): u64 {
        a + b
    }

    fun zero(): u8 {
        0
    }
}
</code></pre>
<p>In this example function <code>sum()</code> is accessible from outside when module is imported, however function <code>zero()</code> is not - it is private by default.</p>
<blockquote>
<p>Keyword <code>public</code> changes function's default <em>private</em> visibility and makes it <em>public</em> - i.e. accessible from outside.</p>
</blockquote>
<p>So basically if you didn't make <code>sum()</code> function <em>public</em>, this wouldn't be possible:</p>
<pre><code class="language-Move">script {
    use 0x1::Math;

    fun main() {
        Math::sum(10, 100); // won't compile!
    }
}
</code></pre>
<h3><a class="header" href="#access-local-functions" id="access-local-functions">Access local functions</a></h3>
<p>There would not be any sense in making private functions if they could not be accessed at all. Private functions exist to do some <em>internal</em> work when public functions are called.</p>
<blockquote>
<p>Private functions can only be accessed in the module where they're defined.</p>
</blockquote>
<p>So how do you access functions in the same module? By simply calling this function like it was imported!</p>
<pre><code class="language-Move">module Math {

    public fun is_zero(a: u8): bool {
        a == zero()
    }

    fun zero(): u8 {
        0
    }
}
</code></pre>
<p>Any function defined in a module is accessible by any function in the same module no matter what visibility modifiers any of them has. This way private functions can still be used as calls inside public ones without exposing some private features or too risky operations.</p>
<h3><a class="header" href="#native-functions" id="native-functions">Native functions</a></h3>
<p>There's a special kind of functions - <em>native</em> ones. <em>Native functions</em> implement functionality which goes beyond Move's possibilities and give you extra power. Native functions are defined by VM itself and may vary in different implementations. Which means they don't have implementation in Move syntax and instead of having function body they end with a semicolon. Keyword <code>native</code> is used to mark native functions. It does not conflict with function visibility modifiers and the same function can be <code>native</code> and <code>public</code> at the same time.</p>
<p>Here's an example from Diem's standard library.</p>
<pre><code class="language-Move">module Signer {

    native public fun borrow_address(s: &amp;signer): &amp;address;

    // ... some other functions ...
}
</code></pre>
<h1><a class="header" href="#advanced-topics" id="advanced-topics">Advanced Topics</a></h1>
<p>In this section you'll learn few programming concepts which are widely used in Move: unique type system feature - <a href="advanced-topics//advanced-topics/types-with-abilities.html"><em>abilities</em></a>, <a href="advanced-topics//advanced-topics/ownership-and-references.html"><em>ownership</em></a> (and how it differs from Rust's one), <a href="advanced-topics//advanced-topics/understanding-generics.html"><em>generics</em></a> and <a href="advanced-topics//advanced-topics/managing-collections-with-vectors.html"><em>vector</em></a>. All of them provide solid foundation for safety and flexibility of Move language.</p>
<h1><a class="header" href="#structures" id="structures">Structures</a></h1>
<p>Structure is a custom type which contains complex data (or no data). It can be described as a simple key-value storage where key is a name of property and value is what's stored. Defined using keyword <code>struct</code>. Struct can have up to 4 abilities, they are specified with type definition.</p>
<blockquote>
<p>Struct is the only way to create custom type in Move.</p>
</blockquote>
<h2><a class="header" href="#definition" id="definition">Definition</a></h2>
<p>Struct definition is only allowed inside a module. It begins with keyword <code>struct</code>, followed by name and curly braces, where struct fields are defined:</p>
<pre><code class="language-Move">struct NAME {
    FIELD1: TYPE1,
    FIELD2: TYPE2,
    ...
}
</code></pre>
<p>Look at these examples of struct definitions:</p>
<pre><code class="language-Move">module M {

    // struct can be without fields
    // but it is a new type
    struct Empty {}

    struct MyStruct {
        field1: address,
        field2: bool,
        field3: Empty
    }

    struct Example {
        field1: u8,
        field2: address,
        field3: u64,
        field4: bool,
        field5: bool,

        // you can use another struct as type
        field6: MyStruct
    }
}
</code></pre>
<p><em>Max number of fields in one struct is 65535</em>.</p>
<p>Every defined struct becomes new a type. This type can be accessed through its module (just like you would access module functions):</p>
<pre><code>M::MyStruct;
// or
M::Example;
</code></pre>
<h3><a class="header" href="#recursive-definition" id="recursive-definition">Recursive definition</a></h3>
<p>Short as never:</p>
<blockquote>
<p>Recursive struct definition is impossible.</p>
</blockquote>
<p>You are allowed to use another struct as type but you can't recursively use the same struct. Move compiler checks recursive definitions and won't let you compile code like this:</p>
<pre><code class="language-Move">module M {
    struct MyStruct {

        // WON'T COMPILE
        field: MyStruct
    }
}
</code></pre>
<h2><a class="header" href="#create-new-struct" id="create-new-struct">Create new struct</a></h2>
<p>To use this type you need to create its <em>instance</em>.</p>
<blockquote>
<p>New instances can only be created inside the module where they're defined.</p>
</blockquote>
<p>To create new instance use it's definition, but instead of passing types pass values of these types:</p>
<pre><code class="language-Move">module Country {
    struct Country {
        id: u8,
        population: u64
    }

    // Contry is a return type of this function!
    public fun new_country(c_id: u8, c_population: u64): Country {
        // structure creation is an expression
        let country = Country {
            id: c_id,
            population: c_population
        };

        country
    }
}
</code></pre>
<p>Move also allows you to create new instances shorter - by passing variable name which matches struct's field (and type!). We can simplify our <code>new_country()</code> method using this rule:</p>
<pre><code class="language-Move">// ...
public fun new_country(id: u8, population: u64): Country {
    // id matches id: u8 field
    // population matches population field
    Country {
        id,
        population
    }

    // or even in one line: Country { id, population }
}
</code></pre>
<p>To create an empty struct (with no fields) simply use curly braces:</p>
<pre><code class="language-Move">public fun empty(): Empty {
    Empty {}
}
</code></pre>
<h2><a class="header" href="#access-struct-fields" id="access-struct-fields">Access struct fields</a></h2>
<p>Structs would have been almost useless if we hadn't had a way to access their fields (though you can create struct without fields).</p>
<blockquote>
<p>Only module can access its struct's fields. Outside of module fields are private.</p>
</blockquote>
<p>Struct fields are only visible inside its module. Outside of this module (in script or another module) it's just a type. To access struct's fields use <code>.</code> (dot) notation:</p>
<pre><code class="language-Move">// ...
public fun get_country_population(country: Country): u64 {
    country.population // &lt;struct&gt;.&lt;property&gt;
}
</code></pre>
<p>If nested struct type is defined in the same module it can be accessed in similar manner which can be generally described as:</p>
<pre><code class="language-Move">&lt;struct&gt;.&lt;field&gt;
// and field can be another struct so
&lt;struct&gt;.&lt;field&gt;.&lt;nested_struct_field&gt;...
</code></pre>
<h2><a class="header" href="#destructing-structures" id="destructing-structures">Destructing structures</a></h2>
<p>To <em>destruct</em> a struct use <code>let &lt;STRUCT DEF&gt; = &lt;STRUCT&gt;</code> syntax:</p>
<pre><code class="language-Move">module Country {

    // ...

    // we'll return values of this struct outside
    public fun destroy(country: Country): (u8, u64) {

        // variables must match struct fields
        // all struct fields must be specified
        let Country { id, population } = country;

        // after destruction country is dropped
        // but its fields are now variables and
        // can be used
        (id, population)
    }
}
</code></pre>
<p>You should remember that unused variables are prohibited in Move and sometimes you may need to destruct a structure without using its fields. For unused struct fields use <code>_</code> - underscore:</p>
<pre><code class="language-Move">module Country {
    // ...

    public fun destroy(country: Country) {

        // this way you destroy struct and don't create unused variables
        let Country { id: _, population: _ } = country;

        // or take only id and don't init `population` variable
        // let Country { id, population: _ } = country;
    }
}
</code></pre>
<p>Destructuring may not seem important right now. But remember it - it will play a huge part when we get to resources.</p>
<h3><a class="header" href="#implementing-getter-functions-for-struct-fields" id="implementing-getter-functions-for-struct-fields">Implementing getter-functions for struct fields</a></h3>
<p>To make struct fields readable outside, you need to implement methods which will read these fields and pass them as return values. Usually the getter method is called the same way as struct's field but it may cause inconvenience if your module defines more than one struct.</p>
<pre><code class="language-Move">module Country {

    struct Country {
        id: u8,
        population: u64
    }

    public fun new_country(id: u8, population: u64): Country {
        Country {
            id, population
        }
    }

    // don't forget to make these methods public!
    public fun id(country: &amp;Country): u8 {
        country.id
    }

    // don't mind ampersand here for now. you'll learn why it's 
    // put here in references chapter 
    public fun population(country: &amp;Country): u64 {
        country.population
    }

    // ... fun destroy ... 
}
</code></pre>
<p>By making getters we've allowed module users access fields of our struct:</p>
<pre><code class="language-Move">script {
    use {{sender}}::Country as C;
    use 0x1::Debug;

    fun main() {
        // variable here is of type C::Country
        let country = C::new_country(1, 10000000);

        Debug::print&lt;u8&gt;(
            &amp;C::id(&amp;country)
        ); // print id

        Debug::print&lt;u64&gt;(
            &amp;C::population(&amp;country)
        );

        // however this is impossible and will lead to compile error
        // let id = country.id;
        // let population = country.population.

        C::destroy(country);
    }
}
</code></pre>
<hr />
<p>Now you know how to define custom type - struct, but by default its functionality is limited. In the next chapter you will learn about abilities - a way to define how values of this type can be manipulated and used.</p>
<h1><a class="header" href="#types-with-abilities" id="types-with-abilities">Types with Abilities</a></h1>
<p>Move has unique type system which is very flexible and customizable. Each type can have up to 4 abilities which define how values of this type can be used, dropped or stored.</p>
<blockquote>
<p>There are 4 type abilities: Copy, Drop, Store and Key.</p>
</blockquote>
<p>Simply described:</p>
<ul>
<li><strong>Copy</strong> - value can be <em>copied</em> (or cloned by value). </li>
<li><strong>Drop</strong> - value can be <em>dropped</em> by the end of scope.</li>
<li><strong>Key</strong> - value can be <em>used as a key</em> for global storage operations.</li>
<li><strong>Store</strong> - value can be <em>stored</em> inside global storage.</li>
</ul>
<p>On this page we will go through <code>Copy</code> and <code>Drop</code> abilities in detail; more context over <code>Key</code> and <code>Store</code> abilities will be given when we get to <a href="advanced-topics//resources/index.html">Resources</a> chapter. </p>
<h3><a class="header" href="#abilities-syntax" id="abilities-syntax">Abilities syntax</a></h3>
<blockquote>
<p>Primitive and built-in types' abilities are pre-defined and unchangeable: integers, vector, addresses and boolean values have <em>copy</em>, <em>drop</em> and <em>store</em> abilities</p>
</blockquote>
<p>However when defining structs you can specify any set of abilities using this syntax:</p>
<pre><code class="language-Move">struct NAME has ABILITY [, ABILITY] { [FIELDS] }
</code></pre>
<p>Or by example:</p>
<pre><code class="language-Move">module Library {
    
    // each ability has matching keyword
    // multiple abilities are listed with comma
    struct Book has store, copy, drop {
        year: u64
    }

    // single ability is also possible
    struct Storage has key {
        books: vector&lt;Book&gt;
    }

    // this one has no abilities 
    struct Empty {}
}
</code></pre>
<h3><a class="header" href="#struct-with-no-abilities" id="struct-with-no-abilities">Struct with no Abilities</a></h3>
<p>Before we jump into how to use abilities and what they bring into the language, let's see what happens if there's a type with no abilities.</p>
<pre><code class="language-Move">module Country {
    struct Country {
        id: u8,
        population: u64
    }
    
    public fun new_country(id: u8, population: u64): Country {
        Country { id, population }
    }
}
</code></pre>
<pre><code class="language-Move">script {
    use {{sender}}::Country;

    fun main() {
        Country::new_country(1, 1000000);
    }   
}
</code></pre>
<p>If you try to run this code, you'll get the following error:</p>
<pre><code>error: 
   ┌── scripts/main.move:5:9 ───
   │
 5 │     Country::new_country(1, 1000000);
   │     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Cannot ignore values without the 'drop' ability. The value must be used
   │
</code></pre>
<p>Method <code>Country::new_country()</code> creates a value; this value is not passed anywhere and automatically dropped when function ends; but Country type doesn't have <em>Drop</em> ability, and it fails. Now let's change our struct definition and add <strong>Drop</strong> Ability.</p>
<h3><a class="header" href="#drop" id="drop">Drop</a></h3>
<p>Using abilities syntax we add <code>has drop</code> specifying <code>drop</code> ability for this struct. All of the instances of this struct will have drop ability and hence will be <em>droppable</em>. </p>
<pre><code class="language-Move">module Country {
    struct Country has drop { // has &lt;ability&gt;
        id: u8,
        population: u64
    }
    // ...
}
</code></pre>
<p>Now, when struct <code>Country</code> can be dropped, our script can be run.</p>
<pre><code class="language-Move">script {
    use {{sender}}::Country;

    fun main() {
        Country::new_country(1, 1000000); // value is dropped
    }   
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> Drop ability only defines <em>drop</em> behavior. <a href="advanced-topics//advanced-topics/struct.html#destructing-structures"><em>Destructuring</em></a> does not require Drop.</p>
</blockquote>
<h3><a class="header" href="#copy" id="copy">Copy</a></h3>
<p>We learned how to create new instances of struct <code>Country</code> and drop them. But what if we wanted to create a <em>copy</em>? By default, structs are passed by value; and to create a copy of this struct we will use keyword <code>copy</code> (you will learn more about this behavior <a href="advanced-topics//advanced-topics/ownership-and-references.html">in the next chapter</a>):</p>
<pre><code class="language-Move">script {
    use {{sender}}::Country;

    fun main() {
        let country = Country::new_country(1, 1000000);
        let _ = copy country;
    }   
}
</code></pre>
<pre><code>   ┌── scripts/main.move:6:17 ───
   │
 6 │         let _ = copy country;
   │                 ^^^^^^^^^^^^ Invalid 'copy' of owned value without the 'copy' ability
   │
</code></pre>
<p>As you could expect, making a copy of type without copy ability failed. Compiler message is clear:</p>
<pre><code class="language-Move">module Country {
    struct Country has drop, copy { // see comma here!
        id: u8,
        population: u64
    }
    // ...
}
</code></pre>
<p>With that change code above would compile and run.</p>
<h3><a class="header" href="#summary-2" id="summary-2">Summary</a></h3>
<ul>
<li>Primitive types have store, copy and drop.</li>
<li>By default structs have no abilities. </li>
<li>Copy and Drop abilities define whether value can be copied and dropped respectively.</li>
<li>It is possible to set up to 4 abilities for a struct.</li>
</ul>
<h3><a class="header" href="#further-reading-2" id="further-reading-2">Further reading</a></h3>
<ul>
<li><a href="https://github.com/diem/diem/blob/main/language/changes/3-abilities.md">Move Abilities Description</a></li>
</ul>
<h1><a class="header" href="#ownership-and-references" id="ownership-and-references">Ownership and References</a></h1>
<p>Move VM implements Rust-like ownership system. And the best description of it is in the <a href="https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html">Rust Book</a>. </p>
<p>I recommend you reading the ownership chapter in the Rust Book even though Rust syntax differs and some of the examples may not be easy to understand. In this chapter we will go through main points anyway.</p>
<blockquote>
<p>Each variable has only one owner scope. When owner scope ends - owned variables are dropped.</p>
</blockquote>
<p>We've already seen this behavior in the <a href="advanced-topics//syntax-basics/expression-and-scope.html">expressions chapter</a>. Remember that a variable lives as long as its scope? Now is the perfect time to get under the hood and learn why it happens.</p>
<p>Owner is a scope which <em>owns</em> a variable. Variables either can be defined in this scope (e.g. with keyword <code>let</code>) or be passed into the scope as arguments. Since the only scope in Move is function's - there are no other ways to put variables into scope.</p>
<p>Each variable has only one owner, which means that when a variable is passed into function as argument, this function becomes the <em>new owner</em>, and the variable is no longer <em>owned</em> by the first function. Or you may say that this other function <em>takes ownership</em> of the variable.</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        // Module::T is a struct
        let a : Module::T = Module::create(10);

        // here variable `a` leaves scope of `main` function
        // and is being put into new scope of `M::value` function
        M::value(a);

        // variable a no longer exists in this scope
        // this code won't compile
        M::value(a);
    }
}
</code></pre>
<p>Let's look at what happens inside the <code>value()</code> function when we pass our value into it:</p>
<pre><code class="language-Move">module M {
    // create_fun skipped
    struct T { value: u8 }

    public fun create(value: u8): T {
        T { value }
    }

    // variable t of type M::T passed
    // `value()` function takes ownership
    public fun value(t: T): u8 {
        // we can use t as variable
        t.value
    }
    // function scope ends, t dropped, only u8 result returned
    // t no longer exists
}
</code></pre>
<p>Of course, a quick workaround is to return a tuple with the original variable and additional results (return value would have been <code>(T, u8)</code>), but Move has a better solution for that.</p>
<h3><a class="header" href="#move-and-copy" id="move-and-copy">Move and Copy</a></h3>
<p>First, you need to understand how Move VM works, and what happens when you pass your value into a function. There are two bytecode instructions in VM: <em>MoveLoc</em> and <em>CopyLoc</em> - both of them can be manually used with keywords <code>move</code> and <code>copy</code> respectively.</p>
<p>When a variable is being passed into another function - it's being <em>moved</em> and <em>MoveLoc</em> OpCode is used. Let's see how our code would look if we've used keyword <code>move</code>:</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let a : Module::T = Module::create(10);

        M::value(move a); // variable a is moved

        // local a is dropped
    }
}
</code></pre>
<p>This is a valid Move code, however, knowing that value will still be moved you don't need to explicitly <em>move</em> it. Now when it's clear we can get to <em>copy</em>.</p>
<h3><a class="header" href="#keyword-copy" id="keyword-copy">Keyword <code>copy</code></a></h3>
<p>If you need to pass a value to the function (where it's being moved) and save a copy of your variable, you can use keyword <code>copy</code>.</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let a : Module::T = Module::create(10);

        // we use keyword copy to clone structure
        // can be used as `let a_copy = copy a`
        M::value(copy a);
        M::value(a); // won't fail, a is still here
    }
}
</code></pre>
<p>In this example we've passed a <em>copy</em> of a variable (hence value) <code>a</code> into the first call of the method <code>value</code> and saved <code>a</code> in local scope to use it again in a second call.</p>
<p>By copying a value we've duplicated it and increased the memory size of our program, so it can be used - but when you copy huge data it may become pricey in terms of memory. Remember - in blockchains every byte counts and affects the price of execution, so using <code>copy</code> all the time may cost you a lot.</p>
<p>Now you are ready to learn about references - a tool that will help you avoid unnecessary copying and literally save some money.</p>
<h2><a class="header" href="#references" id="references">References</a></h2>
<p>Many programming languages have implementation of references (<a href="https://en.wikipedia.org/wiki/Reference_(computer_science)">see Wikipedia</a>). <em>Reference</em> is a link to a variable (usually to a section in the memory) which you can pass into other parts of the program instead of <em>moving</em> the value.</p>
<blockquote>
<p>References (marked with &amp;) allow you to <em>refer</em> to a value without taking <em>ownership</em> of it.</p>
</blockquote>
<p>Let's modify our example and see how references can be used.</p>
<pre><code class="language-Move">module M {
    struct T { value: u8 }
    // ...
    // ...
    // instead of passing a value, we'll pass a reference
    public fun value(t: &amp;T): u8 {
        t.value
    }
}
</code></pre>
<p>We added ampersand <code>&amp;</code> to argument type T - and by doing that we've changed argument type from <code>T</code> to <em>reference to T</em> or simply <code>&amp;T</code>.</p>
<blockquote>
<p>Move supports two types of references: <em>immutable</em> - defined with <code>&amp;</code> (e.g. <code>&amp;T</code>) and <em>mutable</em> - <code>&amp;mut</code> (e.g. <code>&amp;mut T</code>).</p>
</blockquote>
<p>Immutable references allow reading value without changing it. Mutable - the opposite - ability to read and change the value.</p>
<pre><code class="language-Move">module M {
    struct T { value: u8 }

    // returned value is of non-reference type
    public fun create(value: u8): T {
        T { value }
    }

    // immutable references allow reading
    public fun value(t: &amp;T): u8 {
        t.value
    }

    // mutable references allow reading and changing the value
    public fun change(t: &amp;mut T, value: u8) {
        t.value = value;
    }
}
</code></pre>
<p>Now let's see how to use our upgraded module M.</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let t = M::create(10);

        // create a reference directly
        M::change(&amp;mut t, 20);

        // or write reference to a variable
        let mut_ref_t = &amp;mut t;

        M::change(mut_ref_t, 100);

        // same with immutable ref
        let value = M::value(&amp;t);

        // this method also takes only references
        // printed value will be 100
        0x1::Debug::print&lt;u8&gt;(&amp;value);
    }
}
</code></pre>
<blockquote>
<p>Use immutable (&amp;) references to read data from structs, use mutable (&amp;mut) to modify them. By using proper type of references you help maintaining security and help reading your modules so the reader will know whether this method changes the value or only reads.</p>
</blockquote>
<h3><a class="header" href="#borrow-checking" id="borrow-checking">Borrow checking</a></h3>
<p>Move controls the way you use references and helps you prevent unexpected bullet in your foot. To understand that let's see an example. I'll give you a module and a script and then will comment on what's going on and why.</p>
<pre><code class="language-Move">module Borrow {

    struct B { value: u64 }
    struct A { b: B }

    // create A with inner B
    public fun create(value: u64): A {
        A { b: B { value } }
    }

    // give a mutable reference to inner B
    public fun ref_from_mut_a(a: &amp;mut A): &amp;mut B {
        &amp;mut a.b
    }

    // change B
    public fun change_b(b: &amp;mut B, value: u64) {
        b.value = value;
    }
}
</code></pre>
<pre><code class="language-Move">script {
    use {{sender}}::Borrow;

    fun main() {
        // create a struct A { b: B { value: u64 } }
        let a = Borrow::create(0);

        // get mutable reference to B from mut A
        let mut_a = &amp;mut a;
        let mut_b = Borrow::ref_from_mut_a(mut_a);

        // change B
        Borrow::change_b(mut_b, 100000);

        // get another mutable reference from A
        let _ = Borrow::ref_from_mut_a(mut_a);
    }
}
</code></pre>
<p>This code compiles and runs without errors. First, what happens here: we use mutable reference to <code>A</code> to get mutable reference to its inner struct <code>B</code>. Then we change <code>B</code>. Then operation can be repeated.</p>
<p>But what if we've swapped two last expressions and first tried to create a new mutable reference to <code>A</code> while mutable reference to <code>B</code> is still alive?</p>
<pre><code class="language-Move">let mut_a = &amp;mut a;
let mut_b = Borrow::ref_from_mut_a(mut_a);

let _ = Borrow::ref_from_mut_a(mut_a);

Borrow::change_b(mut_b, 100000);
</code></pre>
<p>We would have gotten an error:</p>
<pre><code class="language-Move">    ┌── /scripts/script.move:10:17 ───
    │
 10 │         let _ = Borrow::ref_from_mut_a(mut_a);
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid usage of reference as function argument. Cannot transfer a mutable reference that is being borrowed
    ·
  8 │         let mut_b = Borrow::ref_from_mut_a(mut_a);
    │                     ----------------------------- It is still being mutably borrowed by this reference
    │
</code></pre>
<p>This code won't compile. Why? Because <code>&amp;mut A</code> is <em>being borrowed</em> by <code>&amp;mut B</code>. If we could change <code>A</code> while having mutable reference to its contents, we'd get into an odd situation where <code>A</code> can be changed but reference to its contents is still here. Where would <code>mut_b</code> point to if there was no actual <code>B</code>?</p>
<p>We come to few conclusions:</p>
<ol>
<li>We get a compilation error which means that the Move compiler prevents these cases. It's called <em>borrow checking</em> (originally concept from Rust language). Compiler builds a <em>borrow graph</em> and disallows <em>moving borrowed values</em>. This is one of the reasons why Move is so safe to use in blockchains.</li>
<li>You can create reference from reference, so that original reference will <em>be borrowed</em> by the new one. Mutable and immutable can be created from mutable and only immutable from immutable.</li>
<li>When reference <em>is borrowed</em> it cannot be <em>moved</em> because other values depend on it.</li>
</ol>
<h3><a class="header" href="#dereferencing" id="dereferencing">Dereferencing</a></h3>
<p>References can be dereferenced to get linked value - to do it use asterisk <code>*</code>.</p>
<blockquote>
<p>When dereferencing you're making a <em>copy</em>. Make sure that value has Copy ability.</p>
</blockquote>
<pre><code class="language-Move">module M {
    struct T has copy {}

    // value t here is of reference type
    public fun deref(t: &amp;T): T {
        *t
    }
}
</code></pre>
<blockquote>
<p>Dereference operator does not move original value into current scope. It creates a <em>copy</em> of this value instead.</p>
</blockquote>
<p>There's a technique in Move used to copy inner field of a struct: <code>*&amp;</code> - dereference a reference to the field. Here's a quick example:</p>
<pre><code class="language-Move">module M {
    struct H has copy {}
    struct T { inner: H }

    // ...

    // we can do it even from immutable reference!
    public fun copy_inner(t: &amp;T): H {
        *&amp;t.inner
    }
}
</code></pre>
<p>By using <code>*&amp;</code> (even compiler will advise you to do so) we've copied the inner value of a struct.</p>
<h3><a class="header" href="#referencing-primitive-types" id="referencing-primitive-types">Referencing primitive types</a></h3>
<p>Primitive types (due to their simplicity) do not need to be passed as references and <em>copy</em> operation is done instead. Even if you pass them into function <em>by value</em> they will remain in current scope. You can intentionally use <code>move</code> keyword, but since primitives are very small in size copying them may even be cheaper than passing them by reference or even moving.</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let a = 10;
        M::do_smth(a);
        let _ = a;
    }
}
</code></pre>
<p>This script will compile even though we didn't pass <code>a</code> as a reference. Adding <code>copy</code> is unnecessary - it's already put there by VM.</p>
<h1><a class="header" href="#understanding-generics" id="understanding-generics">Understanding Generics</a></h1>
<p>Generics are essential to Move, they are what makes this language so unique to the blockchain world, and they are the source of Move's flexibility.</p>
<p>To start I'll quote <a href="https://doc.rust-lang.org/stable/book/ch10-00-generics.html">Rust Book</a>: <em>Generics are abstract stand-ins for concrete types or other properties</em>. Practically speaking, they are the way of writing a single function, which can then be used for any type, they can also be called templates as this function can be used as a template handler for any type.</p>
<p>In Move generics can be applied to signatures of <code>struct</code> and <code>function</code>.</p>
<h3><a class="header" href="#in-struct-definition" id="in-struct-definition">In struct definition</a></h3>
<p>First, we'll create a Box which will hold <code>u64</code> value. We've already been through this, so no need for comments.</p>
<pre><code class="language-Move">module Storage {
    struct Box {
        value: u64
    }
}
</code></pre>
<p>This box can only contain value of <code>u64</code> type - this is clear. But what if we wanted to make the same box for <code>u8</code> type or a <code>bool</code>? Would we create type <code>Box1</code> and then <code>Box2</code>? Or would we publish another module for that? The answer is no - use generics instead.</p>
<pre><code class="language-Move">module Storage {
    struct Box&lt;T&gt; {
        value: T
    }
}
</code></pre>
<p>Next to the struct name we've placed <code>&lt;T&gt;</code>. Where angle brackets <code>&lt;..&gt;</code> is a place to define generic types, and <code>T</code> is a type we've <em>templated</em> in this struct. Inside the struct body definition we've used <code>T</code> as a regular type. Type T does not exist, it is a placeholder for <em>any type</em>.</p>
<h3><a class="header" href="#in-function-signature" id="in-function-signature">In function signature</a></h3>
<p>Now let's create a constructor for this struct which will first use type <code>u64</code> for value.</p>
<pre><code class="language-Move">module Storage {
    struct Box&lt;T&gt; {
        value: T
    }

    // type u64 is put into angle brackets meaning
    // that we're using Box with type u64
    public fun create_box(value: u64): Box&lt;u64&gt; {
        Box&lt;u64&gt;{ value }
    }
}
</code></pre>
<p>Generics have a bit more complicated definitions - since they need to have type parameters specified, and regular struct <code>Box</code> becomes <code>Box&lt;u64&gt;</code>. There are no restrictions in what types you can pass into generic's angle brackets. Let's make our <code>create_box</code> method more generic and let users specify any type. How do we do that? By using another generic, now in function signature!</p>
<pre><code class="language-Move">module Storage {
    // ...
    public fun create_box&lt;T&gt;(value: T): Box&lt;T&gt; {
        Box&lt;T&gt; { value }
    }

    // we'll get to this a bit later, trust me
    public fun value&lt;T: copy&gt;(box: &amp;Box&lt;T&gt;): T {
        *&amp;box.value
    }
}
</code></pre>
<h3><a class="header" href="#in-function-calls" id="in-function-calls">In function calls</a></h3>
<p>What we did is we added angle brackets into function signature right after function name. Just the same way as we did with struct. Now how would we use this function? By specifying type in function call.</p>
<pre><code class="language-Move">script {
    use {{sender}}::Storage;
    use 0x1::Debug;

    fun main() {
        // value will be of type Storage::Box&lt;bool&gt;
        let bool_box = Storage::create_box&lt;bool&gt;(true);
        let bool_val = Storage::value(&amp;bool_box);

        assert(bool_val, 0);

        // we can do the same with integer
        let u64_box = Storage::create_box&lt;u64&gt;(1000000);
        let _ = Storage::value(&amp;u64_box);

        // let's do the same with another box!
        let u64_box_in_box = Storage::create_box&lt;Storage::Box&lt;u64&gt;&gt;(u64_box);

        // accessing value of this box in box will be tricky :)
        // Box&lt;u64&gt; is a type and Box&lt;Box&lt;u64&gt;&gt; is also a type
        let value: u64 = Storage::value&lt;u64&gt;(
            &amp;Storage::value&lt;Storage::Box&lt;u64&gt;&gt;( // Box&lt;u64&gt; type
                &amp;u64_box_in_box // Box&lt;Box&lt;u64&gt;&gt; type
            )
        );

        // you've already seen Debug::print&lt;T&gt; method
        // which also uses generics to print any type
        Debug::print&lt;u64&gt;(&amp;value);
    }
}
</code></pre>
<p>Here we have used Box struct with 3 types: <code>bool</code>, <code>u64</code> and with <code>Box&lt;u64&gt;</code> - last one may seem way too complicated but once you've gotten used to it and understood how it works, it becomes part of your routine.</p>
<!-- , Move opens in new way - the way you probably could never imagine in blockchains. -->
<p>Before we go any further, let's take a step back. By adding generics to <code>Box</code> struct we've made this box <em>abstract</em> - its definition is fairly simple compared to capacity it gave us. Now we can create <code>Box</code> with any type - be it <code>u64</code> or <code>address</code>, or even another box, or another struct.</p>
<h3><a class="header" href="#constraints-to-check-abilities" id="constraints-to-check-abilities">Constraints to check Abilities</a></h3>
<p>We've learned about <a href="advanced-topics//advanced-topics/abilities/README.html">abilities</a>. They can be &quot;checked&quot; or <em>constrained</em> in generics; constraints are named after their abilities:</p>
<pre><code class="language-Move">fun name&lt;T: copy&gt;() {} // allow only values that can be copied
fun name&lt;T: copy + drop&gt;() {} // values can be copied and dropped
fun name&lt;T: key + store + drop + copy&gt;() {} // all 4 abilities are present
</code></pre>
<p>...or with structs:</p>
<pre><code class="language-Move">struct name&lt;T: copy + drop&gt; { value: T } // T can be copied and dropped
struct name&lt;T: store&gt; { value: T } // T can be stored in global storage
</code></pre>
<blockquote>
<p>Try to remember this syntax: <code>+</code> (plus) sign may not be intuitive first time; it is the only place in Move where <code>+</code> is used in keyword list.</p>
</blockquote>
<p>Here's an example of a system with constraints:</p>
<pre><code class="language-Move">module Storage {

    // contents of the box can be stored
    struct Box&lt;T: store&gt; has key, store {
        content: T
    }
}
</code></pre>
<p>It is also important to mention that inner types (or generic types) MUST have abilities of the container (for all abilities except <code>key</code>). If you think about it, everything is logical and intuitive: struct with <strong>copy</strong> ability must have contents that also have copy ability otherwise container object cannot be considered copyable. Move compiler will let you compile code that doesn't follow this logic but you won't be able to use these abilities. See this example: </p>
<pre><code class="language-Move">module Storage {
    // non-copyable or droppable struct
    struct Error {}
    
    // constraints are not specified
    struct Box&lt;T&gt; has copy, drop {
        contents: T
    }

    // this method creates box with non-copyable or droppable contents
    public fun create_box(): Box&lt;Error&gt; {
        Box { contents: Error {} }
    }
}
</code></pre>
<p>This code compiles and publishes successfully. But if you try to use it...</p>
<pre><code class="language-Move">script {
    fun main() {
        {{sender}}::Storage::create_box() // value is created and dropped
    }   
}
</code></pre>
<p>You will get an error saying that Box is not droppable:</p>
<pre><code>   ┌── scripts/main.move:5:9 ───
   │
 5 │   Storage::create_box();
   │   ^^^^^^^^^^^^^^^^^^^^^ Cannot ignore values without the 'drop' ability. The value must be used
   │
</code></pre>
<p>That happens because inner value doesn't have drop ability. Container abilities automatically limited by its contents, so, for example if you have a container struct that has copy, drop and store, and inner struct has only drop, it will be impossible to copy or store this container. Another way to look at this is that container doesn't have to have constraints for inner types and can be flexible - used for any type inside.</p>
<blockquote>
<p>But to avoid mistakes always check and, if needed, specify generic constraints in functions and structs. </p>
</blockquote>
<p>In this example safer struct definition could be:</p>
<pre><code class="language-Move">// we add parent's constraints
// now inner type MUST be copyable and droppable
struct Box&lt;T: copy + drop&gt; has copy, drop {
    contents: T
}
</code></pre>
<h3><a class="header" href="#multiple-types-in-generics" id="multiple-types-in-generics">Multiple types in generics</a></h3>
<p>Just like you can use a single type, you can use many. Generic types are put into angle brackets and separated by comma. Let's add a new type <code>Shelf</code> which will hold two boxes of two different types.</p>
<pre><code class="language-Move">module Storage {

    struct Box&lt;T&gt; {
        value: T
    }

    struct Shelf&lt;T1, T2&gt; {
        box_1: Box&lt;T1&gt;,
        box_2: Box&lt;T2&gt;
    }

    public fun create_shelf&lt;Type1, Type2&gt;(
        box_1: Box&lt;Type1&gt;,
        box_2: Box&lt;Type2&gt;
    ): Shelf&lt;Type1, Type2&gt; {
        Shelf {
            box_1,
            box_2
        }
    }
}
</code></pre>
<p>Type parameters for <code>Shelf</code> are listed and matched inside struct's fields definition. Also, as you can see, name of the type parameter inside generics does not matter - it's up to you to choose a proper one. And each type parameter is only valid within definition so no need to match <code>T1</code> or <code>T2</code> with <code>T</code>.</p>
<p>Using multiple generic type parameters is similar to using single:</p>
<pre><code class="language-Move">script {
    use {{sender}}::Storage;

    fun main() {
        let b1 = Storage::create_box&lt;u64&gt;(100);
        let b2 = Storage::create_box&lt;u64&gt;(200);

        // you can use any types - so same ones are also valid
        let _ = Storage::create_shelf&lt;u64, u64&gt;(b1, b2);
    }
}
</code></pre>
<p><em>You can have up to 18,446,744,073,709,551,615 (u64 size) generics in one definition. You definitely will never reach this limit, so feel free to use as many as you need without worrying about limits.</em></p>
<h3><a class="header" href="#unused-type-params" id="unused-type-params">Unused type params</a></h3>
<p>Not every type specified in generic must be used. Look at this example:</p>
<pre><code class="language-Move">module Storage {

    // these two types will be used to mark
    // where box will be sent when it's taken from shelf
    struct Abroad {}
    struct Local {}

    // modified Box will have target property
    struct Box&lt;T, Destination&gt; {
        value: T
    }

    public fun create_box&lt;T, Dest&gt;(value: T): Box&lt;T, Dest&gt; {
        Box { value }
    }
}
</code></pre>
<p>Sometimes it is nice to have generic as a constraint or constant for some action. See how it can be used in script:</p>
<pre><code class="language-Move">
script {
    use {{sender}}::Storage;

    fun main() {
        // value will be of type Storage::Box&lt;bool&gt;
        let _ = Storage::create_box&lt;bool, Storage::Abroad&gt;(true);
        let _ = Storage::create_box&lt;u64, Storage::Abroad&gt;(1000);

        let _ = Storage::create_box&lt;u128, Storage::Local&gt;(1000);
        let _ = Storage::create_box&lt;address, Storage::Local&gt;(0x1);

        // or even u64 destination!
        let _ = Storage::create_box&lt;address, u64&gt;(0x1);
    }
}
</code></pre>
<p>Here we use generics to mark type, but we don't actually use it. You'll soon learn why this definition matters when you get to know resources concept. For now it's just another way to use them.</p>
<!-- ### Copyable

*Copyable kind* - is a kind of types, value of which can be copied. `struct`, `vector` and primitive types - are three main groups of types fitting into this kind.

To understand why Move needs this constraint let's see this example:

```Move
module M {
    public fun deref<T>(t: &T): T {
        *t
    }
}
```

By using *dereference* on a reference you can *copy* the original value and return it as a regular. But what if we've tried to use `resource` in this example? Resource can't be copied, hence this code would fail. Hopefully compiler won't let you compile this type, and kinds exist to manage cases like this.

```Move
module M {
    public fun deref<T: copyable>(t: &T): T {
        *t
    }
}
```

We've added `: copyable` constraint into generic definition, and now type `T` must be of kind *copyable*. So now function accepts only `struct`, `vector` and primitives as type parameters. This code compiles as constraint provides safety over used types and passing non-copyable value here is impossible.

### Resource

Another kind has only one type inside is a `resource` kind. It is used in the same manner:

```Move
module M {
    public fun smth<T: resource>(t: &T) {
        // do smth
    }
}
```

This example here is only needed to show syntax, we'll get to resources soon and you'll learn actual use cases for this constraint. -->
<h1><a class="header" href="#managing-collections-with-vector" id="managing-collections-with-vector">Managing collections with Vector</a></h1>
<p>You're already familiar with the <code>struct</code> type which gives you the ability to create your own types and to store complex data. But sometimes you need something more dynamic, extensible and manageable. And for that Move has Vectors.</p>
<p>Vector is a built-in type for storing <em>collections</em> of data. It is a generic solution for collection of any type (but only one). As its functionality is given to you by the VM; the only way to work with it is by using the <a href="https://github.com/diem/move/tree/main/language/move-stdlib/sources">Move standard library</a> and <code>native</code> functions.</p>
<pre><code class="language-Move">script {
    use 0x1::Vector;

    fun main() {
        // use generics to create an emtpy vector
        let a = Vector::empty&lt;&amp;u8&gt;();
        let i = 0;

        // let's fill it with data
        while (i &lt; 10) {
            Vector::push_back(&amp;mut a, i);
            i = i + 1;
        }

        // now print vector length
        let a_len = Vector::length(&amp;a);
        0x1::Debug::print&lt;u64&gt;(&amp;a_len);

        // then remove 2 elements from it
        Vector::pop_back(&amp;mut a);
        Vector::pop_back(&amp;mut a);

        // and print length again
        let a_len = Vector::length(&amp;a);
        0x1::Debug::print&lt;u64&gt;(&amp;a_len);
    }
}
</code></pre>
<p>Vector can store up to <code>u64</code> number of values of a single non-reference type. To see how it helps managing huge storages let's write a module with it.</p>
<pre><code class="language-Move">module Shelf {

    use 0x1::Vector;

    struct Box&lt;T&gt; {
        value: T
    }

    struct Shelf&lt;T&gt; {
        boxes: vector&lt;Box&lt;T&gt;&gt;
    }

    public fun create_box&lt;T&gt;(value: T): Box&lt;T&gt; {
        Box { value }
    }

    // this method will be inaccessible for non-copyable contents
    public fun value&lt;T: copy&gt;(box: &amp;Box&lt;T&gt;): T {
        *&amp;box.value
    }

    public fun create&lt;T&gt;(): Shelf&lt;T&gt; {
        Shelf {
            boxes: Vector::empty&lt;Box&lt;T&gt;&gt;()
        }
    }

    // box value is moved to the vector
    public fun put&lt;T&gt;(shelf: &amp;mut Shelf&lt;T&gt;, box: Box&lt;T&gt;) {
        Vector::push_back&lt;Box&lt;T&gt;&gt;(&amp;mut shelf.boxes, box);
    }

    public fun remove&lt;T&gt;(shelf: &amp;mut Shelf&lt;T&gt;): Box&lt;T&gt; {
        Vector::pop_back&lt;Box&lt;T&gt;&gt;(&amp;mut shelf.boxes)
    }

    public fun size&lt;T&gt;(shelf: &amp;Shelf&lt;T&gt;): u64 {
        Vector::length&lt;Box&lt;T&gt;&gt;(&amp;shelf.boxes)
    }
}
</code></pre>
<p>We'll create a shelf, few boxes for it and see how to work with vector in module:</p>
<pre><code class="language-Move">script {
    use {{sender}}::Shelf;

    fun main() {

        // create shelf and 2 boxes of type u64
        let shelf = Shelf::create&lt;u64&gt;();
        let box_1 = Shelf::create_box&lt;u64&gt;(99);
        let box_2 = Shelf::create_box&lt;u64&gt;(999);

        // put both boxes to shelf
        Shelf::put(&amp;mut shelf, box_1);
        Shelf::put(&amp;mut shelf, box_2);

        // prints size - 2
        0x1::Debug::print&lt;u64&gt;(&amp;Shelf::size&lt;u64&gt;(&amp;shelf));

        // then take one from shelf (last one pushed)
        let take_back = Shelf::remove(&amp;mut shelf);
        let value     = Shelf::value&lt;u64&gt;(&amp;take_back);

        // verify that the box we took back is one with 999
        assert(value == 999, 1);

        // and print size again - 1
        0x1::Debug::print&lt;u64&gt;(&amp;Shelf::size&lt;u64&gt;(&amp;shelf));
    }
}
</code></pre>
<p>Vectors are very powerful. They allow you to store huge amounts of data (max length is <em>18446744073709551615</em>) and to work with it inside indexed storage.</p>
<h3><a class="header" href="#hex-and-bytestring-literal-for-inline-vector-definitions" id="hex-and-bytestring-literal-for-inline-vector-definitions">Hex and Bytestring literal for inline vector definitions</a></h3>
<p>Vector is also <em>meant</em> to represent strings. VM supports way of passing <code>vector&lt;u8&gt;</code> as argument into <code>main</code> function in script.</p>
<p>But you can also use hexadecimal literal do define a <code>vector&lt;u8&gt;</code> in your script or a module:</p>
<pre><code class="language-Move">script {

    use 0x1::Vector;

    // this is the way to accept arguments in main
    fun main(name: vector&lt;u8&gt;) {
        let _ = name;

        // and this is how you use literals
        // this is a &quot;hello world&quot; string!
        let str = x&quot;68656c6c6f20776f726c64&quot;;

        // hex literal gives you vector&lt;u8&gt; as well
        Vector::length&lt;u8&gt;(&amp;str);
    }
}
</code></pre>
<p>Simpler approach is to use bytestring literals:</p>
<pre><code class="language-Move">script {

    fun main() {
        let _ = b&quot;hello world&quot;;
    }
}
</code></pre>
<p>They are treated as ASCII strings and are also interpreted as <code>vector&lt;u8&gt;</code>.</p>
<h3><a class="header" href="#vector-cheatsheet" id="vector-cheatsheet">Vector cheatsheet</a></h3>
<p>Here's a short cheatsheet for Vector methods from standard library:</p>
<ul>
<li>Create an empty vector of type <code>&lt;E&gt;</code></li>
</ul>
<pre><code class="language-Move">Vector::empty&lt;E&gt;(): vector&lt;E&gt;;
</code></pre>
<ul>
<li>Get length of a vector</li>
</ul>
<pre><code class="language-Move">Vector::length&lt;E&gt;(v: &amp;vector&lt;E&gt;): u64;
</code></pre>
<ul>
<li>Push element to the end of the vector:</li>
</ul>
<pre><code class="language-Move">Vector::push_back&lt;E&gt;(v: &amp;mut vector&lt;E&gt;, e: E);
</code></pre>
<ul>
<li>Get mutable reference to element of vector. For immutable borrow use <code>Vector::borrow()</code></li>
</ul>
<pre><code>Vector::borrow_mut&lt;E&gt;(v: &amp;mut vector&lt;E&gt;, i: u64): &amp;E;
</code></pre>
<ul>
<li>Pop an element from the end of vector:</li>
</ul>
<pre><code>Vector::pop_back&lt;E&gt;(v: &amp;mut vector&lt;E&gt;): E;
</code></pre>
<p>Vector module in the Move standard library: <a href="https://github.com/diem/move/blob/main/language/move-stdlib/sources/Vector.move">link</a></p>
<h1><a class="header" href="#programmable-resources" id="programmable-resources">Programmable Resources</a></h1>
<p>In this section we'll finally learn key feature of Move - resources. They are what makes Move unique, safe and powerful.</p>
<p>To start, let's go through key points from diem developers website (source page was removed after renaming Libra to Diem):</p>
<blockquote>
<ol>
<li>The key feature of Move is the ability to define custom resource types. <em>Resource types are used to encode safe digital assets with rich programmability</em>.</li>
<li><em>Resources are ordinary values in the language</em>. They can be stored as data structures, passed as arguments to procedures, returned from procedures, and so on.</li>
</ol>
</blockquote>
<p>Resource is a special type of <em>structure</em>, and it is possible to define and create new (or use existing) resource right in the Move code. Therefore you're able to manage digital assets the same way you use any other data (like vector or struct).</p>
<blockquote>
<ol start="3">
<li><em>The Move type system provides special safety guarantees for resources</em>. Move resources can never be duplicated, reused, or discarded. A resource type can only be created or destroyed by the module that defines the type. These guarantees are enforced statically by the Move virtual machine via bytecode verification. The Move virtual machine will refuse to run code that has not passed through the bytecode verifier.</li>
</ol>
</blockquote>
<p>In <a href="resources//advanced-topics/ownership-and-references.html">references and ownership chapter</a> you've seen how Move secures scopes and controls variable's owner scope. And in <a href="resources//advanced-topics/understanding-generics.html">generics chapter</a> you've learned that there's a special way of kind-matching to separate <em>copyable</em> and <em>non-copyable</em> types. All of these features provide safety for resource type.</p>
<blockquote>
<ol start="4">
<li>All Diem currencies are implemented using the generic Diem::T type. For example: the LBR currency is represented as <code>Diem::T&lt;LBR::T&gt;</code> and a hypothetical USD currency would be represented as <code>Diem::T&lt;USD::T&gt;</code>. Diem::T has no special status in the language; every Move resource enjoys the same protections.</li>
</ol>
</blockquote>
<p>Just like the Diem currency, other currencies or other types of assets can be represented in Move.</p>
<h3><a class="header" href="#further-reading-3" id="further-reading-3">Further reading</a></h3>
<ul>
<li><a href="https://developers.diem.com/docs/technical-papers/move-paper/">Move whitepaper</a></li>
</ul>
<h1><a class="header" href="#sender-as-signer" id="sender-as-signer">Sender as Signer</a></h1>
<p>Before we get to how to use resources, you need to learn about <code>signer</code> type, and why this type exists.</p>
<blockquote>
<p>Signer is a native non-copyable (resource-like) type which holds address of transaction sender.</p>
</blockquote>
<p>Signer type represents sender authority. In other words - using signer means accessing sender's address and resources. It has no direct relation to <em>signatures</em> or literally <em>signing</em>, in terms of Move VM it simply represents sender.</p>
<blockquote>
<p>Signer type has only one ability - Drop.</p>
</blockquote>
<!-- Important! `0x1::Transaction::sender()` may soon be deprecated [as mentioned here](https://community.libra.org/t/signer-type-and-move-to/2894). So in the future using `signer` will be the only way to get sender's address. -->
<h3><a class="header" href="#signer-in-scripts" id="signer-in-scripts">Signer in scripts</a></h3>
<p>Since signer is a native type, it has to be created. Though unlike <code>vector</code> it cannot be directly created in code, but can be received as a script argument:</p>
<pre><code class="language-Move">script {
    // signer is an owned value
    fun main(account: signer) {
        let _ = account;
    }
}
</code></pre>
<p>Signer argument is put into your scripts automatically by VM, which means that there's no way nor need to pass it into script manually. One more thing - it's always a <em>reference</em>. Even though standard library (in case of Diem it's - <a href="https://github.com/diem/diem/blob/master/language/stdlib/modules/DiemAccount.move">DiemAccount</a>) has access to actual value of signer, functions using this value are private and there's no way to use or pass signer value anywhere else.</p>
<blockquote>
<p>Currently, canonical name of the variable holding signer type is <em>account</em></p>
</blockquote>
<h3><a class="header" href="#signer-module-in-standard-library" id="signer-module-in-standard-library">Signer module in standard library</a></h3>
<p>Native types require native functions, and for signer type it is <code>0x1::Signer</code>. This module is fairly simple (<a href="https://github.com/diem/diem/blob/master/language/diem-framework/modules/Signer.move">link to original module in diem</a>):</p>
<pre><code class="language-Move">module Signer {
    // Borrows the address of the signer
    // Conceptually, you can think of the `signer`
    // as being a resource struct wrapper arround an address
    // ```
    // resource struct Signer { addr: address }
    // ```
    // `borrow_address` borrows this inner field
    native public fun borrow_address(s: &amp;signer): &amp;address;

    // Copies the address of the signer
    public fun address_of(s: &amp;signer): address {
        *borrow_address(s)
    }
}
</code></pre>
<p>As you can see, there're 2 methods, one of which is native and the other one is more handy as it copies address with dereference operator.</p>
<p>Usage of this module is just as simple:</p>
<pre><code class="language-Move">script {
    fun main(account: signer) {
        let _ : address = 0x1::Signer::address_of(&amp;account);
    }
}
</code></pre>
<h3><a class="header" href="#signer-in-module" id="signer-in-module">Signer in module</a></h3>
<pre><code class="language-Move">module M {
    use 0x1::Signer;

    // let's proxy Signer::address_of
    public fun get_address(account: signer): address {
        Signer::address_of(&amp;account)
    }
}
</code></pre>
<blockquote>
<p>Methods using <code>&amp;signer</code> type as argument explicitly show that they are using sender's address.</p>
</blockquote>
<p>One of the reasons for this type was to show which methods require sender authority and which ones don't. So method cannot trick user into unauthorized access to its resources.</p>
<!--  MAYBE ADD HISTORY OF THIS TYPE? -->
<h3><a class="header" href="#further-reading-and-prs" id="further-reading-and-prs">Further reading and PRs</a></h3>
<ul>
<li><a href="https://community.diem.com/t/signer-type-and-move-to/2894">Diem Community thread on signer</a></li>
<li><a href="https://github.com/diem/diem/issues/3679">Issue in Diem repository with reasoning</a></li>
<li><a href="https://github.com/diem/diem/pull/3819">PR in Diem repository</a></li>
</ul>
<h1><a class="header" href="#what-is-resource" id="what-is-resource">What is Resource</a></h1>
<p>Resource is a concept described in Move Whitepaper. Originally it was implemented as its own type but later, with addition of abilities, replaced with two abilities: <code>Key</code> and <code>Store</code>. Resource is meant to be a perfect type for storing digital assets, to achieve that it must to be non-copyable and non-droppable. At the same time it must be storable and transferable between accounts.</p>
<h3><a class="header" href="#definition-1" id="definition-1">Definition</a></h3>
<p>Resource is a struct that has only <code>key</code> and <code>store</code> abilities:</p>
<pre><code class="language-Move">module M {
    struct T has key, store {
        field: u8
    }
}
</code></pre>
<h3><a class="header" href="#key-and-store-abilities" id="key-and-store-abilities">Key and Store abilities</a></h3>
<p>Key ability allows struct to be used as a storage identifier. In other words, <code>key</code> is an ability to be stored as at top-level and be a storage; while <code>store</code> is the ability to be stored <em>under</em> key. You will see how it works in the next chapter. For now keep in mind that even primitive types have store ability - they can be stored, but yet they don't have <code>key</code> and cannot be used as a top-level containers.</p>
<p>Store ability allows value to be stored. That simple.</p>
<h3><a class="header" href="#resource-concept" id="resource-concept">Resource concept</a></h3>
<p>Originally resource had its own type in Move, but with addition of abilities it became a more abstract concept that can be implemented with <em>key</em> and/or <em>store</em> abilities. Let's still go through description for a resource:</p>
<ol>
<li>Resources is stored under account - therefore it <em>exists</em> only when assigned to account; and can only be <em>accessed</em> through this account;</li>
<li>Account can hold <em>only one</em> resource of <em>one type</em>, and this resource must have <code>key</code> ability;</li>
<li>Resource can't be copied nor dropped, but can be stored.</li>
<li>Resource value <em>must be used</em>. When resource created or taken from account, it cannot be dropped and must be stored or destructured.</li>
</ol>
<p>Enough theory, let's get to action!</p>
<h1><a class="header" href="#resource-by-example" id="resource-by-example">Resource by Example</a></h1>
<p>In this section you'll finally learn how to use resources. We'll go through the process of defining a resource and methods to work with it, and in the end you'll get a full contract which you can then use as a template.</p>
<p>We'll create a Collection contract, which will allow us to:</p>
<ul>
<li>start a collection</li>
<li>add and take items from collection</li>
<li>destroy collection</li>
</ul>
<p>Let's begin!</p>
<!-- - offer collectibles to other users
- allow using this module with any type -->
<!-- For better understanding of this chapter I recommend you using Move IDE (which has already been presented in [getting started chapter](/introduction/getting-started.md)) and running all of these modules and scripts in it. It will also highlight possible errors and will automatically sync with standard library to verify that you're using correct methods and addresses.

Directory structure for your project would be:

```
modules/
    Collection.move
scripts/
    use_collection.move
.mvconfig.json
```

And recommended configuration in .mvconfig is:

```json
{
    "sender": "0x1",
    "network": "diem"
}
``` -->
<h1><a class="header" href="#creating-and-moving-resource" id="creating-and-moving-resource">Creating and Moving Resource</a></h1>
<p>First, let's create our module:</p>
<pre><code class="language-Move">// modules/Collection.move
module Collection {


    struct Item has store {
        // we'll think of the properties later
    }

    struct Collection has key {
        items: vector&lt;Item&gt;
    }
}
</code></pre>
<blockquote>
<p>There's a convention to call main resource of a module after the module (e.g. Collection::Collection). If you follow it, your modules will be easy to read and use by other people.</p>
</blockquote>
<h3><a class="header" href="#create-and-move" id="create-and-move">Create and Move</a></h3>
<p>We've defined a struct <code>Collection</code> with <em>Key</em> ability, which will hold vector of type <code>Item</code>. Now let's see how to start new collection and how <em>to store a resource under account</em>. Stored resource in this implementation will live forever under sender's address. No one can modify or take this resource from owner.</p>
<pre><code class="language-Move">// modules/Collection.move
module Collection {

    use 0x1::Vector;

    struct Item has store {}

    struct Collection has key {
        items: vector&lt;Item&gt;
    }

    /// note that &amp;signer type is passed here!
    public fun start_collection(account: &amp;signer) {
        move_to&lt;Collection&gt;(account, Collection {
            items: Vector::empty&lt;Collection&gt;()
        })
    }
}
</code></pre>
<p>Remember <a href="resources/resource-by-example//resources/signer-type.html">signer</a>? Now you see how it in action! To <em>move</em> resource to account you have built-in function <em>move_to</em> which takes <code>signer</code> as a first argument and <code>Collection</code> as second. Signature of <code>move_to</code> function can be represented like:</p>
<pre><code class="language-Move">
native fun move_to&lt;T: key&gt;(account: &amp;signer, value: T);

</code></pre>
<p>That leads to two conclusions:</p>
<ol>
<li>You can only put a resource under your account. You cannot have access to <code>signer</code> value of another account, hence cannot put resource there.</li>
<li>Only one resource of single type can be stored under one address. Doing the same operation twice would lead to discarding existing resource and this must not happen (imagine you have your coins stored and by inaccurate action you discard all your savings by pushing empty balance!). Second attempt to create existing resource will fail with error.</li>
</ol>
<h3><a class="header" href="#check-existence-at-address" id="check-existence-at-address">Check existence at address</a></h3>
<p>To check if resource exists at given address Move has <code>exists</code> function, which signature looks similar to this.</p>
<pre><code class="language-Move">
native fun exists&lt;T: key&gt;(addr: address): bool;
    
</code></pre>
<p>By using generics this function is made type-independent and you can use any resource type to check if it exists at address. Actually, anyone can check if resource exists at given address. But checking existence is not accessing stored value!</p>
<p>Let's write a function to check if user already has collection:</p>
<pre><code class="language-Move">// modules/Collection.move
module Collection {

    struct Item has store, drop {}

    struct Collection has store, key {
        items: Item
    }

    // ... skipped ...

    /// this function will check if resource exists at address
    public fun exists_at(at: address): bool {
        exists&lt;Collection&gt;(at)
    }
}
</code></pre>
<hr />
<p>Now you know how to create a resource, how to move it to sender and how to check if resource already exists. It's time to learn to read this resource and to modify it!</p>
<h1><a class="header" href="#read-and-modify-resource" id="read-and-modify-resource">Read and Modify Resource</a></h1>
<p>To read and modify resource Move has two more built-in functions. Their names perfectly match their goals: <code>borrow_global</code> and <code>borrow_global_mut</code>.</p>
<h2><a class="header" href="#immutable-borrow-with-borrow_global" id="immutable-borrow-with-borrow_global">Immutable borrow with <code>borrow_global</code></a></h2>
<p>In <a href="resources/resource-by-example//advanced-topics/ownership-and-references.html">ownership and references chapter</a> you've got to know mutable (&amp;mut) and immutable references. It's time to put this knowledge to practice!</p>
<pre><code class="language-Move">// modules/Collection.move
module Collection {

    // added a dependency here!
    use 0x1::Signer;
    use 0x1::Vector;

    struct Item has store, drop {}
    struct Collection has key, store {
        items: vector&lt;Item&gt;
    }

    // ... skipped ...

    /// get collection size
    /// mind keyword acquires!
    public fun size(account: &amp;signer): u64 acquires Collection {
        let owner = Signer::address_of(account);
        let collection = borrow_global&lt;Collection&gt;(owner);

        Vector::length(&amp;collection.items)
    }
}
</code></pre>
<p>A lot has happened here. First, let's deal with method signature. Global function <code>borrow_global&lt;T&gt;</code> gives a immutable reference to resource T. It's signature is like:</p>
<pre><code class="language-Move">
native fun borrow_global&lt;T: key&gt;(addr: address): &amp;T;

</code></pre>
<p>By using this function we get <em>read access</em> to resource stored at specific address. Which means that module has capability to read any of its resources at any addresses (if this functionality is implemented).</p>
<p>Another conclusion: due to borrow checking you cannot return reference to resource nor to its contents (as original reference to resource will die on scope end).</p>
<blockquote>
<p>Since resource is a non-copyable type, it is impossible to use dereference operator '*' on it.</p>
</blockquote>
<h3><a class="header" href="#acquires-keyword" id="acquires-keyword">Acquires keyword</a></h3>
<p>There's another detail worth explanation: keyword <code>acquires</code> which is put after function return value. This keyword explicitly defines all the resources <em>acquired</em> by this function. You must specify each acquired resource, even if it's a nested function call actually acquires resource - parent scope must have this resource specified in acquires list.</p>
<p>Syntax for function with <code>acquires</code> is like this:</p>
<pre><code class="language-Move">
fun &lt;name&gt;(&lt;args...&gt;): &lt;ret_type&gt; acquires T, T1 ... {

</code></pre>
<h2><a class="header" href="#mutable-borrow-with-borrow_global_mut" id="mutable-borrow-with-borrow_global_mut">Mutable borrow with <code>borrow_global_mut</code></a></h2>
<p>To get mutable reference to resource, add <code>_mut</code> to your <code>borrow_global</code> and that's all. Let's add a function to add new (currently empty) item to collection.</p>
<pre><code class="language-Move">module Collection {

    // ... skipped ...

    public fun add_item(account: &amp;signer) acquires T {
        let collection = borrow_global_mut&lt;T&gt;(Signer::address_of(account));

        Vector::push_back(&amp;mut collection.items, Item {});
    }
}
</code></pre>
<p>Mutable reference to resource allows creating mutable references to its contents. That is why we're able to modify inner vector <code>items</code> in this example.</p>
<p>Signature for <code>borrow_global_mut</code> is:</p>
<pre><code class="language-Move">
native fun borrow_global_mut&lt;T: key&gt;(addr: address): &amp;mut T;

</code></pre>
<h1><a class="header" href="#take-and-destroy-resource" id="take-and-destroy-resource">Take and Destroy Resource</a></h1>
<p>Final function of this section is <code>move_from</code> which takes resource from account. We'll implement <code>destroy</code> function which will move collection resource <em>from</em> account and will destroy its contents.</p>
<pre><code class="language-Move">// modules/Collection.move
module Collection {

    // ... skipped ...

    public fun destroy(account: &amp;signer) acquires Collection {

        // account no longer has resource attached
        let collection = move_from&lt;Collection&gt;(Signer::address_of(account));

        // now we must use resource value - we'll destructure it
        // look carefully - Items must have drop ability
        let Collection { items: _ } = collection;

        // done. resource destroyed
    }
}
</code></pre>
<p>Resource value must be used. So resource, when taken from account, must be either destructured or passed as return value. However keep in mind that even if you pass this value outside and get it in the script, there are limited options of what to do next as script context does not allow you to do anything with struct or resource except passing it somewhere else. Knowing that - design your modules properly and give user an option to do something with returned resource.</p>
<p>The very last signature:</p>
<pre><code class="language-Move">
native fun move_from&lt;T: key&gt;(addr: address): T;

</code></pre>
<h1><a class="header" href="#further-steps" id="further-steps">Further Steps</a></h1>
<p>In this section you've seen how resource restrictions are represented in Move syntax. You've also learned how to create, check, access, modify and destroy resources. This part is supposed to be last in the book. However you can modify this module to your needs and think of these options:</p>
<ol>
<li>Try to modify this module to support any type with generics;</li>
<li>Look through <a href="https://github.com/starcoinorg/starcoin/blob/master/vm/stdlib/modules/Offer.move">Offer module</a> and think of a way to offer collection to another account.</li>
</ol>
<p>Full code of module Collection can be found <a href="https://github.com/damirka/move-book/blob/master/samples/">on GitHub</a>.</p>
<h1><a class="header" href="#tutorials" id="tutorials">Tutorials</a></h1>
<p>In this section you'll find tutorials which will cover basic usages of Move language and will demonstrate its capabilities.</p>
<h1><a class="header" href="#writing-erc20-token" id="writing-erc20-token">Writing ERC20 Token</a></h1>
<p>To be done...</p>
<h1><a class="header" href="#translations" id="translations">Translations</a></h1>
<p>Book is also available in other languages:</p>
<ul>
<li><a href="https://move-book.com/cn">Chinese</a> (by <a href="https://starcoin.org/">Starcoin team</a>)</li>
</ul>
<h2><a class="header" href="#contribute" id="contribute">Contribute</a></h2>
<p>If you notice any typos or mistakes or willing to contribute, feel free to submit an issue or a PR on <a href="https://github.com/damirka/move-book">GitHub</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-183817972-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
