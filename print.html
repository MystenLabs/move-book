<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Move Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap" rel="stylesheet">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-B1E7R0BHX4"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-B1E7R0BHX4');
        </script>

        <meta name="description" content="First book about the Move programming language and the Move VM. Move documentation, Move tutorials and language reference.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> The Move Book</a></li><li class="chapter-item expanded "><a href="foreword.html"><strong aria-hidden="true">2.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="before-we-begin/index.html"><strong aria-hidden="true">3.</strong> Before we begin</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="before-we-begin/install-sui.html"><strong aria-hidden="true">3.1.</strong> Install Sui</a></li><li class="chapter-item expanded "><a href="before-we-begin/ide-support.html"><strong aria-hidden="true">3.2.</strong> Set up your IDE</a></li><li class="chapter-item expanded "><a href="before-we-begin/move-2024.html"><strong aria-hidden="true">3.3.</strong> Move 2024</a></li></ol></li><li class="chapter-item expanded "><a href="your-first-move/hello-world.html"><strong aria-hidden="true">4.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="your-first-move/hello-sui.html"><strong aria-hidden="true">5.</strong> Hello, Sui!</a></li><li class="chapter-item expanded "><a href="concepts/index.html"><strong aria-hidden="true">6.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/packages.html"><strong aria-hidden="true">6.1.</strong> Package</a></li><li class="chapter-item expanded "><a href="concepts/manifest.html"><strong aria-hidden="true">6.2.</strong> Manifest</a></li><li class="chapter-item expanded "><a href="concepts/address.html"><strong aria-hidden="true">6.3.</strong> Address</a></li><li class="chapter-item expanded "><a href="concepts/what-is-an-account.html"><strong aria-hidden="true">6.4.</strong> Account</a></li><li class="chapter-item expanded "><a href="concepts/what-is-a-transaction.html"><strong aria-hidden="true">6.5.</strong> Transaction</a></li></ol></li><li class="chapter-item expanded "><a href="move-basics/index.html"><strong aria-hidden="true">7.</strong> Move Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="move-basics/module.html"><strong aria-hidden="true">7.1.</strong> Module</a></li><li class="chapter-item expanded "><a href="move-basics/comments.html"><strong aria-hidden="true">7.2.</strong> Comments</a></li><li class="chapter-item expanded "><a href="move-basics/primitive-types.html"><strong aria-hidden="true">7.3.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="move-basics/address.html"><strong aria-hidden="true">7.4.</strong> Address Type</a></li><li class="chapter-item expanded "><a href="move-basics/expression.html"><strong aria-hidden="true">7.5.</strong> Expression</a></li><li class="chapter-item expanded "><a href="move-basics/struct.html"><strong aria-hidden="true">7.6.</strong> Struct</a></li><li class="chapter-item expanded "><a href="move-basics/abilities-introduction.html"><strong aria-hidden="true">7.7.</strong> Abilities: Introduction</a></li><li class="chapter-item expanded "><a href="move-basics/drop-ability.html"><strong aria-hidden="true">7.8.</strong> Ability: Drop</a></li><li class="chapter-item expanded "><a href="move-basics/importing-modules.html"><strong aria-hidden="true">7.9.</strong> Importing Modules</a></li><li class="chapter-item expanded "><a href="move-basics/standard-library.html"><strong aria-hidden="true">7.10.</strong> Standard Library</a></li><li class="chapter-item expanded "><a href="move-basics/vector.html"><strong aria-hidden="true">7.11.</strong> Vector</a></li><li class="chapter-item expanded "><a href="move-basics/option.html"><strong aria-hidden="true">7.12.</strong> Option</a></li><li class="chapter-item expanded "><a href="move-basics/string.html"><strong aria-hidden="true">7.13.</strong> String</a></li><li class="chapter-item expanded "><a href="move-basics/control-flow.html"><strong aria-hidden="true">7.14.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="move-basics/constants.html"><strong aria-hidden="true">7.15.</strong> Constants</a></li><li class="chapter-item expanded "><a href="move-basics/assert-and-abort.html"><strong aria-hidden="true">7.16.</strong> Aborting Execution</a></li><li class="chapter-item expanded "><a href="move-basics/function.html"><strong aria-hidden="true">7.17.</strong> Function</a></li><li class="chapter-item expanded "><a href="move-basics/struct-methods.html"><strong aria-hidden="true">7.18.</strong> Struct Methods</a></li><li class="chapter-item expanded "><a href="move-basics/visibility.html"><strong aria-hidden="true">7.19.</strong> Visibility Modifiers</a></li><li class="chapter-item expanded "><a href="move-basics/ownership-and-scope.html"><strong aria-hidden="true">7.20.</strong> Ownership and Scope</a></li><li class="chapter-item expanded "><a href="move-basics/copy-ability.html"><strong aria-hidden="true">7.21.</strong> Ability: Copy</a></li><li class="chapter-item expanded "><a href="move-basics/references.html"><strong aria-hidden="true">7.22.</strong> References</a></li><li class="chapter-item expanded "><a href="move-basics/generics.html"><strong aria-hidden="true">7.23.</strong> Generics</a></li><li class="chapter-item expanded "><a href="move-basics/type-reflection.html"><strong aria-hidden="true">7.24.</strong> Type Reflection</a></li><li class="chapter-item expanded "><a href="move-basics/testing.html"><strong aria-hidden="true">7.25.</strong> Testing</a></li></ol></li><li class="chapter-item expanded "><a href="object/index.html"><strong aria-hidden="true">8.</strong> Object Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="object/digital-assets.html"><strong aria-hidden="true">8.1.</strong> Language for Digital Assets</a></li><li class="chapter-item expanded "><a href="object/evolution-of-move.html"><strong aria-hidden="true">8.2.</strong> Evolution of Move</a></li><li class="chapter-item expanded "><a href="object/object-model.html"><strong aria-hidden="true">8.3.</strong> What is an Object?</a></li><li class="chapter-item expanded "><a href="object/ownership.html"><strong aria-hidden="true">8.4.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="object/fast-path-and-consensus.html"><strong aria-hidden="true">8.5.</strong> Fast Path & Consensus</a></li></ol></li><li class="chapter-item expanded "><a href="storage/index.html"><strong aria-hidden="true">9.</strong> Using Objects</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="storage/key-ability.html"><strong aria-hidden="true">9.1.</strong> Ability: Key</a></li><li class="chapter-item expanded "><a href="storage/storage-functions.html"><strong aria-hidden="true">9.2.</strong> Storage Functions</a></li><li class="chapter-item expanded "><a href="storage/store-ability.html"><strong aria-hidden="true">9.3.</strong> Ability: Store</a></li><li class="chapter-item expanded "><a href="storage/uid-and-id.html"><strong aria-hidden="true">9.4.</strong> UID and ID</a></li><li class="chapter-item expanded "><a href="storage/transfer-restrictions.html"><strong aria-hidden="true">9.5.</strong> Restricted and Public Transfer</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.6.</strong> Transfer to Object?</div></li></ol></li><li class="chapter-item expanded "><a href="programmability/index.html"><strong aria-hidden="true">10.</strong> Advanced Programmability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programmability/transaction-context.html"><strong aria-hidden="true">10.1.</strong> Transaction Context</a></li><li class="chapter-item expanded "><a href="programmability/module-initializer.html"><strong aria-hidden="true">10.2.</strong> Module Initializer</a></li><li class="chapter-item expanded "><a href="programmability/capability.html"><strong aria-hidden="true">10.3.</strong> Pattern: Capability</a></li><li class="chapter-item expanded "><a href="programmability/epoch-and-time.html"><strong aria-hidden="true">10.4.</strong> Epoch and Time</a></li><li class="chapter-item expanded "><a href="programmability/collections.html"><strong aria-hidden="true">10.5.</strong> Collections</a></li><li class="chapter-item expanded "><a href="programmability/dynamic-fields.html"><strong aria-hidden="true">10.6.</strong> Dynamic Fields</a></li><li class="chapter-item expanded "><a href="programmability/dynamic-object-fields.html"><strong aria-hidden="true">10.7.</strong> Dynamic Object Fields</a></li><li class="chapter-item expanded "><a href="programmability/dynamic-collections.html"><strong aria-hidden="true">10.8.</strong> Dynamic Collections</a></li><li class="chapter-item expanded "><a href="programmability/witness-pattern.html"><strong aria-hidden="true">10.9.</strong> Pattern: Witness</a></li><li class="chapter-item expanded "><a href="programmability/one-time-witness.html"><strong aria-hidden="true">10.10.</strong> One Time Witness</a></li><li class="chapter-item expanded "><a href="programmability/publisher.html"><strong aria-hidden="true">10.11.</strong> Publisher Authority</a></li><li class="chapter-item expanded "><a href="programmability/display.html"><strong aria-hidden="true">10.12.</strong> Display</a></li><li class="chapter-item expanded "><a href="programmability/events.html"><strong aria-hidden="true">10.13.</strong> Events</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.14.</strong> Balance & Coin</div></li><li class="chapter-item expanded "><a href="programmability/sui-framework.html"><strong aria-hidden="true">10.15.</strong> Sui Framework</a></li><li class="chapter-item expanded "><a href="programmability/hot-potato-pattern.html"><strong aria-hidden="true">10.16.</strong> Pattern: Hot Potato</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.17.</strong> Pattern: Request</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.18.</strong> Pattern: Object Capability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.19.</strong> Package Upgrades</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.20.</strong> Transaction Blocks</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.21.</strong> Authorization Patterns</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.22.</strong> Cryptography and Hashing</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.23.</strong> Randomness</div></li><li class="chapter-item expanded "><a href="programmability/bcs.html"><strong aria-hidden="true">10.24.</strong> BCS</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Guides</li><li class="chapter-item expanded "><a href="guides/2024-migration-guide.html"><strong aria-hidden="true">11.</strong> 2024 Migration Guide</a></li><li class="chapter-item expanded "><a href="guides/upgradeability-practices.html"><strong aria-hidden="true">12.</strong> Upgradability Practices</a></li><li class="chapter-item expanded "><a href="guides/building-against-limits.html"><strong aria-hidden="true">13.</strong> Building against Limits</a></li><li class="chapter-item expanded "><a href="guides/better-error-handling.html"><strong aria-hidden="true">14.</strong> Better error handling</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Open-sourcing Libraries</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Creating an NFT Collection</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Tests with Objects</div></li><li class="chapter-item expanded "><a href="guides/coding-conventions.html"><strong aria-hidden="true">18.</strong> Coding Conventions</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="appendix/glossary.html"><strong aria-hidden="true">19.</strong> A - Glossary</a></li><li class="chapter-item expanded "><a href="appendix/reserved-addresses.html"><strong aria-hidden="true">20.</strong> B - Reserved Addresses</a></li><li class="chapter-item expanded "><a href="appendix/publications.html"><strong aria-hidden="true">21.</strong> C - Publications</a></li><li class="chapter-item expanded "><a href="appendix/contributing.html"><strong aria-hidden="true">22.</strong> D - Contributing</a></li><li class="chapter-item expanded "><a href="appendix/acknowledgements.html"><strong aria-hidden="true">23.</strong> E - Acknowledgements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Move Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MystenLabs/move-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-move-book"><a class="header" href="#the-move-book">The Move Book</a></h1>
<!-- TODO: insert author(s) -->
<p>This is the Move Book - a comprehensive guide to the Move programming language and the Sui blockchain. The book is intended for developers who are interested in learning about Move and building on Sui.</p>
<div class="warning">
<p>The book is in active development and a work in progress. If you have any feedback or suggestions, feel free to open an issue or a pull request on the <a href="https://github.com/MystenLabs/move-book">GitHub repository</a>.</p>
</div>
<blockquote>
<p>If you're looking for The Move Reference, you can find it <a href="/reference">here</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>This book is dedicated to Move, a smart contract language that captures the essence of safe
programming with digital assets. Move is designed around the following values:</p>
<ol>
<li>
<p><strong>Secure by default:</strong> Insecure languages are a serious barrier both to accessible smart contract
development and to mainstream adoption of digital assets. The first duty of a smart contract
language is to prevent as many potential safety issues as possible (e.g. re-entrancy, missing
access control checks, arithmetic overflow, ...) by construction. Any changes to Move should
preserve or enhance its existing security guarantees.</p>
</li>
<li>
<p><strong>Expressive by nature:</strong> Move must enable programmers to write any smart contract they can
imagine. But we care as much about the way it <em>feels</em> to write Move as we do about what Move
allows you to do - the language should be rich enough that the features needed for a task are
available, and minimal enough that the choice is obvious. The Move toolchain should be a
productivity enhancer and a thought partner.</p>
</li>
<li>
<p><strong>Intuitive for all:</strong> Smart contracts are only one part of a useful application. Move should
understand the broader context of its usage and design with both the smart contract developer and
the application developer in mind. It should be easy for developers to learn how to read
Move-managed state, build Move powered transactions, and write new Move code.</p>
</li>
</ol>
<p>The core technical elements of Move are:</p>
<ul>
<li>Safe, familiar, and flexible abstractions for digital assets via programmable <em>objects</em>.</li>
<li>A rich <em>ability</em> system (inspired by linear types) that gives programmers extreme control of how
values are created, destroyed, stored, copied, and transferred.</li>
<li>A <em>module</em> system with strong encapsulation features to enable code reuse while maintaining this
control.</li>
<li><em>Dynamic fields</em> for creating hierarchical relationships between objects.</li>
<li><em>Programmable transaction blocks</em> (PTBs) to enable atomic client-side composition of Move-powered
APIs.</li>
</ul>
<p>Move was born in 2018 as part of Facebook's Libra project. It was publicly revealed in 2019, the
first Move-powered network launched in 2020. As of April 2024, there are numerous Move-powered
chains in production with several more in the works. Move is an embedded language with a
platform-agnostic core, which means it takes on a slightly different personality in each chain that
uses it.</p>
<p>Creating a new programming language and bootstrapping a community around it is an ambitious, long
term project. A language has to be an order of magnitude better than alternatives in relevant ways
to have a chance, but even then the quality of the community matters more than the technical
fundamentals. Move is a young language, but it's off to a good start in terms of both
differentiation and community. A small, but fanatical group of smart contract programmers and core
contributors united by the Move values are pushing the boundaries of what smart contracts can do,
the applications they can enable, and who can (safely) write them. If that inspires you, read on!</p>
<p>— Sam Blackshear, creator of Move</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="before-we-begin"><a class="header" href="#before-we-begin">Before we begin</a></h1>
<p>Move requires an environment to run and develop applications, and in this small chapter we will
cover the prerequisites for the Move language: how to set up your IDE, how to install the compiler
and what is Move 2024. If you are already familiar with these topics or have a CLI installed, you
can skip this chapter and proceed to <a href="before-we-begin/../your-first-move/hello-world.html">the next one</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-sui"><a class="header" href="#install-sui">Install Sui</a></h1>
<p>Move is a compiled language, so you need to install a compiler to be able to write and run Move
programs. The compiler is included into the Sui binary, which can be installed or downloaded using
one of the methods below.</p>
<h2 id="download-binary"><a class="header" href="#download-binary">Download Binary</a></h2>
<p>You can download the latest Sui binary from the
<a href="https://github.com/MystenLabs/sui/releases">releases page</a>. The binary is available for macOS,
Linux and Windows. For education purposes and development, we recommend using the <code>mainnet</code> version.</p>
<h2 id="install-using-homebrew-macos"><a class="header" href="#install-using-homebrew-macos">Install using Homebrew (MacOS)</a></h2>
<p>You can install Sui using the <a href="https://brew.sh/">Homebrew</a> package manager.</p>
<pre><code class="language-bash">brew install sui
</code></pre>
<h2 id="install-using-chocolatey-windows"><a class="header" href="#install-using-chocolatey-windows">Install using Chocolatey (Windows)</a></h2>
<p>You can install Sui using the <a href="https://chocolatey.org/install">Chocolatey</a> package manager for
Windows.</p>
<pre><code class="language-bash">choco install sui
</code></pre>
<h2 id="build-using-cargo-macos-linux"><a class="header" href="#build-using-cargo-macos-linux">Build using Cargo (MacOS, Linux)</a></h2>
<p>You can install and build Sui locally by using the Cargo package manager (requires Rust)</p>
<pre><code class="language-bash">cargo install --git https://github.com/MystenLabs/sui.git --bin sui --branch mainnet
</code></pre>
<p>Make sure that your system has the latest Rust versions with the command below.</p>
<pre><code class="language-bash">rustup update stable
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p>For troubleshooting the installation process, please refer to the
<a href="https://docs.sui.io/guides/developer/getting-started/sui-install">Install Sui</a> Guide.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set-up-your-ide"><a class="header" href="#set-up-your-ide">Set up your IDE</a></h1>
<p>There are two most popular IDEs for Move development: VSCode and IntelliJ IDEA. Both of them provide
basic features like syntax highlighting and error messages, though they differ in their additional
features. Whatever IDE you choose, you'll need to use the terminal to run the
<a href="before-we-begin/./install-sui.html">Move CLI</a>.</p>
<blockquote>
<p><strong>IntelliJ Plugin does not support Move 2024 edition, some syntax won't get highlighted.</strong></p>
</blockquote>
<h2 id="vscode"><a class="header" href="#vscode">VSCode</a></h2>
<ul>
<li><a href="https://code.visualstudio.com/">VSCode</a> is a free and open source IDE from Microsoft.</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=mysten.move">Move (Extension)</a> is a language
server extension for Move maintained by <a href="https://mystenlabs.com">MystenLabs</a>.</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax">Move Syntax</a> a simple
syntax highlighting extension for Move by <a href="https://github.com/damirka/">Damir Shamanaev</a>.</li>
</ul>
<h2 id="intellij-idea"><a class="header" href="#intellij-idea">IntelliJ IDEA</a></h2>
<ul>
<li><a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a> is a commercial IDE from JetBrains.</li>
<li><a href="https://plugins.jetbrains.com/plugin/14721-move-language">Move Language Plugin</a> provides a Move
language extension for IntelliJ IDEA by <a href="https://pontem.network/">Pontem Network</a>.</li>
</ul>
<h2 id="emacs"><a class="header" href="#emacs">Emacs</a></h2>
<ul>
<li><a href="https://www.gnu.org/software/emacs/">Emacs</a> is a free and open source text editor.</li>
<li><a href="https://github.com/amnn/move-mode">move-mode</a> is a Move mode for Emacs by
<a href="https://github.com/amnn">Ashok Menon</a>.</li>
</ul>
<h2 id="github-codespaces"><a class="header" href="#github-codespaces">Github Codespaces</a></h2>
<p>The Web-based IDE from Github can be run right in the browser and provides almost a full-featured
VSCode experience.</p>
<ul>
<li><a href="https://github.com/features/codespaces">Github Codespaces</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax">Move Syntax</a> is also
available in the extensions marketplace.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-2024"><a class="header" href="#move-2024">Move 2024</a></h1>
<p>Move 2024 is the new edition of the Move language maintained by Mysten Labs. All of the examples in
this book are written in Move 2024. If you're used to the pre-2024 version of Move, please, refer to
the <a href="before-we-begin/./../guides/2024-migration-guide.html">Move 2024 Migration Guide</a> to learn about the changes and
improvements in the new edition.</p>
<!-- Notes ? -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h1>
<p>In this chapter, you will learn how to create a new package, write a simple module, compile it, and
run tests with the Move CLI. Make sure you have <a href="your-first-move/./../before-we-begin/install-sui.html">installed Sui</a>
and set up your <a href="your-first-move/./../before-we-begin/ide-support.html">IDE environment</a>. Run the command below to
test if Sui has been installed correctly.</p>
<pre><code class="language-bash"># It should print the client version. E.g. sui-client 1.22.0-036299745.
sui client --version
</code></pre>
<blockquote>
<p>Move CLI is a command-line interface for the Move language; it is built into the Sui binary and
provides a set of commands to manage packages, compile and test code.</p>
</blockquote>
<p>The structure of the chapter is as follows:</p>
<ul>
<li><a href="your-first-move/hello-world.html#create-a-new-package">Create a New Package</a></li>
<li><a href="your-first-move/hello-world.html#directory-structure">Directory Structure</a></li>
<li><a href="your-first-move/hello-world.html#compiling-the-package">Compiling the Package</a></li>
<li><a href="your-first-move/hello-world.html#running-tests">Running Tests</a></li>
</ul>
<h2 id="create-a-new-package"><a class="header" href="#create-a-new-package">Create a New Package</a></h2>
<p>To create a new program, we will use the <code>sui move new</code> command followed by the name of the
application. Our first program will be called <code>hello_world</code>.</p>
<blockquote>
<p>Note: In this and other chapters, if you see code blocks with lines starting with <code>$</code> (dollar
sign), it means that the following command should be run in a terminal. The sign should not be
included. It's a common way of showing commands in terminal environments.</p>
</blockquote>
<pre><code class="language-bash">$ sui move new hello_world
</code></pre>
<p>The <code>sui move</code> command gives access to the Move CLI - a built-in compiler, test runner and a utility
for all things Move. The <code>new</code> command followed by the name of the package will create a new package
in a new folder. In our case, the folder name is &quot;hello_world&quot;.</p>
<p>We can view the contents of the folder to see that the package was created successfully.</p>
<pre><code class="language-bash">$ ls -l hello_world
Move.toml
sources
tests
</code></pre>
<h2 id="directory-structure"><a class="header" href="#directory-structure">Directory Structure</a></h2>
<p>Move CLI will create a scaffold of the application and pre-create the directory structure and all
necessary files. Let's see what's inside.</p>
<pre><code class="language-plaintext">hello_world
├── Move.toml
├── sources
│   └── hello_world.move
└── tests
    └── hello_world_tests.move
</code></pre>
<h3 id="manifest"><a class="header" href="#manifest">Manifest</a></h3>
<p>The <code>Move.toml</code> file, known as the <a href="your-first-move/./../concepts/manifest.html">package manifest</a>, contains
definitions and configuration settings for the package. It is used by the Move Compiler to manage
package metadata, fetch dependencies, and register named addresses. We will explain it in detail in
the <a href="your-first-move/./../concepts">Concepts</a> chapter.</p>
<blockquote>
<p>By default, the package features one named address - the name of the package.</p>
</blockquote>
<pre><code class="language-toml">[addresses]
hello_world = &quot;0x0&quot;
</code></pre>
<h3 id="sources"><a class="header" href="#sources">Sources</a></h3>
<p>The <code>sources/</code> directory contains the source files. Move source files have <em>.move</em> extension, and
are typically named after the module defined in the file. For example, in our case, the file name is
<em>hello_world.move</em> and the Move CLI has already placed commented out code inside:</p>
<pre><code class="language-move">/*
/// Module: hello_world
module hello_world::hello_world {

}
*/
</code></pre>
<blockquote>
<p>The <code>/*</code> and <code>*/</code> are the comment delimiters in Move. Everything in between is ignored by the
compiler and can be used for documentation or notes. We explain all ways to comment the code in
the <a href="your-first-move/./../move-basics/comments.html">Basic Syntax</a>.</p>
</blockquote>
<p>The commented out code is a module definition, it starts with the keyword <code>module</code> followed by a
named address (or an address literal), and the module name. The module name is a unique identifier
for the module and has to be unique within the package. The module name is used to reference the
module from other modules or transactions.</p>
<!-- And the module name has to be a valid Move identifier: alphanumeric with underscores to separate words. A common convention is to call modules (and functions) in snake_case - all lowercase, with underscores. Coding conventions are important for readability and maintainability of the code, we summarize them in the Coding Conventions section. -->
<h3 id="tests"><a class="header" href="#tests">Tests</a></h3>
<p>The <code>tests/</code> directory contains package tests. The compiler excludes these files in the regular
build process but uses them in <em>test</em> and <em>dev</em> modes. The tests are written in Move and are marked
with the <code>#[test]</code> attribute. Tests can be grouped in a separate module (then it's usually called
<em>module_name_tests.move</em>), or inside the module they're testing.</p>
<p>Modules, imports, constants and functions can be annotated with <code>#[test_only]</code>. This attribute is
used to exclude modules, functions or imports from the build process. This is useful when you want to
add helpers for your tests without including them in the code that will be published on chain.</p>
<p>The <em>hello_world_tests.move</em> file contains a commented out test module template:</p>
<pre><code class="language-move">/*
#[test_only]
module hello_world::hello_world_tests {
    // uncomment this line to import the module
    // use hello_world::hello_world;

    const ENotImplemented: u64 = 0;

    #[test]
    fun test_hello_world() {
        // pass
    }

    #[test, expected_failure(abort_code = hello_world::hello_world_tests::ENotImplemented)]
    fun test_hello_world_fail() {
        abort ENotImplemented
    }
}
*/
</code></pre>
<h3 id="other-folders"><a class="header" href="#other-folders">Other Folders</a></h3>
<p>Additionally, Move CLI supports the <code>examples/</code> folder. The files there are treated similarly to the
ones placed under the <code>tests/</code> folder - they're only built in the <em>test</em> and <em>dev</em> modes. They are
to be examples of how to use the package or how to integrate it with other packages. The most
popular use case is for documentation purposes and library packages.</p>
<h2 id="compiling-the-package"><a class="header" href="#compiling-the-package">Compiling the Package</a></h2>
<p>Move is a compiled language, and as such, it requires the compilation of source files into Move
Bytecode. It contains only necessary information about the module, its members, and types, and
excludes comments and some identifiers (for example, for constants).</p>
<p>To demonstrate these features, let's replace the contents of the <em>sources/hello_world.move</em> file
with the following:</p>
<pre><code class="language-move">/// The module `hello_world` under named address `hello_world`.
/// The named address is set in the `Move.toml`.
module hello_world::hello_world {
    // Imports the `String` type from the Standard Library
    use std::string::String;

    /// Returns the &quot;Hello, World!&quot; as a `String`.
    public fun hello_world(): String {
        b&quot;Hello, World!&quot;.to_string()
    }
}
</code></pre>
<p>During compilation, the code is built, but not run. A compiled package only includes functions that
can be called by other modules or in a transaction. We will explain these concepts in the
<a href="your-first-move/./../concepts">Concepts</a> chapter. But now, let's see what happens when we run the <em>sui move build</em>.</p>
<pre><code class="language-bash"># run from the `hello_world` folder
$ sui move build

# alternatively, if you didn't `cd` into it
$ sui move build --path hello_world
</code></pre>
<p>It should output the following message on your console.</p>
<pre><code class="language-plaintext">UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING hello_world
</code></pre>
<p>During the compilation, Move Compiler automatically creates a build folder where it places all
fetched and compiled dependencies as well as the bytecode for the modules of the current package.</p>
<blockquote>
<p>If you're using a versioning system, such as Git, build folder should be ignored. For example, you
should use a <code>.gitignore</code> file and add <code>build</code> to it.</p>
</blockquote>
<h2 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h2>
<p>Before we get to testing, we should add a test. Move Compiler supports tests written in Move and
provides the execution environment. The tests can be placed in both the source files and in the
<code>tests/</code> folder. Tests are marked with the <code>#[test]</code> attribute and are automatically discovered by
the compiler. We explain tests in depth in the <a href="your-first-move/./../move-basics/testing.html">Testing</a> section.</p>
<p>Replace the contents of the <code>tests/hello_world_tests.move</code> with the following content:</p>
<pre><code class="language-move">#[test_only]
module hello_world::hello_world_tests {
    use hello_world::hello_world;

    #[test]
    fun test_hello_world() {
        assert!(hello_world::hello_world() == b&quot;Hello, World!&quot;.to_string(), 0);
    }
}
</code></pre>
<p>Here we import the <code>hello_world</code> module, and call its <code>hello_world</code> function to test that the output
is indeed the string &quot;Hello, World!&quot;. Now, that we have tests in place, let's compile the package in
the test mode and run tests. Move CLI has the <code>test</code> command for this:</p>
<pre><code class="language-bash">$ sui move test
</code></pre>
<p>The output should be similar to the following:</p>
<pre><code class="language-plaintext">INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING hello_world
Running Move unit tests
[ PASS    ] 0x0::hello_world_tests::test_hello_world
Test result: OK. Total tests: 1; passed: 1; failed: 0
</code></pre>
<p>If you're running the tests outside of the package folder, you can specify the path to the package:</p>
<pre><code class="language-bash">$ sui move test --path hello_world
</code></pre>
<p>You can also run a single or multiple tests at once by specifying a string. All the tests names
containing the string will be run:</p>
<pre><code class="language-bash">$ sui move test test_hello
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>In this section, we explained the basics of a Move package: its structure, the manifest, the build,
and test flows. <a href="your-first-move/./hello-sui.html">On the next page</a>, we will write an application and see how the
code is structured and what the language can do.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><a href="your-first-move/./../concepts/manifest.html">Package Manifest</a> section</li>
<li>Package in <a href="your-first-move//reference/packages.html">The Move Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-sui"><a class="header" href="#hello-sui">Hello, Sui!</a></h1>
<p>In the <a href="your-first-move/./hello-world.html">previous section</a> we created a new package and demonstrated the basic flow
of creating, building, and testing a Move package. In this section, we will write a simple
application that uses the storage model and can be interacted with. To do this, we will create a
simple todo list application.</p>
<h2 id="create-a-new-package-1"><a class="header" href="#create-a-new-package-1">Create a New Package</a></h2>
<p>Following the same flow as in <a href="your-first-move/./hello-world.html">Hello, World!</a>, we will create a new package called
<code>todo_list</code>.</p>
<pre><code class="language-bash">$ sui move new todo_list
</code></pre>
<h2 id="add-the-code"><a class="header" href="#add-the-code">Add the code</a></h2>
<p>To speed things up and focus on the application logic, we will provide the code for the todo list
application. Replace the contents of the <em>sources/todo_list.move</em> file with the following code:</p>
<blockquote>
<p>Note: while the contents may seem overwhelming at first, we will break it down in the following
sections. Try to focus on what's at hand right now.</p>
</blockquote>
<pre><code class="language-move">/// Module: todo_list
module todo_list::todo_list {
    use std::string::String;

    /// List of todos. Can be managed by the owner and shared with others.
    public struct TodoList has key, store {
        id: UID,
        items: vector&lt;String&gt;
    }

    /// Create a new todo list.
    public fun new(ctx: &amp;mut TxContext): TodoList {
        let list = TodoList {
            id: object::new(ctx),
            items: vector[]
        };

        (list)
    }

    /// Add a new todo item to the list.
    public fun add(list: &amp;mut TodoList, item: String) {
        list.items.push_back(item);
    }

    /// Remove a todo item from the list by index.
    public fun remove(list: &amp;mut TodoList, index: u64): String {
        list.items.remove(index)
    }

    /// Delete the list and the capability to manage it.
    public fun delete(list: TodoList) {
        let TodoList { id, items: _ } = list;
        id.delete();
    }

    /// Get the number of items in the list.
    public fun length(list: &amp;TodoList): u64 {
        list.items.length()
    }
}
</code></pre>
<h2 id="build-the-package"><a class="header" href="#build-the-package">Build the package</a></h2>
<p>To make sure that we did everything correctly, let's build the package by running the
<code>sui move build</code> command. If everything is correct, you should see the output similar to the
following:</p>
<pre><code class="language-bash">$ sui move build
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING todo_list
</code></pre>
<p>If there are no errors following this output, you have successfully built the package. If there are
errors, make sure that:</p>
<ul>
<li>The code is copied correctly</li>
<li>The file name and the package name is correct</li>
</ul>
<p>There are not many other reasons for the code to fail at this stage. But if you are still having
issues, try looking up the structure of the package in
<a href="https://github.com/MystenLabs/move-book/tree/main/packages/todo_list">this location</a>.</p>
<h2 id="set-up-an-account"><a class="header" href="#set-up-an-account">Set up an account</a></h2>
<p>To publish and interact with the package, we need to set up an account. For the sake of simplicity
and demonstration purposes, we will use <em>sui devnet</em> environment.</p>
<blockquote>
<p>If you already have an account set up, you can skip this step.</p>
</blockquote>
<p>If you are doing it for the first time, you will need to create a new account. To do this, run the
<code>sui client</code> command, then the CLI will prompt you with multiple questions. The answers are marked
below with <code>&gt;</code>:</p>
<pre><code class="language-bash">$ sui client
Config file [&quot;/path/to/home/.sui/sui_config/client.yaml&quot;] doesn't exist, do you want to connect to a Sui Full node server [y/N]?
&gt; y
Sui Full node server URL (Defaults to Sui Testnet if not specified) :
&gt;
Select key scheme to generate keypair (0 for ed25519, 1 for secp256k1, 2: for secp256r1):
&gt; 0
</code></pre>
<p>After you have answered the questions, the CLI will generate a new keypair and save it to the
configuration file. You can now use this account to interact with the network.</p>
<p>To check that we have the account set up correctly, run the <code>sui client active-address</code> command:</p>
<pre><code class="language-bash">$ sui client active-address
0x....
</code></pre>
<p>The command will output the address of your account, it starts with <code>0x</code> followed by 64 characters.</p>
<h2 id="requesting-coins"><a class="header" href="#requesting-coins">Requesting Coins</a></h2>
<p>In <em>devnet</em> and <em>testnet</em> environments, the CLI provides a way to request coins to your account, so
you can interact with the network. To request coins, run the <code>sui client faucet</code> command:</p>
<pre><code class="language-bash">$ sui client faucet
Request successful. It can take up to 1 minute to get the coin. Run sui client gas to check your gas coins.
</code></pre>
<p>After waiting a little bit, you can check that the Coin object was sent to your account by running
the <code>sui client balance</code> command:</p>
<pre><code class="language-bash">$ sui client balance
╭────────────────────────────────────────╮
│ Balance of coins owned by this address │
├────────────────────────────────────────┤
│ ╭──────────────────────────────────╮   │
│ │ coin  balance (raw)  balance     │   │
│ ├──────────────────────────────────┤   │
│ │ Sui   1000000000    1.00 SUI     │   │
│ ╰──────────────────────────────────╯   │
╰────────────────────────────────────────╯
</code></pre>
<p>Alternatively, you can query <em>objects</em> owned by your account, by running the <code>sui client objects</code>
command. The actual output will be different, because the object ID is unique, and so is digest, but
the structure will be similar:</p>
<pre><code class="language-bash">$ sui client objects
╭───────────────────────────────────────────────────────────────────────────────────────╮
│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │
│ │ objectId   │  0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de  │ │
│ │ version    │  4                                                                   │ │
│ │ digest     │  nA68oa8gab/CdIRw+240wze8u0P+sRe4vcisbENcR4U=                        │ │
│ │ objectType │  0x0000..0002::coin::Coin                                            │ │
│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │
╰───────────────────────────────────────────────────────────────────────────────────────╯
</code></pre>
<p>Now that we have the account set up and the coins in the account, we can interact with the network.
We will start by publishing the package to the network.</p>
<h2 id="publish"><a class="header" href="#publish">Publish</a></h2>
<p>To publish the package to the network, we will use the <code>sui client publish</code> command. The command
will automatically build the package and use its bytecode to publish in a single transaction.</p>
<blockquote>
<p>We are using the <code>--gas-budget</code> argument during publishing. It specifies how much gas we are
willing to spend on the transaction. We won't touch on this topic in this section, but it's
important to know that every transaction in Sui costs gas, and the gas is paid in SUI coins.</p>
</blockquote>
<p>The <code>gas-budget</code> is specified in <em>MISTs</em>. 1 SUI equals 10^9 MISTs. For the sake of demonstration, we
will use 100,000,000 MISTs, which is 0.1 SUI.</p>
<pre><code class="language-bash"># run this from the `todo_list` folder
$ sui client publish --gas-budget 100000000

# alternatively, you can specify path to the package
$ sui client publish --gas-budget 100000000 todo_list
</code></pre>
<p>The output of the publish command is rather lengthy, so we will show and explain it in parts.</p>
<pre><code class="language-bash">$ sui client publish --gas-budget 100000000
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING todo_list
Successfully verified dependencies on-chain against source.
Transaction Digest: GpcDV6JjjGQMRwHpEz582qsd5MpCYgSwrDAq1JXcpFjW
</code></pre>
<p>As you can see, when we run the <code>publish</code> command, the CLI first builds the package, then verifies
the dependencies on-chain, and finally publishes the package. The output of the command is the
transaction digest, which is a unique identifier of the transaction and can be used to query the
transaction status.</p>
<h3 id="transaction-data"><a class="header" href="#transaction-data">Transaction Data</a></h3>
<p>The section titled <code>TransactionData</code> contains the information about the transaction we just sent. It
features fields like <code>sender</code>, which is your address, the <code>gas_budget</code> set with the <code>--gas-budget</code>
argument, and the Coin we used for payment. It also prints the Commands that were run by the CLI. In
this example, the commands <code>Publish</code> and <code>TransferObject</code> were run - the latter transfers a special
object <code>UpgradeCap</code> to the sender.</p>
<pre><code class="language-plaintext">╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Data                                                                                             │
├──────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                   │
│ Gas Owner: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                │
│ Gas Budget: 100000000 MIST                                                                                   │
│ Gas Price: 1000 MIST                                                                                         │
│ Gas Payment:                                                                                                 │
│  ┌──                                                                                                         │
│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                                    │
│  │ Version: 7                                                                                                │
│  │ Digest: AXYPnups8A5J6pkvLa6RekX2ye3qur66EZ88mEbaUDQ1                                                      │
│  └──                                                                                                         │
│                                                                                                              │
│ Transaction Kind: Programmable                                                                               │
│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │
│ │ Input Objects                                                                                            │ │
│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │
│ │ 0   Pure Arg: Type: address, Value: &quot;0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1&quot; │ │
│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │
│ ╭─────────────────────────────────────────────────────────────────────────╮                                  │
│ │ Commands                                                                │                                  │
│ ├─────────────────────────────────────────────────────────────────────────┤                                  │
│ │ 0  Publish:                                                             │                                  │
│ │  ┌                                                                      │                                  │
│ │  │ Dependencies:                                                        │                                  │
│ │  │   0x0000000000000000000000000000000000000000000000000000000000000001 │                                  │
│ │  │   0x0000000000000000000000000000000000000000000000000000000000000002 │                                  │
│ │  └                                                                      │                                  │
│ │                                                                         │                                  │
│ │ 1  TransferObjects:                                                     │                                  │
│ │  ┌                                                                      │                                  │
│ │  │ Arguments:                                                           │                                  │
│ │  │   Result 0                                                           │                                  │
│ │  │ Address: Input  0                                                    │                                  │
│ │  └                                                                      │                                  │
│ ╰─────────────────────────────────────────────────────────────────────────╯                                  │
│                                                                                                              │
│ Signatures:                                                                                                  │
│    gebjSbVwZwTkizfYg2XIuzdx+d66VxFz8EmVaisVFiV3GkDay6L+hQG3n2CQ1hrWphP6ZLc7bd1WRq4ss+hQAQ==                  │
│                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
</code></pre>
<h3 id="transaction-effects"><a class="header" href="#transaction-effects">Transaction Effects</a></h3>
<p>Transaction Effects contains the status of the transaction, the changes that the transaction made to
the state of the network and the objects involved in the transaction.</p>
<pre><code class="language-plaintext">╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Effects                                                                               │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Digest: GpcDV6JjjGQMRwHpEz582qsd5MpCYgSwrDAq1JXcpFjW                                              │
│ Status: Success                                                                                   │
│ Executed Epoch: 411                                                                               │
│                                                                                                   │
│ Created Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0x160f7856e13b27e5a025112f361370f4efc2c2659cb0023f1e99a8a84d1652f3                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │
│  │ Version: 8                                                                                     │
│  │ Digest: 8y6bhwvQrGJHDckUZmj2HDAjfkyVqHohhvY1Fvzyj7ec                                           │
│  └──                                                                                              │
│  ┌──                                                                                              │
│  │ ID: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe                         │
│  │ Owner: Immutable                                                                               │
│  │ Version: 1                                                                                     │
│  │ Digest: Ein91NF2hc3qC4XYoMUFMfin9U23xQmDAdEMSHLae7MK                                           │
│  └──                                                                                              │
│ Mutated Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │
│  │ Version: 8                                                                                     │
│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                           │
│  └──                                                                                              │
│ Gas Object:                                                                                       │
│  ┌──                                                                                              │
│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │
│  │ Version: 8                                                                                     │
│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                           │
│  └──                                                                                              │
│ Gas Cost Summary:                                                                                 │
│    Storage Cost: 10404400 MIST                                                                    │
│    Computation Cost: 1000000 MIST                                                                 │
│    Storage Rebate: 978120 MIST                                                                    │
│    Non-refundable Storage Fee: 9880 MIST                                                          │
│                                                                                                   │
│ Transaction Dependencies:                                                                         │
│    7Ukrc5GqdFqTA41wvWgreCdHn2vRLfgQ3YMFkdks72Vk                                                   │
│    7d4amuHGhjtYKujEs9YkJARzNEn4mRbWWv3fn4cdKdyh                                                   │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
</code></pre>
<h3 id="events"><a class="header" href="#events">Events</a></h3>
<p>If there were any <em>events</em> emitted, you would see them in this section. Our package does not use
events, so the section is empty.</p>
<pre><code class="language-plaintext">╭─────────────────────────────╮
│ No transaction block events │
╰─────────────────────────────╯
</code></pre>
<h3 id="object-changes"><a class="header" href="#object-changes">Object Changes</a></h3>
<p>These are the changes to <em>objects</em> that transaction has made. In our case, we have <em>created</em> a new
<code>UpgradeCap</code> object which is a special object that allows the sender to upgrade the package in the
future, <em>mutated</em> the Gas object, and <em>published</em> a new package. Packages are also objects on Sui.</p>
<pre><code class="language-plaintext">╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                   │
├──────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Created Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: 0x160f7856e13b27e5a025112f361370f4efc2c2659cb0023f1e99a8a84d1652f3                  │
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                    │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 ) │
│  │ ObjectType: 0x2::package::UpgradeCap                                                          │
│  │ Version: 8                                                                                    │
│  │ Digest: 8y6bhwvQrGJHDckUZmj2HDAjfkyVqHohhvY1Fvzyj7ec                                          │
│  └──                                                                                             │
│ Mutated Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                  │
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                    │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 ) │
│  │ ObjectType: 0x2::coin::Coin&lt;0x2::sui::SUI&gt;                                                    │
│  │ Version: 8                                                                                    │
│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                          │
│  └──                                                                                             │
│ Published Objects:                                                                               │
│  ┌──                                                                                             │
│  │ PackageID: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe                 │
│  │ Version: 1                                                                                    │
│  │ Digest: Ein91NF2hc3qC4XYoMUFMfin9U23xQmDAdEMSHLae7MK                                          │
│  │ Modules: todo_list                                                                            │
│  └──                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────╯
</code></pre>
<h3 id="balance-changes"><a class="header" href="#balance-changes">Balance Changes</a></h3>
<p>This last section contains changes to SUI Coins, in our case, we have <em>spent</em> around 0.015 SUI,
which in MIST is 10,500,000. You can see it under the <em>amount</em> field in the output.</p>
<pre><code class="language-plaintext">╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Balance Changes                                                                                   │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│  ┌──                                                                                              │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │
│  │ CoinType: 0x2::sui::SUI                                                                        │
│  │ Amount: -10426280                                                                              │
│  └──                                                                                              │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
</code></pre>
<h3 id="alternative-output"><a class="header" href="#alternative-output">Alternative Output</a></h3>
<p>It is possible to specify the <code>--json</code> flag during publishing to get the output in JSON format. This
is useful if you want to parse the output programmatically or store it for later use.</p>
<pre><code class="language-bash">$ sui client publish --gas-budget 100000000 --json
</code></pre>
<h3 id="using-the-results"><a class="header" href="#using-the-results">Using the Results</a></h3>
<p>After the package is published on chain, we can interact with it. To do this, we need to find the
address (object ID) of the package. It's under the <code>Published Objects</code> section of the
<code>Object Changes</code> output. The address is unique for each package, so you will need to copy it from
the output.</p>
<p>In this example, the address is:</p>
<pre><code class="language-plaintext">0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe
</code></pre>
<p>Now that we have the address, we can interact with the package. In the next section, we will show
how to interact with the package by sending transactions.</p>
<h2 id="sending-transactions"><a class="header" href="#sending-transactions">Sending Transactions</a></h2>
<p>To demonstrate the interaction with the <code>todo_list</code> package, we will send a transaction to create a
new list and add an item to it. Transactions are sent via the <code>sui client ptb</code> command, it allows
using the <a href="your-first-move/./../concepts/what-is-a-transaction.html">Transaction Blocks</a> at full capacity. The command
may look big and complex, but we go through it step by step.</p>
<h3 id="prepare-the-variables"><a class="header" href="#prepare-the-variables">Prepare the Variables</a></h3>
<p>Before we construct the command, let's store the values we will use in the transaction. Replace the
<code>0x4....</code> with the address of the package you have published. And <code>MY_ADDRESS</code> variable will be
automatically set to your address from the CLI output.</p>
<pre><code class="language-bash">$ export PACKAGE_ID=0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe
$ export MY_ADDRESS=$(sui client active-address)
</code></pre>
<h3 id="building-the-transaction-in-cli"><a class="header" href="#building-the-transaction-in-cli">Building the Transaction in CLI</a></h3>
<p>Now to building an actual transaction. The transaction will consist of two parts: we will call the
<code>new</code> function in the <code>todo_list</code> package to create a new list, and then we will transfer the list
object to our account. The transaction will look like this:</p>
<pre><code class="language-bash">$ sui client ptb \
--gas-budget 100000000 \
--assign sender @$MY_ADDRESS \
--move-call $PACKAGE_ID::todo_list::new \
--assign list \
--transfer-objects &quot;[list]&quot; sender
</code></pre>
<p>In this command, we are using the <code>ptb</code> subcommand to build a transaction. Parameters that follow it
define the actual commands and actions that the transaction will perform. The first two calls we
make are utility calls to set the sender address to the command inputs and set the gas budget for
the transaction.</p>
<pre><code class="language-bash"># sets the gas budget for the transaction
--gas-budget 100000000 \n
# registers a variable &quot;sender=@...&quot;
--assign sender @$MY_ADDRESS \n
</code></pre>
<p>Then we perform the actual call to a function in the package. We use the <code>--move-call</code> followed by
the package ID, the module name, and the function name. In this case, we are calling the <code>new</code>
function in the <code>todo_list</code> package.</p>
<pre><code class="language-bash"># calls the &quot;new&quot; function in the &quot;todo_list&quot; package under the $PACKAGE_ID address
--move-call $PACKAGE_ID::todo_list::new
</code></pre>
<p>The function that we defined actually returns a value, which we want need to store. We use the
<code>--assign</code> command to give a name to the returned value. In this case, we are calling it <code>list</code>. And
then we transfer the object to our account.</p>
<pre><code class="language-bash">--move-call $PACKAGE_ID::todo_list::new \
# assigns the result of the &quot;new&quot; function to the &quot;list&quot; variable (from the previous step)
--assign list \
# transfers the object to the sender
--transfer-objects &quot;[list]&quot; sender
</code></pre>
<p>Once the command is constructed, you can run it in the terminal. If everything is correct, you
should see the output similar to the one we had in previous sections. The output will contain the
transaction digest, the transaction data, and the transaction effects.</p>
<details>
<summary><a style="cursor:pointer">Spoiler: Full transaction output</a></summary>
<pre><code class="language-bash">Transaction Digest: BJwYEnuuMzU4Y8cTwMoJbbQA6cLwPmwxvsRpSmvThoK8
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Data                                                                                             │
├──────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                   │
│ Gas Owner: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                │
│ Gas Budget: 100000000 MIST                                                                                  │
│ Gas Price: 1000 MIST                                                                                         │
│ Gas Payment:                                                                                                 │
│  ┌──                                                                                                         │
│  │ ID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                                    │
│  │ Version: 22                                                                                               │
│  │ Digest: DiBrBMshDiD9cThpaEgpcYSF76uV4hCoE1qRyQ3rnYCB                                                      │
│  └──                                                                                                         │
│                                                                                                              │
│ Transaction Kind: Programmable                                                                               │
│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │
│ │ Input Objects                                                                                            │ │
│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │
│ │ 0   Pure Arg: Type: address, Value: &quot;0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1&quot; │ │
│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │
│ ╭──────────────────────────────────────────────────────────────────────────────────╮                         │
│ │ Commands                                                                         │                         │
│ ├──────────────────────────────────────────────────────────────────────────────────┤                         │
│ │ 0  MoveCall:                                                                     │                         │
│ │  ┌                                                                               │                         │
│ │  │ Function:  new                                                                │                         │
│ │  │ Module:    todo_list                                                          │                         │
│ │  │ Package:   0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe │                         │
│ │  └                                                                               │                         │
│ │                                                                                  │                         │
│ │ 1  TransferObjects:                                                              │                         │
│ │  ┌                                                                               │                         │
│ │  │ Arguments:                                                                    │                         │
│ │  │   Result 0                                                                    │                         │
│ │  │ Address: Input  0                                                             │                         │
│ │  └                                                                               │                         │
│ ╰──────────────────────────────────────────────────────────────────────────────────╯                         │
│                                                                                                              │
│ Signatures:                                                                                                  │
│    C5Lie4dtP5d3OkKzFBa+xM0BiNoB/A4ItthDCRTRBUrEE+jXeNs7mP4AuGwi3nzfTskh29+R1j1Kba4Wdy3QDA==                  │
│                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Effects                                                                               │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Digest: BJwYEnuuMzU4Y8cTwMoJbbQA6cLwPmwxvsRpSmvThoK8                                              │
│ Status: Success                                                                                   │
│ Executed Epoch: 1213                                                                              │
│                                                                                                   │
│ Created Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0x74973c4ea2e78dc409f60481e23761cee68a48156df93a93fbcceb77d1cacdf6                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │
│  │ Version: 23                                                                                    │
│  │ Digest: DuHTozDHMsuA7cFnWRQ1Gb8FQghAEBaj3inasJxqYq1c                                           │
│  └──                                                                                              │
│ Mutated Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │
│  │ Version: 23                                                                                    │
│  │ Digest: 82fwKarGuDhtomr5oS6ZGNvZNw9QVXLSbPdQu6jQgNV7                                           │
│  └──                                                                                              │
│ Gas Object:                                                                                       │
│  ┌──                                                                                              │
│  │ ID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │
│  │ Version: 23                                                                                    │
│  │ Digest: 82fwKarGuDhtomr5oS6ZGNvZNw9QVXLSbPdQu6jQgNV7                                           │
│  └──                                                                                              │
│ Gas Cost Summary:                                                                                 │
│    Storage Cost: 2318000 MIST                                                                     │
│    Computation Cost: 1000000 MIST                                                                 │
│    Storage Rebate: 978120 MIST                                                                    │
│    Non-refundable Storage Fee: 9880 MIST                                                          │
│                                                                                                   │
│ Transaction Dependencies:                                                                         │
│    FSz2fYXmKqTf77mFXNq5JK7cKY8agWja7V5yDKEgL8c3                                                   │
│    GgMZKTt482DYApbAZkPDtdssGHZLbxgjm2uMXhzJax8Q                                                   │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────╮
│ No transaction block events │
╰─────────────────────────────╯

╭───────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                        │
├───────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Created Objects:                                                                                      │
│  ┌──                                                                                                  │
│  │ ObjectID: 0x74973c4ea2e78dc409f60481e23761cee68a48156df93a93fbcceb77d1cacdf6                       │
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )      │
│  │ ObjectType: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList  │
│  │ Version: 23                                                                                        │
│  │ Digest: DuHTozDHMsuA7cFnWRQ1Gb8FQghAEBaj3inasJxqYq1c                                               │
│  └──                                                                                                  │
│ Mutated Objects:                                                                                      │
│  ┌──                                                                                                  │
│  │ ObjectID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                       │
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )      │
│  │ ObjectType: 0x2::coin::Coin&lt;0x2::sui::SUI&gt;                                                         │
│  │ Version: 23                                                                                        │
│  │ Digest: 82fwKarGuDhtomr5oS6ZGNvZNw9QVXLSbPdQu6jQgNV7                                               │
│  └──                                                                                                  │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Balance Changes                                                                                   │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│  ┌──                                                                                              │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │
│  │ CoinType: 0x2::sui::SUI                                                                        │
│  │ Amount: -2339880                                                                               │
│  └──                                                                                              │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
</code></pre>
</details>
<p>The section that we want to focus on is the &quot;Object Changes&quot;. More specifically, the &quot;Created
Objects&quot; part of it. It contains the object ID, the type and the version of the <code>TodoList</code> that you
have created. We will use this object ID to interact with the list.</p>
<pre><code class="language-bash">╭───────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                        │
├───────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Created Objects:                                                                                      │
│  ┌──                                                                                                  │
│  │ ObjectID: 0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553                       │
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )      │
│  │ ObjectType: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList  │
│  │ Version: 22                                                                                        │
│  │ Digest: HyWdUpjuhjLY38dLpg6KPHQ3bt4BqQAbdF5gB8HQdEqG                                               │
│  └──                                                                                                  │
│ Mutated Objects:                                                                                      │
│  ┌──                                                                                                  │
│  │ ObjectID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                       │
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )      │
│  │ ObjectType: 0x2::coin::Coin&lt;0x2::sui::SUI&gt;                                                         │
│  │ Version: 22                                                                                        │
│  │ Digest: DiBrBMshDiD9cThpaEgpcYSF76uV4hCoE1qRyQ3rnYCB                                               │
│  └──                                                                                                  │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────╯
</code></pre>
<p>In this example the object ID is
<code>0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553</code>. And the owner should be your
account address. We achieved this by transferring the object to the sender in the last command of
the transaction.</p>
<p>Another way to test that you have successfully created the list is to check the account objects.</p>
<pre><code class="language-bash">$ sui client objects
</code></pre>
<p>It should have an object that looks similar to this:</p>
<pre><code class="language-plaintext">╭  ...                                                                                  ╮
│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │
│ │ objectId   │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553  │ │
│ │ version    │  22                                                                  │ │
│ │ digest     │  /DUEiCLkaNSgzpZSq2vSV0auQQEQhyH9occq9grMBZM=                        │ │
│ │ objectType │  0x468d..29fe::todo_list::TodoList                                   │ │
│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │
|  ...                                                                                  |
</code></pre>
<h3 id="passing-objects-to-functions"><a class="header" href="#passing-objects-to-functions">Passing Objects to Functions</a></h3>
<p>The TodoList that we created in the previous step is an object that you can interact with as its
owner. You can call functions defined in the <code>todo_list</code> module on this object. To demonstrate this,
we will add an item to the list. First, we will add just one item, and in the second transaction we
will add 3 and remove another one.</p>
<p>Double check that you have variables set up <a href="your-first-move/hello-sui.html#prepare-the-variables">from the previous step</a>, and
then add one more variable for the list object.</p>
<pre><code class="language-bash">$ export LIST_ID=0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553
</code></pre>
<p>Now we can construct the transaction to add an item to the list. The command will look like this:</p>
<pre><code class="language-bash">$ sui client ptb \
--gas-budget 100000000 \
--move-call $PACKAGE_ID::todo_list::add @$LIST_ID &quot;'Finish the Hello, Sui chapter'&quot;
</code></pre>
<p>In this command, we are calling the <code>add</code> function in the <code>todo_list</code> package. The function takes
two arguments: the list object and the item to add. The item is a string, so we need to wrap it in
single quotes. The command will add the item to the list.</p>
<p>If everything is correct, you should see the output similar to the one we had in previous sections.
Now you can check the list object to see if the item was added.</p>
<pre><code class="language-bash">$ sui client object $LIST_ID
</code></pre>
<p>The output should contain the item that you have added.</p>
<pre><code class="language-plaintext">╭───────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ objectId      │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553                                               │
│ version       │  24                                                                                                               │
│ digest        │  FGcXH8MGpMs5BdTnC62CQ3VLAwwexYg2id5DKU7Jr9aQ                                                                     │
│ objType       │  0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList                          │
│ owner         │ ╭──────────────┬──────────────────────────────────────────────────────────────────────╮                           │
│               │ │ AddressOwner │  0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1  │                           │
│               │ ╰──────────────┴──────────────────────────────────────────────────────────────────────╯                           │
│ prevTx        │  EJVK6FEHtfTdCuGkNsU1HcrmUBEN6H6jshfcptnw8Yt1                                                                     │
│ storageRebate │  1558000                                                                                                          │
│ content       │ ╭───────────────────┬───────────────────────────────────────────────────────────────────────────────────────────╮ │
│               │ │ dataType          │  moveObject                                                                               │ │
│               │ │ type              │  0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList  │ │
│               │ │ hasPublicTransfer │  true                                                                                     │ │
│               │ │ fields            │ ╭───────┬───────────────────────────────────────────────────────────────────────────────╮ │ │
│               │ │                   │ │ id    │ ╭────┬──────────────────────────────────────────────────────────────────────╮ │ │ │
│               │ │                   │ │       │ │ id │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553  │ │ │ │
│               │ │                   │ │       │ ╰────┴──────────────────────────────────────────────────────────────────────╯ │ │ │
│               │ │                   │ │ items │ ╭─────────────────────────────────╮                                           │ │ │
│               │ │                   │ │       │ │  finish the Hello, Sui chapter  │                                           │ │ │
│               │ │                   │ │       │ ╰─────────────────────────────────╯                                           │ │ │
│               │ │                   │ ╰───────┴───────────────────────────────────────────────────────────────────────────────╯ │ │
│               │ ╰───────────────────┴───────────────────────────────────────────────────────────────────────────────────────────╯ │
╰───────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
</code></pre>
<p>A JSON representation of the object can be obtained by adding the <code>--json</code> flag to the command.</p>
<pre><code class="language-bash">$ sui client object $LIST_ID --json
</code></pre>
<pre><code class="language-json">{
  &quot;objectId&quot;: &quot;0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553&quot;,
  &quot;version&quot;: &quot;24&quot;,
  &quot;digest&quot;: &quot;FGcXH8MGpMs5BdTnC62CQ3VLAwwexYg2id5DKU7Jr9aQ&quot;,
  &quot;type&quot;: &quot;0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList&quot;,
  &quot;owner&quot;: {
    &quot;AddressOwner&quot;: &quot;0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1&quot;
  },
  &quot;previousTransaction&quot;: &quot;EJVK6FEHtfTdCuGkNsU1HcrmUBEN6H6jshfcptnw8Yt1&quot;,
  &quot;storageRebate&quot;: &quot;1558000&quot;,
  &quot;content&quot;: {
    &quot;dataType&quot;: &quot;moveObject&quot;,
    &quot;type&quot;: &quot;0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList&quot;,
    &quot;hasPublicTransfer&quot;: true,
    &quot;fields&quot;: {
      &quot;id&quot;: {
        &quot;id&quot;: &quot;0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553&quot;
      },
      &quot;items&quot;: [&quot;Finish the Hello, Sui chapter&quot;]
    }
  }
}
</code></pre>
<h3 id="chaining-commands"><a class="header" href="#chaining-commands">Chaining Commands</a></h3>
<p>You can chain multiple commands in a single transaction. This shows the power of Transaction Blocks!
Using the same list object, we will add three more items and remove one. The command will look like
this:</p>
<pre><code class="language-bash">$ sui client ptb \
--gas-budget 100000000 \
--move-call $PACKAGE_ID::todo_list::add @$LIST_ID &quot;'Finish Concepts chapter'&quot; \
--move-call $PACKAGE_ID::todo_list::add @$LIST_ID &quot;'Read the Move Basics chapter'&quot; \
--move-call $PACKAGE_ID::todo_list::add @$LIST_ID &quot;'Learn about Object Model'&quot; \
--move-call $PACKAGE_ID::todo_list::remove @$LIST_ID 0
</code></pre>
<p>If previous commands were successful, this one should not be any different. You can check the list
object to see if the items were added and removed. The JSON representation is a bit more readable!</p>
<pre><code class="language-bash">sui client object $LIST_ID --json
</code></pre>
<pre><code class="language-json">{
  &quot;objectId&quot;: &quot;0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553&quot;,
  &quot;version&quot;: &quot;25&quot;,
  &quot;digest&quot;: &quot;EDTXDsteqPGAGu4zFAj5bbQGTkucWk4hhuUquk39enGA&quot;,
  &quot;type&quot;: &quot;0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList&quot;,
  &quot;owner&quot;: {
    &quot;AddressOwner&quot;: &quot;0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1&quot;
  },
  &quot;previousTransaction&quot;: &quot;7SXLGBSh31jv8G7okQ9mEgnw5MnTfvzzHEHpWf3Sa9gY&quot;,
  &quot;storageRebate&quot;: &quot;1922800&quot;,
  &quot;content&quot;: {
    &quot;dataType&quot;: &quot;moveObject&quot;,
    &quot;type&quot;: &quot;0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList&quot;,
    &quot;hasPublicTransfer&quot;: true,
    &quot;fields&quot;: {
      &quot;id&quot;: {
        &quot;id&quot;: &quot;0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553&quot;
      },
      &quot;items&quot;: [
        &quot;Finish Concepts chapter&quot;,
        &quot;Read the Move Basics chapter&quot;,
        &quot;Learn about Object Model&quot;
      ]
    }
  }
}
</code></pre>
<p>Commands don't have to be in the same package or operate on the same object. Within a single
transaction block, you can interact with multiple packages and objects. This is a powerful feature
that allows you to build complex interactions on-chain!</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this guide, we have shown how to publish a package on the Move blockchain and interact with it
using the Sui CLI. We have demonstrated how to create a new list object, add items to it, and remove
them. We have also shown how to chain multiple commands in a single transaction block. This guide
should give you a good starting point for building your own applications on the Sui blockchain!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>In this chapter you will learn about the basic concepts of Sui and Move. You will learn what is a
package, how to interact with it, what is an account and a transaction, and how data is stored on
Sui. While this chapter is not a complete reference, and you should refer to the
<a href="https://docs.sui.io">Sui Documentation</a> for that, it will give you a good understanding of the
basic concepts required to write Move programs on Sui.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package"><a class="header" href="#package">Package</a></h1>
<!--

    - packages and how they're stored
        - overview of packages and their contents (use a diagram)
        - how a package is created, and what it consists of
        - what is the package manifest
        - describe how "name" field is used
        - mention the "edition" field
        - what are the folders in a package and what are they for
        - how packages are imported (give Sui as an example)
        - what are addresses, and how they identify packages
        - how packages are published
        - leave a note that packages are also *upgradable*

-->
<p>Move is a language for writing smart contracts - programs that are stored and run on the blockchain. A
single program is organized into a package. A package is published on the blockchain and is
identified by an <a href="concepts/./address.html">address</a>. A published package can be interacted with by sending
<a href="concepts/./what-is-a-transaction.html">transactions</a> calling its functions. It can also act as a dependency
for other packages.</p>
<blockquote>
<p>To create a new package, use the <code>sui move new</code> command. To learn more about the command, run
<code>sui move new --help</code>.</p>
</blockquote>
<p>Package consists of modules - separate scopes that contain functions, types, and other items.</p>
<pre><code>package 0x...
    module a
        struct A1
        fun hello_world()
    module b
        struct B1
        fun hello_package()
</code></pre>
<h2 id="package-structure"><a class="header" href="#package-structure">Package Structure</a></h2>
<p>Locally, a package is a directory with a <code>Move.toml</code> file and a <code>sources</code> directory. The <code>Move.toml</code>
file - called the &quot;package manifest&quot; - contains metadata about the package, and the <code>sources</code>
directory contains the source code for the modules. Package usually looks like this:</p>
<pre><code>sources/
    my_module.move
    another_module.move
    ...
tests/
    ...
examples/
    using_my_module.move
Move.toml
</code></pre>
<p>The <code>tests</code> directory is optional and contains tests for the package. Code placed into the <code>tests</code>
directory is not published on-chain and is only availably in tests. The <code>examples</code> directory can be
used for code examples, and is also not published on-chain.</p>
<h2 id="published-package"><a class="header" href="#published-package">Published Package</a></h2>
<p>During development, package doesn't have an address and it needs to be set to <code>0x0</code>. Once a package
is published, it gets a single unique <a href="concepts/./address.html">address</a> on the blockchain containing its
modules' bytecode. A published package becomes <em>immutable</em> and can be interacted with by sending
transactions.</p>
<pre><code>0x...
    my_module: &lt;bytecode&gt;
    another_module: &lt;bytecode&gt;
</code></pre>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="concepts/./manifest.html">Package Manifest</a></li>
<li><a href="concepts/./address.html">Address</a></li>
<li><a href="concepts//reference/packages.html">Packages</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-manifest"><a class="header" href="#package-manifest">Package Manifest</a></h1>
<p>The <code>Move.toml</code> is a manifest file that describes the <a href="concepts/./packages.html">package</a> and its dependencies.
It is written in <a href="https://toml.io/en/">TOML</a> format and contains multiple sections, the most
important of which are <code>[package]</code>, <code>[dependencies]</code> and <code>[addresses]</code>.</p>
<pre><code class="language-toml">[package]
name = &quot;my_project&quot;
version = &quot;0.0.0&quot;
edition = &quot;2024&quot;

[dependencies]
Sui = { git = &quot;https://github.com/MystenLabs/sui.git&quot;, subdir = &quot;crates/sui-framework/packages/sui-framework&quot;, rev = &quot;framework/testnet&quot; }

[addresses]
std =  &quot;0x1&quot;
alice = &quot;0xA11CE&quot;

[dev-addresses]
alice = &quot;0xB0B&quot;
</code></pre>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<h3 id="package-1"><a class="header" href="#package-1">Package</a></h3>
<p>The <code>[package]</code> section is used to describe the package. None of the fields in this section are
published on chain, but they are used in tooling and release management; they also specify the Move
edition for the compiler.</p>
<ul>
<li><code>name</code> - the name of the package when it is imported;</li>
<li><code>version</code> - the version of the package, can be used in release management;</li>
<li><code>edition</code> - the edition of the Move language; currently, the only valid value is <code>2024</code>.</li>
</ul>
<!-- published-at -->
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p>The <code>[dependencies]</code> section is used to specify the dependencies of the project. Each dependency is
specified as a key-value pair, where the key is the name of the dependency, and the value is the
dependency specification. The dependency specification can be a git repository URL or a path to the
local directory.</p>
<pre><code class="language-toml"># git repository
Sui = { git = &quot;https://github.com/MystenLabs/sui.git&quot;, subdir = &quot;crates/sui-framework/packages/sui-framework&quot;, rev = &quot;framework/testnet&quot; }

# local directory
MyPackage = { local = &quot;../my-package&quot; }
</code></pre>
<p>Packages also import addresses from other packages. For example, the Sui dependency adds the <code>std</code>
and <code>sui</code> addresses to the project. These addresses can be used in the code as aliases for the
addresses.</p>
<h3 id="resolving-version-conflicts-with-override"><a class="header" href="#resolving-version-conflicts-with-override">Resolving version conflicts with override</a></h3>
<p>Sometimes dependencies have conflicting versions of the same package. For example, if you have two
dependencies that use different versions of the Sui package, you can override the dependency in the
<code>[dependencies]</code> section. To do so, add the <code>override</code> field to the dependency. The version of the
dependency specified in the <code>[dependencies]</code> section will be used instead of the one specified in
the dependency itself.</p>
<pre><code class="language-toml">[dependencies]
Sui = { override = true, git = &quot;https://github.com/MystenLabs/sui.git&quot;, subdir = &quot;crates/sui-framework/packages/sui-framework&quot;, rev = &quot;framework/testnet&quot; }
</code></pre>
<h3 id="dev-dependencies"><a class="header" href="#dev-dependencies">Dev-dependencies</a></h3>
<p>It is possible to add <code>[dev-dependencies]</code> section to the manifest. It is used to override
dependencies in the dev and test modes. For example, if you want to use a different version of the
Sui package in the dev mode, you can add a custom dependency specification to the
<code>[dev-dependencies]</code> section.</p>
<h3 id="addresses"><a class="header" href="#addresses">Addresses</a></h3>
<p>The <code>[addresses]</code> section is used to add aliases for the addresses. Any address can be specified in
this section, and then used in the code as an alias. For example, if you add <code>alice = &quot;0xA11CE&quot;</code> to
this section, you can use <code>alice</code> as <code>0xA11CE</code> in the code.</p>
<h3 id="dev-addresses"><a class="header" href="#dev-addresses">Dev-addresses</a></h3>
<p>The <code>[dev-addresses]</code> section is the same as <code>[addresses]</code>, but only works for the test and dev
modes. Important to note that it is impossible to introduce new aliases in this section, only
override the existing ones. So in the example above, if you add <code>alice = &quot;0xB0B&quot;</code> to this section,
the <code>alice</code> address will be <code>0xB0B</code> in the test and dev modes, and <code>0xA11CE</code> in the regular build.</p>
<h2 id="toml-styles"><a class="header" href="#toml-styles">TOML styles</a></h2>
<p>The TOML format supports two styles for tables: inline and multiline. The examples above are using
the inline style, but it is also possible to use the multiline style. You wouldn't want to use it
for the <code>[package]</code> section, but it can be useful for the dependencies.</p>
<pre><code class="language-toml"># Inline style
[dependencies]
Sui = { override = true, git = &quot;&quot;, subdir = &quot;crates/sui-framework/packages/sui-framework&quot;, rev = &quot;framework/testnet&quot; }
MyPackage = { local = &quot;../my-package&quot; }
</code></pre>
<pre><code class="language-toml"># Multiline style
[dependencies.Sui]
override = true
git = &quot;https://github.com/MystenLabs/sui.git&quot;
subdir = &quot;crates/sui-framework/packages/sui-framework&quot;
rev = &quot;framework/testnet&quot;

[dependencies.MyPackage]
local = &quot;../my-package&quot;
</code></pre>
<h2 id="further-reading-1"><a class="header" href="#further-reading-1">Further Reading</a></h2>
<ul>
<li><a href="concepts//reference/packages.html">Packages</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="address"><a class="header" href="#address">Address</a></h1>
<!--

Chapter: Concepts
Goal: explain locations and addresses
Notes:
    - don't talk about the type
    - packages, accounts and objects are identified by addresses
    - addresses are 32 bytes long
    - addresses are unique
    - represented as hex strings (64 characters) prefixed with 0x
    - addresses are case insensitive

Links:
    - address type


- mention what an address is, because it identifies a package
    - address is used for packages, objects, and accounts
    - address is a 32-byte value
    - address is written in hexadecimal notation
    - don't describe the type yet
    - focus on the concept of address on blockchain and on Sui in particular

 -->
<p>Address is a unique identifier of a location on the blockchain. It is used to identify
<a href="concepts/./packages.html">packages</a>, <a href="concepts/./what-is-an-account.html">accounts</a>, and <a href="concepts/./object-storage.html">objects</a>.
Address has a fixed size of 32 bytes and is usually represented as a hexadecimal string prefixed
with <code>0x</code>. Addresses are case insensitive.</p>
<pre><code class="language-move">0xe51ff5cd221a81c3d6e22b9e670ddf99004d71de4f769b0312b68c7c4872e2f1
</code></pre>
<p>The address above is an example of a valid address. It is 64 characters long (32 bytes) and prefixed
with <code>0x</code>.</p>
<p>Sui also has reserved addresses that are used to identify standard packages and objects. Reserved
addresses are typically simple values that are easy to remember and type. For example, the address
of the Standard Library is <code>0x1</code>. Addresses, shorter than 32 bytes, are padded with zeros to the
left.</p>
<pre><code class="language-move">0x1 = 0x0000000000000000000000000000000000000000000000000000000000000001
</code></pre>
<p>Here are some examples of reserved addresses:</p>
<ul>
<li><code>0x1</code> - address of the Sui Standard Library (alias <code>std</code>)</li>
<li><code>0x2</code> - address of the Sui Framework (alias <code>sui</code>)</li>
<li><code>0x6</code> - address of the system <code>Clock</code> object</li>
</ul>
<blockquote>
<p>You can find all reserved addresses in the <a href="concepts/../appendix/reserved-addresses.html">Appendix B</a>.</p>
</blockquote>
<h2 id="further-reading-2"><a class="header" href="#further-reading-2">Further reading</a></h2>
<ul>
<li><a href="concepts/../move-basics/address.html">Address type</a> in Move</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="account"><a class="header" href="#account">Account</a></h1>
<!--

- user is an account
    - account is identified by an address
    - account is generated from a private key
    - account can own objects
    - account can send transactions
    - every transaction has a sender
    - sender is identified by an address
    - sui cryptographic agility
    - sui account types
    - supported curves: ed25519, secp256k1, zklogin

 -->
<p>An account is a way to identify a user. An account is generated from a private key, and is
identified by an address. An account can own objects, and can send transactions. Every transaction
has a sender, and the sender is identified by an <a href="concepts/./address.html">address</a>.</p>
<p>Sui supports multiple cryptographic algorithms for account generation. The two supported curves are
ed25519, secp256k1, and there is also a special way of generating an account - zklogin. The
cryptographic agility - the unique feature of Sui - allows for flexibility in the account
generation.</p>
<!-- The cryptographic agility allows for flexibility in the account generation -->
<h2 id="further-reading-3"><a class="header" href="#further-reading-3">Further Reading</a></h2>
<ul>
<li><a href="https://blog.sui.io/wallet-cryptography-specifications/">Cryptography in Sui</a> in the
<a href="https://blog.sui.io">Sui Blog</a></li>
<li><a href="https://docs.sui.io/concepts/cryptography/transaction-auth/keys-addresses">Keys and Addresses</a> in
the <a href="https://docs.sui.io">Sui Docs</a></li>
<li><a href="https://docs.sui.io/concepts/cryptography/transaction-auth/signatures">Signatures</a> in the
<a href="https://docs.sui.io">Sui Docs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction"><a class="header" href="#transaction">Transaction</a></h1>
<p>Transaction is a fundamental concept in the blockchain world. It is a way to interact with a
blockchain. Transactions are used to change the state of the blockchain, and they are the only way
to do so. In Move, transactions are used to call functions in a package, deploy new packages, and
upgrade existing ones.</p>
<!--

- how user interacts with a program
    - mention public functions
    - give a concept of an entry / public function without getting into details
    - mention that functions are called in transactions
    - mention that transactions are sent by accounts
    - every transaction specifies object it operates on

 -->
<h2 id="transaction-structure"><a class="header" href="#transaction-structure">Transaction Structure</a></h2>
<blockquote>
<p>Every transaction explicitly specifies the objects it operates on!</p>
</blockquote>
<p>Transactions consist of:</p>
<ul>
<li>a sender - the <a href="concepts/./what-is-an-account.html">account</a> that <em>signs</em> the transaction;</li>
<li>a list (or a chain) of commands - the operations to be executed;</li>
<li>command inputs - the arguments for the commands: either <code>pure</code> - simple values like numbers or
strings, or <code>object</code> - objects that the transaction will access;</li>
<li>a gas object - the <code>Coin</code> object used to pay for the transaction;</li>
<li>gas price and budget - the cost of the transaction;</li>
</ul>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<p>Sui transactions may consist of multiple commands. Each command is a single built-in command (like
publishing a package) or a call to a function in an already published package. The commands are
executed in the order they are listed in the transaction, and they can use the results of the
previous commands, forming a chain. Transaction either succeeds or fails as a whole.</p>
<p>Schematically, a transaction looks like this (in pseudo-code):</p>
<pre><code>Inputs:
- sender = 0xa11ce

Commands:
- payment = SplitCoins(Gas, [ 1000 ])
- item = MoveCall(0xAAA::market::purchase, [ payment ])
- TransferObjects(item, sender)
</code></pre>
<p>In this example, the transaction consists of three commands:</p>
<ol>
<li><code>SplitCoins</code> - a built-in command that splits a new coin from the passed object, in this case,
the <code>Gas</code> object;</li>
<li><code>MoveCall</code> - a command that calls a function <code>purchase</code> in a package <code>0xAAA</code>, module <code>market</code>
with the given arguments - the <code>payment</code> object;</li>
<li><code>TransferObjects</code> - a built-in command that transfers the object to the recipient.</li>
</ol>
<!--
> There are multiple different implementations of transaction building, for example
-->
<h2 id="transaction-effects-1"><a class="header" href="#transaction-effects-1">Transaction Effects</a></h2>
<p>Transaction effects are the changes that a transaction makes to the blockchain state. More
specifically, a transaction can change the state in the following ways:</p>
<ul>
<li>use the gas object to pay for the transaction;</li>
<li>create, update, or delete objects;</li>
<li>emit events;</li>
</ul>
<p>The result of the executed transaction consists of different parts:</p>
<ul>
<li>Transaction Digest - the hash of the transaction which is used to identify the transaction;</li>
<li>Transaction Data - the inputs, commands and gas object used in the transaction;</li>
<li>Transaction Effects - the status and the &quot;effects&quot; of the transaction, more specifically: the
status of the transaction, updates to objects and their new versions, the gas object used, the gas
cost of the transaction, and the events emitted by the transaction;</li>
<li>Events - the custom <a href="concepts/./../programmability/events.html">events</a> emitted by the transaction;</li>
<li>Object Changes - the changes made to the objects, including the <em>change of ownership</em>;</li>
<li>Balance Changes - the changes made to the aggregate balances of the account involved in the
transaction;</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-basics"><a class="header" href="#move-basics">Move Basics</a></h1>
<p>This chapter is all about the basic syntax of the Move language. It covers the basics of the
language, such as types, modules, functions, and control flow. It focuses on the language without a
storage model or a blockchain, and explains the essential concepts of the language. To learn
features specific to Sui, such as storage functions and abilities, refer to the
<a href="move-basics/../storage/">Using Objects</a> chapter, however, it is recommended to start with this chapter first.</p>
<!-- TODO: cross link with Reference -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="module"><a class="header" href="#module">Module</a></h1>
<!--

Chapter: Base Syntax
Goal: Introduce module keyword.
Notes:
    - modules are the base unit of code organization
    - module members are private by default
    - types internal to the module have special access rules
    - only module can pack and unpack its types

 -->
<p>Module is the base unit of code organization in Move. Modules are used to group and isolate code,
and all of the members of the module are private to the module by default. In this section you will
learn how to define a module, how to declare its members and how to access them from other modules.</p>
<h2 id="module-declaration"><a class="header" href="#module-declaration">Module declaration</a></h2>
<p>Modules are declared using the <code>module</code> keyword followed by the package address, module name and the
module body inside the curly braces <code>{}</code>. The module name should be in <code>snake_case</code> - all lowercase
letters with underscores between words. Modules names must be unique in the package.</p>
<p>Usually, a single file in the <code>sources/</code> folder contains a single module. The file name should match
the module name - for example, a <code>donut_shop</code> module should be stored in the <code>donut_shop.move</code> file.
You can read more about coding conventions in the
<a href="move-basics/../special-topics/coding-conventions.html">Coding Conventions</a> section.</p>
<pre><code class="language-Move">module book::my_module {
    // module body
}
</code></pre>
<p>Structs, functions, constants and imports all part of the module:</p>
<ul>
<li><a href="move-basics/./struct.html">Structs</a></li>
<li><a href="move-basics/./function.html">Functions</a></li>
<li><a href="move-basics/./constants.html">Constants</a></li>
<li><a href="move-basics/./importing-modules.html">Imports</a></li>
<li><a href="move-basics/./struct-methods.html">Struct Methods</a></li>
</ul>
<h2 id="address--named-address"><a class="header" href="#address--named-address">Address / Named address</a></h2>
<p>Module address can be specified as both: an address <em>literal</em> (does not require the <code>@</code> prefix) or a
named address specified in the <a href="move-basics/../concepts/manifest.html">Package Manifest</a>. In the example below,
both are identical because there's a <code>book = &quot;0x0&quot;</code> record in the <code>[addresses]</code> section of the
<code>Move.toml</code>.</p>
<pre><code class="language-Move">module 0x0::address_literal { /* ... */ }
module book::named_address { /* ... */ }
</code></pre>
<p>Addresses section in the Move.toml:</p>
<pre><code class="language-toml"># Move.toml
[addresses]
book = &quot;0x0&quot;
</code></pre>
<h2 id="module-members"><a class="header" href="#module-members">Module members</a></h2>
<p>Module members are declared inside the module body. To illustrate that, let's define a simple module
with a struct, a function and a constant:</p>
<pre><code class="language-Move">module book::my_module_with_members {
    // import
    use book::my_module;

    // a constant
    const CONST: u8 = 0;

    // a struct
    public struct Struct {}

    // method alias
    public use fun function as Struct.struct_fun;

    // function
    fun function(_: &amp;Struct) { /* function body */ }
}
</code></pre>
<h2 id="further-reading-4"><a class="header" href="#further-reading-4">Further reading</a></h2>
<ul>
<li><a href="move-basics//reference/modules.html">Modules</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<!--

Chapter: Basic Syntax
Goal: Introduce comments.
Notes:
    - doc comments are used in docgen
    - only public members are documented
    - doc comments are placed in between attributes and the definition
    - doc comments are allowed for: modules, structs, functions, constants
    - give an example of how doc comments are translated
 -->
<p>Comments are a way to add notes or document your code. They are ignored by the compiler and don't
result in the Move bytecode. You can use comments to explain what your code does, to add notes to
yourself or other developers, to temporarily remove a part of your code, or to generate
documentation. There are three types of comments in Move: line comment, block comment, and doc
comment.</p>
<h2 id="line-comment"><a class="header" href="#line-comment">Line comment</a></h2>
<pre><code class="language-Move">module book::comments_line {
    fun some_function() {
        // this is a comment line
    }
}
</code></pre>
<p>You can use double slash <code>//</code> to comment out the rest of the line. Everything after <code>//</code> will be
ignored by the compiler.</p>
<pre><code class="language-Move">module book::comments_line_2 {
    // let's add a note to everything!
    fun some_function_with_numbers() {
        let a = 10;
        // let b = 10 this line is commented and won't be executed
        let b = 5; // here comment is placed after code
        a + b; // result is 15, not 10!
    }
}
</code></pre>
<h2 id="block-comment"><a class="header" href="#block-comment">Block comment</a></h2>
<p>Block comments are used to comment out a block of code. They start with <code>/*</code> and end with <code>*/</code>.
Everything between <code>/*</code> and <code>*/</code> will be ignored by the compiler. You can use block comments to
comment out a single line or multiple lines. You can even use them to comment out a part of a line.</p>
<pre><code class="language-Move">module book::comments_block {
    fun /* you can comment everywhere */ go_wild() {
        /* here
           there
           everywhere */ let a = 10;
        let b = /* even here */ 10; /* and again */
        a + b;
    }
    /* you can use it to remove certain expressions or definitions
    fun empty_commented_out() {

    }
    */
}
</code></pre>
<p>This example is a bit extreme, but it shows how you can use block comments to comment out a part of
a line.</p>
<h2 id="doc-comment"><a class="header" href="#doc-comment">Doc comment</a></h2>
<p>Documentation comments are special comments that are used to generate documentation for your code.
They are similar to block comments, but they start with three slashes <code>///</code> and are placed before
the definition of the item they document.</p>
<pre><code class="language-Move">/// Module has documentation!
module book::comments_doc {

    /// This is a 0x0 address constant!
    const AN_ADDRESS: address = @0x0;

    /// This is a struct!
    public struct AStruct {
        /// This is a field of a struct!
        a_field: u8,
    }

    /// This function does something!
    /// And it's documented!
    fun do_something() {}
}
</code></pre>
<!-- TODO: docgen, which members are in the documentation -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<!-- TODO: Shall we split this into two pages? Maybe give an overview and focus more on specifics? -->
<p>For simple values, Move has a number of built-in primitive types. They're the base that makes up all
other types. The primitive types are:</p>
<ul>
<li><a href="move-basics/primitive-types.html#booleans">Booleans</a></li>
<li><a href="move-basics/primitive-types.html#integers">Unsigned Integers</a></li>
<li><a href="move-basics/./address.html">Address</a> - covered in the next section</li>
</ul>
<p>However, before we get to the types, let's first look at how to declare and assign variables in
Move.</p>
<h2 id="variables-and-assignment"><a class="header" href="#variables-and-assignment">Variables and assignment</a></h2>
<p>Variables are declared using the <code>let</code> keyword. They are immutable by default, but can be made
mutable using the <code>let mut</code> keyword. The syntax for the <code>let mut</code> statement is:</p>
<pre><code>let &lt;variable_name&gt;[: &lt;type&gt;]  = &lt;expression&gt;;
let mut &lt;variable_name&gt;[: &lt;type&gt;] = &lt;expression&gt;;
</code></pre>
<p>Where:</p>
<ul>
<li><code>&lt;variable_name&gt;</code> - the name of the variable</li>
<li><code>&lt;type&gt;</code> - the type of the variable, optional</li>
<li><code>&lt;expression&gt;</code> - the value to be assigned to the variable</li>
</ul>
<pre><code class="language-move">let x: bool = true;
let mut y: u8 = 42;
</code></pre>
<p>A mutable variable can be reassigned using the <code>=</code> operator.</p>
<pre><code class="language-move">y = 43;
</code></pre>
<p>Variables can also be shadowed by re-declaring.</p>
<pre><code class="language-move">let x: u8 = 42;
let x: u16 = 42;
</code></pre>
<h2 id="booleans"><a class="header" href="#booleans">Booleans</a></h2>
<p>The <code>bool</code> type represents a boolean value - yes or no, true or false. It has two possible values:
<code>true</code> and <code>false</code> which are keywords in Move. For booleans, there's no need to explicitly specify
the type - the compiler can infer it from the value.</p>
<pre><code class="language-move">let x = true;
let y = false;
</code></pre>
<p>Booleans are often used to store flags and to control the flow of the program. Please, refer to the
<a href="move-basics/./control-flow.html">Control Flow</a> section for more information.</p>
<h2 id="integer-types"><a class="header" href="#integer-types">Integer Types</a></h2>
<p>Move supports unsigned integers of various sizes: from 8-bit to 256-bit. The integer types are:</p>
<ul>
<li><code>u8</code> - 8-bit</li>
<li><code>u16</code> - 16-bit</li>
<li><code>u32</code> - 32-bit</li>
<li><code>u64</code> - 64-bit</li>
<li><code>u128</code> - 128-bit</li>
<li><code>u256</code> - 256-bit</li>
</ul>
<pre><code class="language-move">let x: u8 = 42;
let y: u16 = 42;
// ...
let z: u256 = 42;
</code></pre>
<p>Unlike booleans, integer types need to be inferred. In most of the cases, the compiler will infer
the type from the value, usually defaulting to <code>u64</code>. However, sometimes the compiler is unable to
infer the type and will require an explicit type annotation. It can either be provided during
assignment or by using a type suffix.</p>
<pre><code class="language-move">// Both are equivalent
let x: u8 = 42;
let x = 42u8;
</code></pre>
<h3 id="operations"><a class="header" href="#operations">Operations</a></h3>
<p>Move supports the standard arithmetic operations for integers: addition, subtraction,
multiplication, division, and remainder. The syntax for these operations is:</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Operation</th><th>Aborts If</th></tr></thead><tbody>
<tr><td>+</td><td>addition</td><td>Result is too large for the integer type</td></tr>
<tr><td>-</td><td>subtraction</td><td>Result is less than zero</td></tr>
<tr><td>*</td><td>multiplication</td><td>Result is too large for the integer type</td></tr>
<tr><td>%</td><td>modular division</td><td>The divisor is 0</td></tr>
<tr><td>/</td><td>truncating division</td><td>The divisor is 0</td></tr>
</tbody></table>
</div>
<blockquote>
<p>For more operations, including bitwise operations, please refer to the
<a href="move-basics//reference/primitive-types/integers.html#bitwise">Move Reference</a>.</p>
</blockquote>
<p>The type of the operands <em>must match</em>, otherwise, the compiler will raise an error. The result of
the operation will be of the same type as the operands. To perform operations on different types,
the operands need to be cast to the same type.</p>
<!-- TODO: add examples + parentheses for arithmetic operations -->
<!-- TODO: add bitwise operators -->
<h3 id="casting-with-as"><a class="header" href="#casting-with-as">Casting with <code>as</code></a></h3>
<p>Move supports explicit casting between integer types. The syntax for it is:</p>
<pre><code class="language-move">&lt;expression&gt; as &lt;type&gt;
</code></pre>
<p>Note, that it may require parentheses around the expression to prevent ambiguity.</p>
<pre><code class="language-move">let x: u8 = 42;
let y: u16 = x as u16;
let z = 2 * (x as u16); // ambiguous, requires parentheses
</code></pre>
<p>A more complex example, preventing overflow:</p>
<pre><code class="language-move">let x: u8 = 255;
let y: u8 = 255;
let z: u16 = (x as u16) + ((y as u16) * 2);
</code></pre>
<h3 id="overflow"><a class="header" href="#overflow">Overflow</a></h3>
<p>Move does not support overflow / underflow, an operation that results in a value outside the range
of the type will raise a runtime error. This is a safety feature to prevent unexpected behavior.</p>
<pre><code class="language-move">let x = 255u8;
let y = 1u8;

// This will raise an error
let z = x + y;
</code></pre>
<h2 id="further-reading-5"><a class="header" href="#further-reading-5">Further reading</a></h2>
<ul>
<li><a href="move-basics//reference/primitive-types/bool.html">Bool</a> in the Move Reference.</li>
<li><a href="move-basics//reference/primitive-types/integers.html">Integer</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="address-type"><a class="header" href="#address-type">Address Type</a></h1>
<!--

Chapter: Basic Syntax
Goal: Introduce the address type
Notes:
    - a special type
    - named addresses via the Move.toml
    - address literals
    - 0x2 is 0x0000000...02

Links:
    - address concept
    - transaction context
    - Move.toml
    - your first move

 -->
<p>To represent <a href="move-basics/./../concepts/address.html">addresses</a>, Move uses a special type called <code>address</code>. It is
a 32 byte value that can be used to represent any address on the blockchain. Addresses are used in
two syntax forms: hexadecimal addresses prefixed with <code>0x</code> and named addresses.</p>
<pre><code class="language-move">// address literal
let value: address = @0x1;

// named address registered in Move.toml
let value = @std;
let other = @sui;
</code></pre>
<p>An address literal starts with the <code>@</code> symbol followed by a hexadecimal number or an identifier. The
hexadecimal number is interpreted as a 32 byte value. The identifier is looked up in the
<a href="move-basics/./../concepts/manifest.html">Move.toml</a> file and replaced with the corresponding address by the
compiler. If the identifier is not found in the Move.toml file, the compiler will throw an error.</p>
<h2 id="conversion"><a class="header" href="#conversion">Conversion</a></h2>
<p>Sui Framework offers a set of helper functions to work with addresses. Given that the address type
is a 32 byte value, it can be converted to a <code>u256</code> type and vice versa. It can also be converted to
and from a <code>vector&lt;u8&gt;</code> type.</p>
<p>Example: Convert an address to a <code>u256</code> type and back.</p>
<pre><code class="language-move">use sui::address;

let addr_as_u256: u256 = address::to_u256(@0x1);
let addr = address::from_u256(addr_as_u256);
</code></pre>
<p>Example: Convert an address to a <code>vector&lt;u8&gt;</code> type and back.</p>
<pre><code class="language-move">use sui::address;

let addr_as_u8: vector&lt;u8&gt; = address::to_bytes(@0x1);
let addr = address::from_bytes(addr_as_u8);
</code></pre>
<p>Example: Convert an address into a string.</p>
<pre><code class="language-move">use sui::address;
use std::string::String;

let addr_as_string: String = address::to_string(@0x1);
</code></pre>
<h2 id="further-reading-6"><a class="header" href="#further-reading-6">Further reading</a></h2>
<ul>
<li><a href="move-basics//reference/primitive-types/address.html">Address</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expression"><a class="header" href="#expression">Expression</a></h1>
<p>In programming languages expression is a unit of code which returns a value, in Move, almost
everything is an expression, - with the sole exception of <code>let</code> statement which is a declaration. In
this section, we cover the types of expressions and introduce the concept of scope.</p>
<blockquote>
<p>Expressions are sequenced with semicolons <code>;</code>. If there's &quot;no expression&quot; after the semicolon, the
compiler will insert a unit <code>()</code> - an empty expression.</p>
</blockquote>
<h2 id="literals"><a class="header" href="#literals">Literals</a></h2>
<p>In the <a href="move-basics/./primitive-types.html">Primitive Types</a> section, we introduced the basic types of Move. And
to illustrate them, we used literals. A literal is a notation for representing a fixed value in the
source code. Literals are used to initialize variables and to pass arguments to functions. Move has
the following literals:</p>
<ul>
<li><code>true</code> and <code>false</code> for boolean values</li>
<li><code>0</code>, <code>1</code>, <code>123123</code> or other numeric for integer values</li>
<li><code>0x0</code>, <code>0x1</code>, <code>0x123</code> or other hexadecimal for integer values</li>
<li><code>b&quot;bytes_vector&quot;</code> for byte vector values</li>
<li><code>x&quot;0A&quot;</code> HEX literal for byte values</li>
</ul>
<pre><code class="language-move">let b = true;     // true is a literal
let n = 1000;     // 1000 is a literal
let h = 0x0A;     // 0x0A is a literal
let v = b&quot;hello&quot;; // b'hello' is a byte vector literal
let x = x&quot;0A&quot;;    // x'0A' is a byte vector literal
let c = vector[1, 2, 3]; // vector[] is a vector literal
</code></pre>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<p>Arithmetic, logical, and bitwise operators are used to perform operations on values. The result of
an operation is a value, so operators are also expressions.</p>
<pre><code class="language-move">let sum = 1 + 2;   // 1 + 2 is an expression
let sum = (1 + 2); // the same expression with parentheses
let is_true = true &amp;&amp; false; // true &amp;&amp; false is an expression
let is_true = (true &amp;&amp; false); // the same expression with parentheses
</code></pre>
<h2 id="blocks"><a class="header" href="#blocks">Blocks</a></h2>
<p>A block is a sequence of statements and expressions, and it returns the value of the last expression
in the block. A block is written as a pair of curly braces <code>{}</code>. A block is an expression, so it can
be used anywhere an expression is expected.</p>
<pre><code class="language-move">// block with an empty expression, however, the compiler will
// insert an empty expression automatically: `let none = { () }`
// let none = {};

// block with let statements and an expression.
let sum = {
    let a = 1;
    let b = 2;
    a + b // last expression is the value of the block
};

// block is an expression, so it can be used in an expression and
// doesn't have to be assigned to a variable.
{
    let a = 1;
    let b = 2;
    a + b; // not returned - semicolon.
    // compiler automatically inserts an empty expression `()`
};
</code></pre>
<h2 id="function-calls"><a class="header" href="#function-calls">Function Calls</a></h2>
<p>We go into detail about functions in the <a href="move-basics/./functions.html">Functions</a> section. However, we already
used function calls in the previous sections, so it's worth mentioning them here. A function call is
an expression that calls a function and returns the value of the last expression in the function
body.</p>
<pre><code class="language-move">fun add(a: u8, b: u8): u8 {
    a + b
}

#[test]
fun some_other() {
    let sum = add(1, 2); // add(1, 2) is an expression with type u8
}
</code></pre>
<h2 id="control-flow-expressions"><a class="header" href="#control-flow-expressions">Control Flow Expressions</a></h2>
<p>Control flow expressions are used to control the flow of the program. They are also expressions, so
they return a value. We cover control flow expressions in the <a href="move-basics/./control-flow.html">Control Flow</a>
section. Here's a very brief overview:</p>
<pre><code class="language-move">// if is an expression, so it returns a value; if there are 2 branches,
// the types of the branches must match.
if (bool_expr) expr1 else expr2;

// while is an expression, but it returns `()`.
while (bool_expr) { expr; };

// loop is an expression, but returns `()` as well.
loop { expr; break };
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-types-with-struct"><a class="header" href="#custom-types-with-struct">Custom Types with Struct</a></h1>
<p>Move's type system shines when it comes to defining custom types. User defined types can be custom
tailored to the specific needs of the application. Not just on the data level, but also in its
behavior. In this section we introduce the struct definition and how to use it.</p>
<h2 id="struct"><a class="header" href="#struct">Struct</a></h2>
<p>To define a custom type, you can use the <code>struct</code> keyword followed by the name of the type. After
the name, you can define the fields of the struct. Each field is defined with the
<code>field_name: field_type</code> syntax. Field definitions must be separated by commas. The fields can be of
any type, including other structs.</p>
<blockquote>
<p>Move does not support recursive structs, meaning a struct cannot contain itself as a field.</p>
</blockquote>
<pre><code class="language-move">/// A struct representing an artist.
public struct Artist {
    /// The name of the artist.
    name: String,
}

/// A struct representing a music record.
public struct Record {
    /// The title of the record.
    title: String,
    /// The artist of the record. Uses the `Artist` type.
    artist: Artist,
    /// The year the record was released.
    year: u16,
    /// Whether the record is a debut album.
    is_debut: bool,
    /// The edition of the record.
    edition: Option&lt;u16&gt;,
}
</code></pre>
<p>In the example above, we define a <code>Record</code> struct with five fields. The <code>title</code> field is of type
<code>String</code>, the <code>artist</code> field is of type <code>Artist</code>, the <code>year</code> field is of type <code>u16</code>, the <code>is_debut</code>
field is of type <code>bool</code>, and the <code>edition</code> field is of type <code>Option&lt;u16&gt;</code>. The <code>edition</code> field is of
type <code>Option&lt;u16&gt;</code> to represent that the edition is optional.</p>
<p>Structs are private by default, meaning they cannot be imported and used outside of the module they
are defined in. Their fields are also private and can't be accessed from outside the module. See
<a href="move-basics/./visibility.html">visibility</a> for more information on different visibility modifiers.</p>
<blockquote>
<p>Fields of a struct are private and can only be accessed by the module defining the struct. Reading
and writing the fields of a struct in other modules is only possible if the module defining the
struct provides public functions to access the fields.</p>
</blockquote>
<h2 id="create-and-use-an-instance"><a class="header" href="#create-and-use-an-instance">Create and use an instance</a></h2>
<p>We described how struct <em>definition</em> works. Now let's see how to initialize a struct and use it. A
struct can be initialized using the <code>struct_name { field1: value1, field2: value2, ... }</code> syntax.
The fields can be initialized in any order, and all of the fields must be set.</p>
<pre><code class="language-move">let mut artist = Artist {
    name: b&quot;The Beatles&quot;.to_string()
};
</code></pre>
<p>In the example above, we create an instance of the <code>Artist</code> struct and set the <code>name</code> field to a
string &quot;The Beatles&quot;.</p>
<p>To access the fields of a struct, you can use the <code>.</code> operator followed by the field name.</p>
<pre><code class="language-move">// Access the `name` field of the `Artist` struct.
let artist_name = artist.name;

// Access a field of the `Artist` struct.
assert!(artist.name == string::utf8(b&quot;The Beatles&quot;), 0);

// Mutate the `name` field of the `Artist` struct.
artist.name = string::utf8(b&quot;Led Zeppelin&quot;);

// Check that the `name` field has been mutated.
assert!(artist.name == string::utf8(b&quot;Led Zeppelin&quot;), 1);
</code></pre>
<p>Only module defining the struct can access its fields (both mutably and immutably). So the above
code should be in the same module as the <code>Artist</code> struct.</p>
<!-- ## Accessing Fields

Struct fields are private and can be accessed only by the module defining the struct. To access the fields of a struct, you can use the `.` operator followed by the field name.

```move
# anchor: access
// Access the `name` field of the `Artist` struct.
let artist_name = artist.name;

// Access a field of the `Artist` struct.
assert!(artist.name == string::utf8(b"The Beatles"), 0);

// Mutate the `name` field of the `Artist` struct.
artist.name = string::utf8(b"Led Zeppelin");

// Check that the `name` field has been mutated.
assert!(artist.name == string::utf8(b"Led Zeppelin"), 1);
```
-->
<h2 id="unpacking-a-struct"><a class="header" href="#unpacking-a-struct">Unpacking a struct</a></h2>
<p>Structs are non-discardable by default, meaning that the initiated struct value must be used: either
stored or <em>unpacked</em>. Unpacking a struct means deconstructing it into its fields. This is done using
the <code>let</code> keyword followed by the struct name and the field names.</p>
<pre><code class="language-move">// Unpack the `Artist` struct and create a new variable `name`
// with the value of the `name` field.
let Artist { name } = artist;
</code></pre>
<p>In the example above we unpack the <code>Artist</code> struct and create a new variable <code>name</code> with the value
of the <code>name</code> field. Because the variable is not used, the compiler will raise a warning. To
suppress the warning, you can use the underscore <code>_</code> to indicate that the variable is intentionally
unused.</p>
<pre><code class="language-move">// Unpack the `Artist` struct and ignore the `name` field.
let Artist { name: _ } = artist;
</code></pre>
<h2 id="further-reading-7"><a class="header" href="#further-reading-7">Further reading</a></h2>
<ul>
<li><a href="move-basics//reference/structs.html">Structs</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abilities-introduction"><a class="header" href="#abilities-introduction">Abilities: Introduction</a></h1>
<p>Move has a unique type system which allows customizing <em>type abilities</em>.
<a href="move-basics/./struct.html">In the previous section</a>, we introduced the <code>struct</code> definition and how to use it.
However, the instances of the <code>Artist</code> and <code>Record</code> structs had to be unpacked for the code to
compile. This is default behavior of a struct without <em>abilities</em>.</p>
<blockquote>
<p>Throughout the book you will see chapters with name <code>Ability: &lt;name&gt;</code>, where <code>&lt;name&gt;</code> is the name
of the ability. These chapters will cover the ability in detail, how it works, and how to use it
in Move.</p>
</blockquote>
<h2 id="what-are-abilities"><a class="header" href="#what-are-abilities">What are Abilities?</a></h2>
<p>Abilities are a way to allow certain behaviors for a type. They are a part of the struct declaration
and define which behaviours are allowed for the instances of the struct.</p>
<h2 id="abilities-syntax"><a class="header" href="#abilities-syntax">Abilities syntax</a></h2>
<p>Abilities are set in the struct definition using the <code>has</code> keyword followed by a list of abilities.
The abilities are separated by commas. Move supports 4 abilities: <code>copy</code>, <code>drop</code>, <code>key</code>, and
<code>store</code>, each of them is used to define a specific behaviour for the struct instances.</p>
<pre><code class="language-move">/// This struct has the `copy` and `drop` abilities.
struct VeryAble has copy, drop {
    // field: Type1,
    // field2: Type2,
    // ...
}
</code></pre>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>A quick overview of the abilities:</p>
<blockquote>
<p>All of the built-in types, except references, have <code>copy</code>, <code>drop</code> and <code>store</code> abilities.
References have <code>copy</code> and <code>drop</code>.</p>
</blockquote>
<ul>
<li><code>copy</code> - allows the struct to be <em>copied</em>. Explained in the <a href="move-basics/./copy-ability.html">Ability: Copy</a>
chapter.</li>
<li><code>drop</code> - allows the struct to be <em>dropped</em> or <em>discarded</em>. Explained in the
<a href="move-basics/./drop-ability.html">Ability: Drop</a> chapter.</li>
<li><code>key</code> - allows the struct to be used as a <em>key</em> in a storage. Explained in the
<a href="move-basics/./../storage/key-ability.html">Ability: Key</a> chapter.</li>
<li><code>store</code> - allows the struct to be <em>stored</em> in structs with the <em>key</em> ability. Explained in the
<a href="move-basics/./../storage/store-ability.html">Ability: Store</a> chapter.</li>
</ul>
<p>While it is important to mention them here, we will go in detail about each ability in the following
chapters and give a proper context on how to use them.</p>
<h2 id="no-abilities"><a class="header" href="#no-abilities">No abilities</a></h2>
<p>A struct without abilities cannot be discarded, or copied, or stored in the storage. We call such a
struct a <em>Hot Potato</em>. It is a joke, but it is also a good way to remember that a struct without
abilities is like a hot potato - it can only be passed around and requires special handling. Hot
Potato is one of the most powerful patterns in Move, we go in detail about it in the
<a href="move-basics/./../programmability/hot-potato.html">Hot Potato</a> chapter.</p>
<h2 id="further-reading-8"><a class="header" href="#further-reading-8">Further reading</a></h2>
<ul>
<li><a href="move-basics//reference/type-abilities.html">Type Abilities</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abilities-drop"><a class="header" href="#abilities-drop">Abilities: Drop</a></h1>
<!-- TODO: reiterate, given that we introduce abilities one by one -->
<!-- TODO:

- introduce abilities first
- mention them all
- then do one by one

consistency: we / I / you ?
who is we? I am alone, there's no one else here


-->
<!--

// Shall we only talk about `drop` ?
// So that we don't explain scopes and `copy` / `move` semantics just yet?

Chapter: Basic Syntax
Goal: Introduce Copy and Drop abilities of Move. Follows the `struct` section
Notes:
    - compare them to primitive types introduces before;
    - what is an ability without drop
    - drop is not necessary for unpacking
    - make a joke about a bacteria pattern in the code
    - mention that a struct with only `drop` ability is called a Witness
    - mention that a struct without abilities is called a Hot Potato
    - mention that there are two more abilities which are covered in a later chapter

Links:
    - language reference (abilities)
    - authorization patterns (or witness)
    - hot potato pattern
    - key and store abilities (later chapter)

 -->
<p>The <code>drop</code> ability - the simplest of them - allows the instance of a struct to be <em>ignored</em> or
<em>discarded</em>. In many programming languages this behavior is considered default. However, in Move, a
struct without the <code>drop</code> ability is not allowed to be ignored. This is a safety feature of the Move
language, which ensures that all assets are properly handled. An attempt to ignore a struct without
the <code>drop</code> ability will result in a compilation error.</p>
<pre><code class="language-move">module book::drop_ability {

    /// This struct has the `drop` ability.
    public struct IgnoreMe has drop {
        a: u8,
        b: u8,
    }

    /// This struct does not have the `drop` ability.
    public struct NoDrop {}

    #[test]
    // Create an instance of the `IgnoreMe` struct and ignore it.
    // Even though we constructed the instance, we don't need to unpack it.
    fun test_ignore() {
        let no_drop = NoDrop {};
        let _ = IgnoreMe { a: 1, b: 2 }; // no need to unpack

        // The value must be unpacked for the code to compile.
        let NoDrop {} = no_drop; // OK
    }
}
</code></pre>
<p>The <code>drop</code> ability is often used on custom collection types to eliminate the need for special
handling of the collection when it is no longer needed. For example, a <code>vector</code> type has the <code>drop</code>
ability, which allows the vector to be ignored when it is no longer needed. However, the biggest
feature of Move's type system is the ability to not have <code>drop</code>. This ensures that the assets are
properly handled and not ignored.</p>
<p>A struct with a single <code>drop</code> ability is called a <em>Witness</em>. We explain the concept of a <em>Witness</em>
in the
<a href="move-basics/./../programmability/witness-and-abstract-implementation.html">Witness and Abstract Implementation</a>
section.</p>
<h2 id="types-with-the-drop-ability"><a class="header" href="#types-with-the-drop-ability">Types with the <code>drop</code> Ability</a></h2>
<p>All native types in Move have the <code>drop</code> ability. This includes:</p>
<ul>
<li><a href="move-basics/./../move-basics/primitive-types.html#booleans">bool</a></li>
<li><a href="move-basics/./../move-basics/primitive-types.html#integers">unsigned integers</a></li>
<li><a href="move-basics/./../move-basics/vector.html">vector</a></li>
<li><a href="move-basics/./../move-basics/address.html">address</a></li>
</ul>
<p>All of the types defined in the standard library have the <code>drop</code> ability as well. This includes:</p>
<ul>
<li><a href="move-basics/./../move-basics/option.html">Option</a></li>
<li><a href="move-basics/./../move-basics/string.html">String</a></li>
<li><a href="move-basics/./../move-basics/type-reflection.html#typename">TypeName</a></li>
</ul>
<h2 id="further-reading-9"><a class="header" href="#further-reading-9">Further reading</a></h2>
<ul>
<li><a href="move-basics//reference/type-abilities.html">Type Abilities</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="importing-modules"><a class="header" href="#importing-modules">Importing Modules</a></h1>
<!--
    TODO: create a better example for:
        1. Importing a module in general
        2. Importing a member
        3. Importing multiple members
        4. Grouping imports
        5. Self keyword for groups
-->
<!--

Goals:
    - Show the import syntax
    - Local dependencies
    - External dependencies
    - Importing modules from other packages

 -->
<p>Move achieves high modularity and code reuse by allowing module imports. Modules within the same
package can import each other, and a new package can depend on already existing packages and use
their modules too. This section will cover the basics of importing modules and how to use them in
your own code.</p>
<h2 id="importing-a-module"><a class="header" href="#importing-a-module">Importing a Module</a></h2>
<p>Modules defined in the same package can import each other. The <code>use</code> keyword is followed by the
module path, which consists of the package address (or alias) and the module name separated by <code>::</code>.</p>
<pre><code class="language-move">// File: sources/module_one.move
module book::module_one {
    /// Struct defined in the same module.
    public struct Character has drop {}

    /// Simple function that creates a new `Character` instance.
    public fun new(): Character { Character {} }
}
</code></pre>
<p>Another module defined in the same package can import the first module using the <code>use</code> keyword.</p>
<pre><code class="language-move">// File: sources/module_two.move
module book::module_two {
    use book::module_one; // importing module_one from the same package

    /// Calls the `new` function from the `module_one` module.
    public fun create_and_ignore() {
        let _ = module_one::new();
    }
}
</code></pre>
<h2 id="importing-members"><a class="header" href="#importing-members">Importing Members</a></h2>
<p>You can also import specific members from a module. This is useful when you only need a single
function or a single type from a module. The syntax is the same as for importing a module, but you
add the member name after the module path.</p>
<pre><code class="language-move">module book::more_imports {
    use book::module_one::new;       // imports the `new` function from the `module_one` module
    use book::module_one::Character; // importing the `Character` struct from the `module_one` module

    /// Calls the `new` function from the `module_one` module.
    public fun create_character(): Character {
        new()
    }
}
</code></pre>
<h2 id="grouping-imports"><a class="header" href="#grouping-imports">Grouping Imports</a></h2>
<p>Imports can be grouped into a single <code>use</code> statement using the curly braces <code>{}</code>. This is useful
when you need to import multiple members from the same module. Move allows grouping imports from the
same module and from the same package.</p>
<pre><code class="language-move">module book::grouped_imports {
    // imports the `new` function and the `Character` struct from
    /// the `module_one` module
    use book::module_one::{new, Character};

    /// Calls the `new` function from the `module_one` module.
    public fun create_character(): Character {
        new()
    }
}
</code></pre>
<p>Single function imports are less common in Move, since the function names can overlap and cause
confusion. A recommended practice is to import the entire module and use the module path to access
the function. Types have unique names and should be imported individually.</p>
<p>To import members and the module itself in the group import, you can use the <code>Self</code> keyword. The
<code>Self</code> keyword refers to the module itself and can be used to import the module and its members.</p>
<pre><code class="language-move">module book::self_imports {
    // imports the `Character` struct, and the `module_one` module
    use book::module_one::{Self, Character};

    /// Calls the `new` function from the `module_one` module.
    public fun create_character(): Character {
        module_one::new()
    }
}
</code></pre>
<h2 id="resolving-name-conflicts"><a class="header" href="#resolving-name-conflicts">Resolving Name Conflicts</a></h2>
<p>When importing multiple members from different modules, it is possible to have name conflicts. For
example, if you import two modules that both have a function with the same name, you will need to
use the module path to access the function. It is also possible to have modules with the same name
in different packages. To resolve the conflict and avoid ambiguity, Move offers the <code>as</code> keyword to
rename the imported member.</p>
<pre><code class="language-move">module book::conflict_resolution {
    // `as` can be placed after any import, including group imports
    use book::module_one::{Self as mod, Character as Char};

    /// Calls the `new` function from the `module_one` module.
    public fun create(): Char {
        mod::new()
    }
}
</code></pre>
<h2 id="adding-an-external-dependency"><a class="header" href="#adding-an-external-dependency">Adding an External Dependency</a></h2>
<p>Every new package generated via the <code>sui</code> binary features a <code>Move.toml</code> file with a single
dependency on the <em>Sui Framework</em> package. The Sui Framework depends on the <em>Standard Library</em>
package. And both of these packages are available in default configuration. Package dependencies are
defined in the <a href="move-basics/./../concepts/manifest.html">Package Manifest</a> as follows:</p>
<pre><code class="language-toml">[dependencies]
Sui = { git = &quot;https://github.com/MystenLabs/sui.git&quot;, subdir = &quot;crates/sui-framework/packages/sui-framework&quot;, rev = &quot;framework/testnet&quot; }
Local = { local = &quot;../my_other_package&quot; }
</code></pre>
<p>The <code>dependencies</code> section contains a list of package dependencies. The key is the name of the
package, and the value is either a git import table or a local path. The git import contains the URL
of the package, the subdirectory where the package is located, and the revision of the package. The
local path is a relative path to the package directory.</p>
<p>If a dependency is added to the <code>Move.toml</code> file, the compiler will automatically fetch (and later
refetch) the dependencies when building the package.</p>
<h2 id="importing-a-module-from-another-package"><a class="header" href="#importing-a-module-from-another-package">Importing a Module from Another Package</a></h2>
<p>Normally, packages define their addresses in the <code>[addresses]</code> section, so you can use the alias
instead of the address. For example, instead of <code>0x2::coin</code> module, you would use <code>sui::coin</code>. The
<code>sui</code> alias is defined in the Sui Framework package. Similarly, the <code>std</code> alias is defined in the
Standard Library package and can be used to access the standard library modules.</p>
<p>To import a module from another package, you use the <code>use</code> keyword followed by the module path. The
module path consists of the package address (or alias) and the module name separated by <code>::</code>.</p>
<pre><code class="language-move">module book::imports {
    use std::string; // std = 0x1, string is a module in the standard library
    use sui::coin;   // sui = 0x2, coin is a module in the Sui Framework
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<!-- The Move standard library provides a set of modules  -->
<p>The Move Standard Library provides functionality for native types and operations. It is a standard
collection of modules which do not interact with the storage, but provide basic tools for working
and manipulating the data. It is the only dependency of the
<a href="move-basics/../programmability/sui-framework.html">Sui Framework</a>, and is imported together with it.</p>
<h2 id="most-common-modules"><a class="header" href="#most-common-modules">Most Common Modules</a></h2>
<p>In this book we go into detail about most of the modules in the Standard Library, however, it is
also helpful to give an overview of the features, so that you can get a sense of what is available
and which module implements it.</p>
<!-- Custom CSS addition in the theme/custom.css  -->
<div class="modules-table">
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Description</th><th>Chapter</th></tr></thead><tbody>
<tr><td><a href="https://docs.sui.io/references/framework/move-stdlib/string">std::string</a></td><td>Provides basic string operations</td><td><a href="move-basics/./string.html">String</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/move-stdlib/ascii">std::ascii</a></td><td>Provides basic ASCII operations</td><td><a href="move-basics/./string.html">String</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/move-stdlib/option">std::option</a></td><td>Implements an <code>Option&lt;T&gt;</code></td><td><a href="move-basics/./option.html">Option</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/move-stdlib/vector">std::vector</a></td><td>Native operations on the vector type</td><td><a href="move-basics/./vector.html">Vector</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/move-stdlib/bcs">std::bcs</a></td><td>Contains the <code>bcs::to_bytes()</code> function</td><td><a href="move-basics/../move-basics/bcs.html">BCS</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/move-stdlib/address">std::address</a></td><td>Contains a single <code>address::length</code> function</td><td><a href="move-basics/./address.html">Address</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/move-stdlib/type_name">std::type_name</a></td><td>Allows runtime <em>type reflection</em></td><td><a href="move-basics/./type-reflection.html">Type Reflection</a></td></tr>
<tr><td>std::hash</td><td>Hashing functions: <code>sha2_256</code> and <code>sha3_256</code></td><td><a href="move-basics/../programmability/cryptography-and-hashing.html">Cryptography and Hashing</a></td></tr>
<tr><td>std::debug</td><td>Contains debugging functions, which are available in only in <strong>test</strong> mode</td><td><a href="move-basics/./debugging.html">Debugging</a></td></tr>
<tr><td>std::bit_vector</td><td>Provides operations on bit vectors</td><td>-</td></tr>
<tr><td>std::fixed_point32</td><td>Provides the <code>FixedPoint32</code> type</td><td>-</td></tr>
</tbody></table>
</div></div>
<h2 id="exported-addresses"><a class="header" href="#exported-addresses">Exported Addresses</a></h2>
<p>Standard Library exports one named address - <code>std = 0x1</code>.</p>
<pre><code class="language-toml">[addresses]
std = &quot;0x1&quot;
</code></pre>
<h2 id="implicit-imports"><a class="header" href="#implicit-imports">Implicit Imports</a></h2>
<p>Some of the modules are imported implicitly, and are available in the module without explicit <code>use</code>
import. For Standard Library, these modules and types are:</p>
<ul>
<li>std::vector</li>
<li>std::option</li>
<li>std::option::Option</li>
</ul>
<h2 id="importing-std-without-sui-framework"><a class="header" href="#importing-std-without-sui-framework">Importing std without Sui Framework</a></h2>
<p>The Move Standard Library can be imported to the package directly. However, <code>std</code> alone is not
enough to build a meaningful application, as it does not provide any storage capabilities, and can't
interact with the on-chain state.</p>
<pre><code class="language-toml">MoveStdlib = { git = &quot;https://github.com/MystenLabs/sui.git&quot;, subdir = &quot;crates/sui-framework/packages/move-stdlib&quot;, rev = &quot;framework/mainnet&quot; }
</code></pre>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>The source code of the Move Standard Library is available in the
<a href="https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/move-stdlib/sources">Sui repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector"><a class="header" href="#vector">Vector</a></h1>
<p>Vectors are a native way to store collections of elements in Move. They are similar to arrays in
other programming languages, but with a few differences. In this section, we introduce the <code>vector</code>
type and its operations.</p>
<h2 id="vector-syntax"><a class="header" href="#vector-syntax">Vector syntax</a></h2>
<p>The <code>vector</code> type is defined using the <code>vector</code> keyword followed by the type of the elements in
angle brackets. The type of the elements can be any valid Move type, including other vectors. Move
has a vector literal syntax that allows you to create vectors using the <code>vector</code> keyword followed by
square brackets containing the elements (or no elements for an empty vector).</p>
<pre><code class="language-move">// An empty vector of bool elements.
let empty: vector&lt;bool&gt; = vector[];

// A vector of u8 elements.
let v: vector&lt;u8&gt; = vector[10, 20, 30];

// A vector of vector&lt;u8&gt; elements.
let vv: vector&lt;vector&lt;u8&gt;&gt; = vector[
    vector[10, 20],
    vector[30, 40]
];
</code></pre>
<p>The <code>vector</code> type is a built-in type in Move, and does not need to be imported from a module.
However, vector operations are defined in the <code>std::vector</code> module, and you need to import the
module to use them.</p>
<h2 id="vector-operations"><a class="header" href="#vector-operations">Vector operations</a></h2>
<p>The standard library provides methods to manipulate vectors. The following are some of the most
commonly used operations:</p>
<ul>
<li><code>push_back</code>: Adds an element to the end of the vector.</li>
<li><code>pop_back</code>: Removes the last element from the vector.</li>
<li><code>length</code>: Returns the number of elements in the vector.</li>
<li><code>is_empty</code>: Returns true if the vector is empty.</li>
<li><code>remove</code>: Removes an element at a given index.</li>
</ul>
<pre><code class="language-move">let mut v = vector[10u8, 20, 30];

assert!(v.length() == 3, 0);
assert!(!v.is_empty(), 1);

v.push_back(40);
let last_value = v.pop_back();

assert!(last_value == 40, 2);
</code></pre>
<h2 id="destroying-a-vector-of-non-droppable-types"><a class="header" href="#destroying-a-vector-of-non-droppable-types">Destroying a Vector of non-droppable types</a></h2>
<p>A vector of non-droppable types cannot be discarded. If you define a vector of types without <code>drop</code>
ability, the vector value cannot be ignored. However, if the vector is empty, compiler requires an
explicit call to <code>destroy_empty</code> function.</p>
<pre><code class="language-move">    /// A struct without `drop` ability.
    public struct NoDrop {}

    #[test]
    fun test_destroy_empty() {
        // Initialize a vector of `NoDrop` elements.
        let v = vector&lt;NoDrop&gt;[];

        // While we know that `v` is empty, we still need to call
        // the explicit `destroy_empty` function to discard the vector.
        v.destroy_empty();
    }
</code></pre>
<h2 id="further-reading-10"><a class="header" href="#further-reading-10">Further reading</a></h2>
<ul>
<li><a href="move-basics//reference/primitive-types/vector.html">Vector</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option"><a class="header" href="#option">Option</a></h1>
<p>Option is a type that represents an optional value which may or may not exist. The concept of Option
in Move is borrowed from Rust, and it is a very useful primitive in Move. <code>Option</code> is defined in the
<a href="move-basics/./standard-library.html">Standard Library</a>, and is defined as follows:</p>
<p>File: move-stdlib/source/option.move</p>
<pre><code class="language-move">// File: move-stdlib/source/option.move
/// Abstraction of a value that may or may not be present.
struct Option&lt;Element&gt; has copy, drop, store {
    vec: vector&lt;Element&gt;
}
</code></pre>
<blockquote>
<p>The 'std::option' module is implicitly imported in every module, and you don't need to add an
import.</p>
</blockquote>
<p>The <code>Option</code> is a generic type which takes a type parameter <code>Element</code>. It has a single field <code>vec</code>
which is a <code>vector</code> of <code>Element</code>. Vector can have length 0 or 1, and this is used to represent the
presence or absence of a value.</p>
<p>Option type has two variants: <code>Some</code> and <code>None</code>. <code>Some</code> variant contains a value and <code>None</code> variant
represents the absence of a value. The <code>Option</code> type is used to represent the absence of a value in
a type-safe way, and it is used to avoid the need for empty or <code>undefined</code> values.</p>
<h2 id="in-practice"><a class="header" href="#in-practice">In Practice</a></h2>
<p>To showcase why Option type is necessary, let's look at an example. Consider an application which
takes a user input and stores it in a variable. Some fields are required, and some are optional. For
example, a user's middle name is optional. While we could use an empty string to represent the
absence of a middle name, it would require extra checks to differentiate between an empty string and
a missing middle name. Instead, we can use the <code>Option</code> type to represent the middle name.</p>
<pre><code class="language-move">module book::user_registry {
    use std::string::String;

    /// A struct representing a user record.
    public struct User has drop {
        first_name: String,
        middle_name: Option&lt;String&gt;,
        last_name: String,
    }

    /// Create a new `User` struct with the given fields.
    public fun register(
        first_name: String,
        middle_name: Option&lt;String&gt;,
        last_name: String,
    ): User {
        User { first_name, middle_name, last_name }
    }
}
</code></pre>
<p>In the example above, the <code>middle_name</code> field is of type <code>Option&lt;String&gt;</code>. This means that the
<code>middle_name</code> field can either contain a <code>String</code> value or be empty. This makes it clear that the
middle name is optional, and it avoids the need for extra checks to differentiate between an empty
string and a missing middle name.</p>
<h2 id="using-option"><a class="header" href="#using-option">Using Option</a></h2>
<p>To use the <code>Option</code> type, you need to import the <code>std::option</code> module and use the <code>Option</code> type. You
can then create an <code>Option</code> value using the <code>some</code> or <code>none</code> methods.</p>
<pre><code class="language-move">// `option::some` creates an `Option` value with a value.
let mut opt = option::some(b&quot;Alice&quot;);

// `option.is_some()` returns true if option contains a value.
assert!(opt.is_some(), 1);

// internal value can be `borrow`ed and `borrow_mut`ed.
assert!(opt.borrow() == &amp;b&quot;Alice&quot;, 0);

// `option.extract` takes the value out of the option, leaving the option empty.
let inner = opt.extract();

// `option.is_none()` returns true if option is None.
assert!(opt.is_none(), 2);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<p>While Move does not have a built-in type to represent strings, it does have two standard
implementations for strings in the <a href="move-basics/./standard-library.html">Standard Library</a>. The <code>std::string</code>
module defines a <code>String</code> type and methods for UTF-8 encoded strings, and the second module,
<code>std::ascii</code>, provides an ASCII <code>String</code> type and its methods.</p>
<blockquote>
<p>Sui execution environment automatically converts bytevector into <code>String</code> in transaction inputs.
So in many cases, a String does not need to be constructed in the
<a href="move-basics/./../concepts/what-is-a-transaction.html">Transaction Block</a>.</p>
</blockquote>
<!--

## Bytestring Literal

TODO:

- reference vector
- reference literals - [Expression](./expression.md#literals)

-->
<h2 id="strings-are-bytes"><a class="header" href="#strings-are-bytes">Strings are bytes</a></h2>
<p>No matter which type of string you use, it is important to know that strings are just bytes. The
wrappers provided by the <code>string</code> and <code>ascii</code> modules are just that: wrappers. They do provide
safety checks and methods to work with strings, but at the end of the day, they are just vectors of
bytes.</p>
<pre><code class="language-move">module book::custom_string {
    /// Anyone can implement a custom string-like type by wrapping a vector.
    public struct MyString {
        bytes: vector&lt;u8&gt;,
    }

    /// Implement a `from_bytes` function to convert a vector of bytes to a string.
    public fun from_bytes(bytes: vector&lt;u8&gt;): MyString {
        MyString { bytes }
    }

    /// Implement a `bytes` function to convert a string to a vector of bytes.
    public fun bytes(self: &amp;MyString): &amp;vector&lt;u8&gt; {
        &amp;self.bytes
    }
}
</code></pre>
<h2 id="working-with-utf-8-strings"><a class="header" href="#working-with-utf-8-strings">Working with UTF-8 Strings</a></h2>
<p>While there are two types of strings in the standard library, the <code>string</code> module should be
considered the default. It has native implementations of many common operations, and hence is more
efficient than the <code>ascii</code> module, which is fully implemented in Move.</p>
<h3 id="definition"><a class="header" href="#definition">Definition</a></h3>
<p>The <code>String</code> type in the <code>std::string</code> module is defined as follows:</p>
<pre><code class="language-move">// File: move-stdlib/sources/string.move
/// A `String` holds a sequence of bytes which is guaranteed to be in utf8 format.
public struct String has copy, drop, store {
    bytes: vector&lt;u8&gt;,
}
</code></pre>
<h3 id="creating-a-string"><a class="header" href="#creating-a-string">Creating a String</a></h3>
<p>To create a new UTF-8 <code>String</code> instance, you can use the <code>string::utf8</code> method. The
<a href="move-basics/./standard-library.html">Standard Library</a> provides an alias <code>.to_string()</code> on the <code>vector&lt;u8&gt;</code> for
convenience.</p>
<pre><code class="language-move">// the module is `std::string` and the type is `String`
use std::string::{Self, String};

// strings are normally created using the `utf8` function
// type declaration is not necessary, we put it here for clarity
let hello: String = string::utf8(b&quot;Hello&quot;);

// The `.to_string()` alias on the `vector&lt;u8&gt;` is more convenient
let hello = b&quot;Hello&quot;.to_string();
</code></pre>
<h3 id="common-operations"><a class="header" href="#common-operations">Common Operations</a></h3>
<p>UTF8 String provides a number of methods to work with strings. The most common operations on strings
are: concatenation, slicing, and getting the length. Additionally, for custom string operations, the
<code>bytes()</code> method can be used to get the underlying byte vector.</p>
<pre><code class="language-move">let mut str = b&quot;Hello,&quot;.to_string();
let another = b&quot; World!&quot;.to_string();

// append(String) adds the content to the end of the string
str.append(another);

// `sub_string(start, end)` copies a slice of the string
str.sub_string(0, 5); // &quot;Hello&quot;

// `length()` returns the number of bytes in the string
str.length(); // 12 (bytes)

// methods can also be chained! Get a length of a substring
str.sub_string(0, 5).length(); // 5 (bytes)

// whether the string is empty
str.is_empty(); // false

// get the underlying byte vector for custom operations
let bytes: &amp;vector&lt;u8&gt; = str.bytes();
</code></pre>
<h3 id="safe-utf-8-operations"><a class="header" href="#safe-utf-8-operations">Safe UTF-8 Operations</a></h3>
<p>The default <code>utf8</code> method may abort if the bytes passed into it are not valid UTF-8. If you are not
sure that the bytes you are passing are valid, you should use the <code>try_utf8</code> method instead. It
returns an <code>Option&lt;String&gt;</code>, which contains no value if the bytes are not valid UTF-8, and a string
otherwise.</p>
<blockquote>
<p>Hint: the name that starts with <code>try_*</code> indicates that the function returns an Option with the
expected result or <code>none</code> if the operation fails. It is a common naming convention borrowed from
Rust.</p>
</blockquote>
<pre><code class="language-move">// this is a valid UTF-8 string
let hello = b&quot;Hello&quot;.try_to_string();

assert!(hello.is_some(), 0); // abort if the value is not valid UTF-8

// this is not a valid UTF-8 string
let invalid = b&quot;\xFF&quot;.try_to_string();

assert!(invalid.is_none(), 0); // abort if the value is valid UTF-8
</code></pre>
<h3 id="utf-8-limitations"><a class="header" href="#utf-8-limitations">UTF-8 Limitations</a></h3>
<p>The <code>string</code> module does not provide a way to access individual characters in a string. This is
because UTF-8 is a variable-length encoding, and the length of a character can be anywhere from 1 to
4 bytes. Similarly, the <code>length()</code> method returns the number of bytes in the string, not the number
of characters.</p>
<p>However, methods like <code>sub_string</code> and <code>insert</code> check character boundaries and will abort when the
index is in the middle of a character.</p>
<h2 id="ascii-strings"><a class="header" href="#ascii-strings">ASCII Strings</a></h2>
<p>This section is coming soon!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<!--

Chapter: Basic Syntax
Goal: Introduce control flow statements.
Notes:
    - if/else is an expression
    - while () {} loop
    - continue and break
    - loop {}
    - infinite loop is possible but will lead to gas exhaustion
    - return keyword
    - if is an expression and as such requires a semicolon (!!!)

Links:
    - reference (control flow)
    - coding conventions (control flow)

 -->
<p>Control flow statements are used to control the flow of execution in a program. They are used to
make decisions, to repeat a block of code, and to exit a block of code early. Move has the following
control flow statements (explained in detail below):</p>
<ul>
<li><a href="move-basics/control-flow.html#conditional-statements"><code>if</code> and <code>if-else</code></a> - making decisions on whether to execute a block of
code</li>
<li><a href="move-basics/control-flow.html#repeating-statements-with-loops"><code>loop</code> and <code>while</code> loops</a> - repeating a block of code</li>
<li><a href="move-basics/control-flow.html#exiting-a-loop-early"><code>break</code> and <code>continue</code> statements</a> - exiting a loop early</li>
<li><a href="move-basics/control-flow.html#return"><code>return</code></a> statement - exiting a function early</li>
</ul>
<h2 id="conditional-statements"><a class="header" href="#conditional-statements">Conditional Statements</a></h2>
<p>The <code>if</code> expression is used to make decisions in a program. It evaluates a
<a href="move-basics/./expression.html#literals">boolean expression</a> and executes a block of code if the expression is
true. Paired with <code>else</code>, it can execute a different block of code if the expression is false.</p>
<p>The syntax for the <code>if</code> expression is:</p>
<pre><code class="language-move">if (&lt;bool_expression&gt;) &lt;expression&gt;;
if (&lt;bool_expression&gt;) &lt;expression&gt; else &lt;expression&gt;;
</code></pre>
<p>Just like any other expression, <code>if</code> requires a semicolon, if there are other expressions following
it. The <code>else</code> keyword is optional, except for the case when the resulting value is assigned to a
variable. We will cover this below.</p>
<pre><code class="language-move">    #[test]
    fun test_if() {
        let x = 5;

        // `x &gt; 0` is a boolean expression.
        if (x &gt; 0) {
            std::debug::print(&amp;b&quot;X is bigger than 0&quot;.to_string())
        };
    }
</code></pre>
<p>Let's see how we can use <code>if</code> and <code>else</code> to assign a value to a variable:</p>
<pre><code class="language-move">    #[test]
    fun test_if_else() {
        let x = 5;
        let y = if (x &gt; 0) {
            1
        } else {
            0
        };

        assert!(y == 1, 0);
    }
</code></pre>
<p>Here we assign the value of the <code>if</code> expression to the variable <code>y</code>. If <code>x</code> is greater than 0, <code>y</code>
will be assigned the value 1, otherwise 0. The <code>else</code> block is necessary, because both branches must
return a value of the same type. If we omit the <code>else</code> block, the compiler will throw an error.</p>
<!-- TODO: add an error -->
<p>Conditional expressions are one of the most important control flow statements in Move. They can use
either user provided input or some already stored data to make decisions. In particular, they are
used in the <a href="move-basics/./assert-and-abort.html"><code>assert!</code> macro</a> to check if a condition is true, and if not, to
abort execution. We will get to it very soon!</p>
<h2 id="repeating-statements-with-loops"><a class="header" href="#repeating-statements-with-loops">Repeating Statements with Loops</a></h2>
<p>Loops are used to execute a block of code multiple times. Move has two built-in types of loops:
<code>loop</code> and <code>while</code>. In many cases they can be used interchangeably, but usually <code>while</code> is used when
the number of iterations is known in advance, and <code>loop</code> is used when the number of iterations is
not known in advance or there are multiple exit points.</p>
<p>Loops are helpful when dealing with collections, such as vectors, or when we want to repeat a block
of code until a certain condition is met. However, it is important to be careful with loops, as they
can lead to infinite loops, which can lead to gas exhaustion and the transaction being aborted.</p>
<h2 id="the-while-loop"><a class="header" href="#the-while-loop">The <code>while</code> loop</a></h2>
<p>The <code>while</code> statement is used to execute a block of code as long as a boolean expression is true.
Just like we've seen with <code>if</code>, the boolean expression is evaluated before each iteration of the
loop. Just like conditional statements, the <code>while</code> loop is an expression and requires a semicolon
if there are other expressions following it.</p>
<p>The syntax for the <code>while</code> loop is:</p>
<pre><code class="language-move">while (&lt;bool_expression&gt;) { &lt;expressions&gt;; };
</code></pre>
<p>Here is an example of a <code>while</code> loop with a very simple condition:</p>
<pre><code class="language-move">    // This function iterates over the `x` variable until it reaches 10, the
    // return value is the number of iterations it took to reach 10.
    //
    // If `x` is 0, then the function will return 10.
    // If `x` is 5, then the function will return 5.
    fun while_loop(mut x: u8): u8 {
        let mut y = 0;

        // This will loop until `x` is 10.
        // And will never run if `x` is 10 or more.
        while (x &lt; 10) {
            y = y + 1;
            x = x + 1;
        };

        y
    }

    #[test]
    fun test_while() {
        assert!(while_loop(0) == 10, 0); // 10 times
        assert!(while_loop(5) == 5, 0);  // 5 times
        assert!(while_loop(10) == 0, 0); // loop never executed
    }
</code></pre>
<h2 id="infinite-loop"><a class="header" href="#infinite-loop">Infinite <code>loop</code></a></h2>
<p>Now let's imagine a scenario where the boolean expression is always <code>true</code>. For example, if we
literally passed <code>true</code> to the <code>while</code> condition. As you might expect, this would create an infinite
loop, and this is almost what the <code>loop</code> statement works like.</p>
<pre><code class="language-move">    #[test, expected_failure(out_of_gas, location=Self)]
    fun test_infinite_while() {
        let mut x = 0;

        // This will loop forever.
        while (true) {
            x = x + 1;
        };

        // This line will never be executed.
        assert!(x == 5, 0);
    }
</code></pre>
<p>An infinite <code>while</code>, or <code>while</code> without a condition, is a <code>loop</code>. The syntax for it is simple:</p>
<pre><code class="language-move">loop { &lt;expressions&gt;; };
</code></pre>
<p>Let's rewrite the previous example using <code>loop</code> instead of <code>while</code>:</p>
<pre><code class="language-move">    #[test, expected_failure(out_of_gas, location=Self)]
    fun test_infinite_loop() {
        let mut x = 0;

        // This will loop forever.
        loop {
            x = x + 1;
        };

        // This line will never be executed.
        assert!(x == 5, 0);
    }
</code></pre>
<!-- TODO: that's a weak point lmao -->
<p>Infinite loops on their own are not very useful in Move, since every operation in Move costs gas,
and an infinite loop will lead to gas exhaustion. However, they can be used in combination with
<code>break</code> and <code>continue</code> statements to create more complex loops.</p>
<h2 id="exiting-a-loop-early"><a class="header" href="#exiting-a-loop-early">Exiting a Loop Early</a></h2>
<p>As we already mentioned, infinite loops are rather useless on their own. And that's where we
introduce the <code>break</code> and <code>continue</code> statements. They are used to exit a loop early, and to skip the
rest of the current iteration, respectively.</p>
<p>Syntax for the <code>break</code> statement is (without a semicolon):</p>
<pre><code class="language-move">break
</code></pre>
<p>The <code>break</code> statement is used to stop the execution of a loop and exit it early. It is often used in
combination with a conditional statement to exit the loop when a certain condition is met. To
illustrate this point, let's turn the infinite <code>loop</code> from the previous example into something that
looks and behaves more like a <code>while</code> loop:</p>
<pre><code class="language-move">    #[test]
    fun test_break_loop() {
        let mut x = 0;

        // This will loop until `x` is 5.
        loop {
            x = x + 1;

            // If `x` is 5, then exit the loop.
            if (x == 5) {
                break // Exit the loop.
            }
        };

        assert!(x == 5, 0);
    }
</code></pre>
<p>Almost identical to the <code>while</code> loop, right? The <code>break</code> statement is used to exit the loop when <code>x</code>
is 5. If we remove the <code>break</code> statement, the loop will run forever, just like the previous example.</p>
<h2 id="skipping-an-iteration"><a class="header" href="#skipping-an-iteration">Skipping an Iteration</a></h2>
<p>The <code>continue</code> statement is used to skip the rest of the current iteration and start the next one.
Similarly to <code>break</code>, it is used in combination with a conditional statement to skip the rest of the
iteration when a certain condition is met.</p>
<p>Syntax for the <code>continue</code> statement is (without a semicolon):</p>
<pre><code class="language-move">continue
</code></pre>
<p>The example below skips odd numbers and prints only even numbers from 0 to 10:</p>
<pre><code class="language-move">    #[test]
    fun test_continue_loop() {
        let mut x = 0;

        // This will loop until `x` is 10.
        loop {
            x = x + 1;

            // If `x` is odd, then skip the rest of the iteration.
            if (x % 2 == 1) {
                continue // Skip the rest of the iteration.
            };

            std::debug::print(&amp;x);

            // If `x` is 10, then exit the loop.
            if (x == 10) {
                break // Exit the loop.
            }
        };

        assert!(x == 10, 0); // 10
    }
</code></pre>
<p><code>break</code> and <code>continue</code> statements can be used in both <code>while</code> and <code>loop</code> loops.</p>
<h2 id="early-return"><a class="header" href="#early-return">Early Return</a></h2>
<p>The <code>return</code> statement is used to exit a <a href="move-basics/./function.html">function</a> early and return a value. It is
often used in combination with a conditional statement to exit the function when a certain condition
is met. The syntax for the <code>return</code> statement is:</p>
<pre><code class="language-move">return &lt;expression&gt;
</code></pre>
<p>Here is an example of a function that returns a value when a certain condition is met:</p>
<pre><code class="language-move">    /// This function returns `true` if `x` is greater than 0 and not 5,
    /// otherwise it returns `false`.
    fun is_positive(x: u8): bool {
        if (x == 5) {
            return false
        };

        if (x &gt; 0) {
            return true
        };

        false
    }

    #[test]
    fun test_return() {
        assert!(is_positive(5) == false, 0);
        assert!(is_positive(0) == false, 0);
        assert!(is_positive(1) == true, 0);
    }
</code></pre>
<p>Unlike in other languages, the <code>return</code> statement is not required for the last expression in a
function. The last expression in a function block is automatically returned. However, the <code>return</code>
statement is useful when we want to exit a function early if a certain condition is met.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<!--

Chapter: Basic Syntax
Goal: Introduce constants.
Notes:
    - constants are immutable
    - constants are private
    - start with a capital letter always
    - stored in the bytecode (but w/o a name)
    - mention standard for naming constants

Links:
    - next section (abort and assert)
    - coding conventions (constants)
    - constants (language reference)

 -->
<p>Constants are immutable values that are defined at the module level. They often serve as a way to
give names to static values that are used throughout a module. For example, if there's a default
price for a product, you might define a constant for it. Constants are stored in the module's
bytecode, and each time they are used, the value is copied.</p>
<pre><code class="language-move">module book::shop_price {
    use sui::coin::Coin;
    use sui::sui::SUI;

    /// The price of an item in the shop.
    const ITEM_PRICE: u64 = 100;
    /// The owner of the shop, an address.
    const SHOP_OWNER: address = @0xa11ce;

    /// An item sold in the shop.
    public struct Item { /* ... */ }

    /// Purchase an item from the shop.
    public fun purchase(coin: Coin&lt;SUI&gt;): Item {
        assert!(coin.value() == ITEM_PRICE, 0);

        transfer::public_transfer(coin, SHOP_OWNER);

        Item { /* ... */ }
    }
}
</code></pre>
<h2 id="naming-convention"><a class="header" href="#naming-convention">Naming Convention</a></h2>
<p>Constants must start with a capital letter - this is enforced at the compiler level. For constants
used as a value, there's a convention to use uppercase letters and underscores to separate words.
It's a way to make constants stand out from other identifiers in the code. One exception is made for
<a href="move-basics/./assert-and-abort.html#assert-and-abort">error constants</a>, which are written in ECamelCase.</p>
<pre><code class="language-move">/// Price of the item used at the shop.
const ITEM_PRICE: u64 = 100;

/// Error constant.
const EItemNotFound: u64 = 1;
</code></pre>
<h2 id="constants-are-immutable"><a class="header" href="#constants-are-immutable">Constants are Immutable</a></h2>
<p>Constants can't be changed and assigned new values. They are part of the package bytecode, and
inherently immutable.</p>
<pre><code class="language-move">module book::immutable_constants {
    const ITEM_PRICE: u64 = 100;

    // emits an error
    fun change_price() {
        ITEM_PRICE = 200;
    }
}
</code></pre>
<h2 id="using-config-pattern"><a class="header" href="#using-config-pattern">Using Config Pattern</a></h2>
<p>A common use case for an application is to define a set of constants that are used throughout the
codebase. But due to constants being private to the module, they can't be accessed from other
modules. One way to solve this is to define a &quot;config&quot; module that exports the constants.</p>
<pre><code class="language-move">module book::config {
    const ITEM_PRICE: u64 = 100;
    const TAX_RATE: u64 = 10;
    const SHIPPING_COST: u64 = 5;

    /// Returns the price of an item.
    public fun item_price(): u64 { ITEM_PRICE }
    /// Returns the tax rate.
    public fun tax_rate(): u64 { TAX_RATE }
    /// Returns the shipping cost.
    public fun shipping_cost(): u64 { SHIPPING_COST }
}
</code></pre>
<p>This way other modules can import and read the constants, and the update process is simplified. If
the constants need to be changed, only the config module needs to be updated during the package
upgrade.</p>
<h2 id="links-1"><a class="header" href="#links-1">Links</a></h2>
<ul>
<li><a href="move-basics//reference/constants.html">Constants</a> in the Move Reference</li>
<li><a href="move-basics/./../guides/coding-conventions.html#constant">Coding conventions for constants</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aborting-execution"><a class="header" href="#aborting-execution">Aborting Execution</a></h1>
<!-- Consider "aborting execution" -->
<!--

Chapter: Basic Syntax
Goal: Introduce abort keyword and `assert!` macro.
Notes:
    - previous chapter mentions constants
    - error constants standard ECamelCase
    - `assert!` macro
    - asserts should go before the main logic
    - Move has no catch mechanism
    - abort codes are local to the module
    - there are no error messages emitted
    - error codes should handle all possible scenarios in this module

Links:
    - constants (previous section)
 -->
<p>A transaction can either succeed or fail. Successful execution applies all the changes made to
objects and on-chain data, and the transaction is committed to the blockchain. Alternatively, if a
transaction aborts, the changes are not applied. The <code>abort</code> keyword is used to abort a transaction
and revert the changes made so far.</p>
<blockquote>
<p>It is important to note that there is no catch mechanism in Move. If a transaction aborts, the
changes made so far are reverted, and the transaction is considered failed.</p>
</blockquote>
<h2 id="abort"><a class="header" href="#abort">Abort</a></h2>
<p>The <code>abort</code> keyword is used to abort the execution of a transaction. It is used in combination with
an abort code, which will be returned to the caller of the transaction. The abort code is an
<a href="move-basics/./primitive-types.html">integer</a> of type <code>u64</code>.</p>
<pre><code class="language-move">let user_has_access = true;

// abort with a predefined constant if `user_has_access` is false
if (!user_has_access) {
    abort 0
};

// there's an alternative syntax using parenthesis`
if (user_has_access) {
   abort(1)
};
</code></pre>
<p>The code above will, of course, abort with abort code <code>1</code>.</p>
<h2 id="assert"><a class="header" href="#assert">assert!</a></h2>
<p>The <code>assert!</code> macro is a built-in macro that can be used to assert a condition. If the condition is
false, the transaction will abort with the given abort code. The <code>assert!</code> macro is a convenient way
to abort a transaction if a condition is not met. The macro shortens the code otherwise written with
an <code>if</code> expression + <code>abort</code>. The <code>code</code> argument is required and has to be a <code>u64</code> value.</p>
<pre><code class="language-move">// aborts if `user_has_access` is `false` with abort code 0
assert!(user_has_access, 0);

// expands into:
if (!user_has_access) {
    abort 0
};
</code></pre>
<h2 id="error-constants"><a class="header" href="#error-constants">Error constants</a></h2>
<p>To make error codes more descriptive, it is a good practice to define
<a href="move-basics/./constants.html">error constants</a>. Error constants are defined as <code>const</code> declarations and are
usually prefixed with <code>E</code> followed by a camel case name. Error constants are no different from other
constants and don't have special handling, however, they are used to increase the readability of the
code and make it easier to understand the abort scenarios.</p>
<pre><code class="language-move">/// Error code for when the user has no access.
const ENoAccess: u64 = 0;
/// Trying to access a field that does not exist.
const ENoField: u64 = 1;

/// Updates a record.
public fun update_record(/* ... , */ user_has_access: bool, field_exists: bool) {
    // asserts are way more readable now
    assert!(user_has_access, ENoAccess);
    assert!(field_exists, ENoField);

    /* ... */
}
</code></pre>
<h2 id="further-reading-11"><a class="header" href="#further-reading-11">Further reading</a></h2>
<ul>
<li><a href="move-basics//reference/abort-and-assert.html">Abort and Assert</a> in the Move Reference.</li>
<li>We suggest reading the <a href="move-basics/./../guides/better-error-handling.html">Better Error Handling</a> guide to
learn about best practices for error handling in Move.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function"><a class="header" href="#function">Function</a></h1>
<p>Functions are the building blocks of Move programs. They are called from
<a href="move-basics/../concepts/user-interaction.html">user transactions</a> and from other functions and group executable
code into reusable units. Functions can take arguments and return a value. They are declared with
the <code>fun</code> keyword at the module level. Just like any other module member, by default they're private
and can only be accessed from within the module.</p>
<pre><code class="language-move">module book::math {
    /// Function takes two arguments of type `u64` and returns their sum.
    /// The `public` visibility modifier makes the function accessible from
    /// outside the module.
    public fun add(a: u64, b: u64): u64 {
        a + b
    }

    #[test]
    fun test_add() {
        let sum = add(1, 2);
        assert!(sum == 3, 0);
    }
}
</code></pre>
<p>In this example, we define a function <code>add</code> that takes two arguments of type <code>u64</code> and returns their
sum. The function is called from the <code>test_add</code> function, which is a test function located in the
same module. In the test we compare the result of the <code>add</code> function with the expected value and
abort the execution if the result is different.</p>
<h2 id="function-declaration"><a class="header" href="#function-declaration">Function declaration</a></h2>
<blockquote>
<p>There's a convention to call functions in Move with the <code>snake_case</code> naming convention. This means
that the function name should be all lowercase with words separated by underscores. For example,
<code>do_something</code>, <code>add</code>, <code>get_balance</code>, <code>is_authorized</code>, and so on.</p>
</blockquote>
<p>A function is declared with the <code>fun</code> keyword followed by the function name (a valid Move
identifier), a list of arguments in parentheses, and a return type. The function body is a block of
code that contains a sequence of statements and expressions. The last expression in the function
body is the return value of the function.</p>
<pre><code class="language-move">fun return_nothing() {
    // empty expression, function returns `()`
}
</code></pre>
<h2 id="accessing-functions"><a class="header" href="#accessing-functions">Accessing functions</a></h2>
<p>Just like any other module member, functions can be imported and accessed via a path. The path
consists of the module path and the function name separated by <code>::</code>. For example, if you have a
function called <code>add</code> in the <code>math</code> module in the <code>book</code> package, the path to it will be
<code>book::math::add</code>, or, if the module is imported, <code>math::add</code>.</p>
<pre><code class="language-move">module book::use_math {
    use book::math;

    fun call_add() {
        // function is called via the path
        let sum = math::add(1, 2);
    }
}
</code></pre>
<h2 id="multiple-return-values"><a class="header" href="#multiple-return-values">Multiple return values</a></h2>
<p>Move functions can return multiple values, which is useful when you need to return more than one
value from a function. The return type of the function is a tuple of types. The return value is a
tuple of expressions.</p>
<pre><code class="language-move">fun get_name_and_age(): (vector&lt;u8&gt;, u8) {
    (b&quot;John&quot;, 25)
}
</code></pre>
<p>Result of a function call with tuple return has to be unpacked into variables via <code>let (tuple)</code>
syntax:</p>
<pre><code class="language-move">// Tuple must be destructured to access its elements.
// Name and age are declared as immutable variables.
let (name, age) = get_name_and_age();
assert!(name == b&quot;John&quot;, 0);
assert!(age == 25, 0);
</code></pre>
<p>If any of the declared values need to be declared as mutable, the <code>mut</code> keyword is placed before the
variable name:</p>
<pre><code class="language-move">// declare name as mutable, age as immutable
let (mut name, age) = get_name_and_age();
</code></pre>
<p>If some of the arguments are not used, they can be ignored with the <code>_</code> symbol:</p>
<pre><code class="language-move">// ignore the name, only use the age
let (_, age) = get_name_and_age();
</code></pre>
<h2 id="further-reading-12"><a class="header" href="#further-reading-12">Further reading</a></h2>
<ul>
<li><a href="move-basics//reference/functions.html">Functions</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-methods"><a class="header" href="#struct-methods">Struct Methods</a></h1>
<p>Move Compiler supports <em>receiver syntax</em>, which allows defining methods which can be called on
instances of a struct. This is similar to the method syntax in other programming languages. It is a
convenient way to define functions which operate on the fields of a struct.</p>
<h2 id="method-syntax"><a class="header" href="#method-syntax">Method syntax</a></h2>
<p>If the first argument of a function is a struct internal to the module, then the function can be
called using the <code>.</code> operator. If the function uses a struct from another module, then method won't
be associated with the struct by default. In this case, the function can be called using the
standard function call syntax.</p>
<p>When a module is imported, the methods are automatically associated with the struct.</p>
<pre><code class="language-move">module book::hero {
    /// A struct representing a hero.
    public struct Hero has drop {
        health: u8,
        mana: u8,
    }

    /// Create a new Hero.
    public fun new(): Hero { Hero { health: 100, mana: 100 } }

    /// A method which casts a spell, consuming mana.
    public fun heal_spell(hero: &amp;mut Hero) {
        hero.health = hero.health + 10;
        hero.mana = hero.mana - 10;
    }

    /// A method which returns the health of the hero.
    public fun health(hero: &amp;Hero): u8 { hero.health }

    /// A method which returns the mana of the hero.
    public fun mana(hero: &amp;Hero): u8 { hero.mana }

    #[test]
    // Test the methods of the `Hero` struct.
    fun test_methods() {
        let mut hero = new();
        hero.heal_spell();

        assert!(hero.health() == 110, 1);
        assert!(hero.mana() == 90, 2);
    }
}
</code></pre>
<h2 id="method-aliases"><a class="header" href="#method-aliases">Method Aliases</a></h2>
<p>For modules that define multiple structs and their methods, it is possible to define method aliases
to avoid name conflicts, or to provide a better-named method for a struct.</p>
<p>The syntax for aliases is:</p>
<pre><code class="language-move">// for local method association
use fun function_path as Type.method_name;

// exported alias
public use fun function_path as Type.method_name;
</code></pre>
<blockquote>
<p>Public aliases are only allowed for structs defined in the same module. If a struct is defined in
another module, an alias can still be created but cannot be made public.</p>
</blockquote>
<p>In the example below, we changed the <code>hero</code> module and added another type - <code>Villain</code>. Both <code>Hero</code>
and <code>Villain</code> have similar field names and methods. And to avoid name conflicts, we prefixed methods
with <code>hero_</code> and <code>villain_</code> respectively. However, we can create aliases for these methods so that
they can be called on the instances of the structs without the prefix.</p>
<pre><code class="language-move">module book::hero_and_villain {
    /// A struct representing a hero.
    public struct Hero has drop {
        health: u8,
    }

    /// A struct representing a villain.
    public struct Villain has drop {
        health: u8,
    }

    /// Create a new Hero.
    public fun new_hero(): Hero { Hero { health: 100 } }

    /// Create a new Villain.
    public fun new_villain(): Villain { Villain { health: 100 } }

    // Alias for the `hero_health` method. Will be imported automatically when
    // the module is imported.
    public use fun hero_health as Hero.health;

    public fun hero_health(hero: &amp;Hero): u8 { hero.health }

    // Alias for the `villain_health` method. Will be imported automatically
    // when the module is imported.
    public use fun villain_health as Villain.health;

    public fun villain_health(villain: &amp;Villain): u8 { villain.health }

    #[test]
    // Test the methods of the `Hero` and `Villain` structs.
    fun test_associated_methods() {
        let hero = new_hero();
        assert!(hero.health() == 100, 1);

        let villain = new_villain();
        assert!(villain.health() == 100, 3);
    }
}
</code></pre>
<p>As you can see, in the test function, we called the <code>health</code> method on the instances of <code>Hero</code> and
<code>Villain</code> without the prefix. The compiler will automatically associate the methods with the
structs.</p>
<h2 id="aliasing-an-external-modules-method"><a class="header" href="#aliasing-an-external-modules-method">Aliasing an external module's method</a></h2>
<p>It is also possible to associate a function defined in another module with a struct from the current
module. Following the same approach, we can create an alias for the method defined in another
module. Let's use the <code>bcs::to_bytes</code> method from the <a href="move-basics/./standard-library.html">Standard Library</a> and
associate it with the <code>Hero</code> struct. It will allow serializing the <code>Hero</code> struct to a vector of
bytes.</p>
<pre><code class="language-move">// TODO: better example (external module...)
module book::hero_to_bytes {
    // Alias for the `bcs::to_bytes` method. Imported aliases should be defined
    // in the top of the module.
    // public use fun bcs::to_bytes as Hero.to_bytes;

    /// A struct representing a hero.
    public struct Hero has drop {
        health: u8,
        mana: u8,
    }

    /// Create a new Hero.
    public fun new(): Hero { Hero { health: 100, mana: 100 } }

    #[test]
    // Test the methods of the `Hero` struct.
    fun test_hero_serialize() {
        // let mut hero = new();
        // let serialized = hero.to_bytes();
        // assert!(serialized.length() == 3, 1);
    }
}
</code></pre>
<h2 id="further-reading-13"><a class="header" href="#further-reading-13">Further reading</a></h2>
<ul>
<li><a href="move-basics//reference/method-syntax.html">Method Syntax</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visibility-modifiers"><a class="header" href="#visibility-modifiers">Visibility Modifiers</a></h1>
<p>Every module member has a visibility. By default, all module members are <em>private</em> - meaning they
are only accessible within the module they are defined in. However, you can add a visibility
modifier to make a module member <em>public</em> - visible outside the module, or <em>public(package)</em> -
visible in the modules within the same package, or <em>entry</em> - can be called from a transaction but
can't be called from other modules.</p>
<h2 id="internal-visibility"><a class="header" href="#internal-visibility">Internal Visibility</a></h2>
<p>A function or a struct defined in a module which has no visibility modifier is <em>private</em> to the
module. It can't be called from other modules.</p>
<pre><code class="language-move">module book::internal_visibility {
    // This function can be called from other functions in the same module
    fun internal() { /* ... */ }

    // Same module -&gt; can call internal()
    fun call_internal() {
        internal();
    }
}
</code></pre>
<!-- Move compiler won't allow this code to compile: -->
<!-- TODO: add failure flag to example -->
<pre><code class="language-move">module book::try_calling_internal {
    use book::internal_visibility;

    // Different module -&gt; can't call internal()
    fun try_calling_internal() {
        internal_visibility::internal();
    }
}
</code></pre>
<h2 id="public-visibility"><a class="header" href="#public-visibility">Public Visibility</a></h2>
<p>A struct or a function can be made <em>public</em> by adding the <code>public</code> keyword before the <code>fun</code> or
<code>struct</code> keyword.</p>
<pre><code class="language-move">module book::public_visibility {
    // This function can be called from other modules
    public fun public() { /* ... */ }
}
</code></pre>
<p>A public function can be imported and called from other modules. The following code will compile:</p>
<pre><code class="language-move">module book::try_calling_public {
    use book::public_visibility;

    // Different module -&gt; can call public()
    fun try_calling_public() {
        public_visibility::public();
    }
}
</code></pre>
<h2 id="package-visibility"><a class="header" href="#package-visibility">Package Visibility</a></h2>
<p>Move 2024 introduces the <em>package visibility</em> modifier. A function with <em>package visibility</em> can be
called from any module within the same package. It can't be called from other packages.</p>
<pre><code class="language-move">module book::package_visibility {
    public(package) fun package_only() { /* ... */ }
}
</code></pre>
<p>A package function can be called from any module within the same package:</p>
<pre><code class="language-move">module book::try_calling_package {
    use book::package_visibility;

    // Same package `book` -&gt; can call package_only()
    fun try_calling_package() {
        package_visibility::package_only();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-scope"><a class="header" href="#ownership-and-scope">Ownership and Scope</a></h1>
<p>Every variable in Move has a scope and an owner. The scope is the range of code where the variable
is valid, and the owner is the scope that this variable belongs to. Once the owner scope ends, the
variable is dropped. This is a fundamental concept in Move, and it is important to understand how it
works.</p>
<!--

- Borrow Checker
- Mention Rust's borrow checker
- Borrowing / References intro

-->
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>A variable defined in a function scope is owned by this scope. The runtime goes through the function
scope and executes every expression and statement. Once the function scope end, the variables
defined in it are dropped or deallocated.</p>
<pre><code class="language-move">module book::ownership {
    public fun owner() {
        let a = 1; // a is owned by the `owner` function
    } // a is dropped here

    public fun other() {
        let b = 2; // b is owned by the `other` function
    } // b is dropped here

    #[test]
    fun test_owner() {
        owner();
        other();
        // a &amp; b is not valid here
    }
}
</code></pre>
<p>In the example above, the variable <code>a</code> is owned by the <code>owner</code> function, and the variable <code>b</code> is
owned by the <code>other</code> function. When each of these functions are called, the variables are defined,
and when the function ends, the variables are discarded.</p>
<h2 id="returning-a-value"><a class="header" href="#returning-a-value">Returning a Value</a></h2>
<p>If we changed the <code>owner</code> function to return the variable <code>a</code>, then the ownership of <code>a</code> would be
transferred to the caller of the function.</p>
<pre><code class="language-move">module book::ownership {
    public fun owner(): u8 {
        let a = 1; // a defined here
        a // scope ends, a is returned
    }

    #[test]
    fun test_owner() {
        let a = owner();
        // a is valid here
    } // a is dropped here
}
</code></pre>
<h2 id="passing-by-value"><a class="header" href="#passing-by-value">Passing by Value</a></h2>
<p>Additionally, if we passed the variable <code>a</code> to another function, the ownership of <code>a</code> would be
transferred to this function. When performing this operation, we <em>move</em> the value from one scope to
another. This is also called <em>move semantics</em>.</p>
<pre><code class="language-move">module book::ownership {
    public fun owner(): u8 {
        let a = 10;
        a
    } // a is returned

    public fun take_ownership(v: u8) {
        // v is owned by `take_ownership`
    } // v is dropped here

    #[test]
    fun test_owner() {
        let a = owner();
        take_ownership(a);
        // a is not valid here
    }
}
</code></pre>
<h2 id="scopes-with-blocks"><a class="header" href="#scopes-with-blocks">Scopes with Blocks</a></h2>
<p>Each function has a main scope, and it can also have sub-scopes via the use of blocks. A block is a
sequence of statements and expressions, and it has its own scope. Variables defined in a block are
owned by this block, and when the block ends, the variables are dropped.</p>
<pre><code class="language-move">module book::ownership {
    public fun owner() {
        let a = 1; // a is owned by the `owner` function's scope
        {
            let b = 2; // b is owned by the block
            {
                let c = 3; // c is owned by the block
            }; // c is dropped here
        }; // b is dropped here
        // a = b; // error: b is not valid here
        // a = c; // error: c is not valid here
    } // a is dropped here
}
</code></pre>
<p>However, shall we use the return value of a block, the ownership of the variable is transferred to
the caller of the block.</p>
<pre><code class="language-move">module book::ownership {
    public fun owner(): u8 {
        let a = 1; // a is owned by the `owner` function's scope
        let b = {
            let c = 2; // c is owned by the block
            c // c is returned
        }; // c is dropped here
        a + b // both a and b are valid here
    }
}
</code></pre>
<h2 id="copyable-types"><a class="header" href="#copyable-types">Copyable Types</a></h2>
<p>Some types in Move are <em>copyable</em>, which means that they can be copied without transferring the
ownership. This is useful for types that are small and cheap to copy, such as integers and booleans.
Move compiler will automatically copy these types when they are passed to a function or returned
from a function, or when they're <em>moved</em> to a scope and then accessed in their original scope.</p>
<h2 id="further-reading-14"><a class="header" href="#further-reading-14">Further reading</a></h2>
<ul>
<li><a href="move-basics//reference/variables.html">Local Variables and Scopes</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abilities-copy"><a class="header" href="#abilities-copy">Abilities: Copy</a></h1>
<p>In Move, the <em>copy</em> ability on a type indicates that the instance or the value of the type can be
copied. While this behavior may feel very natural when working with numbers or other simple types,
it is not the default for custom types in Move. This is because Move is designed to express digital
assets and resources, and inability to copy is a key element of the resource model.</p>
<p>However, Move type system allows you to define custom types with the <em>copy</em> ability.</p>
<pre><code class="language-move">public struct Copyable has copy {}
</code></pre>
<p>In the example above, we define a custom type <code>Copyable</code> with the <em>copy</em> ability. This means that
instances of <code>Copyable</code> can be copied, both implicitly and explicitly.</p>
<pre><code class="language-move">let a = Copyable {};
let b = a;   // `a` is copied to `b`
let c = *&amp;b; // explicit copy via dereference operator

let Copyable {} = a; // doesn't have `drop`
let Copyable {} = b; // doesn't have `drop`
let Copyable {} = c; // doesn't have `drop`
</code></pre>
<p>In the example above, <code>a</code> is copied to <code>b</code> implicitly, and then explicitly copied to <code>c</code> using the
dereference operator. If <code>Copyable</code> did not have the <em>copy</em> ability, the code would not compile, and
the Move compiler would raise an error.</p>
<h2 id="copying-and-drop"><a class="header" href="#copying-and-drop">Copying and Drop</a></h2>
<p>The <code>copy</code> ability is closely related to <a href="move-basics/./drop-ability.html"><code>drop</code> ability</a>. If a type has the
<em>copy</em> ability, very likely that it should have <code>drop</code> too. This is because the <em>drop</em> ability is
required to clean up the resources when the instance is no longer needed. If a type has only <em>copy</em>,
then managing its instances gets more complicated, as the values cannot be ignored.</p>
<pre><code class="language-move">public struct Value has copy, drop {}
</code></pre>
<p>All of the primitive types in Move behave as if they have the <em>copy</em> and <em>drop</em> abilities. This
means that they can be copied and dropped, and the Move compiler will handle the memory management
for them.</p>
<h2 id="types-with-the-copy-ability"><a class="header" href="#types-with-the-copy-ability">Types with the <code>copy</code> Ability</a></h2>
<p>All native types in Move have the <code>copy</code> ability. This includes:</p>
<ul>
<li><a href="move-basics/./../move-basics/primitive-types.html#booleans">bool</a></li>
<li><a href="move-basics/./../move-basics/primitive-types.html#integers">unsigned integers</a></li>
<li><a href="move-basics/./../move-basics/vector.html">vector</a></li>
<li><a href="move-basics/./../move-basics/address.html">address</a></li>
</ul>
<p>All of the types defined in the standard library have the <code>copy</code> ability as well. This includes:</p>
<ul>
<li><a href="move-basics/./../move-basics/option.html">Option</a></li>
<li><a href="move-basics/./../move-basics/string.html">String</a></li>
<li><a href="move-basics/./../move-basics/type-reflection.html#typename">TypeName</a></li>
</ul>
<h2 id="further-reading-15"><a class="header" href="#further-reading-15">Further reading</a></h2>
<ul>
<li><a href="move-basics//reference/type-abilities.html">Type Abilities</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<!--

Chapter: Basic Syntax
Goal: Show what the borrow checker is and how it works.
Notes:
    - give the metro pass example
    - show why passing by reference is useful
    - mention that reference comparison is faster
    - references can be both mutable and immutable
    - immutable access to shared objects is faster
    - implicit copy
    - moving the value
    - unpacking a reference (mutable and immutable)

 -->
<p>In the <a href="move-basics/./ownership-and-scope.html">Ownership and Scope</a> section, we explained that when a value is
passed to a function, it is <em>moved</em> to the function's scope. This means that the function becomes
the owner of the value, and the original scope (owner) can no longer use it. This is an important
concept in Move, as it ensures that the value is not used in multiple places at the same time.
However, there are use cases when we want to pass a value to a function but retain the ownership.
This is where references come into play.</p>
<p>To illustrate this, let's consider a simple example - an application for a metro (subway) pass. We
will look at 4 different scenarios:</p>
<ol>
<li>Card can be purchased at the kiosk for a fixed price</li>
<li>Card can be shown to inspectors to prove that the passenger has a valid pass</li>
<li>Card can be used at the turnstile to enter the metro, and spend a ride</li>
<li>Card can be recycled once it's empty</li>
</ol>
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<p>The initial layout of the metro pass application is simple. We define the <code>Card</code> type and the <code>USES</code>
<a href="move-basics/./constants.html">constant</a> that represents the number of rides for a single card. We also add an
<a href="move-basics/./assert-and-abort.html#error-constants">error constant</a> for the case when the card is empty.</p>
<pre><code class="language-move">module book::metro_pass {
    /// Error code for when the card is empty.
    const ENoUses: u64 = 0;

    /// Number of uses for a metro pass card.
    const USES: u8 = 3;

    /// A metro pass card
    public struct Card { uses: u8 }

    /// Purchase a metro pass card.
    public fun purchase(/* pass a Coin */): Card {
        Card { uses: USES }
    }
}
</code></pre>
<!-- In [the previous section](./ownership-and-scope.md) we explained the ownership and scope in Move. We showed how the value is *moved* to a new scope, and how it changes the owner. In this section, we will explain how to *borrow* a reference to a value to avoid moving it, and how Move's *borrow checker* ensures that the references are used correctly. -->
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<p>References are a way to <em>show</em> a value to a function without giving up the ownership. In our case,
when we show the Card to the inspector, we don't want to give up the ownership of it, and we don't
allow them to spend the rides. We just want to allow <em>reading</em> the value of the Card and prove its
ownership.</p>
<p>To do so, in the function signature, we use the <code>&amp;</code> symbol to indicate that we are passing a
reference to the value, not the value itself.</p>
<pre><code class="language-move">    /// Show the metro pass card to the inspector.
    public fun is_valid(card: &amp;Card): bool {
        card.uses &gt; 0
    }
</code></pre>
<p>Now the function can't take the ownership of the card, and it can't spend the rides. But it can read
its value. Worth noting, that a signature like this makes it impossible to call the function without
a Card at all. This is an important property which allows the
<a href="move-basics/./../programmability/capability.html">Capability Pattern</a> which we will cover in the next chapters.</p>
<h2 id="mutable-reference"><a class="header" href="#mutable-reference">Mutable Reference</a></h2>
<p>In some cases, we want to allow the function to change the value of the Card. For example, when we
use the Card at the turnstile, we want to spend a ride. To implement it, we use the <code>&amp;mut</code> keyword
in the function signature.</p>
<pre><code class="language-move">    /// Use the metro pass card at the turnstile to enter the metro.
    public fun enter_metro(card: &amp;mut Card) {
        assert!(card.uses &gt; 0, ENoUses);
        card.uses = card.uses - 1;
    }
</code></pre>
<p>As you can see in the function body, the <code>&amp;mut</code> reference allows mutating the value, and the
function can spend the rides.</p>
<h2 id="passing-by-value-1"><a class="header" href="#passing-by-value-1">Passing by Value</a></h2>
<p>Lastly, let's give an illustration of what happens when we pass the value itself to the function. In
this case, the function takes the ownership of the value, and the original scope can no longer use
it. The owner of the Card can recycle it, and, hence, lose the ownership.</p>
<pre><code class="language-move">    /// Recycle the metro pass card.
    public fun recycle(card: Card) {
        assert!(card.uses == 0, ENoUses);
        let Card { uses: _ } = card;
    }
</code></pre>
<p>In the <code>recycle</code> function, the Card is <em>taken by value</em> and can be unpacked and destroyed. The
original scope can't use it anymore.</p>
<h2 id="full-example"><a class="header" href="#full-example">Full Example</a></h2>
<p>To illustrate the full flow of the application, let's put all the pieces together in a test.</p>
<pre><code class="language-move">    #[test]
    fun test_card_2024() {
        // declaring variable as mutable because we modify it
        let mut card = purchase();

        card.enter_metro(); // modify the card but don't move it
        assert!(card.is_valid(), 0); // read the card!

        card.enter_metro(); // modify the card but don't move it
        card.enter_metro(); // modify the card but don't move it

        card.recycle(); // move the card out of the scope
    }
</code></pre>
<!-- ## Dereference and Copy -->
<!-- TODO: defer and copy, *& -->
<!-- ## Notes -->
<!--
    Move 2024 is great but it's better to show the example with explicit &t and &mut t
    ...and then say that the example could be rewritten with the new syntax


-->
<!-- ## Move 2024

Here's the test from this page written with the Move 2024 syntax:

```move
    #[test]
    fun test_card_2024() {
        // declaring variable as mutable because we modify it
        let mut card = purchase();

        card.enter_metro(); // modify the card but don't move it
        assert!(card.is_valid(), 0); // read the card!

        card.enter_metro(); // modify the card but don't move it
        card.enter_metro(); // modify the card but don't move it

        card.recycle(); // move the card out of the scope
    }
```
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Generics are a way to define a type or function that can work with any type. This is useful when you
want to write a function which can be used with different types, or when you want to define a type
that can hold any other type. Generics are the foundation of many advanced features in Move, such as
collections, abstract implementations, and more.</p>
<h2 id="in-the-standard-library"><a class="header" href="#in-the-standard-library">In the Standard Library</a></h2>
<p>In this chapter we already mentioned the <a href="move-basics/./vector.html">vector</a> type, which is a generic type that
can hold any other type. Another example of a generic type in the standard library is the
<a href="move-basics/./option.html">Option</a> type, which is used to represent a value that may or may not be present.</p>
<h2 id="generic-syntax"><a class="header" href="#generic-syntax">Generic Syntax</a></h2>
<p>To define a generic type or function, a type signature needs to have a list of generic parameters
enclosed in angle brackets (<code>&lt;</code> and <code>&gt;</code>). The generic parameters are separated by commas.</p>
<pre><code class="language-move">/// Container for any type `T`.
public struct Container&lt;T&gt; has drop {
    value: T,
}

/// Function that creates a new `Container` with a generic value `T`.
public fun new&lt;T&gt;(value: T): Container&lt;T&gt; {
    Container { value }
}
</code></pre>
<p>In the example above, <code>Container</code> is a generic type with a single type parameter <code>T</code>, the <code>value</code>
field of the container stores the <code>T</code>. The <code>new</code> function is a generic function with a single type
parameter <code>T</code>, and it returns a <code>Container</code> with the given value. Generic types must be initialed
with a concrete type, and generic functions must be called with a concrete type.</p>
<pre><code class="language-move">#[test]
fun test_container() {
    // these three lines are equivalent
    let container: Container&lt;u8&gt; = new(10); // type inference
    let container = new&lt;u8&gt;(10); // create a new `Container` with a `u8` value
    let container = new(10u8);

    assert!(container.value == 10, 0x0);

    // Value can be ignored only if it has the `drop` ability.
    let Container { value: _ } = container;
}
</code></pre>
<p>In the test function <code>test_generic</code> we demonstrate three equivalent ways to create a new <code>Container</code>
with a <code>u8</code> value. Because numeric types need to be inferred, we specify the type of the number
literal.</p>
<h2 id="multiple-type-parameters"><a class="header" href="#multiple-type-parameters">Multiple Type Parameters</a></h2>
<p>You can define a type or function with multiple type parameters. The type parameters are then
separated by commas.</p>
<pre><code class="language-move">/// A pair of values of any type `T` and `U`.
public struct Pair&lt;T, U&gt; {
    first: T,
    second: U,
}

/// Function that creates a new `Pair` with two generic values `T` and `U`.
public fun new_pair&lt;T, U&gt;(first: T, second: U): Pair&lt;T, U&gt; {
    Pair { first, second }
}
</code></pre>
<p>In the example above, <code>Pair</code> is a generic type with two type parameters <code>T</code> and <code>U</code>, and the
<code>new_pair</code> function is a generic function with two type parameters <code>T</code> and <code>U</code>. The function returns
a <code>Pair</code> with the given values. The order of the type parameters is important, and it should match
the order of the type parameters in the type signature.</p>
<pre><code class="language-move">#[test]
fun test_generic() {
    // these three lines are equivalent
    let pair_1: Pair&lt;u8, bool&gt; = new_pair(10, true); // type inference
    let pair_2 = new_pair&lt;u8, bool&gt;(10, true); // create a new `Pair` with a `u8` and `bool` values
    let pair_3 = new_pair(10u8, true);

    assert!(pair_1.first == 10, 0x0);
    assert!(pair_1.second, 0x0);

    // Unpacking is identical.
    let Pair { first: _, second: _ } = pair_1;
    let Pair { first: _, second: _ } = pair_2;
    let Pair { first: _, second: _ } = pair_3;

}
</code></pre>
<p>If we added another instance where we swapped type parameters in the <code>new_pair</code> function, and tried
to compare two types, we'd see that the type signatures are different, and cannot be compared.</p>
<pre><code class="language-move">#[test]
fun test_swap_type_params() {
    let pair1: Pair&lt;u8, bool&gt; = new_pair(10u8, true);
    let pair2: Pair&lt;bool, u8&gt; = new_pair(true, 10u8);

    // this line will not compile
    // assert!(pair1 == pair2, 0x0);

    let Pair { first: pf1, second: ps1 } = pair1; // first1: u8, second1: bool
    let Pair { first: pf2, second: ps2 } = pair2; // first2: bool, second2: u8

    assert!(pf1 == ps2, 0x0); // 10 == 10
    assert!(ps1 == pf2, 0x0); // true == true
}
</code></pre>
<p>Types for variables <code>pair1</code> and <code>pair2</code> are different, and the comparison will not compile.</p>
<h2 id="why-generics"><a class="header" href="#why-generics">Why Generics?</a></h2>
<p>In the examples above we focused on instantiating generic types and calling generic functions to
create instances of these types. However, the real power of generics is the ability to define shared
behavior for the base, generic type, and then use it independently of the concrete types. This is
especially useful when working with collections, abstract implementations, and other advanced
features in Move.</p>
<pre><code class="language-move">/// A user record with name, age, and some generic metadata
public struct User&lt;T&gt; {
    name: String,
    age: u8,
    /// Varies depending on application.
    metadata: T,
}
</code></pre>
<p>In the example above, <code>User</code> is a generic type with a single type parameter <code>T</code>, with shared fields
<code>name</code> and <code>age</code>, and the generic <code>metadata</code> field which can store any type. No matter what the
<code>metadata</code> is, all of the instances of <code>User</code> will have the same fields and methods.</p>
<pre><code class="language-move">/// Updates the name of the user.
public fun update_name&lt;T&gt;(user: &amp;mut User&lt;T&gt;, name: String) {
    user.name = name;
}

/// Updates the age of the user.
public fun update_age&lt;T&gt;(user: &amp;mut User&lt;T&gt;, age: u8) {
    user.age = age;
}
</code></pre>
<h2 id="phantom-type-parameters"><a class="header" href="#phantom-type-parameters">Phantom Type Parameters</a></h2>
<p>In some cases, you may want to define a generic type with a type parameter that is not used in the
fields or methods of the type. This is called a <em>phantom type parameter</em>. Phantom type parameters
are useful when you want to define a type that can hold any other type, but you want to enforce some
constraints on the type parameter.</p>
<pre><code class="language-move">/// A generic type with a phantom type parameter.
public struct Coin&lt;phantom T&gt; {
    value: u64
}
</code></pre>
<p>The <code>Coin</code> type here does not contain any fields or methods that use the type parameter <code>T</code>. It is
used to differentiate between different types of coins, and to enforce some constraints on the type
parameter <code>T</code>.</p>
<pre><code class="language-move">public struct USD {}
public struct EUR {}

#[test]
fun test_phantom_type() {
    let coin1: Coin&lt;USD&gt; = Coin { value: 10 };
    let coin2: Coin&lt;EUR&gt; = Coin { value: 20 };

    // Unpacking is identical because the phantom type parameter is not used.
    let Coin { value: _ } = coin1;
    let Coin { value: _ } = coin2;
}
</code></pre>
<p>In the example above, we demonstrate how to create two different instances of <code>Coin</code> with different
phantom type parameters <code>USD</code> and <code>EUR</code>. The type parameter <code>T</code> is not used in the fields or methods
of the <code>Coin</code> type, but it is used to differentiate between different types of coins. It will make
sure that the <code>USD</code> and <code>EUR</code> coins are not mixed up.</p>
<h2 id="constraints-on-type-parameters"><a class="header" href="#constraints-on-type-parameters">Constraints on Type Parameters</a></h2>
<p>Type parameters can be constrained to have certain abilities. This is useful when you need the inner
type to allow certain behavior, such as <em>copy</em> or <em>drop</em>. The syntax for constraining a type
parameter is <code>T: &lt;ability&gt; + &lt;ability&gt;</code>.</p>
<pre><code class="language-move">/// A generic type with a type parameter that has the `drop` ability.
public struct Droppable&lt;T: drop&gt; {
    value: T,
}

/// A generic struct with a type parameter that has the `copy` and `drop` abilities.
public struct CopyableDroppable&lt;T: copy + drop&gt; {
    value: T, // T must have the `copy` and `drop` abilities
}
</code></pre>
<p>Move Compiler will enforce that the type parameter <code>T</code> has the specified abilities. If the type
parameter does not have the specified abilities, the code will not compile.</p>
<!-- TODO: failure case -->
<pre><code class="language-move">/// Type without any abilities.
public struct NoAbilities {}

#[test]
fun test_constraints() {
    // Fails - `NoAbilities` does not have the `drop` ability
    // let droppable = Droppable&lt;NoAbilities&gt; { value: 10 };

    // Fails - `NoAbilities` does not have the `copy` and `drop` abilities
    // let copyable_droppable = CopyableDroppable&lt;NoAbilities&gt; { value: 10 };
}
</code></pre>
<h2 id="further-reading-16"><a class="header" href="#further-reading-16">Further Reading</a></h2>
<ul>
<li><a href="move-basics//reference/generics.html">Generics</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-reflection"><a class="header" href="#type-reflection">Type Reflection</a></h1>
<p>In programming languages <em>reflection</em> is the ability of a program to examine and modify its own
structure and behavior. In Move, there's a limited form of reflection that allows you to inspect the
type of a value at runtime. This is useful when you need to store type information in a homogeneous
collection, or when you need to check if a type belongs to a package.</p>
<p>Type reflection is implemented in the <a href="move-basics/./standard-library.html">Standard Library</a> module
<code>std::type_name</code>. Expressed very roughly, it gives a single function <code>get&lt;T&gt;()</code> which returns the
name of the type <code>T</code>.</p>
<h2 id="in-practice-1"><a class="header" href="#in-practice-1">In practice</a></h2>
<p>The module is pretty straightforward, and operations allowed on the result are limited to getting a
string representation and extracting the module and address of the type.</p>
<pre><code class="language-move">module book::type_reflection {
    use std::ascii::String;
    use std::type_name::{Self, TypeName};

    /// A function that returns the name of the type `T` and its module and address.
    public fun do_i_know_you&lt;T&gt;(): (String, String, String) {
        let type_name: TypeName = type_name::get&lt;T&gt;();

        // there's a way to borrow
        let str: &amp;String = type_name.borrow_string();

        let module_name: String = type_name.get_module();
        let address_str: String = type_name.get_address();

        // and a way to consume the value
        let str = type_name.into_string();

        (str, module_name, address_str)
    }

    #[test_only]
    public struct MyType {}

    #[test]
    fun test_type_reflection() {
        let (type_name, module_name, _address_str) = do_i_know_you&lt;MyType&gt;();

        //
        assert!(module_name == b&quot;type_reflection&quot;.to_ascii_string(), 1);
    }
}
</code></pre>
<h2 id="further-reading-17"><a class="header" href="#further-reading-17">Further reading</a></h2>
<p>Type reflection is an important part of the language, and it is a crucial part of some of the more
advanced patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>A crucial part of any software development, and even more - blockchain development, is testing.
Here, we will cover the basics of testing in Move and how to write and organize tests for your Move
code.</p>
<h2 id="the-test-attribute"><a class="header" href="#the-test-attribute">The <code>#[test]</code> attribute</a></h2>
<p>Tests in Move are functions marked with the <code>#[test]</code> attribute. This attribute tells the compiler
that the function is a test function, and it should be run when the tests are executed. Test
functions are regular functions, but they must take no arguments and have no return value. They
are excluded from the bytecode, and are never published.</p>
<pre><code class="language-move">module book::testing {
    // Test attribute is placed before the `fun` keyword. Can be both above or
    // right before the `fun` keyword: `#[test] fun my_test() { ... }`
    // The name of the test would be `book::testing::simple_test`.
    #[test]
    fun simple_test() {
        let sum = 2 + 2;
        assert!(sum == 4, 1);
    }

    // The name of the test would be `book::testing::more_advanced_test`.
    #[test] fun more_advanced_test() {
        let sum = 2 + 2 + 2;
        assert!(sum == 4, 1);
    }
}
</code></pre>
<h2 id="running-tests-1"><a class="header" href="#running-tests-1">Running Tests</a></h2>
<p>To run tests, you can use the <code>sui move test</code> command. This command will first build the package in
the <em>test mode</em> and then run all the tests found in the package. During test mode, modules from both
<code>sources/</code> and <code>tests/</code> directories are processed, and the tests are executed.</p>
<pre><code class="language-bash">$ sui move test
&gt; INCLUDING DEPENDENCY Sui
&gt; INCLUDING DEPENDENCY MoveStdlib
&gt; BUILDING book
&gt; Running Move unit tests
&gt; ...
</code></pre>
<!-- TODO: fill output -->
<h2 id="test-fail-cases-with-expected_failure"><a class="header" href="#test-fail-cases-with-expected_failure">Test Fail Cases with <code>#[expected_failure]</code></a></h2>
<p>Tests for fail cases can be marked with <code>#[expected_failure]</code>. This attribute placed on a <code>#[test]</code>
function tells the compiler that the test is expected to fail. This is useful when you want to test
that a function fails when a certain condition is met.</p>
<blockquote>
<p>This attribute can only be placed on a <code>#[test]</code> function.</p>
</blockquote>
<p>The attribute can take an argument for abort code, which is the expected abort code when the test
fails. If the test fails with a different abort code, the test will fail. If the execution did not
abort, the test will also fail.</p>
<pre><code class="language-move">module book::testing_failure {

    const EInvalidArgument: u64 = 1;

    #[test]
    #[expected_failure(abort_code = 0)]
    fun test_fail() {
        abort 0 // aborts with 0
    }

    // attributes can be grouped together
    #[test, expected_failure(abort_code = EInvalidArgument)]
    fun test_fail_1() {
        abort 1 // aborts with 1
    }
}
</code></pre>
<p>The <code>abort_code</code> argument can use constants defined in the tests module as well as imported from
other modules. This is the only case where constants can be used and &quot;accessed&quot; in other modules.</p>
<h2 id="utilities-with-test_only"><a class="header" href="#utilities-with-test_only">Utilities with <code>#[test_only]</code></a></h2>
<p>In some cases, it is helpful to give the test environment access to some of the internal functions
or features. It simplifies the testing process and allows for more thorough testing. However, it is
important to remember that these functions should not be included in the final package. This is
where the <code>#[test_only]</code> attribute comes in handy.</p>
<pre><code class="language-move">module book::testing {
    // Public function which uses the `secret` function.
    public fun multiply_by_secret(x: u64): u64 {
        x * secret()
    }

    /// Private function which is not available to the public.
    fun secret(): u64 { 100 }

    #[test_only]
    /// This function is only available for testing purposes in tests and other
    /// test-only functions. Mind the visibility - for `#[test_only]` it is
    /// common to use `public` visibility.
    public fun secret_for_testing(): u64 {
        secret()
    }

    #[test]
    // In the test environment we have access to the `secret_for_testing` function.
    fun test_multiply_by_secret() {
        let expected = secret_for_testing() * 2;
        assert!(multiply_by_secret(2) == expected, 1);
    }
}
</code></pre>
<p>Functions marked with the <code>#[test_only]</code> will be available to the test environment, and to the other
modules if their visibility is set so.</p>
<h2 id="further-reading-18"><a class="header" href="#further-reading-18">Further Reading</a></h2>
<ul>
<li><a href="https://move-book.com/reference/unit-testing.html">Unit Testing</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-model"><a class="header" href="#object-model">Object Model</a></h1>
<p>This chapter describes the Object Model of Sui. It focuses on the theory and concepts behind the
Object Model, preparing you for a practical dive into Sui Storage operations and resource ownership.
For convenience and easier lookup, we split the chapter into several sections, each covering a
specific aspect of the Object Model.</p>
<div class="warning">
<p>In no way should this chapter be considered a comprehensive guide to the Object Model. It is only a
high-level overview of the concepts and principles behind the Object Model.</p>
<p>For a more detailed description, refer to the
<a href="https://docs.sui.io/concepts/object-model">Sui Documentation</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move---language-for-digital-assets"><a class="header" href="#move---language-for-digital-assets">Move - Language for Digital Assets</a></h1>
<p>Smart-contract programming languages have historically focused on defining and managing digital
assets. For example, the ERC-20 standard in Ethereum pioneered a set of standards to interact with
digital currency tokens, establishing a blueprint for creating and managing digital currencies on
the blockchain. Subsequently, the introduction of the ERC-721 standard marked a significant
evolution, popularising the concept of non-fungible tokens (NFTs), which represent unique,
indivisible assets. These standards laid the groundwork for the complex digital assets we see today.</p>
<!-- ## Move and Digital Assets -->
<!-- note: consider "native" -> "fine-grained" -->
<p>However, Ethereum's programming model lacked a native representation of assets. In other words,
externally, a Smart Contract behaved like an asset, but the language itself did not have a way to
inherently represent assets. From the start, Move aimed to provide a first-class abstraction for
assets, opening up new avenues for thinking about and programming assets.</p>
<!-- Move was initially created in 2018 as part of the Libra project. The language was designed to address shortcomings in existing smart contract languages, especially in handling assets and access control. The Move language aims to provide first-class abstractions for these concepts, improving the safety and productivity of smart contract programming. -->
<p>It is important to highlight which properties are essential for an asset:</p>
<ul>
<li>
<p><strong>Ownership:</strong> Every asset is associated with an owner(s), mirroring the straightforward concept
of ownership in the physical world—just as you own a car, you can own a digital asset. Move
enforces ownership in such a way that once an asset is <em>moved</em>, the previous owner completely
loses any control over it. This mechanism ensures a clear and secure change of ownership.</p>
</li>
<li>
<p><strong>Non-copyable:</strong> In the real world, unique items cannot be duplicated effortlessly. Move applies
this principle to digital assets, ensuring they cannot be arbitrarily copied within the program.
This property is crucial for maintaining the scarcity and uniqueness of digital assets, mirroring
the intrinsic value of physical assets.</p>
</li>
<li>
<p><strong>Non-discardable:</strong> Just as you cannot accidentally lose a house or a car without a trace, Move
ensures that no asset can be discarded or lost in a program. Instead, assets must be explicitly
transferred or destroyed. This property guarantees the deliberate handling of digital assets,
preventing accidental loss and ensuring accountability in asset management.</p>
</li>
</ul>
<p>Move managed to encapsulate these properties in its design, becoming an ideal language for digital
assets.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>Move was designed to provide a first-class abstraction for digital assets, enabling developers to
create and manage assets natively.</li>
<li>Essential properties of digital assets include ownership, non-copyability, and non-discardability,
which Move enforces in its design.</li>
<li>Move's asset model mirrors real-world asset management, ensuring secure and accountable asset
ownership and transfer.</li>
</ul>
<h2 id="further-reading-19"><a class="header" href="#further-reading-19">Further reading</a></h2>
<ul>
<li><a href="https://developers.diem.com/papers/diem-move-a-language-with-programmable-resources/2019-06-18.pdf">Move: A Language With Programmable Resources (pdf)</a>
by Sam Blackshear, Evan Cheng, David L. Dill, Victor Gao, Ben Maurer, Todd Nowacki, Alistair Pott,
Shaz Qadeer, Rain, Dario Russi, Stephane Sezer, Tim Zakian, Runtian Zhou*</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evolution-of-move"><a class="header" href="#evolution-of-move">Evolution of Move</a></h1>
<p>While Move was created to manage digital assets, its initial storage model was bulky and not
well-suited for many use cases. For instance, if Alice wanted to transfer an asset X to Bob, Bob had
to create a new &quot;empty&quot; resource, and then Alice could transfer asset X to Bob. This process was not
intuitive and presented implementation challenges, partly due to the restrictive design of
<a href="https://www.diem.com/en-us">Diem</a>. Another drawback of the original design was the lack of built-in
support for a &quot;transfer&quot; operation, requiring every module to implement its own storage transfer
logic. Additionally, managing heterogeneous collections of assets in a single account was
particularly challenging.</p>
<p>Sui addressed these challenges by redesigning the storage and ownership model of objects to more
closely resemble real-world object interactions. With a native concept of ownership and <em>transfer</em>,
Alice can directly transfer asset X to Bob. Furthermore, Bob can maintain a collection of different
assets without any preparatory steps. These improvements laid the foundation for the Object Model in
Sui.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<ul>
<li>Move's initial storage model was not well-suited for managing digital assets, requiring complex
and restrictive transfer operations.</li>
<li>Sui introduced the Object Model, which provides a native concept of ownership, simplifying asset
management and enabling heterogeneous collections.</li>
</ul>
<h2 id="further-reading-20"><a class="header" href="#further-reading-20">Further reading</a></h2>
<ul>
<li><a href="https://blog.sui.io/why-we-created-sui-move/">Why We Created Sui Move</a> by Sam Blackshear</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-an-object"><a class="header" href="#what-is-an-object">What is an Object?</a></h1>
<p>The Object Model in Sui can be viewed as a high-level abstraction representing digital assets as
<em>objects</em>. These objects have their own type and associated behaviors, a unique identifier, and
support native storage operations like <em>transfer</em> and <em>share</em>. Designed to be intuitive and easy to
use, the Object Model enables a wide range of use cases to be implemented with ease.</p>
<p>Objects in Sui have the following properties:</p>
<ul>
<li>
<p><strong>Type:</strong> Every object has a type, defining the structure and behavior of the object. Objects of
different types cannot be mixed or used interchangeably, ensuring objects are used correctly
according to their type system.</p>
</li>
<li>
<p><strong>Unique ID:</strong> Each object has a unique identifier, distinguishing it from other objects. This ID
is generated upon the object's creation and is immutable. It's used to track and identify objects
within the system.</p>
</li>
</ul>
<!-- Note: consider "shared across many entities" -->
<ul>
<li>
<p><strong>Owner:</strong> Every object is associated with an owner, who has control over the object. Ownership on
Sui can be exclusive to an account, shared across the network, or frozen, allowing read-only
access without modification or transfer capabilities. We will discuss ownership in more detail in
the following sections.</p>
</li>
<li>
<p><strong>Data:</strong> Objects encapsulate their data, simplifying management and manipulation. The data
structure and operations are defined by the object's type.</p>
</li>
<li>
<p><strong>Version:</strong> The transition from accounts to objects is facilitated by object versioning.
Traditionally, blockchains use a <em>nonce</em> to prevent replay attacks. In Sui, the object's version
acts as a nonce, preventing replay attacks for each object.</p>
</li>
<li>
<p><strong>Digest:</strong> Every object has a digest, which is a hash of the object's data. The digest is used to
cryptographically verify the integrity of the object's data and ensures that it has not been
tampered with. The digest is calculated when the object is created and is updated whenever the
object's data changes.</p>
</li>
</ul>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<ul>
<li>Objects in Sui are high-level abstractions representing digital assets.</li>
<li>Objects have a type, unique ID, owner, data, version, and digest.</li>
<li>The Object Model simplifies asset management and enables a wide range of use cases.</li>
</ul>
<h2 id="further-reading-21"><a class="header" href="#further-reading-21">Further reading</a></h2>
<ul>
<li><a href="https://docs.sui.io/concepts/object-model">Object Model</a> in Sui Documentation.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-1"><a class="header" href="#ownership-1">Ownership</a></h1>
<p>Sui introduces four distinct ownership types for objects: single owner, shared state, immutable
shared state, and object-owner. Each model offers unique characteristics and suits different use
cases, enhancing flexibility and control in object management.</p>
<h2 id="account-owner-or-single-owner"><a class="header" href="#account-owner-or-single-owner">Account Owner (or Single Owner)</a></h2>
<p>The account owner, also known as the <em>single owner</em> model, is the foundational ownership type in
Sui. Here, an object is owned by a single account, granting that account exclusive control over the
object within the behaviors associated with its type. This model embodies the concept of <em>true
ownership</em>, where the account possesses complete authority over the object, making it inaccessible
to others for modification or transfer. This level of ownership clarity is a significant advantage
over other blockchain systems, where ownership definitions can be more ambiguous, and smart
contracts may have the ability to alter or transfer assets without the owner's consent.</p>
<!-- TODO: add an example -->
<h2 id="shared-state"><a class="header" href="#shared-state">Shared State</a></h2>
<p>Single owner model has its limitations: for example, it is very tricky to implement a marketplace
for digital assets without a shared state. For a generic marketplace scenario, imagine that Alice
owns an asset X, and she wants to sell it by putting it into a shared marketplace. Then Bob can come
and buy the asset directly from the marketplace. The reason why this is tricky is that it is
impossible to write a smart contract that would &quot;lock&quot; the asset in Alice's account and take it out
when Bob buys it. First, it will be a violation of the single owner model, and second, it requires a
shared access to the asset.</p>
<p>To facilitate a problem of shared data access, Sui has introduced a shared ownership model. In this
model, an object can be shared with the network. Shared objects can be read and modified by any
account on the network, and the rules of interaction are defined by the implementation of the
object. Typical uses for shared objects are: marketplaces, shared resources, escrows, and other
scenarios where multiple accounts need access to the same state.</p>
<h2 id="immutable-frozen-state"><a class="header" href="#immutable-frozen-state">Immutable (Frozen) State</a></h2>
<p>Sui also offers the <em>frozen object</em> model, where an object becomes permanently read-only. These
immutable objects, while readable, cannot be modified or moved, providing a stable and constant
state accessible to all network participants. Frozen objects are ideal for public data, reference
materials, and other use cases where the state permanence is desirable.</p>
<h2 id="object-owner"><a class="header" href="#object-owner">Object Owner</a></h2>
<p>The last ownership model in Sui is the <em>object owner</em>. In this model, an object is owned by another
object. This feature allows creating complex relationships between objects, store large
heterogenious collections, and implementing extensible and modular systems. Practically speaking,
since the transactions are initiated by accounts, the transaction still accesses the parent object,
but it can then access the child objects through the parent object.</p>
<p>A use case we love to mention is a game character. Alice can own the Hero object from a game, and
the Hero can own items: also represented as objects, like a &quot;Map&quot;, or a &quot;Compass&quot;. Alice may take
the &quot;Map&quot; from the &quot;Hero&quot; object, and then send it to Bob, or sell it on a marketplace. With object
owner, it becomes very natural to imagine how the assets can be structured and managed in relation
to each other.</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<ul>
<li><strong>Single Owner:</strong> Objects are owned by a single account, granting exclusive control over the
object.</li>
<li><strong>Shared State:</strong> Objects can be shared with the network, allowing multiple accounts to read and
modify the object.</li>
<li><strong>Immutable State:</strong> Objects become permanently read-only, providing a stable and constant state.</li>
<li><strong>Object Owner:</strong> Objects can own other objects, enabling complex relationships and modular
systems.</li>
</ul>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>In the next section we will talk about transaction execution paths in Sui, and how the ownership
models affect the transaction execution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fast-path--consensus"><a class="header" href="#fast-path--consensus">Fast Path &amp; Consensus</a></h1>
<p>The Object Model allows for variable transaction execution paths, depending on the object's
ownership type. The transaction execution path determines how the transaction is processed and
validated by the network. In this section, we'll explore the different transaction execution paths
in Sui and how they interact with the consensus mechanism.</p>
<h2 id="concurrency-challenge"><a class="header" href="#concurrency-challenge">Concurrency Challenge</a></h2>
<p>At its core, blockchain technology faces a fundamental concurrency challenge: multiple parties may
try to modify or access the same data simultaneously in a decentralized environment. This requires a
system for sequencing and validating transactions to support the network's consistency. Sui
addresses this challenge through a consensus mechanism, ensuring all nodes agree on the
transactions' sequence and state.</p>
<p>Consider a marketplace scenario where Alice and Bob simultaneously attempt to purchase the same
asset. The network must resolve this conflict to prevent double-spending, ensuring that at most one
transaction succeeds while the other is rightfully rejected.</p>
<h2 id="fast-path"><a class="header" href="#fast-path">Fast Path</a></h2>
<p>However, not all transactions require the same level of validation and consensus. For example, if
Alice wants to transfer an object that she owns to Bob, the network can process this transaction
without sequencing it with respect to all other transactions in the network, as only Alice has the
authority to access the object. This is known as the <em>fast path</em> execution, where transactions
accessing account-owned objects are processed quickly without the need for extensive consensus. No
concurrent data access -&gt; simpler challenge -&gt; fast path.</p>
<p>Another ownership model that allows for fast path execution is the <em>immutable state</em>. Since
immutable objects cannot change, transactions involving them can be processed quickly without the
need to sequence them.</p>
<h2 id="consensus-path"><a class="header" href="#consensus-path">Consensus Path</a></h2>
<p>Transactions that do access shared state - on Sui it is represented with shared objects - require
sequencing to ensure that the state is updated and consistented across all nodes. This is known as
the execution through <em>consensus</em>, where transactions accessing shared objects are subject to the
agreement process to maintain network consistency.</p>
<!-- On Sui consensus is per-object - mention!!! -->
<h2 id="objects-owned-by-objects"><a class="header" href="#objects-owned-by-objects">Objects owned by Objects</a></h2>
<p>Lastly, it is important to mention that objects owned by other objects are subject to the same rules
as the parent object. If the parent object is <em>shared</em>, the child object is also transitively
shared. If the parent object is immutable, the child object is also immutable.</p>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<ul>
<li><strong>Fast Path:</strong> Transactions involving account-owned objects or immutable shared state are
processed quickly without the need for extensive consensus.</li>
<li><strong>Consensus Path:</strong> Transactions involving shared objects require sequencing and consensus to
ensure network integrity.</li>
<li><strong>Objects owned by Objects:</strong> Child objects inherit the ownership model of the parent object.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-objects"><a class="header" href="#using-objects">Using Objects</a></h1>
<p>In the <a href="storage/./../object">Object Model</a> chapter we briefly explained the evolution of the Move language
from an account-based model to an object-based model. In this chapter, we will dive deeper into the
object model and explore how to use objects in your Sui applications. If you haven't read the
<a href="storage/./../object">Object Model</a> chapter yet, we recommend you do so before continuing with this chapter.</p>
<!-- Mention what Sui Verifier is! Bytecode level verification. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-key-ability"><a class="header" href="#the-key-ability">The Key Ability</a></h1>
<p>In the <a href="storage/./../move-basics">Basic Syntax</a> chapter we already covered two out of four abilities -
<a href="storage/./../move-basics/drop-ability.html">Drop</a> and <a href="storage/./../move-basics/copy-ability.html">Copy</a>. They affect the behaviour of the value in a
scope and are not directly related to storage. It is time to cover the <code>key</code> ability, which allows
the struct to be stored.</p>
<p>Historically, the <code>key</code> ability was created to mark the type as a <em>key in the storage</em>. A type with
the <code>key</code> ability could be stored at top-level in the storage, and could be <em>directly owned</em> by an
account or address. With the introduction of the <a href="storage/./../object">Object Model</a>, the <code>key</code> ability
naturally became the defining ability for the object.</p>
<!-- TODO: What is Sui Verifier - link, later -->
<h2 id="object-definition"><a class="header" href="#object-definition">Object Definition</a></h2>
<p>A struct with the <code>key</code> ability is considered an object and can be used in the storage functions.
The Sui Verifier will require the first field of the struct to be named <code>id</code> and have the type
<code>UID</code>.</p>
<pre><code class="language-move">public struct Object has key {
    id: UID, // required
    name: String,
}

/// Creates a new Object with a Unique ID
public fun new(name: String, ctx: &amp;mut TxContext): Object {
    Object {
        id: object::new(ctx), // creates a new UID
        name,
    }
}
</code></pre>
<p>A struct with the <code>key</code> ability is still a struct, and can have any number of fields and associated
functions. There is no special handling or syntax for packing, accessing or unpacking the struct.</p>
<p>However, because the first field of an object struct must be of type <code>UID</code> - a non-copyable and
non-droppable type (we will get to it very soon!), the struct transitively cannot have <code>drop</code> and
<code>copy</code> abilities. Thus, the object is non-discardable by design.</p>
<!-- ## Asset Definition

In the context of the [Object Model](./../object/digital-assets.md), an object with the `key` ability can be considered an asset. It is non-discardable, unique, and can be *owned*.
 -->
<h2 id="types-with-the-key-ability"><a class="header" href="#types-with-the-key-ability">Types with the <code>key</code> Ability</a></h2>
<p>Due to the <code>UID</code> requirement for types with <code>key</code>, none of the native types in Move can have the
<code>key</code> ability, nor can any of the <a href="storage/./../move-basics/standard-library.html">Standard Library</a> types.
The <code>key</code> ability is only present in the <a href="storage/./../programmability/sui-framework.html">Sui Framework</a> and
custom types.</p>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Key ability defines the object in Move, and objects are intended to be <em>stored</em>. In the next section
we present the <code>sui::transfer</code> module, which provides native storage functions for objects.</p>
<h2 id="further-reading-22"><a class="header" href="#further-reading-22">Further reading</a></h2>
<ul>
<li><a href="storage//reference/type-abilities.html">Type Abilities</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-functions"><a class="header" href="#storage-functions">Storage Functions</a></h1>
<p>The module that defines main storage operations is <code>sui::transfer</code>. It is implicitly imported in all
packages that depend on the <a href="storage/./../programmability/sui-framework.html">Sui Framework</a>, so, like other
implicitly imported modules (e.g. <code>std::option</code> or <code>std::vector</code>), it does not require adding a use
statement.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The <code>transfer</code> module provides functions to perform all three storage operations matching
<a href="storage/./../object/ownership.html">ownership types</a> which we explained before:</p>
<blockquote>
<p>On this page we will only talk about so-called <em>restricted</em> storage operations, later we will
cover <em>public</em> ones, after the <code>store</code> ability is introduced.</p>
</blockquote>
<ol>
<li><em>Transfer</em> - send an object to an address, put it into <em>account owned</em> state;</li>
<li><em>Share</em> - put an object into a <em>shared</em> state, so it is available to everyone;</li>
<li><em>Freeze</em> - put an object into <em>immutable</em> state, so it becomes a public constant and can never
change.</li>
</ol>
<p>The <code>transfer</code> module is a go-to for most of the storage operations, except a special case with
<a href="storage/./../programmability/dynamic-fields.html">Dynamic Fields</a> awaits us in the next chapter.</p>
<h2 id="ownership-and-references-a-quick-recap"><a class="header" href="#ownership-and-references-a-quick-recap">Ownership and References: A Quick Recap</a></h2>
<p>In the <a href="storage/./../move-basics/ownership-and-scope.html">Ownership and Scope</a> and
<a href="storage/./../move-basics/references.html">References</a> chapters, we covered the basics of ownership and
references in Move. It is important that you understand these concepts when using storage functions.
Here is a quick recap of the most important points:</p>
<ul>
<li>The <em>move</em> semantics in Move means that the value is <em>moved</em> from one scope to another. In other
words, if an instance of a type is passed to a function <em>by value</em>, it is <em>moved</em> to the function
scope and can't be accessed in the caller scope anymore.</li>
<li>To maintain the ownership of the value, you can pass it <em>by reference</em>. Either by <em>immutable
reference</em> <code>&amp;T</code> or <em>mutable reference</em> <code>&amp;mut T</code>. Then the value is <em>borrowed</em> and can be accessed
in the caller scope, however the owner stays the same.</li>
</ul>
<pre><code class="language-move">/// Moved by value
public fun take&lt;T&gt;(value: T) { /* value is moved here! */ abort 0 }

/// For immutable reference
public fun borrow&lt;T&gt;(value: &amp;T) { /* value is borrowed here! can be read */ abort 0 }

/// For mutable reference
public fun borrow_mut&lt;T&gt;(value: &amp;mut T) { /* value is mutably borrowed here! */ abort 0 }
</code></pre>
<!-- TODO part on:
    - object does not have an associated storage type
    - the same type of object can be stored differently
    - the objects must be specified in the transaction by their ID
 -->
<h2 id="transfer"><a class="header" href="#transfer">Transfer</a></h2>
<p>The <code>transfer::transfer</code> function is a public function used to transfer an object to another
address. Its signature is as follows, only accepts a type with the <a href="storage/./key-ability.html"><code>key</code> ability</a>
and an <a href="storage/./../move-basics/address.html">address</a> of the recipient. Please, note that the object is
passed into the function <em>by value</em>, therefore it is <em>moved</em> to the function scope and then moved to
the recipient address:</p>
<pre><code class="language-move">// File: sui-framework/sources/transfer.move
public fun transfer&lt;T: key&gt;(obj: T, recipient: address);
</code></pre>
<p>In the next example, you can see how it can be used in a module that defines and sends an object to
the transaction sender.</p>
<pre><code class="language-move">module book::transfer_to_sender {

    /// A struct with `key` is an object. The first field is `id: UID`!
    public struct AdminCap has key { id: UID }

    /// `init` function is a special function that is called when the module
    /// is published. It is a good place to create application objects.
    fun init(ctx: &amp;mut TxContext) {
        // Create a new `AdminCap` object, in this scope.
        let admin_cap = AdminCap { id: object::new(ctx) };

        // Transfer the object to the transaction sender.
        transfer::transfer(admin_cap, ctx.sender());

        // admin_cap is gone! Can't be accessed anymore.
    }

    /// Transfers the `AdminCap` object to the `recipient`. Thus, the recipient
    /// becomes the owner of the object, and only they can access it.
    public fun transfer_admin_cap(cap: AdminCap, recipient: address) {
        transfer::transfer(cap, recipient);
    }
}
</code></pre>
<p>When the module is published, the <code>init</code> function will get called, and the <code>AdminCap</code> object which
we created there will be <em>transferred</em> to the transaction sender. The <code>ctx.sender()</code> function
returns the sender address for the current transaction.</p>
<p>Once the <code>AdminCap</code> has been transferred to the sender, for example, to <code>0xa11ce</code>, the sender, and
only the sender, will be able to access the object. The object is now <em>account owned</em>.</p>
<blockquote>
<p>Account owned objects are a subject to <em>true ownership</em> - only the account owner can access them.
This is a fundamental concept in the Sui storage model.</p>
</blockquote>
<p>Let's extend the example with a function that uses <code>AdminCap</code> to authorize a mint of a new object
and its transfer to another address:</p>
<pre><code class="language-move">/// Some `Gift` object that the admin can `mint_and_transfer`.
public struct Gift has key { id: UID }

/// Creates a new `Gift` object and transfers it to the `recipient`.
public fun mint_and_transfer(
    _: &amp;AdminCap, recipient: address, ctx: &amp;mut TxContext
) {
    let gift = Gift { id: object::new(ctx) };
    transfer::transfer(gift, recipient);
}
</code></pre>
<p>The <code>mint_and_transfer</code> function is a public function that &quot;could&quot; be called by anyone, but it
requires an <code>AdminCap</code> object to be passed as the first argument by reference. Without it, the
function will not be callable. This is a simple way to restrict access to privileged functions
called <em><a href="storage/./../programmability/capability.html">Capability</a></em>. Because the <code>AdminCap</code> object is <em>account
owned</em>, only <code>0xa11ce</code> will be able to call the <code>mint_and_transfer</code> function.</p>
<p>The <code>Gift</code>s sent to recipients will also be <em>account owned</em>, each gift being unique and owned
exclusively by the recipient.</p>
<p>A quick recap:</p>
<ul>
<li><code>transfer</code> function is used to send an object to an address;</li>
<li>The object becomes <em>account owned</em> and can only be accessed by the recipient;</li>
<li>Functions can be gated by requiring an object to be passed as an argument, creating a
<em>capability</em>.</li>
</ul>
<h2 id="freeze"><a class="header" href="#freeze">Freeze</a></h2>
<p>The <code>transfer::freeze_object</code> function is public function used to put an object into an <em>immutable</em>
state. Once an object is <em>frozen</em>, it can never be changed, and it can be accessed by anyone by
immutable reference.</p>
<p>The function signature is as follows, only accepts a type with the
<a href="storage/./key-ability.html"><code>key</code> ability</a>. Just like all other storage functions, it takes the object <em>by
value</em>:</p>
<pre><code class="language-move">// File: sui-framework/sources/transfer.move
public fun freeze_object&lt;T: key&gt;(obj: T);
</code></pre>
<p>Let's expand on the previous example and add a function that allows the admin to create a <code>Config</code>
object and freeze it:</p>
<pre><code class="language-move">/// Some `Config` object that the admin can `create_and_freeze`.
public struct Config has key {
    id: UID,
    message: String
}

/// Creates a new `Config` object and freezes it.
public fun create_and_freeze(
    _: &amp;AdminCap,
    message: String,
    ctx: &amp;mut TxContext
) {
    let config = Config {
        id: object::new(ctx),
        message
    };

    // Freeze the object so it becomes immutable.
    transfer::freeze_object(config);
}

/// Returns the message from the `Config` object.
/// Can access the object by immutable reference!
public fun message(c: &amp;Config): String { c.message }
</code></pre>
<p>Config is an object that has a <code>message</code> field, and the <code>create_and_freeze</code> function creates a new
<code>Config</code> and freezes it. Once the object is frozen, it can be accessed by anyone by immutable
reference. The <code>message</code> function is a public function that returns the message from the <code>Config</code>
object. Config is now publicly available by its ID, and the message can be read by anyone.</p>
<blockquote>
<p>Function definitions are not connected to the object's state. It is possible to define a function
that takes a mutable reference to an object that is used as frozen. However, it won't be callable
on a frozen object.</p>
</blockquote>
<p>The <code>message</code> function can be called on an immutable <code>Config</code> object, however, two functions below
are not callable on a frozen object:</p>
<pre><code class="language-move">// === Functions below can't be called on a frozen object! ===

/// The function can be defined, but it won't be callable on a frozen object.
/// Only immutable references are allowed.
public fun message_mut(c: &amp;mut Config): &amp;mut String { &amp;mut c.message }

/// Deletes the `Config` object, takes it by value.
/// Can't be called on a frozen object!
public fun delete_config(c: Config) {
    let Config { id, message: _ } = c;
    id.delete()
}
</code></pre>
<p>To summarize:</p>
<ul>
<li><code>transfer::freeze_object</code> function is used to put an object into an <em>immutable</em> state;</li>
<li>Once an object is <em>frozen</em>, it can never be changed, deleted or transferred, and it can be
accessed by anyone by immutable reference;</li>
</ul>
<h2 id="owned---frozen"><a class="header" href="#owned---frozen">Owned -&gt; Frozen</a></h2>
<p>Since the <code>transfer::freeze_object</code> signature accepts any type with the <code>key</code> ability, it can take
an object that was created in the same scope, but it can also take an object that was owned by an
account. This means that the <code>freeze_object</code> function can be used to <em>freeze</em> an object that was
<em>transferred</em> to the sender. For security concerns, we would not want to freeze the <code>AdminCap</code>
object - it would be a security risk to allow access to it to anyone. However, we can freeze the
<code>Gift</code> object that was minted and transferred to the recipient:</p>
<blockquote>
<p>Single Owner -&gt; Immutable conversion is possible!</p>
</blockquote>
<pre><code class="language-move">/// Freezes the `Gift` object so it becomes immutable.
public fun freeze_gift(gift: Gift) {
    transfer::freeze_object(gift);
}
</code></pre>
<h2 id="share"><a class="header" href="#share">Share</a></h2>
<p>The <code>transfer::share_object</code> function is a public function used to put an object into a <em>shared</em>
state. Once an object is <em>shared</em>, it can be accessed by anyone by a mutable reference (hence,
immutable too). The function signature is as follows, only accepts a type with the
<a href="storage/./key-ability.html"><code>key</code> ability</a>:</p>
<pre><code class="language-move">// File: sui-framework/sources/transfer.move
public fun share_object&lt;T: key&gt;(obj: T);
</code></pre>
<p>Once an object is <em>shared</em>, it is publicly available as a mutable reference.</p>
<h2 id="special-case-shared-object-deletion"><a class="header" href="#special-case-shared-object-deletion">Special Case: Shared Object Deletion</a></h2>
<p>While the shared object can't normally be taken by value, there is one special case where it can -
if the function that takes it deletes the object. This is a special case in the Sui storage model,
and it is used to allow the deletion of shared objects. To show how it works, we will create a
function that creates and shares a Config object and then another one that deletes it:</p>
<pre><code class="language-move">/// Creates a new `Config` object and shares it.
public fun create_and_share(message: String, ctx: &amp;mut TxContext) {
    let config = Config {
        id: object::new(ctx),
        message
    };

    // Share the object so it becomes shared.
    transfer::share_object(config);
}
</code></pre>
<p>The <code>create_and_share</code> function creates a new <code>Config</code> object and shares it. The object is now
publicly available as a mutable reference. Let's create a function that deletes the shared object:</p>
<pre><code class="language-move">/// Deletes the `Config` object, takes it by value.
/// Can be called on a shared object!
public fun delete_config(c: Config) {
    let Config { id, message: _ } = c;
    id.delete()
}
</code></pre>
<p>The <code>delete_config</code> function takes the <code>Config</code> object by value and deletes it, and the Sui Verifier
would allow this call. However, if the function returned the <code>Config</code> object back or attempted to
<code>freeze</code> or <code>transfer</code> it, the Sui Verifier would reject the transaction.</p>
<pre><code class="language-move">// Won't work!
public fun transfer_shared(c: Config, to: address) {
    transfer::transfer(c, to);
}
</code></pre>
<p>To summarize:</p>
<ul>
<li><code>share_object</code> function is used to put an object into a <em>shared</em> state;</li>
<li>Once an object is <em>shared</em>, it can be accessed by anyone by a mutable reference;</li>
<li>Shared objects can be deleted, but they can't be transferred or frozen.</li>
</ul>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>Now that you know main features of the <code>transfer</code> module, you can start building more complex
applications on Sui that involve storage operations. In the next chapter, we will cover the
<a href="storage/./store-ability.html">Store Ability</a> which allows storing data inside objects and relaxes transfer
restrictions which we barely touched on here. And after that we will cover the
<a href="storage/./uid-and-id.html">UID and ID</a> types which are the most important types in the Sui storage model.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ability-store"><a class="header" href="#ability-store">Ability: Store</a></h1>
<p>Now that you have an understanding of top-level storage functions which are enabled by the
<a href="storage/./key-ability.html"><code>key</code></a> ability, we can talk about the last ability in the list - <code>store</code>.</p>
<h2 id="definition-1"><a class="header" href="#definition-1">Definition</a></h2>
<p>The <code>store</code> is a special ability that allows a type to be <em>stored</em> in objects. This ability is
required for the type to be used as a field in a struct that has the <code>key</code> ability. Another way to
put it is that the <code>store</code> ability allows the value to be <em>wrapped</em> in an object.</p>
<blockquote>
<p>The <code>store</code> ability also relaxes restrictions on transfer operations. We talk about it more in the
<a href="storage/./transfer-restrictions.html">Restricted and Public Transfer</a> section.</p>
</blockquote>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>In previous sections we already used types with the <code>key</code> ability: all objects must have a <code>UID</code>
field, which we used in examples; we also used the <code>Storable</code> type as a part of the <code>Config</code> struct.
The <code>Config</code> type also has the <code>store</code> ability.</p>
<pre><code class="language-move">/// This type has the `store` ability.
public struct Storable has store {}

/// Config contains a `Storable` field which must have the `store` ability.
public struct Config has key, store {
    id: UID,
    stores: Storable,
}

/// MegaConfig contains a `Config` field which has the `store` ability.
public struct MegaConfig has key {
    id: UID,
    config: Config, // there it is!
}
</code></pre>
<h2 id="types-with-the-store-ability"><a class="header" href="#types-with-the-store-ability">Types with the <code>store</code> Ability</a></h2>
<p>All native types (except for references) in Move have the <code>store</code> ability. This includes:</p>
<ul>
<li><a href="storage/./../move-basics/primitive-types.html#booleans">bool</a></li>
<li><a href="storage/./../move-basics/primitive-types.html#integers">unsigned integers</a></li>
<li><a href="storage/./../move-basics/vector.html">vector</a></li>
<li><a href="storage/./../move-basics/address.html">address</a></li>
</ul>
<p>All of the types defined in the standard library have the <code>store</code> ability as well. This includes:</p>
<ul>
<li><a href="storage/./../move-basics/option.html">Option</a></li>
<li><a href="storage/./../move-basics/string.html">String</a></li>
<li><a href="storage/./../move-basics/type-reflection.html#typename">TypeName</a></li>
</ul>
<h2 id="further-reading-23"><a class="header" href="#further-reading-23">Further reading</a></h2>
<ul>
<li><a href="storage//reference/type-abilities.html">Type Abilities</a> in the Move Reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uid-and-id"><a class="header" href="#uid-and-id">UID and ID</a></h1>
<p>The <code>UID</code> type is defined in the <code>sui::object</code> module and is a wrapper around an <code>ID</code> which, in
turn, wraps the <code>address</code> type. The UIDs on Sui are guaranteed to be unique, and can't be reused
after the object was deleted.</p>
<pre><code class="language-move">// File: sui-framework/sources/object.move
/// UID is a unique identifier of an object
public struct UID has store {
    id: ID
}

/// ID is a wrapper around an address
public struct ID has store, drop {
    bytes: address
}
</code></pre>
<!-- User doesn't know anything about TxContext yet... -->
<h2 id="fresh-uid-generation"><a class="header" href="#fresh-uid-generation">Fresh UID generation:</a></h2>
<ul>
<li>UID is derived from the <code>tx_hash</code> and an <code>index</code> which is incremented for each new UID.</li>
<li>The <code>derive_id</code> function is implemented in the <code>sui::tx_context</code> module, and that is why TxContext
is required for UID generation.</li>
<li>Sui Verifier will not allow using a UID that wasn't created in the same function. That prevents
UIDs from being pre-generated and reused after the object was unpacked.</li>
</ul>
<p>New UID is created with the <code>object::new(ctx)</code> function. It takes a mutable reference to TxContext,
and returns a new UID.</p>
<pre><code class="language-move">let ctx = &amp;mut tx_context::dummy();
let uid = object::new(ctx);
</code></pre>
<p>On Sui, <code>UID</code> acts as a representation of an object, and allows defining behaviors and features of
an object. One of the key-features - <a href="storage/">Dynamic Fields</a> - is possible because of the <code>UID</code> type
being explicit. Additionally, it allows the <a href="storage/">Transfer To Object (TTO)</a> which we will explain later
in this chapter.</p>
<h2 id="uid-lifecycle"><a class="header" href="#uid-lifecycle">UID lifecycle</a></h2>
<p>The <code>UID</code> type is created with the <code>object::new(ctx)</code> function, and it is destroyed with the
<code>object::delete(uid)</code> function. The <code>object::delete</code> consumes the UID <em>by value</em>, and it is
impossible to delete it unless the value was unpacked from an Object.</p>
<pre><code class="language-move">let ctx = &amp;mut tx_context::dummy();

let char = Character {
    id: object::new(ctx)
};

let Character { id } = char;
id.delete();
</code></pre>
<h2 id="keeping-the-uid"><a class="header" href="#keeping-the-uid">Keeping the UID</a></h2>
<p>The <code>UID</code> does not need to be deleted immediately after the object struct is unpacked. Sometimes it
may carry <a href="storage/./../programmability/dynamic-fields.html">Dynamic Fields</a> or objects transferred to it via
<a href="storage/./transfer-to-object.html">Transfer To Object</a>. In such cases, the UID may be kept and stored in a
separate object.</p>
<h2 id="proof-of-deletion"><a class="header" href="#proof-of-deletion">Proof of Deletion</a></h2>
<p>The ability to return the UID of an object may be utilized in pattern called <em>proof of deletion</em>. It
is a rarely used technique, but it may be useful in some cases, for example, the creator or an
application may incentivize the deletion of an object by exchanging the deleted IDs for some reward.</p>
<p>In framework development this method could be used to ignore / bypass certain restrictions on
&quot;taking&quot; the object. If there's a container that enforces certain logic on transfers, like Kiosk
does, there could be a special scenario of skipping the checks by providing a proof of deletion.</p>
<p>This is one of the open topics for exploration and research, and it may be used in various ways.</p>
<h2 id="id"><a class="header" href="#id">ID</a></h2>
<p>When talking about <code>UID</code> we should also mention the <code>ID</code> type. It is a wrapper around the <code>address</code>
type, and is used to represent an address-pointer. Usually, <code>ID</code> is used to point at an object,
however, there's no restriction, and no guarantee that the <code>ID</code> points to an existing object.</p>
<blockquote>
<p>ID can be received as a transaction argument in a
<a href="storage/./../concepts/what-is-a-transaction.html">Transaction Block</a>. Alternatively, ID can be created from
an <code>address</code> value using <code>to_id()</code> function.</p>
</blockquote>
<!--
```move

TODO: !!!!

```
-->
<h2 id="fresh_object_address"><a class="header" href="#fresh_object_address">fresh_object_address</a></h2>
<p>TxContext provides the <code>fresh_object_address</code> function which can be utilized to create unique
addresses and <code>ID</code> - it may be useful in some application that assign unique identifiers to user
actions - for example, an order_id in a marketplace.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="restricted-and-public-transfer"><a class="header" href="#restricted-and-public-transfer">Restricted and Public Transfer</a></h1>
<p>Storage Operations that we described in the <a href="storage/./storage-functions.html">previous sections</a> are
restricted by default - they can only be called in the module defining the object. In other terms,
the type must be <em>internal</em> to the module to be used in storage operations. This restriction is
implemented in the Sui Verifier and is enforced at the bytecode level.</p>
<p>However, to allow objects to be transferred and stored in other modules, these restrictions can be
relaxed. The <code>sui::transfer</code> module offers a set of <em>public_*</em> functions that allow calling
storage operations in other modules. The functions are prefixed with <code>public_</code> and are available to
all modules and transactions.</p>
<h2 id="public-storage-operations"><a class="header" href="#public-storage-operations">Public Storage Operations</a></h2>
<p>The <code>sui::transfer</code> module provides the following public functions. They are almost identical to the
ones we already covered, but can be called from any module.</p>
<pre><code class="language-move">// File: sui-framework/sources/transfer.move
/// Public version of the `transfer` function.
public fun public_transfer&lt;T: key + store&gt;(object: T, to: address) {}

/// Public version of the `share_object` function.
public fun public_share_object&lt;T: key + store&gt;(object: T) {}

/// Public version of the `freeze_object` function.
public fun public_freeze_object&lt;T: key + store&gt;(object: T) {}
</code></pre>
<p>To illustrate the usage of these functions, consider the following example: module A defines an
ObjectK with <code>key</code> and ObjectKS with <code>key + store</code> abilities, and module B tries to implement a
<code>transfer</code> function for these objects.</p>
<blockquote>
<p>In this example we use <code>transfer::transfer</code>, but the behaviour is identical for <code>share_object</code> and
<code>freeze_object</code> functions.</p>
</blockquote>
<pre><code class="language-move">/// Defines `ObjectK` and `ObjectKS` with `key` and `key + store`
/// abilities respectively
module book::transfer_a {
    public struct ObjectK has key { id: UID }
    public struct ObjectKS has key, store { id: UID }
}

/// Imports the `ObjectK` and `ObjectKS` types from `transfer_a` and attempts
/// to implement different `transfer` functions for them
module book::transfer_b {
    // types are not internal to this module
    use book::transfer_a::{ObjectK, ObjectKS};

    // Fails! ObjectK is not `store`, and ObjectK is not internal to this module
    public fun transfer_k(k: ObjectK, to: address) {
        sui::transfer::transfer(k, to);
    }

    // Fails! ObjectKS has `store` but the function is not public
    public fun transfer_ks(ks: ObjectKS, to: address) {
        sui::transfer::transfer(ks, to);
    }

    // Fails! ObjectK is not `store`, `public_transfer` requires `store`
    public fun public_transfer_k(k: ObjectK) {
        sui::transfer::public_transfer(k);
    }

    // Works! ObjectKS has `store` and the function is public
    public fun public_transfer_ks(y: ObjectKS, to: address) {
        sui::transfer::public_transfer(y, to);
    }
}
</code></pre>
<p>To expand on the example above:</p>
<ul>
<li><input disabled="" type="checkbox"/>
<code>transfer_k</code> fails because ObjectK is not internal to module <code>transfer_b</code></li>
<li><input disabled="" type="checkbox"/>
<code>transfer_ks</code> fails because ObjectKS is not internal to module <code>transfer_b</code></li>
<li><input disabled="" type="checkbox"/>
<code>public_transfer_k</code> fails because ObjectK does not have the <code>store</code> ability</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>public_transfer_ks</code> works because ObjectKS has the <code>store</code> ability and the transfer is public</li>
</ul>
<h2 id="implications-of-store"><a class="header" href="#implications-of-store">Implications of <code>store</code></a></h2>
<p>The decision on whether to add the <code>store</code> ability to a type should be made carefully. On one hand,
it is de-facto a requirement for the type to be <em>usable</em> by other applications. On the other hand,
it allows <em>wrapping</em> and changing the intended storage model. For example, a character may be
intended to be owned by accounts, but with the <code>store</code> ability it can be frozen (cannot be shared -
this transition is restricted).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-programmability"><a class="header" href="#advanced-programmability">Advanced Programmability</a></h1>
<p>In previous chapters we've covered <a href="programmability/./../move-basics">the basics of Move</a> and
<a href="programmability/./../storage">Sui Storage Model</a>. Now it's time to dive deeper into the advanced
topics of Sui programmability.</p>
<p>This chapter introduces more complex concepts, practices and features of Move and Sui that are
essential for building more sophisticated applications. It is intended for developers who are
already familiar with the basics of Move and Sui, and are looking to expand their knowledge and
skills.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-context"><a class="header" href="#transaction-context">Transaction Context</a></h1>
<p>Every transaction has the execution context. The context is a set of predefined variables that are
available to the program during execution. For example, every transaction has a sender address, and
the transaction context contains a variable that holds the sender address.</p>
<p>The transaction context is available to the program through the <code>TxContext</code> struct. The struct is
defined in the <code>sui::tx_context</code> module and contains the following fields:</p>
<pre><code class="language-move">// File: sui-framework/sources/tx_context.move
/// Information about the transaction currently being executed.
/// This cannot be constructed by a transaction--it is a privileged object created by
/// the VM and passed in to the entrypoint of the transaction as `&amp;mut TxContext`.
struct TxContext has drop {
    /// The address of the user that signed the current transaction
    sender: address,
    /// Hash of the current transaction
    tx_hash: vector&lt;u8&gt;,
    /// The current epoch number
    epoch: u64,
    /// Timestamp that the epoch started at
    epoch_timestamp_ms: u64,
    /// Counter recording the number of fresh id's created while executing
    /// this transaction. Always 0 at the start of a transaction
    ids_created: u64
}
</code></pre>
<p>Transaction context cannot be constructed manually or directly modified. It is created by the system
and passed to the function as a reference in a transaction. Any function called in a
<a href="programmability/./../concepts/what-is-a-transaction.html">Transaction</a> has access to the context and can pass it into
the nested calls.</p>
<blockquote>
<p><code>TxContext</code> has to be the last argument in the function signature.</p>
</blockquote>
<h2 id="reading-the-transaction-context"><a class="header" href="#reading-the-transaction-context">Reading the Transaction Context</a></h2>
<p>With only exception of the <code>ids_created</code>, all of the fields in the <code>TxContext</code> have getters. The
getters are defined in the <code>sui::tx_context</code> module and are available to the program. The getters
don't require <code>&amp;mut</code> because they don't modify the context.</p>
<pre><code class="language-move">public fun some_action(ctx: &amp;TxContext) {
    let me = ctx.sender();
    let epoch = ctx.epoch();
    let digest = ctx.digest();
    // ...
}
</code></pre>
<h2 id="mutability"><a class="header" href="#mutability">Mutability</a></h2>
<p>The <code>TxContext</code> is required to create new objects (or just <code>UID</code>s) in the system. New UIDs are
derived from the transaction digest, and for the digest to be unique, there needs to be a changing
parameter. Sui uses the <code>ids_created</code> field for that. Every time a new UID is created, the
<code>ids_created</code> field is incremented by one. This way, the digest is always unique.</p>
<p>Internally, it is represented as the <code>derive_id</code> function:</p>
<pre><code class="language-move">// File: sui-framework/sources/tx_context.move
native fun derive_id(tx_hash: vector&lt;u8&gt;, ids_created: u64): address;
</code></pre>
<h2 id="generating-unique-addresses"><a class="header" href="#generating-unique-addresses">Generating unique addresses</a></h2>
<p>The underlying <code>derive_id</code> function can also be utilized in your program to generate unique
addresses. The function itself is not exposed, but a wrapper function <code>fresh_object_address</code> is
available in the <code>sui::tx_context</code> module. It may be useful if you need to generate a unique
identifier in your program.</p>
<pre><code class="language-move">// File: sui-framework/sources/tx_context.move
/// Create an `address` that has not been used. As it is an object address, it will never
/// occur as the address for a user.
/// In other words, the generated address is a globally unique object ID.
public fun fresh_object_address(ctx: &amp;mut TxContext): address {
    let ids_created = ctx.ids_created;
    let id = derive_id(*&amp;ctx.tx_hash, ids_created);
    ctx.ids_created = ids_created + 1;
    id
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module-initializer"><a class="header" href="#module-initializer">Module Initializer</a></h1>
<p>A common use case in many applications is to run certain code just once when the package is
published. Imagine a simple store module that needs to create the main Store object upon its
publication. In Sui, this is achieved by defining an <code>init</code> function within the module. This
function will automatically be called when the module is published.</p>
<blockquote>
<p>All of the modules' <code>init</code> functions are called during the publishing process. Currently, this
behavior is limited to the publish command and does not extend to
<a href="programmability/./package-upgrades.html">package upgrades</a>.</p>
</blockquote>
<pre><code class="language-move">module book::shop {
    /// The Capability which grants the Shop owner the right to manage
    /// the shop.
    public struct ShopOwnerCap has key, store { id: UID }

    /// The singular Shop itself, created in the `init` function.
    public struct Shop has key {
        id: UID,
        /* ... */
    }

    // Called only once, upon module publication. It must be
    // private to prevent external invocation.
    fun init(ctx: &amp;mut TxContext) {
        // Transfers the ShopOwnerCap to the sender (publisher).
        transfer::transfer(ShopOwnerCap {
            id: object::new(ctx)
        }, ctx.sender());

        // Shares the Shop object.
        transfer::share_object(Shop {
            id: object::new(ctx)
        });
    }
}
</code></pre>
<p>In the same package, another module can have its own <code>init</code> function, encapsulating distinct logic.</p>
<pre><code class="language-move">// In the same package as the `shop` module
module book::bank {

    public struct Bank has key {
        id: UID,
        /* ... */
    }

    fun init(ctx: &amp;mut TxContext) {
        transfer::share_object(Bank {
            id: object::new(ctx)
        });
    }
}
</code></pre>
<h2 id="init-features"><a class="header" href="#init-features"><code>init</code> features</a></h2>
<p>The function is called on publish, if it is present in the module and follows the rules:</p>
<ul>
<li>The function has to be named <code>init</code>, be private and have no return values.</li>
<li>Takes one or two arguments: <a href="programmability/./one-time-witness.html">One Time Witness</a> (optional) and
<a href="programmability/./transaction-context.html">TxContext</a>. With <code>TxContext</code> always being the last argument.</li>
</ul>
<pre><code class="language-move">fun init(ctx: &amp;mut TxContext) { /* ... */}
fun init(otw: OTW, ctx: &amp;mut TxContext) { /* ... */ }
</code></pre>
<p>TxContext can also be passed as immutable reference: <code>&amp;TxContext</code>. However, practically speaking, it
should always be <code>&amp;mut TxContext</code> since the <code>init</code> function can't access the onchain state and to
create new objects it requires the mutable reference to the context.</p>
<pre><code class="language-move">fun init(ctx: &amp;TxContext) { /* ... */}
fun init(otw: OTW, ctx: &amp;TxContext) { /* ... */ }
</code></pre>
<h2 id="trust-and-security"><a class="header" href="#trust-and-security">Trust and security</a></h2>
<p>While <code>init</code> function can be used to create sensitive objects once, it is important to know that the
same object (eg. <code>StoreOwnerCap</code> from the first example) can still be created in another function.
Especially given that new functions can be added to the module during an upgrade. So the <code>init</code>
function is a good place to set up the initial state of the module, but it is not a security measure
on its own.</p>
<p>There are ways to guarantee that the object was created only once, such as the
<a href="programmability/./one-time-witness.html">One Time Witness</a>. And there are ways to limit or disable the upgrade of the
module, which we will cover in the <a href="programmability/./package-upgrades.html">Package Upgrades</a> chapter.</p>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next steps</a></h2>
<p>As follows from the definition, the <code>init</code> function is guaranteed to be called only once when the
module is published. So it is a good place to put the code that initializes module's objects and
sets up the environment and configuration.</p>
<p>For example, if there's a <a href="programmability/./capability.html">Capability</a> which is required for certain actions, it
should be created in the <code>init</code> function. In the next chapter we will talk about the <code>Capability</code>
pattern in more detail.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-capability"><a class="header" href="#pattern-capability">Pattern: Capability</a></h1>
<p>In programming, a <em>capability</em> is a token that gives the owner the right to perform a specific
action. It is a pattern that is used to control access to resources and operations. A simple example
of a capability is a key to a door. If you have the key, you can open the door. If you don't have
the key, you can't open the door. A more practical example is an Admin Capability which allows the
owner to perform administrative operations, which regular users cannot.</p>
<h2 id="capability-is-an-object"><a class="header" href="#capability-is-an-object">Capability is an Object</a></h2>
<p>In the <a href="programmability/./../object/">Sui Object Model</a>, capabilities are represented as objects.
An owner of an object can pass this object to a function to prove that they have the right to
perform a specific action. Due to strict typing, the function taking a capability as an argument can
only be called with the correct capability.</p>
<blockquote>
<p>There's a convention to name capabilities with the <code>Cap</code> suffix, for example, <code>AdminCap</code> or
<code>KioskOwnerCap</code>.</p>
</blockquote>
<pre><code class="language-move">module book::capability {
    use std::string::String;
    use sui::event;

    /// The capability granting the application admin the right to create new
    /// accounts in the system.
    public struct AdminCap has key, store { id: UID }

    /// The user account in the system.
    public struct Account has key, store {
        id: UID,
        name: String
    }

    /// A simple `Ping` event with no data.
    public struct Ping has copy, drop { by: ID }

    /// Creates a new account in the system. Requires the `AdminCap` capability
    /// to be passed as the first argument.
    public fun new(_: &amp;AdminCap, name: String, ctx: &amp;mut TxContext): Account {
        Account {
            id: object::new(ctx),
            name,
        }
    }

    /// Account, and any other objects, can also be used as a Capability in the
    /// application. For example, to emit an event.
    public fun send_ping(acc: &amp;Account) {
        event::emit(Ping {
            by: acc.id.to_inner()
        })
    }

    /// Updates the account name. Can only be called by the `Account` owner.
    public fun update(account: &amp;mut Account, name: String) {
        account.name = name;
    }
}
</code></pre>
<h2 id="using-init-for-admin-capability"><a class="header" href="#using-init-for-admin-capability">Using <code>init</code> for Admin Capability</a></h2>
<p>A very common practice is to create a single <code>AdminCap</code> object on package publish. This way, the
application can have a setup phase where the admin account prepares the state of the application.</p>
<pre><code class="language-move">module book::admin_cap {
    /// The capability granting the admin privileges in the system.
    /// Created only once in the `init` function.
    public struct AdminCap has key { id: UID }

    /// Create the AdminCap object on package publish and transfer it to the
    /// package owner.
    fun init(ctx: &amp;mut TxContext) {
        transfer::transfer(
            AdminCap { id: object::new(ctx) },
            ctx.sender()
        )
    }
}
</code></pre>
<h2 id="address-check-vs-capability"><a class="header" href="#address-check-vs-capability">Address check vs Capability</a></h2>
<p>Utilizing objects as capabilities is a relatively new concept in blockchain programming. And in
other smart-contract languages, authorization is often performed by checking the address of the
sender. This pattern is still viable on Sui, however, overall recommendation is to use capabilities
for better security, discoverability, and code organization.</p>
<p>Let's look at how the <code>new</code> function that creates a user would look like if it was using the address
check:</p>
<pre><code class="language-move">/// Error code for unauthorized access.
const ENotAuthorized: u64 = 0;

/// The application admin address.
const APPLICATION_ADMIN: address = @0xa11ce;

/// Creates a new user in the system. Requires the sender to be the application
/// admin.
public fun new(ctx: &amp;mut TxContext): User {
    assert!(ctx.sender() == APPLICATION_ADMIN, ENotAuthorized);
    User { id: object::new(ctx) }
}
</code></pre>
<p>And now, let's see how the same function would look like with the capability:</p>
<pre><code class="language-move">/// Grants the owner the right to create new users in the system.
public struct AdminCap {}

/// Creates a new user in the system. Requires the `AdminCap` capability to be
/// passed as the first argument.
public fun new(_: &amp;AdminCap, ctx: &amp;mut TxContext): User {
    User { id: object::new(ctx) }
}
</code></pre>
<p>Using capabilities has several advantages over the address check:</p>
<ul>
<li>Migration of admin rights is easier with capabilities due to them being objects. In case of
address, if the admin address changes, all the functions that check the address need to be
updated - hence, require a <a href="programmability/./package-upgrades.html">package upgrade</a>.</li>
<li>Function signatures are more descriptive with capabilities. It is clear that the <code>new</code> function
requires the <code>AdminCap</code> to be passed as an argument. And this function can't be called without it.</li>
<li>Object Capabilities don't require extra checks in the function body, and hence, decrease the
chance of a developer mistake.</li>
<li>An owned Capability also serves in discovery. The owner of the AdminCap can see the object in
their account (via a Wallet or Explorer), and know that they have the admin rights. This is less
transparent with the address check.</li>
</ul>
<p>However, the address approach has its own advantages. For example, if an address is multisig, and
transaction building gets more complex, it might be easier to check the address. Also, if there's a
central object of the application that is used in every function, it can store the admin address,
and this would simplify migration. The central object approach is also valuable for revokable
capabilities, where the admin can revoke the capability from the user.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epoch-and-time"><a class="header" href="#epoch-and-time">Epoch and Time</a></h1>
<p>Sui has two ways of accessing the current time: <code>Epoch</code> and <code>Time</code>. The former represents
operational periods in the system and changed roughly every 24 hours. The latter represents the
current time in milliseconds since the Unix Epoch. Both can be accessed freely in the program.</p>
<h2 id="epoch"><a class="header" href="#epoch">Epoch</a></h2>
<p>Epochs are used to separate the system into operational periods. During an epoch the validator set
is fixed, however, at the epoch boundary, the validator set can be changed. Epochs play a crucial
role in the consensus algorithm and are used to determine the current validator set. They are also
used as measurement in the staking mechanism.</p>
<p>Epoch can be read from the <a href="programmability/./transaction-context.html">transaction context</a>:</p>
<pre><code class="language-move">public fun current_epoch(ctx: &amp;TxContext) {
    let epoch = ctx.epoch();
    // ...
}
</code></pre>
<p>It is also possible to get the unix timestamp of the epoch start:</p>
<pre><code class="language-move">public fun current_epoch_start(ctx: &amp;TxContext) {
    let epoch_start = ctx.epoch_timestamp_ms();
    // ...
}
</code></pre>
<p>Normally, epochs are used in staking and system operations, however, in custom scenarios they can be
used to emulate 24h periods. They are critical if an application relies on the staking logic or
needs to know the current validator set.</p>
<h2 id="time"><a class="header" href="#time">Time</a></h2>
<p>For a more precise time measurement, Sui provides the <code>Clock</code> object. It is a system object that is
updated during checkpoints by the system, which stores the current time in milliseconds since the
Unix Epoch. The <code>Clock</code> object is defined in the <code>sui::clock</code> module and has a reserved address
<code>0x6</code>.</p>
<p>Clock is a shared object, but a transaction attempting to access it mutably will fail. This
limitation allows parallel access to the <code>Clock</code> object, which is important for maintaining
performance.</p>
<pre><code class="language-move">// File: sui-framework/clock.move
/// Singleton shared object that exposes time to Move calls.  This
/// object is found at address 0x6, and can only be read (accessed
/// via an immutable reference) by entry functions.
///
/// Entry Functions that attempt to accept `Clock` by mutable
/// reference or value will fail to verify, and honest validators
/// will not sign or execute transactions that use `Clock` as an
/// input parameter, unless it is passed by immutable reference.
struct Clock has key {
    id: UID,
    /// The clock's timestamp, which is set automatically by a
    /// system transaction every time consensus commits a
    /// schedule, or by `sui::clock::increment_for_testing` during
    /// testing.
    timestamp_ms: u64,
}
</code></pre>
<p>There is only one public function available in the <code>Clock</code> module - <code>timestamp_ms</code>. It returns the
current time in milliseconds since the Unix Epoch.</p>
<pre><code class="language-move">use sui::clock::Clock;

/// Clock needs to be passed as an immutable reference.
public fun current_time(clock: &amp;Clock) {
    let time = clock.timestamp_ms();
    // ...
}
</code></pre>
<!-- TODO:

## Testing

TODO: how to use Clock in tests. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections"><a class="header" href="#collections">Collections</a></h1>
<p>Collection types are a fundamental part of any programming language. They are used to store a
collection of data, such as a list of items. The <code>vector</code> type has already been covered in the
<a href="programmability/./../move-basics/vector.html">vector section</a>, and in this chapter we will cover the vector-based
collection types offered by the <a href="programmability/./sui-framework.html">Sui Framework</a>.</p>
<h2 id="vector-1"><a class="header" href="#vector-1">Vector</a></h2>
<p>While we have previously covered the <code>vector</code> type in the
<a href="programmability/./../move-basics/vector.html">vector section</a>, it is worth going over it again in a new context. This
time we will cover the usage of the <code>vector</code> type in objects and how it can be used in an
application.</p>
<pre><code class="language-move">module book::collections_vector {
    use std::string::String;

    /// The Book that can be sold by a `BookStore`
    public struct Book has key, store {
        id: UID,
        name: String
    }

    /// The BookStore that sells `Book`s
    public struct BookStore has key, store {
        id: UID,
        books: vector&lt;Book&gt;
    }
}
</code></pre>
<h2 id="vecset"><a class="header" href="#vecset">VecSet</a></h2>
<p><code>VecSet</code> is a collection type that stores a set of unique items. It is similar to a <code>vector</code>, but it
does not allow duplicate items. This makes it useful for storing a collection of unique items, such
as a list of unique IDs or addresses.</p>
<pre><code class="language-move">module book::collections_vec_set {
    use sui::vec_set::{Self, VecSet};

    public struct App has drop {
        /// `VecSet` used in the struct definition
        subscribers: VecSet&lt;address&gt;
    }

    #[test]
    fun vec_set_playground() {
        let set = vec_set::empty&lt;u8&gt;(); // create an empty set
        let mut set = vec_set::singleton(1); // create a set with a single item

        set.insert(2); // add an item to the set
        set.insert(3);

        assert!(set.contains(&amp;1), 0); // check if an item is in the set
        assert!(set.size() == 3, 1); // get the number of items in the set
        assert!(!set.is_empty(), 2); // check if the set is empty

        set.remove(&amp;2); // remove an item from the set
    }
}
</code></pre>
<p>VecSet will fail on attempt to insert a an item that already exists in the set.</p>
<h2 id="vecmap"><a class="header" href="#vecmap">VecMap</a></h2>
<p><code>VecMap</code> is a collection type that stores a map of key-value pairs. It is similar to a <code>VecSet</code>, but
it allows you to associate a value with each item in the set. This makes it useful for storing a
collection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs
and their associated data.</p>
<p>Keys in a <code>VecMap</code> are unique, and each key can only be associated with a single value. If you try
to insert a key-value pair with a key that already exists in the map, the old value will be replaced
with the new value.</p>
<pre><code class="language-move">module book::collections {
    use std::string::String;
    use sui::vec_map::{Self, VecMap};

    public struct Metadata has drop {
        name: String,
        /// `VecMap` used in the struct definition
        attributes: VecMap&lt;String, String&gt;
    }

    #[test]
    fun vec_map_playground() {
        let mut map = vec_map::empty(); // create an empty map

        map.insert(2, b&quot;two&quot;.to_string()); // add a key-value pair to the map
        map.insert(3, b&quot;three&quot;.to_string());

        assert!(map.contains(&amp;2), 0); // check if a key is in the map

        map.remove(&amp;2); // remove a key-value pair from the map
    }
}
</code></pre>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>Standard collection types are a great way to store typed data with guaranteed safety and
consistency. However, they are limited by the type of data they can store - the type system won't
allow you to store a wrong type in a collection; and they're limited in size - by the object size
limit. They will work for relatively small-sized sets and lists, but for larger collections you may
need to use a different approach.</p>
<p>Another limitations on collection types is inability to compare them. Because the order of insertion
is not guaranteed, an attempt to compare a <code>VecSet</code> to another <code>VecSet</code> may not yield the expected
results.</p>
<blockquote>
<p>This behavior is caught by the linter and will emit a warning: <em>Comparing collections of type
'sui::vec_set::VecSet' may yield unexpected result</em></p>
</blockquote>
<pre><code class="language-move">let mut set1 = vec_set::empty();
set1.insert(1);
set1.insert(2);

let mut set2 = vec_set::empty();
set2.insert(2);
set2.insert(1);

assert!(set1 == set2, 0);
</code></pre>
<p>In the example above, the comparison will fail because the order of insertion is not guaranteed, and
the two <code>VecSet</code> instances may have different orders of elements. And the comparison will fail even
if the two <code>VecSet</code> instances contain the same elements.</p>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<ul>
<li>Vector is a native type that allows storing a list of items.</li>
<li>VecSet is built on top of vector and allows storing sets of unique items.</li>
<li>VecMap is used to store key-value pairs in a map-like structure.</li>
<li>Vector-based collections are strictly typed and limited by the object size limit and are best
suited for small-sized sets and lists.</li>
</ul>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<p>In the next section we will cover <a href="programmability/./dynamic-fields.html">Dynamic Fields</a> - an important primitive
that allows for <a href="programmability/./dynamic-collections.html">Dynamic Collections</a> - a way to store large collections
of data in a more flexible, yet more expensive way.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-fields"><a class="header" href="#dynamic-fields">Dynamic Fields</a></h1>
<p>Sui Object model allows objects to be attached to other objects as <em>dynamic fields</em>. The behavior is
similar to how a <code>Map</code> works in other programming languages. However, unlike a <code>Map</code> which in Move
would be strictly typed (we have covered it in the <a href="programmability/./collections.html">Collections</a> section), dynamic
fields allow attaching objects of any type. A similar approach from the world of frontend
development would be a JavaScript Object type which allows storing any type of data dynamically.</p>
<blockquote>
<p>There's no limit to the number of dynamic fields that can be attached to an object. Thus, dynamic
fields can be used to store large amounts of data that don't fit into the object limit size.</p>
</blockquote>
<p>Dynamic Fields allow for a wide range of applications, from splitting data into smaller parts to
avoid <a href="programmability/./../guides/building-against-limits.html">object size limit</a> to attaching objects as a part of
application logic.</p>
<h2 id="definition-2"><a class="header" href="#definition-2">Definition</a></h2>
<p>Dynamic Fields are defined in the <code>sui::dynamic_field</code> module of the
<a href="programmability/./sui-framework.html">Sui Framework</a>. They are attached to object's <code>UID</code> via a <em>name</em>, and can be
accessed using that name. There can be only one field with a given name attached to an object.</p>
<p>File: sui-framework/sources/dynamic_field.move</p>
<pre><code class="language-move">/// Internal object used for storing the field and value
public struct Field&lt;Name: copy + drop + store, Value: store&gt; has key {
    /// Determined by the hash of the object ID, the field name
    /// value and it's type, i.e. hash(parent.id || name || Name)
    id: UID,
    /// The value for the name of this field
    name: Name,
    /// The value bound to this field
    value: Value,
}
</code></pre>
<p>As the definition shows, dynamic fields are stored in an internal <code>Field</code> object, which has the
<code>UID</code> generated in a deterministic way based on the object ID, the field name, and the field type.
The <code>Field</code> object contains the field name and the value bound to it. The constraints on the <code>Name</code>
and <code>Value</code> type parameters define the abilities that the key and value must have.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>The methods available for dynamic fields are straightforward: a field can be added with <code>add</code>,
removed with <code>remove</code>, and read with <code>borrow</code> and <code>borrow_mut</code>. Additionally, the <code>exists_</code> method
can be used to check if a field exists (for stricter checks with type, there is an
<code>exists_with_type</code> method).</p>
<pre><code class="language-move">module book::dynamic_collection {
    // a very common alias for `dynamic_field` is `df` since the
    // module name is quite long
    use sui::dynamic_field as df;
    use std::string::String;

    /// The object that we will attach dynamic fields to.
    public struct Character has key {
        id: UID
    }

    // List of different accessories that can be attached to a character.
    // They must have the `store` ability.
    public struct Hat has key, store { id: UID, color: u32 }
    public struct Mustache has key, store { id: UID }

    #[test]
    fun test_character_and_accessories() {
        let ctx = &amp;mut tx_context::dummy();
        let mut character = Character { id: object::new(ctx) };

        // Attach a hat to the character's UID
        df::add(
            &amp;mut character.id,
            b&quot;hat_key&quot;,
            Hat { id: object::new(ctx), color: 0xFF0000 }
        );

        // Similarly, attach a mustache to the character's UID
        df::add(
            &amp;mut character.id,
            b&quot;mustache_key&quot;,
            Mustache { id: object::new(ctx) }
        );

        // Check that the hat and mustache are attached to the character
        //
        assert!(df::exists_(&amp;character.id, b&quot;hat_key&quot;), 0);
        assert!(df::exists_(&amp;character.id, b&quot;mustache_key&quot;), 1);

        // Modify the color of the hat
        let hat: &amp;mut Hat = df::borrow_mut(&amp;mut character.id, b&quot;hat_key&quot;);
        hat.color = 0x00FF00;

        // Remove the hat and mustache from the character
        let hat: Hat = df::remove(&amp;mut character.id, b&quot;hat_key&quot;);
        let mustache: Mustache = df::remove(&amp;mut character.id, b&quot;mustache_key&quot;);

        // Check that the hat and mustache are no longer attached to the character
        assert!(!df::exists_(&amp;character.id, b&quot;hat_key&quot;), 0);
        assert!(!df::exists_(&amp;character.id, b&quot;mustache_key&quot;), 1);

        sui::test_utils::destroy(character);
        sui::test_utils::destroy(mustache);
        sui::test_utils::destroy(hat);
    }
}
</code></pre>
<p>In the example above, we define a <code>Character</code> object and two different types of accessories that
could never be put together in a vector. However, dynamic fields allow us to store them together in
a single object. Both objects are attached to the <code>Character</code> via a <code>vector&lt;u8&gt;</code> (bytestring
literal), and can be accessed using their respective keys.</p>
<p>As you can see, when we attached the accessories to the Character, we passed them <em>by value</em>. In
other words, both values were moved to a new scope, and their ownership was transferred to the
<code>Character</code> object. If we changed the ownership of <code>Character</code> object, the accessories would have
been moved with it.</p>
<p>And the last important property of dynamic fields we should highlight is that they are <em>accessed
through their parent</em>. This means that the <code>Hat</code> and <code>Mustache</code> objects are not directly accessible
and follow the same rules as the parent object.</p>
<h2 id="foreign-types-as-dynamic-fields"><a class="header" href="#foreign-types-as-dynamic-fields">Foreign Types as Dynamic Fields</a></h2>
<p>Dynamic fields allow objects to carry data of any type, including those defined in other modules.
This is possible due to their generic nature and relatively weak constraints on the type parameters.
Let's illustrate this by attaching a few different values to a <code>Character</code> object.</p>
<pre><code class="language-move">let mut character = Character { id: object::new(ctx) };

// Attach a `String` via a `vector&lt;u8&gt;` name
df::add(&amp;mut character.id, b&quot;string_key&quot;, b&quot;Hello, World!&quot;.to_string());

// Attach a `u64` via a `u32` name
df::add(&amp;mut character.id, 1000u32, 1_000_000_000u64);

// Attach a `bool` via a `bool` name
df::add(&amp;mut character.id, true, false);
</code></pre>
<p>In this example we showed how different types can be used for both <em>name</em> and the <em>value</em> of a
dynamic field. The <code>String</code> is attached via a <code>vector&lt;u8&gt;</code> name, the <code>u64</code> is attached via a <code>u32</code>
name, and the <code>bool</code> is attached via a <code>bool</code> name. Anything is possible with dynamic fields!</p>
<h2 id="orphaned-dynamic-fields"><a class="header" href="#orphaned-dynamic-fields">Orphaned Dynamic Fields</a></h2>
<blockquote>
<p>To prevent orphaned dynamic fields, please, use
<a href="programmability/./dynamic-collections.html">Dynamic Collection Types</a> such as <code>Bag</code> as they track the dynamic
fields and won't allow unpacking if there are attached fields.</p>
</blockquote>
<p>The <code>object::delete()</code> function, which is used to delete a UID, does not track the dynamic fields,
and cannot prevent dynamic fields from becoming orphaned. Once the parent UID is deleted, the
dynamic fields are not automatically deleted, and they become orphaned. This means that the dynamic
fields are still stored in the blockchain, but they will never become accessible again.</p>
<pre><code class="language-move">let hat = Hat { id: object::new(ctx), color: 0xFF0000 };
let mut character = Character { id: object::new(ctx) };

// Attach a `Hat` via a `vector&lt;u8&gt;` name
df::add(&amp;mut character.id, b&quot;hat_key&quot;, hat);

// ! DO NOT do this in your code
// ! Danger - deleting the parent object
let Character { id } = character;
id.delete();

// ...`Hat` is now stuck in a limbo, it will never be accessible again
</code></pre>
<p>Orphaned objects are not a subject to storage rebate, and the storage fees will remain unclaimed.
One way to avoid orphaned dynamic fields during unpacking of an object is to return the <code>UID</code> and
store it somewhere temporarily until the dynamic fields are removed and handled properly.</p>
<h2 id="custom-type-as-a-field-name"><a class="header" href="#custom-type-as-a-field-name">Custom Type as a Field Name</a></h2>
<p>In the examples above, we used primitive types as field names since they have the required set of
abilities. But dynamic fields get even more interesting when we use custom types as field names.
This allows for a more structured way of storing data, and also allows for protecting the field
names from being accessed by other modules.</p>
<pre><code class="language-move">/// A custom type with fields in it.
public struct AccessoryKey has copy, drop, store { name: String }

/// An empty key, can be attached only once.
public struct MetadataKey has copy, drop, store {}
</code></pre>
<p>Two field names that we defined above are <code>AccessoryKey</code> and <code>MetadataKey</code>. The <code>AccessoryKey</code> has a
<code>String</code> field in it, hence it can be used multiple times with different <code>name</code> values. The
<code>MetadataKey</code> is an empty key, and can be attached only once.</p>
<pre><code class="language-move">let mut character = Character { id: object::new(ctx) };

// Attaching via an `AccessoryKey { name: b&quot;hat&quot; }`
df::add(
    &amp;mut character.id,
    AccessoryKey { name: b&quot;hat&quot;.to_string() },
    Hat { id: object::new(ctx), color: 0xFF0000 }
);
// Attaching via an `AccessoryKey { name: b&quot;mustache&quot; }`
df::add(
    &amp;mut character.id,
    AccessoryKey { name: b&quot;mustache&quot;.to_string() },
    Mustache { id: object::new(ctx) }
);

// Attaching via a `MetadataKey`
df::add(&amp;mut character.id, MetadataKey {}, 42);
</code></pre>
<p>As you can see, custom types do work as field names but as long as they can be <em>constructed</em> by the
module, in other words - if they are <em>internal</em> to the module and defined in it. This limitation on
struct packing can open up new ways in the design of the application.</p>
<p>This approach is used in the <a href="programmability/./object-capability.html">Object Capability</a> pattern, where an application can authorize a
foreign object to perform operations in it while not exposing the capabilities to other modules.</p>
<h2 id="exposing-uid"><a class="header" href="#exposing-uid">Exposing UID</a></h2>
<div class="warning">
<p>Mutable access to <code>UID</code> is a security risk. Exposing <code>UID</code> of your type as a mutable reference can
lead to unwanted modifications or removal of the object's dynamic fields. Additionally, it affects
the <a href="programmability/./../storage/transfer-to-object.html">Transfer to Object</a> and
<a href="programmability/./dynamic-object-fields.html">Dynamic Object Fields</a>. Make sure to understand the implications before
exposing the <code>UID</code> as a mutable reference.</p>
</div>
<p>Because dynamic fields are attached to <code>UID</code>s, their usage in other modules depends on whether the
<code>UID</code> can be accessed. By default struct visibility protects the <code>id</code> field and won't let other
modules access it directly. However, if there's a public accessor method that returns a reference to
<code>UID</code>, dynamic fields can be read in other modules.</p>
<pre><code class="language-move">/// Exposes the UID of the character, so that other modules can read
/// dynamic fields.
public fun uid(c: &amp;Character): &amp;UID {
    &amp;c.id
}
</code></pre>
<p>In the example above, we show how to expose the <code>UID</code> of a <code>Character</code> object. This solution may
work for some applications, however, it is important to remember that exposed <code>UID</code> allows reading
<em>any</em> dynamic field attached to the object.</p>
<p>If you need to expose the <code>UID</code> only within the package, use a restrictive visibility, like
<code>public(package)</code>, or even better - use more specific accessor methods that would allow only reading
specific fields.</p>
<pre><code class="language-move">/// Only allow modules in the same package to access the UID.
public(package) fun uid_package(c: &amp;Character): &amp;UID {
    &amp;c.id
}

/// Allow borrowing dynamic fields from the character.
public fun borrow&lt;Name: copy + store + drop, Value: store&gt;(
    c: &amp;Character,
    n: Name
): &amp;Value {
    df::borrow(&amp;c.id, n)
}
</code></pre>
<h2 id="dynamic-fields-vs-fields"><a class="header" href="#dynamic-fields-vs-fields">Dynamic Fields vs Fields</a></h2>
<p>Dynamic Fields are more expensive than regular fields, as they require additional storage and costs
for accessing them. Their flexibility comes at a price, and it is important to understand the
implications when making a decision between using dynamic fields and regular fields.</p>
<h2 id="limits"><a class="header" href="#limits">Limits</a></h2>
<p>Dynamic Fields are not subject to the <a href="programmability/./../guides/building-against-limits.html">object size limit</a>,
and can be used to store large amounts of data. However, they are still subject to the
<a href="programmability/./../guides/building-against-limits.html">dynamic fields created limit</a>, which is set to 1000 fields
per transaction.</p>
<h2 id="applications"><a class="header" href="#applications">Applications</a></h2>
<p>Dynamic Fields can play a crucial role in applications of any complexity. They open up a variety of
different use cases, from storing heterogeneous data to attaching objects as part of the application
logic. They allow for certain <a href="programmability/./../guides/upgradeability-practices.html">upgradeability practices</a>
based on the ability to define them <em>later</em> and change the type of the field.</p>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<p>In the next section we will cover <a href="programmability/./dynamic-object-fields.html">Dynamic Object Fields</a> and explain
how they differ from dynamic fields, and what are the implications of using them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-object-fields"><a class="header" href="#dynamic-object-fields">Dynamic Object Fields</a></h1>
<blockquote>
<p>This section expands on the <a href="programmability/./dynamic-fields.html">Dynamic Fields</a>. Please, read it first to
understand the basics of dynamic fields.</p>
</blockquote>
<p>Another variation of dynamic fields is <em>dynamic object fields</em>, which have certain differences from
regular dynamic fields. In this section, we will cover the specifics of dynamic object fields and
explain how they differ from regular dynamic fields.</p>
<blockquote>
<p>General recommendation is to avoid using dynamic object fields in favor of (just) dynamic fields,
especially if there's no need for direct discovery through the ID. The extra costs of dynamic
object fields may not be justified by the benefits they provide.</p>
</blockquote>
<h2 id="definition-3"><a class="header" href="#definition-3">Definition</a></h2>
<p>Dynamic Object Fields are defined in the <code>sui::dynamic_object_fields</code> module in the
<a href="programmability/./sui-framework.html">Sui Framework</a>. They are similar to dynamic fields in many ways, but unlike
them, dynamic object fields have an extra constraint on the <code>Value</code> type. The <code>Value</code> must have a
combination of <code>key</code> and <code>store</code>, not just <code>store</code> as in the case of dynamic fields.</p>
<p>They're less explicit in their framework definition, as the concept itself is more abstract:</p>
<p>File: sui-framework/sources/dynamic_object_fields.move</p>
<pre><code class="language-move">/// Internal object used for storing the field and the name associated with the
/// value. The separate type is necessary to prevent key collision with direct
/// usage of dynamic_field
public struct Wrapper&lt;Name&gt; has copy, drop, store {
    name: Name,
}
</code></pre>
<p>Unlike <code>Field</code> type in the <a href="programmability/./dynamic-fields.html#definition">Dynamic Fields</a> section, the <code>Wrapper</code>
type only stores the name of the field. The value is the object itself, and is <em>not wrapped</em>.</p>
<p>The constraints on the <code>Value</code> type become visible in the methods available for dynamic object
fields. Here's the signature for the <code>add</code> function:</p>
<pre><code class="language-move">/// Adds a dynamic object field to the object `object: &amp;mut UID` at field
/// specified by `name: Name`. Aborts with `EFieldAlreadyExists` if the object
/// already has that field with that name.
public fun add&lt;Name: copy + drop + store, Value: key + store&gt;(
    // we use &amp;mut UID in several spots for access control
    object: &amp;mut UID,
    name: Name,
    value: Value,
) { /* implementation omitted */ }
</code></pre>
<p>The rest of the methods which are identical to the ones in the
<a href="programmability/./dynamic-fields.html#usage">Dynamic Fields</a> section have the same constraints on the <code>Value</code> type.
Let's list them for reference:</p>
<ul>
<li><code>add</code> - adds a dynamic object field to the object</li>
<li><code>remove</code> - removes a dynamic object field from the object</li>
<li><code>borrow</code> - borrows a dynamic object field from the object</li>
<li><code>borrow_mut</code> - borrows a mutable reference to a dynamic object field from the object</li>
<li><code>exists_</code> - checks if a dynamic object field exists</li>
<li><code>exists_with_type</code> - checks if a dynamic object field exists with a specific type</li>
</ul>
<p>Additionally, there is an <code>id</code> method which returns the <code>ID</code> of the <code>Value</code> object without
specifying its type.</p>
<h2 id="usage--differences-with-dynamic-fields"><a class="header" href="#usage--differences-with-dynamic-fields">Usage &amp; Differences with Dynamic Fields</a></h2>
<p>The main difference between dynamic fields and dynamic object fields is that the latter allows
storing <em>only objects</em> as values. This means that you can't store primitive types like <code>u64</code> or
<code>bool</code>. It may be considered a limitation, if not for the fact that dynamic object fields are <em>not
wrapped</em> into a separate object.</p>
<blockquote>
<p>The relaxed requirement for wrapping keeps the object available for off-chain discovery via its
ID. However, this property may not be outstanding if wrapped object indexing is implemented,
making the dynamic object fields a redundant feature.</p>
</blockquote>
<pre><code class="language-move">module book::dynamic_object_field {
    use std::string::String;

    // there are two common aliases for the long module name: `dof` and
    // `ofield`. Both are commonly used and met in different projects.
    use sui::dynamic_object_field as dof;
    use sui::dynamic_field as df;

    /// The `Character` that we will use for the example
    public struct Character has key { id: UID }

    /// Metadata that doesn't have the `key` ability
    public struct Metadata has store, drop { name: String }

    /// Accessory that has the `key` and `store` abilities.
    public struct Accessory has key, store { id: UID }

    #[test]
    fun equip_accessory() {
        let ctx = &amp;mut tx_context::dummy();
        let mut character = Character { id: object::new(ctx) };

        // Create an accessory and attach it to the character
        let hat = Accessory { id: object::new(ctx) };

        // Add the hat to the character. Just like with `dynamic_fields`
        dof::add(&amp;mut character.id, b&quot;hat_key&quot;, hat);

        // However for non-key structs we can only use `dynamic_field`
        df::add(&amp;mut character.id, b&quot;metadata_key&quot;, Metadata {
            name: b&quot;John&quot;.to_string()
        });

        // Borrow the hat from the character
        let hat_id = dof::id(&amp;character.id, b&quot;hat_key&quot;).extract(); // Option&lt;ID&gt;
        let hat_ref: &amp;Accessory = dof::borrow(&amp;character.id, b&quot;hat_key&quot;);
        let hat_mut: &amp;mut Accessory = dof::borrow_mut(&amp;mut character.id, b&quot;hat_key&quot;);
        let hat: Accessory = dof::remove(&amp;mut character.id, b&quot;hat_key&quot;);

        // Clean up, Metadata is an orphan now.
        sui::test_utils::destroy(hat);
        sui::test_utils::destroy(character);
    }
}
</code></pre>
<h2 id="pricing-differences"><a class="header" href="#pricing-differences">Pricing Differences</a></h2>
<p>Dynamic Object Fields come a little more expensive than dynamic fields. Because of their internal
structure, they require 2 objects: the Wrapper for Name and the Value. Because of this, the cost of
adding and accessing object fields (loading 2 objects compared to 1 for dynamic fields) is higher.</p>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<p>Both dynamic field and dynamic object fields are powerful features which allow for innovative
solutions in applications. However, they are relatively low-level and require careful handling to
avoid orphaned fields. In the next section, we will introduce a higher-level abstraction -
<a href="programmability/./dynamic-collections.html">Dynamic Collections</a> - which can help with managing dynamic fields and
objects more effectively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-collections"><a class="header" href="#dynamic-collections">Dynamic Collections</a></h1>
<p><a href="programmability/./sui-framework.html">Sui Framework</a> offers a variety of collection types that build on the
<a href="programmability/./dynamic-fields.html">dynamic fields</a> and <a href="programmability/./dynamic-object-fields.html">dynamic object fields</a>
concepts. These collections are designed to be a safer and more understandable way to store and
manage dynamic fields and objects.</p>
<p>For each collection type we will specify the primitive they use, and the specific features they
offer.</p>
<blockquote>
<p>Unlike dynamic (object) fields which operate on UID, collection types have their own type and
allow calling <a href="programmability/./../move-basics/struct-methods.html">associated functions</a>.</p>
</blockquote>
<h2 id="common-concepts"><a class="header" href="#common-concepts">Common Concepts</a></h2>
<p>All of the collection types share the same set of methods, which are:</p>
<ul>
<li><code>add</code> - adds a field to the collection</li>
<li><code>remove</code> - removes a field from the collection</li>
<li><code>borrow</code> - borrows a field from the collection</li>
<li><code>borrow_mut</code> - borrows a mutable reference to a field from the collection</li>
<li><code>contains</code> - checks if a field exists in the collection</li>
<li><code>length</code> - returns the number of fields in the collection</li>
<li><code>is_empty</code> - checks if the <code>length</code> is 0</li>
</ul>
<p>All collection types support index syntax for <code>borrow</code> and <code>borrow_mut</code> methods. If you see square
brackets in the examples, they are translated into <code>borrow</code> and <code>borrow_mut</code> calls.</p>
<pre><code class="language-move">let hat: &amp;Hat = &amp;bag[b&quot;key&quot;];
let hat_mut: &amp;mut Hat = &amp;mut bag[b&quot;key&quot;];

// is equivalent to
let hat: &amp;Hat = bag.borrow(b&quot;key&quot;);
let hat_mut: &amp;mut Hat = bag.borrow_mut(b&quot;key&quot;);
</code></pre>
<p>In the examples we won't focus on these functions, but rather on the differences between the
collection types.</p>
<h2 id="bag"><a class="header" href="#bag">Bag</a></h2>
<p>Bag, as the name suggests, acts as a &quot;bag&quot; of heterogeneous values. It is a simple, non-generic type
that can store any data. Bag will never allow orphaned fields, as it tracks the number of fields and
can't be destroyed if it's not empty.</p>
<pre><code class="language-move">// File: sui-framework/sources/bag.move
public struct Bag has key, store {
    /// the ID of this bag
    id: UID,
    /// the number of key-value pairs in the bag
    size: u64,
}
</code></pre>
<p>Due to Bag storing any types, the extra methods it offers is:</p>
<ul>
<li><code>contains_with_type</code> - checks if a field exists with a specific type</li>
</ul>
<p>Used as a struct field:</p>
<pre><code class="language-move">/// Imported from the `sui::bag` module.
use sui::bag::{Self, Bag};

/// An example of a `Bag` as a struct field.
public struct Carrier has key {
    id: UID,
    bag: Bag
}
</code></pre>
<p>Using the Bag:</p>
<pre><code class="language-move">let mut bag = bag::new(ctx);

// bag has the `length` function to get the number of elements
assert!(bag.length() == 0, 0);

bag.add(b&quot;my_key&quot;, b&quot;my_value&quot;.to_string());

// length has changed to 1
assert!(bag.length() == 1, 1);

// in order: `borrow`, `borrow_mut` and `remove`
// the value type must be specified
let field_ref: &amp;String = &amp;bag[b&quot;my_key&quot;];
let field_mut: &amp;mut String = &amp;mut bag[b&quot;my_key&quot;];
let field: String = bag.remove(b&quot;my_key&quot;);

// length is back to 0 - we can unpack
bag.destroy_empty();
</code></pre>
<h2 id="objectbag"><a class="header" href="#objectbag">ObjectBag</a></h2>
<p>Defined in the <code>sui::object_bag</code> module. Identical to <a href="programmability/dynamic-collections.html#bag">Bag</a>, but uses
<a href="programmability/./dynamic-object-fields.html">dynamic object fields</a> internally. Can only store objects as values.</p>
<h2 id="table"><a class="header" href="#table">Table</a></h2>
<p>Table is a typed dynamic collection that has a fixed type for keys and values. It is defined in the
<code>sui::table</code> module.</p>
<pre><code class="language-move">// File: sui-framework/sources/table.move
public struct Table&lt;phantom K: copy + drop + store, phantom V: store&gt; has key, store {
    /// the ID of this table
    id: UID,
    /// the number of key-value pairs in the table
    size: u64,
}
</code></pre>
<p>Used as a struct field:</p>
<pre><code class="language-move">/// Imported from the `sui::table` module.
use sui::table::{Self, Table};

/// Some record type with `store`
public struct Record has store { /* ... */ }

/// An example of a `Table` as a struct field.
public struct UserRegistry has key {
    id: UID,
    table: Table&lt;address, Record&gt;
}
</code></pre>
<p>Using the Table:</p>
<pre><code class="language-move">#[test] fun test_table() {
let ctx = &amp;mut tx_context::dummy();

// Table requires explicit type parameters for the key and value
// ...but does it only once in initialization.
let mut table = table::new&lt;address, String&gt;(ctx);

// table has the `length` function to get the number of elements
assert!(table.length() == 0, 0);

table.add(@0xa11ce, b&quot;my_value&quot;.to_string());
table.add(@0xb0b, b&quot;another_value&quot;.to_string());

// length has changed to 2
assert!(table.length() == 2, 2);

// in order: `borrow`, `borrow_mut` and `remove`
let addr_ref = &amp;table[@0xa11ce];
let addr_mut = &amp;mut table[@0xa11ce];

// removing both values
let _addr = table.remove(@0xa11ce);
let _addr = table.remove(@0xb0b);

// length is back to 0 - we can unpack
table.destroy_empty();
</code></pre>
<h2 id="objecttable"><a class="header" href="#objecttable">ObjectTable</a></h2>
<p>Defined in the <code>sui::object_table</code> module. Identical to <a href="programmability/dynamic-collections.html#table">Table</a>, but uses
<a href="programmability/./dynamic-object-fields.html">dynamic object fields</a> internally. Can only store objects as values.</p>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<ul>
<li><a href="programmability/dynamic-collections.html#bag">Bag</a> - a simple collection that can store any type of data</li>
<li><a href="programmability/dynamic-collections.html#objectbag">ObjectBag</a> - a collection that can store only objects</li>
<li><a href="programmability/dynamic-collections.html#table">Table</a> - a typed dynamic collection that has a fixed type for keys and values</li>
<li><a href="programmability/dynamic-collections.html#objecttable">ObjectTable</a> - same as Table, but can only store objects</li>
</ul>
<!-- [Linked Table](#linkedtable) -->
<h2 id="linkedtable"><a class="header" href="#linkedtable">LinkedTable</a></h2>
<p>This section is coming soon!</p>
<!-- TODO! -->
<!-- ## Choosing a Collection Type

Depending on the needs of your project, you may choose to -->
<!-- ## LinkedTable

TODO: ... -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-witness"><a class="header" href="#pattern-witness">Pattern: Witness</a></h1>
<p>Witness is a pattern of proving an existence by constructing a proof. In the context of programming,
witness is a way to prove a certain property of a system by providing a value that can only be
constructed if the property holds.</p>
<h2 id="witness-in-move"><a class="header" href="#witness-in-move">Witness in Move</a></h2>
<p>In the <a href="programmability/./../move-basics/struct.html">Struct</a> section we have shown that a struct can only be
created - or <em>packed</em> - by the module defining it. Hence, in Move, a module proves ownership of the
type by constructing it. This is one of the most important patterns in Move, and it is widely used
for generic type instantiation and authorization.</p>
<p>Practically speaking, for the witness to be used, there has to be a function that expects a witness
as an argument. In the example below it is the <code>new</code> function that expects a witness of the <code>T</code> type
to create a <code>Instance&lt;T&gt;</code> instance.</p>
<blockquote>
<p>It is often the case that the witness struct is not stored, and for that the function may require
the <a href="programmability/./../move-basics/drop-ability.html">Drop</a> ability for the type.</p>
</blockquote>
<pre><code class="language-move">module book::witness {
    /// A struct that requires a witness to be created.
    public struct Instance&lt;T&gt; { t: T }

    /// Create a new instance of `Instance&lt;T&gt;` with the provided T.
    public fun new&lt;T&gt;(witness: T): Instance&lt;T&gt; {
        Instance { t: witness }
    }
}
</code></pre>
<p>The only way to construct an <code>Instance&lt;T&gt;</code> is to call the <code>new</code> function with an instance of the
type <code>T</code>. This is a basic example of the witness pattern in Move. A module providing a witness often
has a matching implementation, like the module <code>book::witness_source</code> below:</p>
<pre><code class="language-move">module book::witness_source {
    use book::witness::{Self, Instance};

    /// A struct used as a witness.
    public struct W {}

    /// Create a new instance of `Instance&lt;W&gt;`.
    public fun new_instance(): Instance&lt;W&gt; {
        witness::new(W {})
    }
}
</code></pre>
<p>The instance of the struct <code>W</code> is passed into the <code>new_instance</code> function to create an <code>Instance&lt;W&gt;</code>, thereby
proving that the module <code>book::witness_source</code> owns the type <code>W</code>.</p>
<h2 id="instantiating-a-generic-type"><a class="header" href="#instantiating-a-generic-type">Instantiating a Generic Type</a></h2>
<p>Witness allows generic types to be instantiated with a concrete type. This is useful for inheriting
associated behaviors from the type with an option to extend them, if the module provides the ability
to do so.</p>
<pre><code class="language-move">// File: sui-framework/sources/balance.move
/// A Supply of T. Used for minting and burning.
public struct Supply&lt;phantom T&gt; has key, store {
    id: UID,
    value: u64
}

/// Create a new supply for type T with the provided witness.
public fun create_supply&lt;T: drop&gt;(_w: T): Supply&lt;T&gt; {
    Supply { value: 0 }
}

/// Get the `Supply` value.
public fun supply_value&lt;T&gt;(supply: &amp;Supply&lt;T&gt;): u64 {
    supply.value
}
</code></pre>
<p>In the example above, which is borrowed from the <code>balance</code> module of the
<a href="programmability/./sui-framework.html">Sui Framework</a>, the <code>Supply</code> a generic struct that can be constructed only by
supplying a witness of the type <code>T</code>. The witness is taken by value and <em>discarded</em> - hence the <code>T</code>
must have the <a href="programmability/./../move-basics/drop-ability.html">drop</a> ability.</p>
<p>The instantiated <code>Supply&lt;T&gt;</code> can then be used to mint new <code>Balance&lt;T&gt;</code>'s, where <code>T</code> is the type of
the supply.</p>
<pre><code class="language-move">// File: sui-framework/sources/balance.move
/// Storable balance.
struct Balance&lt;phantom T&gt; has store {
    value: u64
}

/// Increase supply by `value` and create a new `Balance&lt;T&gt;` with this value.
public fun increase_supply&lt;T&gt;(self: &amp;mut Supply&lt;T&gt;, value: u64): Balance&lt;T&gt; {
    assert!(value &lt; (18446744073709551615u64 - self.value), EOverflow);
    self.value = self.value + value;
    Balance { value }
}
</code></pre>
<h2 id="one-time-witness"><a class="header" href="#one-time-witness">One Time Witness</a></h2>
<p>While a struct can be created any number of times, there are cases where a struct should be
guaranteed to be created only once. For this purpose, Sui provides the &quot;One-Time Witness&quot; - a
special witness that can only be used once. We explain it in more detail in the
<a href="programmability/./one-time-witness.html">next section</a>.</p>
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<ul>
<li>Witness is a pattern of proving a certain property by constructing a proof.</li>
<li>In Move, a module proves ownership of a type by constructing it.</li>
<li>Witness is often used for generic type instantiation and authorization.</li>
</ul>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<p>In the next section, we will learn about the <a href="programmability/./one-time-witness.html">One Time Witness</a> pattern.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="one-time-witness-1"><a class="header" href="#one-time-witness-1">One Time Witness</a></h1>
<p>While regular <a href="programmability/./witness-pattern.html">Witness</a> is a great way to statically prove the ownership of a
type, there are cases where we need to ensure that a Witness is instantiated only once. And this is
the purpose of the One Time Witness (OTW).</p>
<!--
Notes to self:
  - background first or definition first - which one is better?
  - why would someone read this section?
  - if we removed the OTW from docs, then we should give definition first.
-->
<h2 id="definition-4"><a class="header" href="#definition-4">Definition</a></h2>
<p>The OTW is a special type of Witness that can be used only once. It cannot be manually
created and it is guaranteed to be unique per module. Sui Adapter treats a type as an OTW if it follows these rules:</p>
<ol>
<li>Has only <code>drop</code> ability.</li>
<li>Has no fields.</li>
<li>Is not a generic type.</li>
<li>Named after the module with all uppercase letters.</li>
</ol>
<p>Here is an example of an OTW:</p>
<pre><code class="language-move">module book::one_time {
    /// The OTW for the `book::one_time` module.
    /// Only `drop`, no fields, no generics, all uppercase.
    public struct ONE_TIME has drop {}

    /// Receive the instance of `ONE_TIME` as the first argument.
    fun init(otw: ONE_TIME, ctx: &amp;mut TxContext) {
        // do something with the OTW
    }
}
</code></pre>
<p>The OTW cannot be constructed manually, and any code attempting to do so will result in
a compilation error. The OTW can be received as the first argument in the
<a href="programmability/./module-initializer.html">module initializer</a>. And because the <code>init</code> function is called only once
per module, the OTW is guaranteed to be instantiated only once.</p>
<h2 id="enforcing-the-otw"><a class="header" href="#enforcing-the-otw">Enforcing the OTW</a></h2>
<p>To check if a type is an OTW, <code>sui::types</code> module of the
<a href="programmability/./sui-framework.html">Sui Framework</a> offers a special function <code>is_one_time_witness</code> that can be used
to check if the type is an OTW.</p>
<pre><code class="language-move">use sui::types;

const ENotOneTimeWitness: u64 = 1;

/// Takes an OTW as an argument, aborts if the type is not OTW.
public fun takes_witness&lt;T: drop&gt;(otw: T) {
    assert!(types::is_one_time_witness(&amp;otw), ENotOneTimeWitness);
}
</code></pre>
<!-- ## Background

Before we get to actual definition of the OTW, let's consider a simple example. We want to build a generic implementation of a Coin type, which can be initialized with a witness. A instance of a witness `T` is used to create a new `TreasuryCap<T>` which is then used to mint a new `Coin<T>`.

```move
module book::simple_coin {

    /// Controls the supply of the Coin.
    public struct TreasuryCap<phantom T> has key, store {
        id: UID,
        total_supply: u64,
    }

    /// The Coin type where the `T` is a witness.
    public struct Coin<phantom T> has key, store {
        id: UID,
        value: u64,
    }

    /// Create a new TreasuryCap with a witness.
    /// Vulnerable: we can create multiple TreasuryCap<T> with the same witness.
    public fun new<T: drop>(_: T, ctx: &mut TxContext): TreasuryCap<T> {
        TreasuryCap { id: object::new(ctx), total_supply: 0 }
    }

    /// We use a regular witness to authorize the minting.
    public fun mint<T>(
        treasury: &mut TreasuryCap<T>,
        value: u64,
        ctx: &mut TxContext
    ) {
        treasury.total_supply = treasury.total_supply + value;
        Coin { id: object::new(ctx), value }
    }
}
```

A dishonest developer would be able to create multiple `TreasuryCap`s with the same witness, and mint more `Coin`s than expected. Here is an example of such a malicious module:

```move
module book::simple_coin_cheater {
    /// The Coin witness.
    public struct Move has drop {}

    /// Initialize the TreasuryCap with the Move witness.
    /// ...and do it twice! >_<
    fun init(ctx: &mut TxContext) {
        let treasury_cap = book::simple_coin::new(Move {}, ctx);
        let secret_treasury = book::simple_coin::new(Move {}, ctx);

        transfer::public_transfer(treasury_cap, ctx.sender())
        transfer::public_transfer(secret_treasury, ctx.sender())
    }
}

```

The example above has no protection against issuing multiple `TreasuryCap`s with the same witness, and in real-world application, this creates a problem of trust. If it was a human decision to support a Coin based on this implementation, they would have to make sure that:

- there is only one `TreasuryCap` for a given `T`.
- the module cannot be upgraded to issue more `TreasuryCap`s.
- the module code does not contain any backdoors to issue more `TreasuryCap`s.

However, it is not possible to check any of these conditions inside the Move code. And to prevent the need for trust, Sui introduces the OTW pattern.

## Solving the Coin Problem

To solve the case of multiple `TreasuryCap`s, we can use the OTW pattern. By defining the `COIN_OTW` type as an OTW, we can ensure that the `COIN_OTW` is used only once. The `COIN_OTW` is then used to create a new `TreasuryCap` and mint a new `Coin`.

```move

With

```move
module book::coin_otw {

    /// The OTW for the `book::coin_otw` module.
    struct COIN_OTW has drop {}

    /// Receive the instance of `COIN_OTW` as the first argument.
    fun init(otw: COIN_OTW, ctx: &mut TxContext) {
        let treasury_cap = book::simple_coin::new(COIN_OTW {}, ctx);
        transfer::public_transfer(treasury_cap, ctx.sender())
    }
}
```


 -->
<!-- ## Case Study: Coin

TODO: add a story behind TreasuryCap and Coin

-->
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<p>The OTW pattern is a great way to ensure that a type is used only once. Most of the
developers should understand how to define and receive the OTW, while the OTW checks and enforcement
is mostly needed in libraries and frameworks. For example, the <code>sui::coin</code> module requires an OTW
in the <code>coin::create_currency</code> method, therefore enforcing that the <code>coin::TreasuryCap</code>
is created only once.</p>
<p>OTW is a powerful tool that lays the foundation for the <a href="programmability/./publisher.html">Publisher</a>
object, which we will cover in the next section.</p>
<!--

## Questions
- What other ways could be used to prevent multiple `TreasuryCap`s?
- Are there any other ways to use the OTW?

 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="publisher-authority"><a class="header" href="#publisher-authority">Publisher Authority</a></h1>
<p>In application design and development, it is often needed to prove publisher authority. This is
especially important in the context of digital assets, where the publisher may enable or disable
certain features for their assets. The Publisher Object is an object, defined in the
<a href="programmability/./sui-framework.html">Sui Framework</a>, that allows the publisher to prove their <em>authority over a
type</em>.</p>
<h2 id="definition-5"><a class="header" href="#definition-5">Definition</a></h2>
<p>The Publisher object is defined in the <code>sui::package</code> module of the Sui Framework. It is a very
simple, non-generic object that can be initialized once per module (and multiple times per package)
and is used to prove the authority of the publisher over a type. To claim a Publisher object, the
publisher must present a <a href="programmability/./one-time-witness.html">One Time Witness</a> to the <code>package::claim</code> function.</p>
<pre><code class="language-move">// File: sui-framework/sources/package.move
public struct Publisher has key, store {
    id: UID,
    package: String,
    module_name: String,
}
</code></pre>
<blockquote>
<p>If you're not familiar with the One Time Witness, you can read more about it
<a href="programmability/./one-time-witness.html">here</a>.</p>
</blockquote>
<p>Here's a simple example of claiming a <code>Publisher</code> object in a module:</p>
<pre><code class="language-move">module book::publisher {
    /// Some type defined in the module.
    public struct Book {}

    /// The OTW for the module.
    public struct PUBLISHER has drop {}

    /// Uses the One Time Witness to claim the Publisher object.
    fun init(otw: PUBLISHER, ctx: &amp;mut TxContext) {
        // Claim the Publisher object.
        let publisher = sui::package::claim(otw, ctx);

        // Usually it is transferred to the sender.
        // It can also be stored in another object.
        transfer::public_transfer(publisher, ctx.sender())
    }
}
</code></pre>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>The Publisher object has two functions associated with it which are used to prove the publisher's
authority over a type:</p>
<pre><code class="language-move">// Checks if the type is from the same module, hence the `Publisher` has the
// authority over it.
assert!(publisher.from_module&lt;Book&gt;(), 0);

// Checks if the type is from the same package, hence the `Publisher` has the
// authority over it.
assert!(publisher.from_package&lt;Book&gt;(), 0);
</code></pre>
<h2 id="publisher-as-admin-role"><a class="header" href="#publisher-as-admin-role">Publisher as Admin Role</a></h2>
<p>For small applications or simple use cases, the Publisher object can be used as an admin
<a href="programmability/./capability.html">capability</a>. While in the broader context, the Publisher object has control over
system configurations, it can also be used to manage the application's state.</p>
<pre><code class="language-move">/// Some action in the application gated by the Publisher object.
public fun admin_action(cap: &amp;Publisher, /* app objects... */ param: u64) {
    assert!(cap.from_module&lt;Book&gt;(), ENotAuthorized);

    // perform application-specific action
}
</code></pre>
<p>However, Publisher misses some native properties of <a href="programmability/./capability.html">Capabilities</a>, such as type
safety and expressiveness. The signature for the <code>admin_action</code> is not very explicit, can be
called by anyone else. And due to <code>Publisher</code> object being standard, there now is a risk of
unauthorized access if the <code>from_module</code> check is not performed. So it's important to be cautious
when using the <code>Publisher</code> object as an admin role.</p>
<h2 id="role-on-sui"><a class="header" href="#role-on-sui">Role on Sui</a></h2>
<p>Publisher is required for certain features on Sui. <a href="programmability/./display.html">Object Display</a> can be created
only by the Publisher, and TransferPolicy - an important component of the Kiosk system - also
requires the Publisher object to prove ownership of the type.</p>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<p>In the next chapter we will cover the first feature that requires the Publisher object - Object
Display - a way to describe objects for clients, and standardize metadata. A must-have for
user-friendly applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-display"><a class="header" href="#object-display">Object Display</a></h1>
<p>Objects on Sui are explicit in their structure and behavior and can be displayed in an
understandable way. However, to support richer metadata for clients, there's a standard and
efficient way of &quot;describing&quot; them to the client - the <code>Display</code> object defined in the
<a href="programmability/./sui-framework.html">Sui Framework</a>.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>Historically, there were different attempts to agree on a standard structure of an object so it can
be displayed in a user interface. One of the approaches was to define certain fields in the object
struct which, when present, would be used in the UI. This approach was not flexible enough and
required developers to define the same fields in every object, and sometimes the fields did not make
sense for the object.</p>
<pre><code class="language-move">/// An attempt to standardize the object structure for display.
public struct CounterWithDisplay has key {
    id: UID,
    /// If this field is present it will be displayed in the UI as `name`.
    name: String,
    /// If this field is present it will be displayed in the UI as `description`.
    description: String,
    // ...
    image: String,
    /// Actual fields of the object.
    counter: u64,
    // ...
}
</code></pre>
<p>If any of the fields contained static data, it would be duplicated in every object. And, since Move
does not have interfaces, it is not possible to know if an object has a specific field without
&quot;manually&quot; checking the object's type, which makes the client fetching more complex.</p>
<h2 id="object-display-1"><a class="header" href="#object-display-1">Object Display</a></h2>
<p>To address these issues, Sui introduces a standard way of describing an object for display. Instead
of defining fields in the object struct, the display metadata is stored in a separate object, which
is associated with the type. This way, the display metadata is not duplicated, and it is easy to
extend and maintain.</p>
<p>Another important feature of Sui Display is the ability to define templates and use object fields in
those templates. Not only it allows for a more flexible display, but it also frees the developer
from the need to define the same fields with the same names and types in every object.</p>
<blockquote>
<p>The Object Display is natively supported by the Sui Fullnode, and the client can fetch the display
metadata for any object if the object type has a Display associated with it.</p>
</blockquote>
<pre><code class="language-move">module book::arena {
    use std::string::String;
    use sui::package;
    use sui::display;

    /// The One Time Witness to claim the `Publisher` object.
    public struct ARENA has drop {}

    /// Some object which will be displayed.
    public struct Hero has key {
        id: UID,
        class: String,
        level: u64,
    }

    /// In the module initializer we create the `Publisher` object, and then
    /// the Display for the `Hero` type.
    fun init(otw: ARENA, ctx: &amp;mut TxContext) {
        let publisher = package::claim(otw, ctx);
        let mut display = display::new&lt;Hero&gt;(&amp;publisher, ctx);

        display.add(
            b&quot;name&quot;.to_string(),
            b&quot;{class} (lvl. {level})&quot;.to_string()
        );

        display.add(
            b&quot;description&quot;.to_string(),
            b&quot;One of the greatest heroes of all time. Join us!&quot;.to_string()
        );

        display.add(
            b&quot;link&quot;.to_string(),
            b&quot;https://example.com/hero/{id}&quot;.to_string()
        );

        display.add(
            b&quot;image_url&quot;.to_string(),
            b&quot;https://example.com/hero/{class}.jpg&quot;.to_string()
        );

        // Update the display with the new data.
        // Must be called to apply changes.
        display.update_version();

        transfer::public_transfer(publisher, ctx.sender());
        transfer::public_transfer(display, ctx.sender());
    }
}
</code></pre>
<h2 id="creator-privilege"><a class="header" href="#creator-privilege">Creator Privilege</a></h2>
<p>While the objects can be owned by accounts and may be a subject to
<a href="programmability/./../object/ownership.html#account-owner-or-single-owner">True Ownership</a>, the Display can be owned
by the creator of the object. This way, the creator can update the display metadata and apply the
changes globally without the need to update every object. The creator can also transfer Display to
another account or even build an application around the object with custom functionality to manage
the metadata.</p>
<h2 id="standard-fields"><a class="header" href="#standard-fields">Standard Fields</a></h2>
<p>The fields that are supported most widely are:</p>
<ul>
<li><code>name</code> - A name for the object. The name is displayed when users view the object.</li>
<li><code>description</code> - A description for the object. The description is displayed when users view the
object.</li>
<li><code>link</code> - A link to the object to use in an application.</li>
<li><code>image_url</code> - A URL or a blob with the image for the object.</li>
<li><code>thumbnail_url</code> - A URL to a smaller image to use in wallets, explorers, and other products as a
preview.</li>
<li><code>project_url</code> - A link to a website associated with the object or creator.</li>
<li><code>creator</code> - A string that indicates the object creator.</li>
</ul>
<blockquote>
<p>Please, refer to the <a href="https://docs.sui.io/standards/display">Sui Documentation</a> for the most
up-to-date list of supported fields.</p>
</blockquote>
<p>While there's a standard set of fields, the Display object does not enforce them. The developer can
define any fields they need, and the client can use them as they see fit. Some applications may
require additional fields, and omit other, and the Display is flexible enough to support them.</p>
<h2 id="working-with-display"><a class="header" href="#working-with-display">Working with Display</a></h2>
<p>The <code>Display</code> object is defined in the <code>sui::display</code> module. It is a generic struct that takes a
phantom type as a parameter. The phantom type is used to associate the <code>Display</code> object with the
type it describes. The <code>fields</code> of the <code>Display</code> object are a <code>VecMap</code> of key-value pairs, where the
key is the field name and the value is the field value. The <code>version</code> field is used to version the
display metadata, and is updated on the <code>update_display</code> call.</p>
<p>File: sui-framework/sources/display.move</p>
<pre><code class="language-move">struct Display&lt;phantom T: key&gt; has key, store {
    id: UID,
    /// Contains fields for display. Currently supported
    /// fields are: name, link, image and description.
    fields: VecMap&lt;String, String&gt;,
    /// Version that can only be updated manually by the Publisher.
    version: u16
}
</code></pre>
<p>The <a href="programmability/./publisher.html">Publisher</a> object is required to a new Display, since it serves as the proof of
ownership of type.</p>
<h2 id="template-syntax"><a class="header" href="#template-syntax">Template Syntax</a></h2>
<p>Currently, Display supports simple string interpolation and can use struct fields (and paths) in its
templates. The syntax is trivial - <code>{path}</code> is replaced with the value of the field at the path. The
path is a dot-separated list of field names, starting from the root object in case of nested fields.</p>
<pre><code class="language-move">/// Some common metadata for objects.
public struct Metadata has store {
    name: String,
    description: String,
    published_at: u64
}

/// The type with nested Metadata field.
public struct LittlePony has key, store {
    id: UID,
    image_url: String,
    metadata: Metadata
}
</code></pre>
<p>The Display for the type <code>LittlePony</code> above could be defined as follows:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;Just a pony&quot;,
  &quot;image_url&quot;: &quot;{image_url}&quot;,
  &quot;description&quot;: &quot;{metadata.description}&quot;
}
</code></pre>
<h2 id="multiple-display-objects"><a class="header" href="#multiple-display-objects">Multiple Display Objects</a></h2>
<p>There's no restriction to how many <code>Display&lt;T&gt;</code> objects can be created for a specific <code>T</code>. However,
the most recently updated <code>Display&lt;T&gt;</code> will be used by the fullnode.</p>
<h2 id="further-reading-24"><a class="header" href="#further-reading-24">Further Reading</a></h2>
<ul>
<li><a href="https://docs.sui.io/standards/display">Sui Object Display</a> is Sui Documentation</li>
<li><a href="programmability/./publisher.html">Publisher</a> - the representation of the creator</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events-1"><a class="header" href="#events-1">Events</a></h1>
<p>Events are a way to notify off-chain listeners about on-chain events. They are used to emit
additional information about the transaction that is not stored - and, hence, can't be accessed -
on-chain. Events are emitted by the <code>sui::event</code> module located in the
<a href="programmability/./sui-framework.html">Sui Framework</a>.</p>
<blockquote>
<p>Any custom type with the <a href="programmability/./../move-basics/copy-ability.html">copy</a> and
<a href="programmability/./../move-basics/drop-ability.html">drop</a> abilities can be emitted as an event.
Sui Verifier requires the type to be internal to the module.</p>
</blockquote>
<pre><code class="language-move">// File: sui-framework/sources/event.move
module sui::event {
    /// Emit a custom Move event, sending the data offchain.
    ///
    /// Used for creating custom indexes and tracking onchain
    /// activity in a way that suits a specific application the most.
    ///
    /// The type `T` is the main way to index the event, and can contain
    /// phantom parameters, eg `emit(MyEvent&lt;phantom T&gt;)`.
    public native fun emit&lt;T: copy + drop&gt;(event: T);
}
</code></pre>
<h2 id="emitting-events"><a class="header" href="#emitting-events">Emitting Events</a></h2>
<p>Events are emitted using the <code>emit</code> function in the <code>sui::event</code> module. The function takes a single
argument - the event to be emitted. The event data is passed by value,</p>
<pre><code class="language-move">module book::events {
    use sui::coin::Coin;
    use sui::sui::SUI;
    use sui::event;

    /// The item that can be purchased.
    public struct Item has key { id: UID }

    /// Event emitted when an item is purchased. Contains the ID of the item and
    /// the price for which it was purchased.
    public struct ItemPurchased has copy, drop {
        item: ID,
        price: u64
    }

    /// A marketplace function which performs the purchase of an item.
    public fun purchase(coin: Coin&lt;SUI&gt;, ctx: &amp;mut TxContext) {
        let item = Item { id: object::new(ctx) };

        // Create an instance of `ItemPurchased` and pass it to `event::emit`.
        event::emit(ItemPurchased {
            item: object::id(&amp;item),
            price: coin.value()
        });

        // Omitting the rest of the implementation to keep the example simple.
        abort 0
    }
}
</code></pre>
<p>The Sui Verifier requires the type passed to the <code>emit</code> function to be <em>internal to the module</em>. So
emitting a type from another module will result in a compilation error. Primitive types, although
they match the <em>copy</em> and <em>drop</em> requirement, are not allowed to be emitted as events.</p>
<h2 id="event-structure"><a class="header" href="#event-structure">Event Structure</a></h2>
<p>Events are a part of the transaction result and are stored in the <em>transaction effects</em>. As such,
they natively have the <code>sender</code> field which is the address who sent the transaction. So adding a
&quot;sender&quot; field to the event is not necessary. Similarly, event metadata contains the timestamp. But
it is important to note that the timestamp is relative to the node and may vary a little from node
to node.</p>
<!-- ## Reliability -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="sui-framework"><a class="header" href="#sui-framework">Sui Framework</a></h1>
<p>Sui Framework is a default dependency set in the <a href="programmability/./../concepts/manifest.html">Package Manifest</a>. It
depends on the <a href="programmability/./../move-basics/standard-library.html">Standard Library</a> and provides Sui-specific
features, including the interaction with the storage, and Sui-specific native types and modules.</p>
<p><em>For convenience, we grouped the modules in the Sui Framework into multiple categories. But they're
still part of the same framework.</em></p>
<h2 id="core"><a class="header" href="#core">Core</a></h2>
<!-- Custom CSS addition in the theme/custom.css  -->
<div class="modules-table">
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Description</th><th>Chapter</th></tr></thead><tbody>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/address">sui::address</a></td><td>Adds conversion methods to the <a href="programmability/./../move-basics/address.html">address type</a></td><td><a href="programmability/./../move-basics/address.html">Address</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/transfer">sui::transfer</a></td><td>Implements the storage operations for Objects</td><td><a href="programmability/./../object">It starts with an Object</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/tx_context">sui::tx_context</a></td><td>Contains the <code>TxContext</code> struct and methods to read it</td><td><a href="programmability/./transaction-context.html">Transaction Context</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/object">sui::object</a></td><td>Defines the <code>UID</code> and <code>ID</code> type, required for creating objects</td><td><a href="programmability/./../object">It starts with an Object</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/clock">sui::clock</a></td><td>Defines the <code>Clock</code> type and its methods</td><td><a href="programmability/./epoch-and-time.html">Epoch and Time</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/dynamic_field">sui::dynamic_field</a></td><td>Implements methods to add, use and remove dynamic fields</td><td><a href="programmability/./dynamic-fields.html">Dynamic Fields</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/dynamic_object_field">sui::dynamic_object_field</a></td><td>Implements methods to add, use and remove dynamic object fields</td><td><a href="programmability/./dynamic-object-fields.html">Dynamic Object Fields</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/event">sui::event</a></td><td>Allows emitting events for off-chain listeners</td><td><a href="programmability/./events.html">Events</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/package">sui::package</a></td><td>Defines the <code>Publisher</code> type and package upgrade methods</td><td><a href="programmability/./publisher.html">Publisher</a>, <a href="programmability/./package-upgrades.html">Package Upgrades</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/display">sui::display</a></td><td>Implements the <code>Display</code> object and ways to create and update it</td><td><a href="programmability/./display.html">Display</a></td></tr>
</tbody></table>
</div></div>
<h2 id="collections-1"><a class="header" href="#collections-1">Collections</a></h2>
<div class="modules-table">
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Description</th><th>Chapter</th></tr></thead><tbody>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/vec_set">sui::vec_set</a></td><td>Implements a set type</td><td><a href="programmability/./collections.html">Collections</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/vec_map">sui::vec_map</a></td><td>Implements a map with vector keys</td><td><a href="programmability/./collections.html">Collections</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/table">sui::table</a></td><td>Implements the <code>Table</code> type and methods to interact with it</td><td><a href="programmability/./dynamic-collections.html">Dynamic Collections</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/linked_table">sui::linked_table</a></td><td>Implements the <code>LinkedTable</code> type and methods to interact with it</td><td><a href="programmability/./dynamic-collections.html">Dynamic Collections</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/bag">sui::bag</a></td><td>Implements the <code>Bag</code> type and methods to interact with it</td><td><a href="programmability/./dynamic-collections.html">Dynamic Collections</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/object_table">sui::object_table</a></td><td>Implements the <code>ObjectTable</code> type and methods to interact with it</td><td><a href="programmability/./dynamic-collections.html">Dynamic Collections</a></td></tr>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/object_bag">sui::object_bag</a></td><td>Implements the <code>ObjectBag</code> type and methods to interact with it</td><td><a href="programmability/./dynamic-collections.html">Dynamic Collections</a></td></tr>
</tbody></table>
</div></div>
<h2 id="utilities"><a class="header" href="#utilities">Utilities</a></h2>
<div class="modules-table">
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Description</th><th>Chapter</th></tr></thead><tbody>
<tr><td><a href="https://docs.sui.io/references/framework/sui-framework/bcs">sui::bcs</a></td><td>Implements the BCS encoding and decoding functions</td><td><a href="programmability/./bcs.html">Binary Canonical Serialization</a></td></tr>
</tbody></table>
</div>
<h2 id="exported-addresses-1"><a class="header" href="#exported-addresses-1">Exported Addresses</a></h2>
<p>Sui Framework exports two named addresses: <code>sui = 0x2</code> and <code>std = 0x1</code> from the std dependency.</p>
<pre><code class="language-toml">[addresses]
sui = &quot;0x2&quot;

# Exported from the MoveStdlib dependency
std = &quot;0x1&quot;
</code></pre>
<h2 id="implicit-imports-1"><a class="header" href="#implicit-imports-1">Implicit Imports</a></h2>
<p>Just like with <a href="programmability/./../move-basics/standard-library.html#implicit-imports">Standard Library</a>, some of
the modules and types are imported implicitly in the Sui Framework. This is the list of modules and
types that are available without explicit <code>use</code> import:</p>
<ul>
<li>sui::object</li>
<li>sui::object::ID</li>
<li>sui::object::UID</li>
<li>sui::tx_context</li>
<li>sui::tx_context::TxContext</li>
<li>sui::transfer</li>
</ul>
<h2 id="source-code-1"><a class="header" href="#source-code-1">Source Code</a></h2>
<p>The source code of the Sui Framework is available in the
<a href="https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources">Sui repository</a>.</p>
<!--

Modules:

Coins:
- sui::pay
- sui::sui
- sui::coin
- sui::token
- sui::balance
- sui::deny_list

Commerce:
- sui::kiosk
- sui::display
- sui::kiosk_extension
- sui::transfer_policy


- sui::bcs
- sui::hex
- sui::math
- sui::types
- sui::borrow


- sui::authenticator

- sui::priority_queue
- sui::table_vec

- sui::url
- sui::versioned

- sui::prover
- sui::random

- sui::bls12381
- sui::ecdsa_k1
- sui::ecdsa_r1
- sui::ecvrf
- sui::ed25519
(also mention verifier 16 growth)
- sui::group_ops
- sui::hash
- sui::hmac
- sui::poseidon
- sui::zklogin_verified_id
- sui::zklogin_verified_issuer

 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-hot-potato"><a class="header" href="#pattern-hot-potato">Pattern: Hot Potato</a></h1>
<p>A case in the abilities system - a struct without any abilities - is called <em>hot potato</em>. It cannot
be stored (not as <a href="programmability/./../storage/key-ability.html">an object</a> nor as
<a href="programmability/./../storage/store-ability.html">a field in another struct</a>), it cannot be
<a href="programmability/./../move-basics/copy-ability.html">copied</a> or <a href="programmability/./../move-basics/drop-ability.html">discarded</a>. Hence,
once constructed, it must be gracefully <a href="programmability/./../move-basics/struct.html">unpacked by its module</a>, or the
transaction will abort due to unused value without drop.</p>
<blockquote>
<p>If you're familiar with languages that support <em>callbacks</em>, you can think of a hot potato as an
obligation to call a callback function. If you don't call it, the transaction will abort.</p>
</blockquote>
<p>The name comes from the children's game where a ball is passed quickly between players, and none of
the players want to be the last one holding it when the music stops, or they are out of the game.
This is the best illustration of the pattern - the instance of a hot-potato struct is passed between
calls, and none of the modules can keep it.</p>
<h2 id="defining-a-hot-potato"><a class="header" href="#defining-a-hot-potato">Defining a Hot Potato</a></h2>
<p>A hot potato can be any struct with no abilities. For example, the following struct is a hot potato:</p>
<pre><code class="language-move">public struct Request {}
</code></pre>
<p>Because the <code>Request</code> has no abilities and cannot be stored or ignored, the module must provide a
function to unpack it. For example:</p>
<pre><code class="language-move">/// Constructs a new `Request`
public fun new_request(): Request { Request {} }

/// Unpacks the `Request`. Due to the nature of the hot potato, this function
/// must be called to avoid aborting the transaction.
public fun confirm_request(request: Request) {
    let Request {} = request;
}
</code></pre>
<h2 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h2>
<p>In the following example, the <code>Promise</code> hot potato is used to ensure that the borrowed value, when
taken from the container, is returned back to it. The <code>Promise</code> struct contains the ID of the
borrowed object, and the ID of the container, ensuring that the borrowed value was not swapped for
another and is returned to the correct container.</p>
<pre><code class="language-move">/// A generic container for any Object with `key + store`. The Option type
/// is used to allow taking and putting the value back.
public struct Container&lt;T: key + store&gt; has key {
    id: UID,
    value: Option&lt;T&gt;,
}

/// A Hot Potato struct that is used to ensure the borrowed value is returned.
public struct Promise {
    /// The ID of the borrowed object. Ensures that there wasn't a value swap.
    id: ID,
    /// The ID of the container. Ensures that the borrowed value is returned to
    /// the correct container.
    container_id: ID,
}

/// A module that allows borrowing the value from the container.
public fun borrow_val&lt;T: key + store&gt;(container: &amp;mut Container&lt;T&gt;): (T, Promise) {
    assert!(container.value.is_some());
    let value = container.value.extract();
    let id = object::id(&amp;value);
    (value, Promise { id, container_id: object::id(container) })
}

/// Put the taken item back into the container.
public fun return_val&lt;T: key + store&gt;(
    container: &amp;mut Container&lt;T&gt;, value: T, promise: Promise
) {
    let Promise { id, container_id } = promise;
    assert!(object::id(container) == container_id);
    assert!(object::id(&amp;value) == id);
    container.value.fill(value);
}
</code></pre>
<h2 id="applications-1"><a class="header" href="#applications-1">Applications</a></h2>
<p>Below we list some of the common use cases for the hot potato pattern.</p>
<h3 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h3>
<p>As shown in the <a href="programmability/hot-potato-pattern.html#example-usage">example above</a>, the hot potato is very effective for borrowing with
a guarantee that the borrowed value is returned to the correct container. While the example focuses
on a value stored inside an <code>Option</code>, the same pattern can be applied to any other storage type, say
a <a href="programmability/./dynamic-fields.html">dynamic field</a>.</p>
<h3 id="flash-loans"><a class="header" href="#flash-loans">Flash Loans</a></h3>
<p>Canonical example of the hot potato pattern is flash loans. A flash loan is a loan that is borrowed
and repaid in the same transaction. The borrowed funds are used to perform some operations, and the
repaid funds are returned to the lender. The hot potato pattern ensures that the borrowed funds are
returned to the lender.</p>
<p>An example usage of this pattern may look like this:</p>
<pre><code class="language-move">// Borrow the funds from the lender.
let (asset_a, potato) = lender.borrow(amount);

// Perform some operations with the borrowed funds.
let asset_b = dex.trade(loan);
let proceeds = another_contract::do_something(asset_b);

// Keep the commission and return the rest to the lender.
let pay_back = proceeds.split(amount, ctx);
lender.repay(pay_back, potato);
transfer::public_transfer(proceeds, ctx.sender());
</code></pre>
<h3 id="variable-path-execution"><a class="header" href="#variable-path-execution">Variable-path execution</a></h3>
<p>The hot potato pattern can be used to introduce variation in the execution path. For example, if
there is a module which allows purchasing a <code>Phone</code> for some &quot;Bonus Points&quot; or for USD, the hot
potato can be used to decouple the purchase from the payment. The approach is very similar to how
some shops work - you take the item from the shelf, and then you go to the cashier to pay for it.</p>
<pre><code class="language-move">/// A `Phone`. Can be purchased in a store.
public struct Phone has key, store { id: UID }

/// A ticket that must be paid to purchase the `Phone`.
public struct Ticket { amount: u64 }

/// Return the `Phone` and the `Ticket` that must be paid to purchase it.
public fun purchase_phone(ctx: &amp;mut TxContext): (Phone, Ticket) {
    (
        Phone { id: object::new(ctx) },
        Ticket { amount: 100 }
    )
}

/// The customer may pay for the `Phone` with `BonusPoints` or `SUI`.
public fun pay_in_bonus_points(ticket: Ticket, payment: Coin&lt;BONUS&gt;) {
    let Ticket { amount } = ticket;
    assert!(payment.value() == amount);
    abort 0 // omitting the rest of the function
}

/// The customer may pay for the `Phone` with `USD`.
public fun pay_in_usd(ticket: Ticket, payment: Coin&lt;USD&gt;) {
    let Ticket { amount } = ticket;
    assert!(payment.value() == amount);
    abort 0 // omitting the rest of the function
}
</code></pre>
<p>This decoupling technique allows separating the purchase logic from the payment logic, making the
code more modular and easier to maintain. The <code>Ticket</code> could be split into its own module, providing
a basic interface for the payment, and the shop implementation could be extended to support other
goods without changing the payment logic.</p>
<h3 id="compositional-patterns"><a class="header" href="#compositional-patterns">Compositional Patterns</a></h3>
<p>Hot potato can be used to link together different modules in a compositional way. Its module may
define ways to interact with the hot potato, for example, stamp it with a type signature, or to
extract some information from it. This way, the hot potato can be passed between different modules,
and even different packages within the same transaction.</p>
<p>The most important compositional pattern is the <a href="programmability/./request-pattern.html">Request Pattern</a>, which we
will cover in the next section.</p>
<h3 id="usage-in-the-sui-framework"><a class="header" href="#usage-in-the-sui-framework">Usage in the Sui Framework</a></h3>
<p>The pattern is used in various forms in the Sui Framework. Here are some examples:</p>
<ul>
<li><code>sui::borrow</code> - uses hot potato to ensure that the borrowed value is returned to the correct
container.</li>
<li><code>sui::transfer_policy</code> - defines a <code>TransferRequest</code> - a hot potato which can only be consumed if
all conditions are met.</li>
<li><code>sui::token</code> - in the Closed Loop Token system, an <code>ActionRequest</code> carries the information about
the performed action and collects approvals similarly to <code>TransferRequest</code>.</li>
</ul>
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<ul>
<li>A hot potato is a struct without abilities, it must come with a way to create and destroy it.</li>
<li>Hot potatoes are used to ensure that some action is taken before the transaction ends, similar to
a callback.</li>
<li>Most common use cases for hot potato are borrowing, flash loans, variable-path execution, and
compositional patterns.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-canonical-serialization"><a class="header" href="#binary-canonical-serialization">Binary Canonical Serialization</a></h1>
<p>Binary Canonical Serialization (BCS) is a binary encoding format for structured data. It was
originally designed in Diem, and became the standard serialization format for Move. BCS is simple,
efficient, deterministic, and easy to implement in any programming language.</p>
<blockquote>
<p>The full format specification is available in the
<a href="https://github.com/zefchain/bcs">BCS repository</a>.</p>
</blockquote>
<h2 id="format"><a class="header" href="#format">Format</a></h2>
<p>BCS is a binary format that supports unsigned integers up to 256 bits, options, booleans, unit
(empty value), fixed and variable-length sequences, and maps. The format is designed to be
deterministic, meaning that the same data will always be serialized to the same bytes.</p>
<blockquote>
<p>&quot;BCS is not a self-describing format. As such, in order to deserialize a message, one must know
the message type and layout ahead of time&quot; from the <a href="https://github.com/zefchain/bcs">README</a></p>
</blockquote>
<p>Integers are stored in little-endian format, and variable-length integers are encoded using a
variable-length encoding scheme. Sequences are prefixed with their length as ULEB128, enumerations
are stored as the index of the variant followed by the data, and maps are stored as an ordered
sequence of key-value pairs.</p>
<p>Structs are treated as a sequence of fields, and the fields are serialized in the order they are
defined in the struct. The fields are serialized using the same rules as the top-level data.</p>
<h2 id="using-bcs"><a class="header" href="#using-bcs">Using BCS</a></h2>
<p>The <a href="programmability/./sui-framework.html">Sui Framework</a> includes the sui::bcs module for encoding and decoding data. Encoding functions are native to the VM, and decoding functions are implemented in Move.</p>
<h2 id="encoding"><a class="header" href="#encoding">Encoding</a></h2>
<p>To encode data, use the <code>bcs::to_bytes</code> function, which converts data references into byte vectors. This function supports encoding any types, including structs.</p>
<pre><code class="language-move">// File: move-stdlib/sources/bcs.move
public native fun to_bytes&lt;T&gt;(t: &amp;T): vector&lt;u8&gt;;
</code></pre>
<p>The following example shows how to encode a struct using BCS. The <code>to_bytes</code> function can take any
value and encode it as a vector of bytes.</p>
<pre><code class="language-move">use sui::bcs;

// 0x01 - a single byte with value 1 (or 0 for false)
let bool_bytes = bcs::to_bytes(&amp;true);
// 0x2a - just a single byte
let u8_bytes = bcs::to_bytes(&amp;42u8);
// 0x2a00000000000000 - 8 bytes
let u64_bytes = bcs::to_bytes(&amp;42u64);
// address is a fixed sequence of 32 bytes
// 0x0000000000000000000000000000000000000000000000000000000000000002
let addr = bcs::to_bytes(&amp;@sui);
</code></pre>
<h3 id="encoding-a-struct"><a class="header" href="#encoding-a-struct">Encoding a Struct</a></h3>
<p>Structs encode similarly to simple types. Here is how to encode a struct using BCS:</p>
<pre><code class="language-move">let data = CustomData {
    num: 42,
    string: b&quot;hello, world!&quot;.to_string(),
    value: true
};

let struct_bytes = bcs::to_bytes(&amp;data);

let mut custom_bytes = vector[];
custom_bytes.append(bcs::to_bytes(&amp;42u8));
custom_bytes.append(bcs::to_bytes(&amp;b&quot;hello, world!&quot;.to_string()));
custom_bytes.append(bcs::to_bytes(&amp;true));

// struct is just a sequence of fields, so the bytes should be the same!
assert!(&amp;struct_bytes == &amp;custom_bytes, 0);
</code></pre>
<h2 id="decoding"><a class="header" href="#decoding">Decoding</a></h2>
<p>Because BCS does not self-describe and Move is statically typed, decoding requires prior knowledge of the data type. The <code>sui::bcs</code> module provides various functions to assist with this process.</p>
<h3 id="wrapper-api"><a class="header" href="#wrapper-api">Wrapper API</a></h3>
<p>BCS is implemented as a wrapper in Move. The decoder takes the bytes by value, and then allows the
caller to <em>peel off</em> the data by calling different decoding functions, prefixed with <code>peel_*</code>. The
data is split off the bytes, and the remainder bytes are kept in the wrapper until the
<code>into_remainder_bytes</code> function is called.</p>
<pre><code class="language-move">use sui::bcs;

// BCS instance should always be declared as mutable
let mut bcs = bcs::new(x&quot;010000000000000000&quot;);

// Same bytes can be read differently, for example: Option&lt;u64&gt;
let value: Option&lt;u64&gt; = bcs.peel_option_u64();

assert!(value.is_some(), 0);
assert!(value.borrow() == &amp;0, 1);

let remainder = bcs.into_remainder_bytes();

assert!(remainder.length() == 0, 2);
</code></pre>
<p>There is a common practice to use multiple variables in a single <code>let</code> statement during decoding. It
makes code a little bit more readable and helps to avoid unnecessary copying of the data.</p>
<pre><code class="language-move">let mut bcs = bcs::new(x&quot;0101010F0000000000F00000000000&quot;);

// mind the order!!!
// handy way to peel multiple values
let (bool_value, u8_value, u64_value) = (
    bcs.peel_bool(),
    bcs.peel_u8(),
    bcs.peel_u64()
);
</code></pre>
<h3 id="decoding-vectors"><a class="header" href="#decoding-vectors">Decoding Vectors</a></h3>
<p>While most of the primitive types have a dedicated decoding function, vectors need special handling,
which depends on the type of the elements. For vectors, first you need to decode the length of the
vector, and then decode each element in a loop.</p>
<pre><code class="language-move">let mut bcs = bcs::new(x&quot;0101010F0000000000F00000000000&quot;);

// bcs.peel_vec_length() peels the length of the vector :)
let mut len = bcs.peel_vec_length();
let mut vec = vector[];

// then iterate depending on the data type
while (len &gt; 0) {
    vec.push_back(bcs.peel_u64()); // or any other type
    len = len - 1;
};

assert!(vec.length() == 1, 0);
</code></pre>
<p>For most common scenarios, <code>bcs</code> module provides a basic set of functions for decoding vectors:</p>
<ul>
<li><code>peel_vec_address(): vector&lt;address&gt;</code></li>
<li><code>peel_vec_bool(): vector&lt;bool&gt;</code></li>
<li><code>peel_vec_u8(): vector&lt;u8&gt;</code></li>
<li><code>peel_vec_u64(): vector&lt;u64&gt;</code></li>
<li><code>peel_vec_u128(): vector&lt;u128&gt;</code></li>
<li><code>peel_vec_vec_u8(): vector&lt;vector&lt;u8&gt;&gt;</code> - vector of byte vectors</li>
</ul>
<h3 id="decoding-option"><a class="header" href="#decoding-option">Decoding Option</a></h3>
<!--
> Coincidentally, Option, being a vector in Move, overlaps with the representation of an enum with a
> single variant in BCS, and makes Option in Rust fully compatible with the one in Move.
-->
<p><a href="programmability/./../move-basics/option.html">Option</a> is represented as a vector of either 0 or 1 element. To read an
option, you would treat it like a vector and check its length (first byte - either 1 or 0).</p>
<pre><code class="language-move">let mut bcs = bcs::new(x&quot;00&quot;);
let is_some = bcs.peel_bool();

assert!(is_some == false, 0);

let mut bcs = bcs::new(x&quot;0101&quot;);
let is_some = bcs.peel_bool();
let value = bcs.peel_u8();

assert!(is_some == true, 1);
assert!(value == 1, 2);
</code></pre>
<blockquote>
<p>If you need to decode an option of a custom type, use the method in the code snippet above.</p>
</blockquote>
<p>The most common scenarios, <code>bcs</code> module provides a basic set of functions for decoding Option's:</p>
<ul>
<li><code>peel_option_address(): Option&lt;address&gt;</code></li>
<li><code>peel_option_bool(): Option&lt;bool&gt;</code></li>
<li><code>peel_option_u8(): Option&lt;u8&gt;</code></li>
<li><code>peel_option_u64(): Option&lt;u64&gt;</code></li>
<li><code>peel_option_u128(): Option&lt;u128&gt;</code></li>
</ul>
<h3 id="decoding-structs"><a class="header" href="#decoding-structs">Decoding Structs</a></h3>
<p>Structs are decoded field by field, and there is no standard function to automatically decode bytes
into a Move struct, and it would have been a violation of the Move's type system. Instead, you need
to decode each field manually.</p>
<pre><code class="language-move">// some bytes... 
let mut bcs = bcs::new(x&quot;0101010F0000000000F00000000000&quot;);

let (age, is_active, name) = (
    bcs.peel_u8(),
    bcs.peel_bool(),
    bcs.peel_vec_u8().to_string()
);

let user = User { age, is_active, name };
</code></pre>
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<p>Binary Canonical Serialization is an efficient binary format for structured data, ensuring consistent serialization across platforms. The Sui Framework provides comprehensive tools for working with BCS, allowing extensive functionality through built-in functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-2024-migration-guide"><a class="header" href="#move-2024-migration-guide">Move 2024 Migration Guide</a></h1>
<p>Move 2024 is the new edition of the Move language that is maintained by Mysten Labs. This guide is
intended to help you understand the differences between the 2024 edition and the previous version of
the Move language.</p>
<blockquote>
<p>This guide provides a high-level overview of the changes in the new edition. For a more detailed
and exhaustive list of changes, refer to the
<a href="https://docs.sui.io/guides/developer/advanced/move-2024-migration">Sui Documentation</a>.</p>
</blockquote>
<h2 id="using-the-new-edition"><a class="header" href="#using-the-new-edition">Using the New Edition</a></h2>
<p>To use the new edition, you need to specify the edition in the <code>move</code> file. The edition is specified
in the <code>move</code> file using the <code>edition</code> keyword. Currently, the only available edition is
<code>2024.beta</code>.</p>
<pre><code class="language-ini">edition = &quot;2024.beta&quot;;
</code></pre>
<h2 id="migration-tool"><a class="header" href="#migration-tool">Migration Tool</a></h2>
<p>The Move CLI has a migration tool that updates the code to the new edition. To use the migration
tool, run the following command:</p>
<pre><code class="language-bash">$ sui move migrate
</code></pre>
<p>The migration tool will update the code to use the <code>let mut</code> syntax, the new <code>public</code> modifier for
strucs, and the <code>public(package)</code> function visibility instead of <code>friend</code> declarations.</p>
<h2 id="mutable-bindings-with-let-mut"><a class="header" href="#mutable-bindings-with-let-mut">Mutable bindings with <code>let mut</code></a></h2>
<p>Move 2024 introduces <code>let mut</code> syntax to declare mutable variables. The <code>let mut</code> syntax is used to
declare a mutable variable that can be changed after it is declared.</p>
<blockquote>
<p><code>let mut</code> declaration is now required for mutable variables. Compiler will emit an error if you
try to reassign a variable without the <code>mut</code> keyword.</p>
</blockquote>
<pre><code class="language-move">// Move 2020
let x: u64 = 10;
x = 20;

// Move 2024
let mut x: u64 = 10;
x = 20;
</code></pre>
<p>Additionally, the <code>mut</code> keyword is used in tuple destructuring and function arguments to declare
mutable variables.</p>
<pre><code class="language-move">// takes by value and mutates
fun takes_by_value_and_mutates(mut v: Value): Value {
    v.field = 10;
    v
}

// `mut` should be placed before the variable name
fun destruct() {
    let (x, y) = point::get_point();
    let (mut x, y) = point::get_point();
    let (mut x, mut y) = point::get_point();
}

// in struct unpack
fun unpack() {
    let Point { x, mut y } = point::get_point();
    let Point { mut x, mut y } = point::get_point();
}
</code></pre>
<h2 id="friends-are-deprecated"><a class="header" href="#friends-are-deprecated">Friends are Deprecated</a></h2>
<p>In Move 2024, the <code>friend</code> keyword is deprecated. Instead, you can use the <code>public(package)</code>
visibility modifier to make functions visible to other modules in the same package.</p>
<pre><code class="language-move">// Move 2020
friend book::friend_module;
public(friend) fun protected_function() {}

// Move 2024
public(package) fun protected_function_2024() {}
</code></pre>
<h2 id="struct-visibility"><a class="header" href="#struct-visibility">Struct Visibility</a></h2>
<p>In Move 2024, structs get a visibility modifier. Currently, the only available visibility modifier
is <code>public</code>.</p>
<pre><code class="language-move">// Move 2020
struct Book {}

// Move 2024
public struct Book {}
</code></pre>
<h2 id="method-syntax-1"><a class="header" href="#method-syntax-1">Method Syntax</a></h2>
<p>In the new edition, functions which have a struct as the first argument are associated with the
struct. This means that the function can be called using the dot notation. Methods defined in the
same module with the type are automatically exported.</p>
<blockquote>
<p>Methods are automatically exported if the type is defined in the same module as the method. It is
impossible to export methods for types defined in other modules. However, you can create
<a href="guides/2024-migration-guide.html#method-aliases">custom aliases</a> for methods in the module scope.</p>
</blockquote>
<pre><code class="language-move">public fun count(c: &amp;Counter): u64 { /* ... */ }

fun use_counter() {
    // move 2020
    let count = counter::count(&amp;c);

    // move 2024
    let count = c.count();
}
</code></pre>
<h2 id="methods-for-built-in-types"><a class="header" href="#methods-for-built-in-types">Methods for Built-in Types</a></h2>
<p>In Move 2024, some of the native and standard types received associated methods. For example, the
<code>vector</code> type has a <code>to_string</code> method that converts the vector into a UTF8 string.</p>
<pre><code class="language-move">fun aliases() {
    // vector to string and ascii string
    let str: String = b&quot;Hello, World!&quot;.to_string();
    let ascii: ascii::String = b&quot;Hello, World!&quot;.to_ascii_string();

    // address to bytes
    let bytes = @0xa11ce.to_bytes();
}
</code></pre>
<p>For the full list of built-in aliases, refer to the
<a href="guides/../move-basics/standard-library.html#source-code">Standard Library</a> and
<a href="guides/../programmability/sui-framework.html#source-code">Sui Framework</a> source code.</p>
<h2 id="borrowing-operator"><a class="header" href="#borrowing-operator">Borrowing Operator</a></h2>
<p>Some of the built-in types support borrowing operators. The borrowing operator is used to get a
reference to the element at the specified index. The borrowing operator is defined as <code>[]</code>.</p>
<pre><code class="language-move">fun play_vec() {
    let v = vector[1,2,3,4];
    let first = &amp;v[0];         // calls vector::borrow(v, 0)
    let first_mut = &amp;mut v[0]; // calls vector::borrow_mut(v, 0)
    let first_copy = v[0];     // calls *vector::borrow(v, 0)
}
</code></pre>
<p>Types that support the borrowing operator are:</p>
<ul>
<li><code>vector</code></li>
<li><code>sui::vec_map::VecMap</code></li>
<li><code>sui::table::Table</code></li>
<li><code>sui::bag::Bag</code></li>
<li><code>sui::object_table::ObjectTable</code></li>
<li><code>sui::object_bag::ObjectBag</code></li>
<li><code>sui::linked_table::LinkedTable</code></li>
</ul>
<p>To implement the borrowing operator for a custom type, you need to add a <code>#[syntax(index)]</code>
attribute to the methods.</p>
<pre><code class="language-move">#[syntax(index)]
public fun borrow(c: &amp;List&lt;T&gt;, key: String): &amp;T { /* ... */ }

#[syntax(index)]
public fun borrow_mut(c: &amp;mut List&lt;T&gt;, key: String): &amp;mut T { /* ... */ }
</code></pre>
<h2 id="method-aliases-1"><a class="header" href="#method-aliases-1">Method Aliases</a></h2>
<p>In Move 2024, methods can be associated with types. The alias can be defined for any type locally to
the module; or publicly, if the type is defined in the same module.</p>
<pre><code class="language-move">// my_module.move
// Local: type is foreign to the module
use fun my_custom_function as vector.do_magic;

// sui-framework/kiosk/kiosk.move
// Exported: type is defined in the same module
public use fun kiosk_owner_cap_for as KioskOwnerCap.kiosk;
</code></pre>
<!-- ## Macros

Macros are introduced in Move 2024. And `assert!` is no longer a built-in function - Instead, it's a macro.

```move
// can be called as for!(0, 10, |i| call(i));
macro fun for($start: u64, $stop: u64, $body: |u64|) {
    let mut i = $start;
    let stop = $stop;
    while (i < stop) {
        $body(i);
        i = i + 1
    }
}
```
 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgradeability-practices"><a class="header" href="#upgradeability-practices">Upgradeability Practices</a></h1>
<p>To talk about best practices for upgradeability, we need to first understand what can be upgraded in
a package. The base premise of upgradeability is that an upgrade should not break public
compatibility with the previous version. The parts of the module which can be used in dependent
packages should not change their static signature. This applies to modules - a module can not be
removed from a package, public structs - they can be used in function signatures and public
functions - they can be called from other packages.</p>
<pre><code class="language-move">// module can not be removed from the package
module book::upgradable {
    // dependencies can be changed (if they are not used in public signatures)
    use std::string::String;
    use sui::event; // can be removed

    // public structs can not be removed and can't be changed
    public struct Book has key {
        id: UID,
        title: String,
    }

    // public structs can not be removed and can't be changed
    public struct BookCreated has copy, drop {
        /* ... */
    }

    // public functions can not be removed and their signature can never change
    // but the implementation can be changed
    public fun create_book(ctx: &amp;mut TxContext): Book {
        create_book_internal(ctx)

        // can be removed and changed
        event::emit(BookCreated {
            /* ... */
        })
    }

    // package-visibility functions can be removed and changed
    public(package) fun create_book_package(ctx: &amp;mut TxContext): Book {
        create_book_internal(ctx)
    }

    // entry functions can be removed and changed as long they're not public
    entry fun create_book_entry(ctx: &amp;mut TxContext): Book {
        create_book_internal(ctx)
    }

    // private functions can be removed and changed
    fun create_book_internal(ctx: &amp;mut TxContext): Book {
        abort 0
    }
}
</code></pre>
<!--
## Using entry and friend functions

TODO: Add a section about entry and friend functions
-->
<h2 id="versioning-objects"><a class="header" href="#versioning-objects">Versioning objects</a></h2>
<!-- This practice is for function version locking based on a shared state -->
<p>To discard previous versions of the package, the objects can be versioned. As long as the object
contains a version field, and the code which uses the object expects and asserts a specific version,
the code can be force-migrated to the new version. Normally, after an upgrade, admin functions can
be used to update the version of the shared state, so that the new version of code can be used, and
the old version aborts with a version mismatch.</p>
<pre><code class="language-move">module book::versioned_state {

    const EVersionMismatch: u64 = 0;

    const VERSION: u8 = 1;

    /// The shared state (can be owned too)
    public struct SharedState has key {
        id: UID,
        version: u8,
        /* ... */
    }

    public fun mutate(state: &amp;mut SharedState) {
        assert!(state.version == VERSION, EVersionMismatch);
        // ...
    }
}
</code></pre>
<h2 id="versioning-configuration-with-dynamic-fields"><a class="header" href="#versioning-configuration-with-dynamic-fields">Versioning configuration with dynamic fields</a></h2>
<!-- This practice is for versioning the contents / structure of objects -->
<p>There's a common pattern in Sui which allows changing the stored configuration of an object while
retaining the same object signature. This is done by keeping the base object simple and versioned
and adding an actual configuration object as a dynamic field. Using this <em>anchor</em> pattern, the
configuration can be changed with package upgrades while keeping the same base object signature.</p>
<pre><code class="language-move">module book::versioned_config {
    use sui::vec_map::VecMap;
    use std::string::String;

    /// The base object
    public struct Config has key {
        id: UID,
        version: u16
    }

    /// The actual configuration
    public struct ConfigV1 has store {
        data: Bag,
        metadata: VecMap&lt;String, String&gt;
    }

    // ...
}
</code></pre>
<h2 id="modular-architecture"><a class="header" href="#modular-architecture">Modular architecture</a></h2>
<p>This section is coming soon!</p>
<!-- TODO: add two patterns for modular architecture: object capability (SuiFrens) and witness registry (SuiNS) -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-against-limits"><a class="header" href="#building-against-limits">Building against Limits</a></h1>
<p>To guarantee the safety and security of the network, Sui has certain limits and restrictions. These
limits are in place to prevent abuse and to ensure that the network remains stable and efficient.
This guide provides an overview of these limits and restrictions, and how to build your application
to work within them.</p>
<p>The limits are defined in the protocol configuration and are enforced by the network. If any of the
limits are exceeded, the transaction will either be rejected or aborted. The limits, being a part of
the protocol, can only be changed through a network upgrade.</p>
<h2 id="transaction-size"><a class="header" href="#transaction-size">Transaction Size</a></h2>
<p>The size of a transaction is limited to 128KB. This includes the size of the transaction payload,
the size of the transaction signature, and the size of the transaction metadata. If a transaction
exceeds this limit, it will be rejected by the network.</p>
<h2 id="object-size"><a class="header" href="#object-size">Object Size</a></h2>
<p>The size of an object is limited to 256KB. This includes the size of the object data. If an object
exceeds this limit, it will be rejected by the network. While a single object cannot bypass this
limit, for more extensive storage options, one could use a combination of a base object with other
attached to it using dynamic fields (eg Bag).</p>
<h2 id="single-pure-argument-size"><a class="header" href="#single-pure-argument-size">Single Pure Argument Size</a></h2>
<p>The size of a single pure argument is limited to 16KB. A transaction argument bigger than this limit
will result in execution failure. So in order to create a vector of more than ~500 addresses (given
that a single address is 32 bytes), it needs to be joined dynamically either in Transaction Block or
in a Move function. Standard functions like <code>vector::append()</code> can join two vectors of ~16KB
resulting in a ~32KB of data as a single value.</p>
<h2 id="maximum-number-of-objects-created"><a class="header" href="#maximum-number-of-objects-created">Maximum Number of Objects created</a></h2>
<p>The maximum number of objects that can be created in a single transaction is 2048. If a transaction
attempts to create more than 2048 objects, it will be rejected by the network. This also affects
<a href="guides/./../programmability/dynamic-fields.html">dynamic fields</a>, as both the key and the value are objects.
So the maximum number of dynamic fields that can be created in a single transaction is 1024.</p>
<h2 id="maximum-number-of-dynamic-fields-created"><a class="header" href="#maximum-number-of-dynamic-fields-created">Maximum Number of Dynamic Fields created</a></h2>
<p>The maximum number of dynamic fields that can be created in a single object is 1024. If an object
attempts to create more than 1024 dynamic fields, it will be rejected by the network.</p>
<h2 id="maximum-number-of-events"><a class="header" href="#maximum-number-of-events">Maximum Number of Events</a></h2>
<p>The maximum number of events that can be emitted in a single transaction is 1024. If a transaction
attempts to emit more than 1024 events, it will be aborted.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="better-error-handling"><a class="header" href="#better-error-handling">Better error handling</a></h1>
<p>Whenever execution encounters an abort, transaction fails and abort code is returned to the caller.
Move VM returns the module name that aborted the transaction and the abort code. This behavior is
not fully transparent to the caller of the transaction, especially when a single function contains
multiple calls to the same function which may abort. In this case, the caller will not know which
call aborted the transaction, and it will be hard to debug the issue or provide meaningful error
message to the user.</p>
<pre><code class="language-move">module book::module_a {
    use book::module_b;

    public fun do_something() {
        let field_1 = module_b::get_field(1); // may abort with 0
        /* ... a lot of logic ... */
        let field_2 = module_b::get_field(2); // may abort with 0
        /* ... some more logic ... */
        let field_3 = module_b::get_field(3); // may abort with 0
    }
}
</code></pre>
<p>The example above illustrates the case when a single function contains multiple calls which may
abort. If the caller of the <code>do_something</code> function receives an abort code <code>0</code>, it will be hard to
understand which call to <code>module_b::get_field</code> aborted the transaction. To address this problem,
there are common patterns that can be used to improve error handling.</p>
<h2 id="rule-1-handle-all-possible-scenarios"><a class="header" href="#rule-1-handle-all-possible-scenarios">Rule 1: Handle all possible scenarios</a></h2>
<p>It is considered a good practice to provide a safe &quot;check&quot; function that returns a boolean value
indicating whether an operation can be performed safely. If the <code>module_b</code> provides a function
<code>has_field</code> that returns a boolean value indicating whether a field exists, the <code>do_something</code>
function can be rewritten as follows:</p>
<pre><code class="language-move">module book::module_a {
    use book::module_b;

    const ENoField: u64 = 0;

    public fun do_something() {
        assert!(module_b::has_field(1), ENoField);
        let field_1 = module_b::get_field(1);
        /* ... */
        assert!(module_b::has_field(2), ENoField);
        let field_2 = module_b::get_field(2);
        /* ... */
        assert!(module_b::has_field(3), ENoField);
        let field_3 = module_b::get_field(3);
    }
}
</code></pre>
<p>By adding custom checks before each call to <code>module_b::get_field</code>, the developer of the <code>module_a</code>
takes control over the error handling. And it allows implementing the second rule.</p>
<h2 id="rule-2-abort-with-different-codes"><a class="header" href="#rule-2-abort-with-different-codes">Rule 2: Abort with different codes</a></h2>
<p>The second trick, once the abort codes are handled by the caller module, is to use different abort
codes for different scenarios. This way, the caller module can provide a meaningful error message to
the user. The <code>module_a</code> can be rewritten as follows:</p>
<pre><code class="language-move">module book::module_a {
    use book::module_b;

    const ENoFieldA: u64 = 0;
    const ENoFieldB: u64 = 1;
    const ENoFieldC: u64 = 2;

    public fun do_something() {
        assert!(module_b::has_field(1), ENoFieldA);
        let field_1 = module_b::get_field(1);
        /* ... */
        assert!(module_b::has_field(2), ENoFieldB);
        let field_2 = module_b::get_field(2);
        /* ... */
        assert!(module_b::has_field(3), ENoFieldC);
        let field_3 = module_b::get_field(3);
    }
}
</code></pre>
<p>Now, the caller module can provide a meaningful error message to the user. If the caller receives an
abort code <code>0</code>, it can be translated to &quot;Field 1 does not exist&quot;. If the caller receives an abort
code <code>1</code>, it can be translated to &quot;Field 2 does not exist&quot;. And so on.</p>
<h2 id="rule-3-return-bool-instead-of-assert"><a class="header" href="#rule-3-return-bool-instead-of-assert">Rule 3: Return bool instead of assert</a></h2>
<p>A developer is often tempted to add a public function that would assert all the conditions and abort
the execution. However, it is a better practice to create a function that returns a boolean value
instead. This way, the caller module can handle the error and provide a meaningful error message to
the user.</p>
<pre><code class="language-move">module book::some_app_assert {

    const ENotAuthorized: u64 = 0;

    public fun do_a() {
        assert_is_authorized();
        // ...
    }

    public fun do_b() {
        assert_is_authorized();
        // ...
    }

    /// Don't do this
    public fun assert_is_authorized() {
        assert!(/* some condition */ true, ENotAuthorized);
    }
}
</code></pre>
<p>This module can be rewritten as follows:</p>
<pre><code class="language-move">module book::some_app {
    const ENotAuthorized: u64 = 0;

    public fun do_a() {
        assert!(is_authorized(), ENotAuthorized);
        // ...
    }

    public fun do_b() {
        assert!(is_authorized(), ENotAuthorized);
        // ...
    }

    public fun is_authorized(): bool {
        /* some condition */ true
    }

    // a private function can still be used to avoid code duplication for a case
    // when the same condition with the same abort code is used in multiple places
    fun assert_is_authorized() {
        assert!(is_authorized(), ENotAuthorized);
    }
}
</code></pre>
<p>Utilizing these three rules will make the error handling more transparent to the caller of the
transaction, and it will allow other developers to use custom abort codes in their modules.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coding-conventions"><a class="header" href="#coding-conventions">Coding Conventions</a></h1>
<h2 id="naming"><a class="header" href="#naming">Naming</a></h2>
<h3 id="module-1"><a class="header" href="#module-1">Module</a></h3>
<ol>
<li>Module names should be in <code>snake_case</code>.</li>
<li>Module names should be descriptive and should not be too long.</li>
</ol>
<pre><code class="language-move">module book::conventions { /* ... */ }
module book::common_pracices { /* ... */ }
</code></pre>
<h3 id="constant"><a class="header" href="#constant">Constant</a></h3>
<ol>
<li>Constants should be in <code>SCREAMING_SNAKE_CASE</code>.</li>
<li>Error constants should be in <code>EPascalCase</code></li>
</ol>
<pre><code class="language-move">const MAX_PRICE: u64 = 1000;
const EInvalidInput: u64 = 0;
</code></pre>
<h3 id="function-1"><a class="header" href="#function-1">Function</a></h3>
<ol>
<li>Function names should be in <code>snake_case</code>.</li>
<li>Function names should be descriptive.</li>
</ol>
<pre><code class="language-move">public fun add(a: u64, b: u64): u64 { a + b }
public fun create_if_not_exists() { /* ... */ }
</code></pre>
<h3 id="struct-1"><a class="header" href="#struct-1">Struct</a></h3>
<ol>
<li>Struct names should be in <code>PascalCase</code>.</li>
<li>Struct fields should be in <code>snake_case</code>.</li>
<li>Capabilities should be suffixed with <code>Cap</code>.</li>
</ol>
<pre><code class="language-move">public struct Hero has key {
    id: UID
    value: u64,
    another_value: u64,
}

public struct AdminCap has key { id: UID }
</code></pre>
<h3 id="struct-method"><a class="header" href="#struct-method">Struct Method</a></h3>
<ol>
<li>Struct methods should be in <code>snake_case</code>.</li>
<li>If there's multiple structs with the same method, the method should be prefixed with the struct
name. In this case, an alias can be added to the method using <code>use fun</code>.</li>
</ol>
<pre><code class="language-move">public fun value(h: &amp;Hero): u64 { h.value }

public use fun hero_health as Hero.health;
public fun hero_health(h: &amp;Hero): u64 { h.another_value }

public use fun boar_health as Boar.health;
public fun boar_health(b: &amp;Boar): u64 { b.another_value }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-a-glossary"><a class="header" href="#appendix-a-glossary">Appendix A: Glossary</a></h1>
<ul>
<li>Fast Path - term used to describe a transaction that does not involve shared objects, and can be
executed without the need for consensus.</li>
<li>Parallel Execution - term used to describe the ability of the Sui runtime to execute transactions
in parallel, including the ones that involve shared objects.</li>
<li>Internal Type - type that is defined within the module. Fields of this type can not be accessed
from outside the module, and, in case of &quot;key&quot;-only abilities, can not be used in <code>public_*</code>
transfer functions.</li>
</ul>
<h2 id="abilities"><a class="header" href="#abilities">Abilities</a></h2>
<ul>
<li>key - ability that allows the struct to be used as a key in the storage. On Sui, the key ability
marks an object and requires the first field to be a <code>id: UID</code>.</li>
<li>store - ability that allows the struct to be stored inside other objects. This ability relaxes
restrictions applied to internal structs, allowing <code>public_*</code> transfer functions to accept them as
arguments. It also enables the object to be stored as a dynamic field.</li>
<li>copy - ability that allows the struct to be copied. On Sui, the <code>copy</code> ability conflicts with the
<code>key</code> ability, and can not be used together with it.</li>
<li>drop - ability that allows the struct to be ignored or discarded. On Sui, the <code>drop</code> ability
cannot be used together with the <code>key</code> ability, as objects are not allowed to be ignored.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-b-reserved-addresses"><a class="header" href="#appendix-b-reserved-addresses">Appendix B: Reserved Addresses</a></h1>
<p>Reserved addresses are special addresses that have a specific purpose on Sui. They stay the same
between environments and are used for specific native operations.</p>
<ul>
<li><code>0x1</code> - address of the <a href="appendix/./../move-basics/standard-library.html">Standard Library</a> (alias <code>std</code>)</li>
<li><code>0x2</code> - address of the <a href="appendix/./../programmability/sui-framework.html">Sui Framework</a> (alias <code>sui</code>)</li>
<li><code>0x5</code> - address of the <code>SuiSystem</code> object</li>
<li><code>0x6</code> - address of the system <a href="appendix/./../programmability/epoch-and-time.html"><code>Clock</code> object</a></li>
<li><code>0x8</code> - address of the system <code>Random</code> object</li>
<li><code>0x403</code> - address of the <code>DenyList</code> system object</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-c-publications"><a class="header" href="#appendix-c-publications">Appendix C: Publications</a></h1>
<p>This section lists publications related to Move and Sui.</p>
<ul>
<li><a href="https://arxiv.org/abs/2205.05181">The Move Borrow Checker</a> by Sam Blackshear, John Mitchell, Todd
Nowacki, Shaz Qadeer.</li>
<li><a href="https://arxiv.org/abs/2004.05106">Resources: A Safe Language Abstraction for Money</a> by Sam
Blackshear, David L. Dill, Shaz Qadeer, Clark W. Barrett, John C. Mitchell, Oded Padon, Yoni
Zohar.</li>
<li><a href="https://arxiv.org/abs/2110.05043">Robust Safety for Move</a> by Marco Patrignani, Sam Blackshear</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-d-contributing"><a class="header" href="#appendix-d-contributing">Appendix D: Contributing</a></h1>
<p>To contribute to this book, please, submit a pull request to the
<a href="https://github.com/MystenLabs/move-book">GitHub repository</a>. The repository contains the source
files for the book, written in mdBook format.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-e-acknowledgements"><a class="header" href="#appendix-e-acknowledgements">Appendix E: Acknowledgements</a></h1>
<p><a href="https://doc.rust-lang.org/book">The Rust Book</a> has been a great inspiration for this book. I am
personally grateful to the authors of the book, Steve Klabnik and Carol Nichols, for their work, as
I have learned a lot from it. This book is a small tribute to their work and an attempt to bring a
similar learning experience to the Move community.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/switcher.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
