"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6176],{1481:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"storage/transfer-restrictions","title":"Restricted and Public Transfer","description":"Storage Operations that we described in the previous sections are","source":"@site/../book/storage/transfer-restrictions.md","sourceDirName":"storage","slug":"/storage/transfer-restrictions","permalink":"/storage/transfer-restrictions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"7.4. UID and ID","permalink":"/storage/uid-and-id"},"next":{"title":"Advanced Programmability","permalink":"/programmability/"}}');var r=t(3420),i=t(5521);const o={},c="Restricted and Public Transfer",a={},l=[{value:"Public Storage Operations",id:"public-storage-operations",level:2},{value:"Implications of <code>store</code>",id:"implications-of-store",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"restricted-and-public-transfer",children:"Restricted and Public Transfer"})}),"\n",(0,r.jsxs)(n.p,{children:["Storage Operations that we described in the ",(0,r.jsx)(n.a,{href:"./storage-functions",children:"previous sections"})," are\nrestricted by default - they can only be called in the module defining the object. In other terms,\nthe type must be ",(0,r.jsx)(n.em,{children:"internal"})," to the module to be used in storage operations. This restriction is\nimplemented in the Sui Verifier and is enforced at the bytecode level."]}),"\n",(0,r.jsxs)(n.p,{children:["However, to allow objects to be transferred and stored in other modules, these restrictions can be\nrelaxed. The ",(0,r.jsx)(n.code,{children:"sui::transfer"})," module offers a set of ",(0,r.jsx)(n.em,{children:"public_*"})," functions that allow calling\nstorage operations in other modules. The functions are prefixed with ",(0,r.jsx)(n.code,{children:"public_"})," and are available to\nall modules and transactions."]}),"\n",(0,r.jsx)(n.h2,{id:"public-storage-operations",children:"Public Storage Operations"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"sui::transfer"})," module provides the following public functions. They are almost identical to the\nones we already covered, but can be called from any module."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module sui::transfer;\n\n/// Public version of the `transfer` function.\npublic fun public_transfer<T: key + store>(object: T, to: address) {}\n\n/// Public version of the `share_object` function.\npublic fun public_share_object<T: key + store>(object: T) {}\n\n/// Public version of the `freeze_object` function.\npublic fun public_freeze_object<T: key + store>(object: T) {}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["To illustrate the usage of these functions, consider the following example: module A defines an\nObjectK with ",(0,r.jsx)(n.code,{children:"key"})," and ObjectKS with ",(0,r.jsx)(n.code,{children:"key + store"})," abilities, and module B tries to implement a\n",(0,r.jsx)(n.code,{children:"transfer"})," function for these objects."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["In this example we use ",(0,r.jsx)(n.code,{children:"transfer::transfer"}),", but the behavior is identical for ",(0,r.jsx)(n.code,{children:"share_object"})," and\n",(0,r.jsx)(n.code,{children:"freeze_object"})," functions."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"/// Defines `ObjectK` and `ObjectKS` with `key` and `key + store`\n/// abilities respectively\nmodule book::transfer_a;\n\npublic struct ObjectK has key { id: UID }\npublic struct ObjectKS has key, store { id: UID }\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"/// Imports the `ObjectK` and `ObjectKS` types from `transfer_a` and attempts\n/// to implement different `transfer` functions for them\nmodule book::transfer_b;\n\n// types are not internal to this module\nuse book::transfer_a::{ObjectK, ObjectKS};\n\n// Fails! ObjectK is not `store`, and ObjectK is not internal to this module\npublic fun transfer_k(k: ObjectK, to: address) {\n    sui::transfer::transfer(k, to);\n}\n\n// Fails! ObjectKS has `store` but the function is not public\npublic fun transfer_ks(ks: ObjectKS, to: address) {\n    sui::transfer::transfer(ks, to);\n}\n\n// Fails! ObjectK is not `store`, `public_transfer` requires `store`\npublic fun public_transfer_k(k: ObjectK) {\n    sui::transfer::public_transfer(k);\n}\n\n// Works! ObjectKS has `store` and the function is public\npublic fun public_transfer_ks(y: ObjectKS, to: address) {\n    sui::transfer::public_transfer(y, to);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"To expand on the example above:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.code,{children:"transfer_k"})," fails because ObjectK is not internal to module ",(0,r.jsx)(n.code,{children:"transfer_b"})]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.code,{children:"transfer_ks"})," fails because ObjectKS is not internal to module ",(0,r.jsx)(n.code,{children:"transfer_b"})]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.code,{children:"public_transfer_k"})," fails because ObjectK does not have the ",(0,r.jsx)(n.code,{children:"store"})," ability"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.code,{children:"public_transfer_ks"})," works because ObjectKS has the ",(0,r.jsx)(n.code,{children:"store"})," ability and the transfer is public"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"implications-of-store",children:["Implications of ",(0,r.jsx)(n.code,{children:"store"})]}),"\n",(0,r.jsxs)(n.p,{children:["The decision on whether to add the ",(0,r.jsx)(n.code,{children:"store"})," ability to a type should be made carefully. On one hand,\nit is de-facto a requirement for the type to be ",(0,r.jsx)(n.em,{children:"usable"})," by other applications. On the other hand,\nit allows ",(0,r.jsx)(n.em,{children:"wrapping"})," and changing the intended storage model. For example, a character may be\nintended to be owned by accounts, but with the ",(0,r.jsx)(n.code,{children:"store"})," ability it can be frozen (cannot be shared -\nthis transition is restricted)."]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},5521:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var s=t(6672);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);