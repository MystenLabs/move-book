"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6990],{5521:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>i});var t=o(6672);const r={},l=t.createContext(r);function s(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(l.Provider,{value:n},e.children)}},7531:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"control-flow/labeled-control-flow","title":"Labeled Control Flow | Reference","description":"","source":"@site/../reference/control-flow/labeled-control-flow.md","sourceDirName":"control-flow","slug":"/control-flow/labeled-control-flow","permalink":"/reference/control-flow/labeled-control-flow","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Labeled Control Flow | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"6.2 Loops","permalink":"/reference/control-flow/loops"},"next":{"title":"6.4 Pattern Matching","permalink":"/reference/control-flow/pattern-matching"}}');var r=o(3420),l=o(5521);const s={title:"Labeled Control Flow | Reference",description:""},i="Labeled Control Flow",c={},a=[{value:"Loops",id:"loops",level:2},{value:"Labeled Blocks",id:"labeled-blocks",level:2},{value:"Restrictions",id:"restrictions",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"labeled-control-flow",children:"Labeled Control Flow"})}),"\n",(0,r.jsxs)(n.p,{children:["Move supports labeled control flow when writing both loops and blocks of code, allowing you\nto ",(0,r.jsx)(n.code,{children:"break"})," and ",(0,r.jsx)(n.code,{children:"continue"})," loops and ",(0,r.jsx)(n.code,{children:"return"})," from blocks (which can be particularly helpful in the\npresence of macros)."]}),"\n",(0,r.jsx)(n.h2,{id:"loops",children:"Loops"}),"\n",(0,r.jsxs)(n.p,{children:["Loops allow you to define and transfer control to specific labels in a function. For example, we can\nnest two loops and use ",(0,r.jsx)(n.code,{children:"break"})," and ",(0,r.jsx)(n.code,{children:"continue"})," with those labels to precisely specify control flow.\nYou can prefix any ",(0,r.jsx)(n.code,{children:"loop"})," or ",(0,r.jsx)(n.code,{children:"while"})," form with a ",(0,r.jsx)(n.code,{children:"'label:"})," form to allow breaking or continuing\ndirectly there."]}),"\n",(0,r.jsxs)(n.p,{children:["To demonstrate this behavior, consider a function that takes nested vectors of numbers (i.e.,\n",(0,r.jsx)(n.code,{children:"vector<vector<u64>>"}),") to sum against some threshold, which behaves as follows:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If the sum of all the numbers are under the threshold, return that sum."}),"\n",(0,r.jsx)(n.li,{children:"If adding a number to the current sum would surpass the threshold, return the current sum."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We can write this by iterating over the vector of vectors as nested loops and labelling the outer\none. If any addition in the inner loop would push us over the threshold, we can use ",(0,r.jsx)(n.code,{children:"break"})," with the\nouter label to escape both loops at once:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"fun sum_until_threshold(input: &vector<vector<u64>>, threshold: u64): u64 {\n    let mut sum = 0;\n    let mut i = 0;\n    let input_size = input.length();\n\n    'outer: loop {\n        // breaks to outer since it is the closest enclosing loop\n        if (i >= input_size) break sum;\n\n        let vec = &input[i];\n        let size = vec.length();\n        let mut j = 0;\n\n        while (j < size) {\n            let v_entry = vec[j];\n            if (sum + v_entry < threshold) {\n                sum = sum + v_entry;\n            } else {\n                // the next element we saw would break the threshold,\n                // so we return the current sum\n                break 'outer sum\n            };\n            j = j + 1;\n        };\n        i = i + 1;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"These sorts of labels can also be used with a nested loop form, providing precise control in larger\nbodies of code. For example, if we were processing a large table where each entry required iteration\nthat might see us continuing the inner or outer loop, we could express that code using labels:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"let x = 'outer: loop {\n    ...\n    'inner: while (cond) {\n        ...\n        if (cond0) { break 'outer value };\n        ...\n        if (cond1) { continue 'inner }\n        else if (cond2) { continue 'outer }\n        ...\n    }\n        ...\n};\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["It's a better way to use Macros instead of Loops, similarly, use ",(0,r.jsx)(n.code,{children:"return"})," to control the flow.\nJust like above function ",(0,r.jsx)(n.code,{children:"sum_until_threshold"}),", can use ",(0,r.jsx)(n.code,{children:"macro"})," to rewrite it:"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"fun sum_until_threshold(input: &vector<vector<u64>>, threshold: u64): u64 {\n    'outer: {\n        (*input).fold!(0, |sum, inner_vec| {\n            inner_vec.fold!(sum, |sum, num| if (sum + num < threshold) sum + num else return 'outer sum)\n        })\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"labeled-blocks",children:"Labeled Blocks"}),"\n",(0,r.jsx)(n.p,{children:"Labeled blocks allow you to write Move programs that contain intra-function non-local control flow,\nincluding inside of macro lambdas and returning values:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:'fun named_return(n: u64): vector<u8> {\n    let x = \'a: {\n        if (n % 2 == 0) {\n            return \'a b"even"\n        };\n        b"odd"\n    };\n    x\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In this simple example, the program checks if the input ",(0,r.jsx)(n.code,{children:"n"})," is even. If it is, the program leaves\nthe block labeled ",(0,r.jsx)(n.code,{children:"'a:"})," with the value ",(0,r.jsx)(n.code,{children:'b"even"'}),". If not, the code continues, ending the block\nlabeled ",(0,r.jsx)(n.code,{children:"'a:"})," with the value ",(0,r.jsx)(n.code,{children:'b"odd"'}),". At the end, we set ",(0,r.jsx)(n.code,{children:"x"})," to the value and then return it."]}),"\n",(0,r.jsxs)(n.p,{children:["This control flow feature works across macro bodies as well. For example, suppose we wanted to write\na function to find the first even number in a vector, and that we have some macro ",(0,r.jsx)(n.code,{children:"for_ref"})," that\niterates the vector elements in a loop:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"macro fun for_ref<$T>($vs: &vector<$T>, $f: |&$T|) {\n    let vs = $vs;\n    let mut i = 0;\n    let end = vs.length();\n    while (i < end) {\n        $f(vs.borrow(i));\n        i = i + 1;\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.code,{children:"for_ref"})," and a label, we can write a lambda expression to pass ",(0,r.jsx)(n.code,{children:"for_ref"})," that will escape the\nloop, returning the first even number it finds:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"fun find_first_even(vs: vector<u64>): Option<u64> {\n    'result: {\n        for_ref!(&vs, |n| if (*n % 2 == 0) { return 'result option::some(*n)});\n        option::none()\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This function will iterate ",(0,r.jsx)(n.code,{children:"vs"})," until it finds an even number, and return that (or return\n",(0,r.jsx)(n.code,{children:"option::none()"})," if no even number exists). This makes named labels a powerful tool for interacting\nwith control flow macros such as ",(0,r.jsx)(n.code,{children:"for!"}),", allowing you to customize iteration behavior in those\ncontexts."]}),"\n",(0,r.jsx)(n.h2,{id:"restrictions",children:"Restrictions"}),"\n",(0,r.jsxs)(n.p,{children:["To clarify program behavior, you may only use ",(0,r.jsx)(n.code,{children:"break"})," and ",(0,r.jsx)(n.code,{children:"continue"})," with loop labels, while\n",(0,r.jsx)(n.code,{children:"return"})," will only work with block labels. To this end, the following programs produce errors:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"fun bad_loop() {\n    'name: loop {\n        return 'name 5\n            // ^^^^^ Invalid usage of 'return' with a loop block label\n    }\n}\n\nfun bad_block() {\n    'name: {\n        continue 'name;\n              // ^^^^^ Invalid usage of 'break' with a loop block label\n        break 'name;\n           // ^^^^^ Invalid usage of 'break' with a loop block label\n    }\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);