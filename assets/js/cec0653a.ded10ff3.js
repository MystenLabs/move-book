"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8557],{5521:(e,i,s)=>{s.d(i,{R:()=>c,x:()=>l});var n=s(6672);const t={},o=n.createContext(t);function c(e){const i=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),n.createElement(o.Provider,{value:i},e.children)}},5650:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"move-basics/copy-ability","title":"Abilities: Copy","description":"In Move, the copy ability on a type indicates that the instance or the value of the type can be","source":"@site/../book/move-basics/copy-ability.md","sourceDirName":"move-basics","slug":"/move-basics/copy-ability","permalink":"/move-basics/copy-ability","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.21. Ownership and Scope","permalink":"/move-basics/ownership-and-scope"},"next":{"title":"5.23. References","permalink":"/move-basics/references"}}');var t=s(3420),o=s(5521);const c={},l="Abilities: Copy",r={},a=[{value:"Copying and Drop",id:"copying-and-drop",level:2},{value:"Types with the <code>copy</code> Ability",id:"types-with-the-copy-ability",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const i={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"abilities-copy",children:"Abilities: Copy"})}),"\n",(0,t.jsxs)(i.p,{children:["In Move, the ",(0,t.jsx)(i.em,{children:"copy"})," ability on a type indicates that the instance or the value of the type can be\ncopied, or duplicated. While this behavior is provided by default when working with numbers or other\nprimitive types, it is not the default for custom types. Move is designed to express digital assets\nand resources, and controlling the ability to duplicate resources is a key principle of the resource\nmodel. However, the Move type system allows you to add the ",(0,t.jsx)(i.em,{children:"copy"})," ability to custom types:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/copy-ability.move anchor=copyable",children:"public struct Copyable has copy {}\n"})}),"\n",(0,t.jsxs)(i.p,{children:["In the example above, we define a custom type ",(0,t.jsx)(i.code,{children:"Copyable"})," with the ",(0,t.jsx)(i.em,{children:"copy"})," ability. This means that\ninstances of ",(0,t.jsx)(i.code,{children:"Copyable"})," can be copied, both implicitly and explicitly."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/copy-ability.move anchor=copyable_test",children:"let a = Copyable {}; // allowed because the Copyable struct has the `copy` ability\nlet b = a;   // `a` is copied to `b`\nlet c = *&b; // explicit copy via dereference operator\n\n// Copyable doesn't have the `drop` ability, so every instance (a, b, and c) must\n// be used or explicitly destructured. The `drop` ability is explained below.\nlet Copyable {} = a;\nlet Copyable {} = b;\nlet Copyable {} = c;\n"})}),"\n",(0,t.jsxs)(i.p,{children:["In the example above, ",(0,t.jsx)(i.code,{children:"a"})," is copied to ",(0,t.jsx)(i.code,{children:"b"})," implicitly, and then explicitly copied to ",(0,t.jsx)(i.code,{children:"c"})," using the\ndereference operator. If ",(0,t.jsx)(i.code,{children:"Copyable"})," did not have the ",(0,t.jsx)(i.em,{children:"copy"})," ability, the code would not compile, and\nthe Move compiler would raise an error."]}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsxs)(i.p,{children:["Note: In Move, destructuring with empty brackets is often used to consume unused variables,\nespecially for types without the drop ability. This prevents compiler errors from values going out\nof scope without explicit use. Also, Move requires the type name in destructuring (e.g.,\n",(0,t.jsx)(i.code,{children:"Copyable"})," in ",(0,t.jsx)(i.code,{children:"let Copyable {} = a;"}),") because it enforces strict typing and ownership rules."]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"copying-and-drop",children:"Copying and Drop"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"copy"})," ability is closely related to the ",(0,t.jsxs)(i.a,{href:"./drop-ability",children:[(0,t.jsx)(i.code,{children:"drop"})," ability"]}),". If a type has the\n",(0,t.jsx)(i.em,{children:"copy"})," ability, it is very likely that it should have ",(0,t.jsx)(i.code,{children:"drop"})," too. This is because the ",(0,t.jsx)(i.em,{children:"drop"})," ability\nis required to clean up resources when the instance is no longer needed. If a type only has ",(0,t.jsx)(i.em,{children:"copy"}),",\nmanaging its instances gets more complicated, as the instances must be explicitly used or consumed."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/copy-ability.move anchor=copy_drop",children:"public struct Value has copy, drop {}\n"})}),"\n",(0,t.jsxs)(i.p,{children:["All of the primitive types in Move behave as if they have the ",(0,t.jsx)(i.em,{children:"copy"})," and ",(0,t.jsx)(i.em,{children:"drop"})," abilities. This\nmeans that they can be copied and dropped, and the Move compiler will handle the memory management\nfor them."]}),"\n",(0,t.jsxs)(i.h2,{id:"types-with-the-copy-ability",children:["Types with the ",(0,t.jsx)(i.code,{children:"copy"})," Ability"]}),"\n",(0,t.jsxs)(i.p,{children:["All native types in Move have the ",(0,t.jsx)(i.code,{children:"copy"})," ability. This includes:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"./../move-basics/primitive-types#booleans",children:"bool"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"./../move-basics/primitive-types#integer-types",children:"unsigned integers"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"./../move-basics/vector",children:"vector"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"./../move-basics/address",children:"address"})}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["All of the types defined in the standard library have the ",(0,t.jsx)(i.code,{children:"copy"})," ability as well. This includes:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"./../move-basics/option",children:"Option"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"./../move-basics/string",children:"String"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"./../move-basics/type-reflection",children:"TypeName"})}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"./../../reference/abilities",children:"Type Abilities"})," in the Move Reference."]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);