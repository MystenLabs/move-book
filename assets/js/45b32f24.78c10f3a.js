"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4537],{5521:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>i});var t=s(6672);const o={},c=t.createContext(o);function r(e){const n=t.useContext(c);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(c.Provider,{value:n},e.children)}},8754:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"constants","title":"Constants | Reference","description":"","source":"@site/../reference/constants.md","sourceDirName":".","slug":"/constants","permalink":"/reference/constants","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Constants | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"9. Enums","permalink":"/reference/enums"},"next":{"title":"11. Generics","permalink":"/reference/generics"}}');var o=s(3420),c=s(5521);const r={title:"Constants | Reference",description:""},i="Constants",a={},l=[{value:"Declaration",id:"declaration",level:2},{value:"Naming",id:"naming",level:2},{value:"Visibility",id:"visibility",level:2},{value:"Valid Expressions",id:"valid-expressions",level:2},{value:"Values",id:"values",level:3},{value:"Complex Expressions",id:"complex-expressions",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"constants",children:"Constants"})}),"\n",(0,o.jsxs)(n.p,{children:["Constants are a way of giving a name to shared, static values inside of a ",(0,o.jsx)(n.code,{children:"module"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"The constant's value must be known at compilation. The constant's value is stored in the compiled\nmodule. And each time the constant is used, a new copy of that value is made."}),"\n",(0,o.jsx)(n.h2,{id:"declaration",children:"Declaration"}),"\n",(0,o.jsxs)(n.p,{children:["Constant declarations begin with the ",(0,o.jsx)(n.code,{children:"const"})," keyword, followed by a name, a type, and a value."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",children:"const <name>: <type> = <expression>;\n"})}),"\n",(0,o.jsx)(n.p,{children:"For example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module a::example;\n\nconst MY_ADDRESS: address = @a;\n\npublic fun permissioned(addr: address) {\n    assert!(addr == MY_ADDRESS, 0);\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"naming",children:"Naming"}),"\n",(0,o.jsxs)(n.p,{children:["Constants must start with a capital letter ",(0,o.jsx)(n.code,{children:"A"})," to ",(0,o.jsx)(n.code,{children:"Z"}),". After the first letter, constant names can\ncontain underscores ",(0,o.jsx)(n.code,{children:"_"}),", letters ",(0,o.jsx)(n.code,{children:"a"})," to ",(0,o.jsx)(n.code,{children:"z"}),", letters ",(0,o.jsx)(n.code,{children:"A"})," to ",(0,o.jsx)(n.code,{children:"Z"}),", or digits ",(0,o.jsx)(n.code,{children:"0"})," to ",(0,o.jsx)(n.code,{children:"9"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"const FLAG: bool = false;\nconst EMyErrorCode: u64 = 0;\nconst ADDRESS_42: address = @0x42;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Even though you can use letters ",(0,o.jsx)(n.code,{children:"a"})," to ",(0,o.jsx)(n.code,{children:"z"})," in a constant. The\n",(0,o.jsx)(n.a,{href:"./coding-conventions",children:"general style guidelines"})," are to use just uppercase letters ",(0,o.jsx)(n.code,{children:"A"})," to ",(0,o.jsx)(n.code,{children:"Z"}),", with\nunderscores ",(0,o.jsx)(n.code,{children:"_"})," between each word. For error codes, we use ",(0,o.jsx)(n.code,{children:"E"})," as a prefix and then upper camel case\n(also known as Pascal case) for the rest of the name, as seen in ",(0,o.jsx)(n.code,{children:"EMyErrorCode"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The current naming restriction of starting with ",(0,o.jsx)(n.code,{children:"A"})," to ",(0,o.jsx)(n.code,{children:"Z"})," is in place to give room for future\nlanguage features."]}),"\n",(0,o.jsx)(n.h2,{id:"visibility",children:"Visibility"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"public"})," or ",(0,o.jsx)(n.code,{children:"public(package)"})," constants are not currently supported. ",(0,o.jsx)(n.code,{children:"const"})," values can be used only\nin the declaring module. However, as a convenience, they can be used across modules in\n",(0,o.jsx)(n.a,{href:"./unit-testing",children:"unit tests attributes"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"valid-expressions",children:"Valid Expressions"}),"\n",(0,o.jsxs)(n.p,{children:["Currently, constants are limited to the primitive types ",(0,o.jsx)(n.code,{children:"bool"}),", ",(0,o.jsx)(n.code,{children:"u8"}),", ",(0,o.jsx)(n.code,{children:"u16"}),", ",(0,o.jsx)(n.code,{children:"u32"}),", ",(0,o.jsx)(n.code,{children:"u64"}),", ",(0,o.jsx)(n.code,{children:"u128"}),",\n",(0,o.jsx)(n.code,{children:"u256"}),", ",(0,o.jsx)(n.code,{children:"address"}),", and ",(0,o.jsx)(n.code,{children:"vector<T>"}),", where ",(0,o.jsx)(n.code,{children:"T"})," is the valid type for a constant."]}),"\n",(0,o.jsx)(n.h3,{id:"values",children:"Values"}),"\n",(0,o.jsxs)(n.p,{children:["Commonly, ",(0,o.jsx)(n.code,{children:"const"}),"s are assigned a simple value, or literal, of their type. For example"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:'const MY_BOOL: bool = false;\nconst MY_ADDRESS: address = @0x70DD;\nconst BYTES: vector<u8> = b"hello world";\nconst HEX_BYTES: vector<u8> = x"DEADBEEF";\n'})}),"\n",(0,o.jsx)(n.h3,{id:"complex-expressions",children:"Complex Expressions"}),"\n",(0,o.jsx)(n.p,{children:"In addition to literals, constants can include more complex expressions, as long as the compiler is\nable to reduce the expression to a value at compile time."}),"\n",(0,o.jsx)(n.p,{children:"Currently, equality operations, all boolean operations, all bitwise operations, and all arithmetic\noperations can be used."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"const RULE: bool = true && false;\nconst CAP: u64 = 10 * 100 + 1;\nconst SHIFTY: u8 = {\n    (1 << 1) * (1 << 2) * (1 << 3) * (1 << 4)\n};\nconst HALF_MAX: u128 = 340282366920938463463374607431768211455 / 2;\nconst REM: u256 =\n    57896044618658097711785492504343953926634992332820282019728792003956564819968 % 654321;\nconst EQUAL: bool = 1 == 1;\n"})}),"\n",(0,o.jsx)(n.p,{children:"If the operation would result in a runtime exception, the compiler will give an error that it is\nunable to generate the constant's value"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"const DIV_BY_ZERO: u64 = 1 / 0; // ERROR!\nconst SHIFT_BY_A_LOT: u64 = 1 << 100; // ERROR!\nconst NEGATIVE_U64: u64 = 0 - 1; // ERROR!\n"})}),"\n",(0,o.jsx)(n.p,{children:"Additionally, constants can refer to other constants within the same module."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"const BASE: u8 = 4;\nconst SQUARE: u8 = BASE * BASE;\n"})}),"\n",(0,o.jsx)(n.p,{children:"Note though, that any cycle in the constant definitions results in an error."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"const A: u16 = B + 1;\nconst B: u16 = A + 1; // ERROR!\n"})})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);