"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4370],{4811:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var r=t(9378);const a={},s=r.createContext(a);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:n},e.children)}},9979:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"control-flow/pattern-matching","title":"Pattern Matching | Reference","description":"","source":"@site/../reference/control-flow/pattern-matching.md","sourceDirName":"control-flow","slug":"/control-flow/pattern-matching","permalink":"/reference/control-flow/pattern-matching","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Pattern Matching | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"6.3 Labeled Control Flow","permalink":"/reference/control-flow/labeled-control-flow"},"next":{"title":"Functions | Reference","permalink":"/reference/functions"}}');var a=t(2714),s=t(4811);const i={title:"Pattern Matching | Reference",description:""},c="Pattern Matching",o={},h=[{value:"<code>match</code> Syntax",id:"match-syntax",level:2},{value:"Pattern Syntax",id:"pattern-syntax",level:2},{value:"Patterns and Variables",id:"patterns-and-variables",level:3},{value:"Combining Patterns",id:"combining-patterns",level:3},{value:"Restrictions on Some Patterns",id:"restrictions-on-some-patterns",level:3},{value:"Pattern Typing",id:"pattern-typing",level:3},{value:"Matching",id:"matching",level:2},{value:"Matching Constructors",id:"matching-constructors",level:3},{value:"Ability Constraints",id:"ability-constraints",level:3},{value:"Exhaustiveness",id:"exhaustiveness",level:2},{value:"Guards",id:"guards",level:2},{value:"Limitations on Specific Patterns",id:"limitations-on-specific-patterns",level:2},{value:"Mutability Usage",id:"mutability-usage",level:3},{value:"<code>..</code> Usage",id:"-usage",level:3}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"pattern-matching",children:"Pattern Matching"})}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"match"})," expression is a powerful control structure that allows you to compare a value against a\nseries of patterns and then execute code based on which pattern matches first. Patterns can be\nanything from simple literals to complex, nested struct and enum definitions. As opposed to ",(0,a.jsx)(n.code,{children:"if"}),"\nexpressions, which change control flow based on a ",(0,a.jsx)(n.code,{children:"bool"}),"-typed test expression, a ",(0,a.jsx)(n.code,{children:"match"})," expression\noperates over a value of any type and selects one of many arms."]}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"match"})," expression can match Move values as well as mutable or immutable references, binding\nsub-patterns accordingly."]}),"\n",(0,a.jsx)(n.p,{children:"For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"fun run(x: u64): u64 {\n    match (x) {\n        1 => 2,\n        2 => 3,\n        x => x,\n    }\n}\n\nrun(1); // returns 2\nrun(2); // returns 3\nrun(3); // returns 3\nrun(0); // returns 0\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"match-syntax",children:[(0,a.jsx)(n.code,{children:"match"})," Syntax"]}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"match"})," takes an expression and a non-empty series of ",(0,a.jsx)(n.em,{children:"match arms"})," delimited by commas."]}),"\n",(0,a.jsxs)(n.p,{children:["Each match arm consists of a pattern (",(0,a.jsx)(n.code,{children:"p"}),"), an optional guard (",(0,a.jsx)(n.code,{children:"if (g)"})," where ",(0,a.jsx)(n.code,{children:"g"})," is an expression\nof type ",(0,a.jsx)(n.code,{children:"bool"}),"), an arrow (",(0,a.jsx)(n.code,{children:"=>"}),"), and an arm expression (",(0,a.jsx)(n.code,{children:"e"}),") to execute when the pattern matches.\nFor example,"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"match (expression) {\n    pattern1 if (guard_expression) => expression1,\n    pattern2 => expression2,\n    pattern3 => { expression3, expression4, ... },\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Match arms are checked in order from top to bottom, and the first pattern that matches (with a guard\nexpression, if present, that evaluates to ",(0,a.jsx)(n.code,{children:"true"}),") will be executed."]}),"\n",(0,a.jsxs)(n.p,{children:["Note that the series of match arms within a ",(0,a.jsx)(n.code,{children:"match"})," must be exhaustive, meaning that every possible\nvalue of the type being matched must be covered by one of the patterns in the ",(0,a.jsx)(n.code,{children:"match"}),". If the series\nof match arms is not exhaustive, the compiler will raise an error."]}),"\n",(0,a.jsx)(n.h2,{id:"pattern-syntax",children:"Pattern Syntax"}),"\n",(0,a.jsxs)(n.p,{children:["A pattern is matched by a value if the value is equal to the pattern, and where variables and\nwildcards (e.g., ",(0,a.jsx)(n.code,{children:"x"}),", ",(0,a.jsx)(n.code,{children:"y"}),", ",(0,a.jsx)(n.code,{children:"_"}),", or ",(0,a.jsx)(n.code,{children:".."}),') are "equal" to anything.']}),"\n",(0,a.jsx)(n.p,{children:"Patterns are used to match values. Patterns can be"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Pattern"}),(0,a.jsx)(n.th,{children:"Description"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Literal"}),(0,a.jsxs)(n.td,{children:["A literal value, such as ",(0,a.jsx)(n.code,{children:"1"}),", ",(0,a.jsx)(n.code,{children:"true"}),", ",(0,a.jsx)(n.code,{children:"@0x1"})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Constant"}),(0,a.jsxs)(n.td,{children:["A constant value, e.g., ",(0,a.jsx)(n.code,{children:"MyConstant"})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Variable"}),(0,a.jsxs)(n.td,{children:["A variable, e.g., ",(0,a.jsx)(n.code,{children:"x"}),", ",(0,a.jsx)(n.code,{children:"y"}),", ",(0,a.jsx)(n.code,{children:"z"})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Wildcard"}),(0,a.jsxs)(n.td,{children:["A wildcard, e.g., ",(0,a.jsx)(n.code,{children:"_"})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Constructor"}),(0,a.jsxs)(n.td,{children:["A constructor pattern, e.g., ",(0,a.jsx)(n.code,{children:"MyStruct { x, y }"}),", ",(0,a.jsx)(n.code,{children:"MyEnum::Variant(x)"})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"At-pattern"}),(0,a.jsxs)(n.td,{children:["An at-pattern, e.g., ",(0,a.jsx)(n.code,{children:"x @ MyEnum::Variant(..)"})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Or-pattern"}),(0,a.jsxs)(n.td,{children:["An or-pattern, e.g., ",(0,a.jsx)(n.code,{children:"MyEnum::Variant(..) | MyEnum::OtherVariant(..)"})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Multi-arity wildcard"}),(0,a.jsxs)(n.td,{children:["A multi-arity wildcard, e.g., ",(0,a.jsx)(n.code,{children:"MyEnum::Variant(..)"})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Mutable-binding"}),(0,a.jsxs)(n.td,{children:["A mutable-binding pattern, e.g., ",(0,a.jsx)(n.code,{children:"mut x"})]})]})]})]}),"\n",(0,a.jsx)(n.p,{children:"Patterns in Move have the following grammar:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bnf",children:'pattern = <literal>\n        | <constant>\n        | <variable>\n        | _\n        | C { <variable> : inner-pattern ["," <variable> : inner-pattern]* } // where C is a struct or enum variant\n        | C ( inner-pattern ["," inner-pattern]* ... )                       // where C is a struct or enum variant\n        | C                                                                  // where C is an enum variant\n        | <variable> @ top-level-pattern\n        | pattern | pattern\n        | mut <variable>\ninner-pattern = pattern\n              | ..     // multi-arity wildcard\n'})}),"\n",(0,a.jsx)(n.p,{children:"Some examples of patterns are:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"// literal pattern\n1\n\n// constant pattern\nMyConstant\n\n// variable pattern\nx\n\n// wildcard pattern\n_\n\n// constructor pattern that matches `MyEnum::Variant` with the fields `1` and `true`\nMyEnum::Variant(1, true)\n\n// constructor pattern that matches `MyEnum::Variant` with the fields `1` and binds the second field's value to `x`\nMyEnum::Variant(1, x)\n\n// multi-arity wildcard pattern that matches multiple fields within the `MyEnum::Variant` variant\nMyEnum::Variant(..)\n\n// constructor pattern that matches the `x` field of `MyStruct` and binds the `y` field to `other_variable`\nMyStruct { x, y: other_variable }\n\n// at-pattern that matches `MyEnum::Variant` and binds the entire value to `x`\nx @ MyEnum::Variant(..)\n\n// or-pattern that matches either `MyEnum::Variant` or `MyEnum::OtherVariant`\nMyEnum::Variant(..) | MyEnum::OtherVariant(..)\n\n// same as the above or-pattern, but with explicit wildcards\nMyEnum::Variant(_, _) | MyEnum::OtherVariant(_, _)\n\n// or-pattern that matches either `MyEnum::Variant` or `MyEnum::OtherVariant` and binds the u64 field to `x`\nMyEnum::Variant(x, _) | MyEnum::OtherVariant(_, x)\n\n// constructor pattern that matches `OtherEnum::V` and if the inner `MyEnum` is `MyEnum::Variant`\nOtherEnum::V(MyEnum::Variant(..))\n"})}),"\n",(0,a.jsx)(n.h3,{id:"patterns-and-variables",children:"Patterns and Variables"}),"\n",(0,a.jsx)(n.p,{children:"Patterns that contain variables bind them to the match subject or subject subcomponent being\nmatched. These variables can then be used either in any match guard expressions, or on the\nright-hand side of the match arm. For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"public struct Wrapper(u64)\n\nfun add_under_wrapper_unless_equal(wrapper: Wrapper, x: u64): Wrapper {\n    match (wrapper) {\n        Wrapper(y) if (y == x) => Wrapper(y),\n        Wrapper(y) => Wrapper(y + x),\n    }\n}\nadd_under_wrapper_unless_equal(Wrapper(1), 2); // returns Wrapper(3)\nadd_under_wrapper_unless_equal(Wrapper(2), 3); // returns Wrapper(5)\nadd_under_wrapper_unless_equal(Wrapper(3), 3); // returns Wrapper(3)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"combining-patterns",children:"Combining Patterns"}),"\n",(0,a.jsxs)(n.p,{children:["Patterns can be nested, but patterns can also be combined using the or operator (",(0,a.jsx)(n.code,{children:"|"}),"). For example,\n",(0,a.jsx)(n.code,{children:"p1 | p2"})," succeeds if either pattern ",(0,a.jsx)(n.code,{children:"p1"})," or ",(0,a.jsx)(n.code,{children:"p2"})," matches the subject. This pattern can occur\nanywhere -- either as a top-level pattern or a sub-pattern within another pattern."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"public enum MyEnum has drop {\n    Variant(u64, bool),\n    OtherVariant(bool, u64),\n}\n\nfun test_or_pattern(x: u64): u64 {\n    match (x) {\n        MyEnum::Variant(1 | 2 | 3, true) | MyEnum::OtherVariant(true, 1 | 2 | 3) => 1,\n        MyEnum::Variant(8, true) | MyEnum::OtherVariant(_, 6 | 7) => 2,\n        _ => 3,\n    }\n}\n\ntest_or_pattern(MyEnum::Variant(3, true)); // returns 1\ntest_or_pattern(MyEnum::OtherVariant(true, 2)); // returns 1\ntest_or_pattern(MyEnum::Variant(8, true)); // returns 2\ntest_or_pattern(MyEnum::OtherVariant(false, 7)); // returns 2\ntest_or_pattern(MyEnum::OtherVariant(false, 80)); // returns 3\n"})}),"\n",(0,a.jsx)(n.h3,{id:"restrictions-on-some-patterns",children:"Restrictions on Some Patterns"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"mut"})," and ",(0,a.jsx)(n.code,{children:".."})," patterns also have specific conditions placed on when, where, and how they can be\nused, as detailed in ",(0,a.jsx)(n.a,{href:"#limitations-on-specific-patterns",children:"Limitations on Specific Patterns"}),". At a\nhigh level, the ",(0,a.jsx)(n.code,{children:"mut"})," modifier can only be used on variable patterns, and the ",(0,a.jsx)(n.code,{children:".."})," pattern can only\nbe used once within a constructor pattern -- and not as a top-level pattern."]}),"\n",(0,a.jsxs)(n.p,{children:["The following is an ",(0,a.jsx)(n.em,{children:"invalid"})," usage of the ",(0,a.jsx)(n.code,{children:".."})," pattern because it is used as a top-level pattern:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"match (x) {\n    .. => 1,\n    // ERROR: `..` pattern can only be used within a constructor pattern\n}\n\nmatch (x) {\n    MyStruct(.., ..) => 1,\n    // ERROR:    ^^  `..` pattern can only be used once within a constructor pattern\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"pattern-typing",children:"Pattern Typing"}),"\n",(0,a.jsxs)(n.p,{children:["Patterns are not expressions, but they are nevertheless typed. This means that the type of a pattern\nmust match the type of the value it matches. For example, the pattern ",(0,a.jsx)(n.code,{children:"1"})," has an integer type, the\npattern ",(0,a.jsx)(n.code,{children:"MyEnum::Variant(1, true)"})," has type ",(0,a.jsx)(n.code,{children:"MyEnum"}),", the pattern ",(0,a.jsx)(n.code,{children:"MyStruct { x, y }"})," has type\n",(0,a.jsx)(n.code,{children:"MyStruct"}),", and ",(0,a.jsx)(n.code,{children:"OtherStruct<bool> { x: true, y: 1}"})," has type ",(0,a.jsx)(n.code,{children:"OtherStruct<bool>"}),". If you try to\nmatch on an expression that differs from the type of the pattern in the match, this will result in a\ntype error. For example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"match (1) {\n    // The `true` literal pattern is of type `bool` so this is a type error.\n    true => 1,\n    // TYPE ERROR: expected type u64, found bool\n    _ => 2,\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Similarly, the following would also result in a type error because ",(0,a.jsx)(n.code,{children:"MyEnum"})," and ",(0,a.jsx)(n.code,{children:"MyStruct"})," are\ndifferent types:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"match (MyStruct { x: 0, y: 0 }) {\n    MyEnum::Variant(..) => 1,\n    // TYPE ERROR: expected type MyEnum, found MyStruct\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"matching",children:"Matching"}),"\n",(0,a.jsx)(n.p,{children:'Prior to delving into the specifics of pattern matching and what it means for a value to "match" a\npattern, let\'s examine a few examples to provide an intuition for the concept.'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"fun test_lit(x: u64): u8 {\n    match (x) {\n        1 => 2,\n        2 => 3,\n        _ => 4,\n    }\n}\ntest_lit(1); // returns 2\ntest_lit(2); // returns 3\ntest_lit(3); // returns 4\ntest_lit(10); // returns 4\n\nfun test_var(x: u64): u64 {\n    match (x) {\n        y => y,\n    }\n}\ntest_var(1); // returns 1\ntest_var(2); // returns 2\ntest_var(3); // returns 3\n...\n\nconst MyConstant: u64 = 10;\nfun test_constant(x: u64): u64 {\n    match (x) {\n        MyConstant => 1,\n        _ => 2,\n    }\n}\ntest_constant(MyConstant); // returns 1\ntest_constant(10); // returns 1\ntest_constant(20); // returns 2\n\nfun test_or_pattern(x: u64): u64 {\n    match (x) {\n        1 | 2 | 3 => 1,\n        4 | 5 | 6 => 2,\n        _ => 3,\n    }\n}\ntest_or_pattern(3); // returns 1\ntest_or_pattern(5); // returns 2\ntest_or_pattern(70); // returns 3\n\nfun test_or_at_pattern(x: u64): u64 {\n    match (x) {\n        x @ (1 | 2 | 3) => x + 1,\n        y @ (4 | 5 | 6) => y + 2,\n        z => z + 3,\n    }\n}\ntest_or_pattern(2); // returns 3\ntest_or_pattern(5); // returns 7\ntest_or_pattern(70); // returns 73\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The most important thing to note from these examples is that a pattern matches a value if the value\nis equal to the pattern, and wildcard/variable patterns match anything. This is true for literals,\nvariables, and constants. For example, in the ",(0,a.jsx)(n.code,{children:"test_lit"})," function, the value ",(0,a.jsx)(n.code,{children:"1"})," matches the pattern\n",(0,a.jsx)(n.code,{children:"1"}),", the value ",(0,a.jsx)(n.code,{children:"2"})," matches the pattern ",(0,a.jsx)(n.code,{children:"2"}),", and the value ",(0,a.jsx)(n.code,{children:"3"})," matches the wildcard ",(0,a.jsx)(n.code,{children:"_"}),". Similarly,\nin the ",(0,a.jsx)(n.code,{children:"test_var"})," function, both the value ",(0,a.jsx)(n.code,{children:"1"})," and the value ",(0,a.jsx)(n.code,{children:"2"})," matches the pattern ",(0,a.jsx)(n.code,{children:"y"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["A variable ",(0,a.jsx)(n.code,{children:"x"}),' matches (or "equals") any value, and a wildcard ',(0,a.jsx)(n.code,{children:"_"})," matches any value (but only one\nvalue). Or-patterns are like a logical OR, where a value matches the pattern if it matches any of\npatterns in the or-pattern so ",(0,a.jsx)(n.code,{children:"p1 | p2 | p3"}),' should be read "matches p1, or p2, or p3".']}),"\n",(0,a.jsx)(n.h3,{id:"matching-constructors",children:"Matching Constructors"}),"\n",(0,a.jsx)(n.p,{children:"Pattern matching includes the concept of constructor patterns. These patterns allow you to inspect\nand access deep within both structs and enums, and are one of the most powerful parts of pattern\nmatching. Constructor patterns, coupled with variable bindings, allow you to match on values by\ntheir structure, and pull out the parts of the value you care about for usage on the right-hand side\nof the match arm."}),"\n",(0,a.jsx)(n.p,{children:"Take the following:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"fun f(x: MyEnum): u64 {\n    match (x) {\n        MyEnum::Variant(1, true) => 1,\n        MyEnum::OtherVariant(_, 3) => 2,\n        MyEnum::Variant(..) => 3,\n        MyEnum::OtherVariant(..) => 4,\n    }\n}\nf(MyEnum::Variant(1, true)); // returns 1\nf(MyEnum::Variant(2, true)); // returns 3\nf(MyEnum::OtherVariant(false, 3)); // returns 2\nf(MyEnum::OtherVariant(true, 3)); // returns 2\nf(MyEnum::OtherVariant(true, 2)); // returns 4\n"})}),"\n",(0,a.jsxs)(n.p,{children:['This is saying that "if ',(0,a.jsx)(n.code,{children:"x"})," is ",(0,a.jsx)(n.code,{children:"MyEnum::Variant"})," with the fields ",(0,a.jsx)(n.code,{children:"1"})," and ",(0,a.jsx)(n.code,{children:"true"}),", then return ",(0,a.jsx)(n.code,{children:"1"}),". If\nit is ",(0,a.jsx)(n.code,{children:"MyEnum::OtherVariant"})," with any value for the first field, and ",(0,a.jsx)(n.code,{children:"3"})," for the second, then return\n",(0,a.jsx)(n.code,{children:"2"}),". If it is ",(0,a.jsx)(n.code,{children:"MyEnum::Variant"})," with any fields, then return ",(0,a.jsx)(n.code,{children:"3"}),". Finally, if it is\n",(0,a.jsx)(n.code,{children:"MyEnum::OtherVariant"})," with any fields, then return ",(0,a.jsx)(n.code,{children:"4"}),'".']}),"\n",(0,a.jsxs)(n.p,{children:["You can also nest patterns. So, if you wanted to match either 1, 2, or 10, instead of just matching\n1 in the previous ",(0,a.jsx)(n.code,{children:"MyEnum::Variant"}),", you could do so with an or-pattern:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"fun f(x: MyEnum): u64 {\n    match (x) {\n        MyEnum::Variant(1 | 2 | 10, true) => 1,\n        MyEnum::OtherVariant(_, 3) => 2,\n        MyEnum::Variant(..) => 3,\n        MyEnum::OtherVariant(..) => 4,\n    }\n}\nf(MyEnum::Variant(1, true)); // returns 1\nf(MyEnum::Variant(2, true)); // returns 1\nf(MyEnum::Variant(10, true)); // returns 1\nf(MyEnum::Variant(10, false)); // returns 3\n"})}),"\n",(0,a.jsx)(n.h3,{id:"ability-constraints",children:"Ability Constraints"}),"\n",(0,a.jsxs)(n.p,{children:["Additionally, match bindings are subject to the same ability restrictions as other aspects of Move.\nIn particular, the compiler will signal an error if you try to match a value (not-reference) without\n",(0,a.jsx)(n.code,{children:"drop"})," using a wildcard, as the wildcard expects to drop the value. Similarly, if you bind a\nnon-",(0,a.jsx)(n.code,{children:"drop"})," value using a binder, it must be used in the right-hand side of the match arm. In\naddition, if you fully destruct that value, you have unpacked it, matching the semantics of\n",(0,a.jsxs)(n.a,{href:"./../structs#destroying-structs-via-pattern-matching",children:["non-",(0,a.jsx)(n.code,{children:"drop"})," struct unpacking"]}),". See the\n",(0,a.jsxs)(n.a,{href:"./../abilities#drop",children:["abilities section on ",(0,a.jsx)(n.code,{children:"drop"})]})," for more details about the ",(0,a.jsx)(n.code,{children:"drop"})," capability."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"public struct NonDrop(u64)\n\nfun drop_nondrop(x: NonDrop): u64 {\n    match (x) {\n        NonDrop(1) => 1,\n        _ => 2\n        // ERROR: cannot wildcard match on a non-droppable value\n    }\n}\n\nfun destructure_nondrop(x: NonDrop): u64 {\n    match (x) {\n        NonDrop(1) => 1,\n        NonDrop(_) => 2\n        // OK!\n    }\n}\n\nfun use_nondrop(x: NonDrop): NonDrop {\n    match (x) {\n        NonDrop(1) => NonDrop(8),\n        x => x\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"exhaustiveness",children:"Exhaustiveness"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"match"})," expression in Move must be ",(0,a.jsx)(n.em,{children:"exhaustive"}),": every possible value of the type being matched\nmust be covered by one of the patterns in one of the match's arms. If the series of match arms is\nnot exhaustive, the compiler will raise an error. Note that any arm with a guard expression does not\ncontribute to match exhaustion, as it might fail to match at runtime."]}),"\n",(0,a.jsxs)(n.p,{children:["As an example, a match on a ",(0,a.jsx)(n.code,{children:"u8"})," is exhaustive only if it matches on ",(0,a.jsx)(n.em,{children:"every"})," number from 0 to 255\ninclusive, unless there is a wildcard or variable pattern present. Similarly, a match on a ",(0,a.jsx)(n.code,{children:"bool"}),"\nwould need to match on both ",(0,a.jsx)(n.code,{children:"true"})," and ",(0,a.jsx)(n.code,{children:"false"}),", unless there is a wildcard or variable pattern\npresent."]}),"\n",(0,a.jsx)(n.p,{children:"For structs, because there is only one type of constructor for the type, only one constructor needs\nto be matched, but the fields within the struct need to be matched exhaustively as well. Conversely,\nenums may define multiple variants, and each variant must be matched (including any sub-fields) for\nthe match to be considered exhaustive."}),"\n",(0,a.jsxs)(n.p,{children:["Because underscores and variables are wildcards that match anything, they count as matching all\nvalues of the type they are matching on in that position. Additionally, the multi-arity wildcard\npattern ",(0,a.jsx)(n.code,{children:".."})," can be used to match on multiple values within a struct or enum variant."]}),"\n",(0,a.jsxs)(n.p,{children:["To see some examples of ",(0,a.jsx)(n.em,{children:"non-exhaustive"})," matches, consider the following:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"public enum MyEnum {\n    Variant(u64, bool),\n    OtherVariant(bool, u64),\n}\n\npublic struct Pair<T>(T, T)\n\nfun f(x: MyEnum): u8 {\n    match (x) {\n        MyEnum::Variant(1, true) => 1,\n        MyEnum::Variant(_, _) => 1,\n        MyEnum::OtherVariant(_, 3) => 2,\n        // ERROR: not exhaustive as the value `MyEnum::OtherVariant(_, 4)` is not matched.\n    }\n}\n\nfun match_pair_bool(x: Pair<bool>): u8 {\n    match (x) {\n        Pair(true, true) => 1,\n        Pair(true, false) => 1,\n        Pair(false, false) => 1,\n        // ERROR: not exhaustive as the value `Pair(false, true)` is not matched.\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"These examples can then be made exhaustive by adding a wildcard pattern to the end of the match arm,\nor by fully matching on the remaining values:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"fun f(x: MyEnum): u8 {\n    match (x) {\n        MyEnum::Variant(1, true) => 1,\n        MyEnum::Variant(_, _) => 1,\n        MyEnum::OtherVariant(_, 3) => 2,\n        // Now exhaustive since this will match all values of MyEnum::OtherVariant\n        MyEnum::OtherVariant(..) => 2,\n\n    }\n}\n\nfun match_pair_bool(x: Pair<bool>): u8 {\n    match (x) {\n        Pair(true, true) => 1,\n        Pair(true, false) => 1,\n        Pair(false, false) => 1,\n        // Now exhaustive since this will match all values of Pair<bool>\n        Pair(false, true) => 1,\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"guards",children:"Guards"}),"\n",(0,a.jsxs)(n.p,{children:["As previously mentioned, you can add a guard to a match arm by adding an ",(0,a.jsx)(n.code,{children:"if"})," clause after the\npattern. This guard will run ",(0,a.jsx)(n.em,{children:"after"})," the pattern has been matched but ",(0,a.jsx)(n.em,{children:"before"})," the expression on the\nright hand side of the arrow is evaluated. If the guard expression evaluates to ",(0,a.jsx)(n.code,{children:"true"})," then the\nexpression on the right hand side of the arrow will be evaluated, if it evaluates to ",(0,a.jsx)(n.code,{children:"false"})," then it\nwill be considered a failed match and the next match arm in the ",(0,a.jsx)(n.code,{children:"match"})," expression will be checked."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"fun match_with_guard(x: u64): u64 {\n    match (x) {\n        1 if (false) => 1,\n        1 => 2,\n        _ => 3,\n    }\n}\n\nmatch_with_guard(1); // returns 2\nmatch_with_guard(0); // returns 3\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Guard expressions can reference variables bound in the pattern during evaluation. However, note that\n",(0,a.jsx)(n.em,{children:"variables are only available as immutable reference in guards"})," regardless of the pattern being\nmatched -- even if there are mutability specifiers on the variable or if the pattern is being\nmatched by value."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"fun incr(x: &mut u64) {\n    *x = *x + 1;\n}\n\nfun match_with_guard_incr(x: u64): u64 {\n    match (x) {\n        x if ({ incr(&mut x); x == 1 }) => 1,\n        // ERROR:    ^^^ invalid borrow of immutable value\n        _ => 2,\n    }\n}\n\nfun match_with_guard_incr2(x: &mut u64): u64 {\n    match (x) {\n        x if ({ incr(&mut x); x == 1 }) => 1,\n        // ERROR:    ^^^ invalid borrow of immutable value\n        _ => 2,\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Additionally, it is important to note any match arms that have guard expressions will not be\nconsidered either for exhaustivity purposes because the compiler has no way of evaluating the guard\nexpression statically."}),"\n",(0,a.jsx)(n.h2,{id:"limitations-on-specific-patterns",children:"Limitations on Specific Patterns"}),"\n",(0,a.jsxs)(n.p,{children:["There are some restrictions on when the ",(0,a.jsx)(n.code,{children:".."})," and ",(0,a.jsx)(n.code,{children:"mut"})," pattern modifiers can be used in a pattern."]}),"\n",(0,a.jsx)(n.h3,{id:"mutability-usage",children:"Mutability Usage"}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"mut"})," modifier can be placed on a variable pattern to specify that the ",(0,a.jsx)(n.em,{children:"variable"})," is to be mutated\nin the right-hand expression of the match arm. Note that since the ",(0,a.jsx)(n.code,{children:"mut"})," modifier only signifies\nthat the variable is to be mutated, not the underlying data, this can be used on all types of match\n(by value, immutable reference, and mutable reference)."]}),"\n",(0,a.jsxs)(n.p,{children:["Note that the ",(0,a.jsx)(n.code,{children:"mut"})," modifier can only be applied to variables, and not other types of patterns."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"public struct MyStruct(u64)\n\nfun top_level_mut(x: MyStruct): u64 {\n    match (x) {\n        mut MyStruct(y) => 1,\n        // ERROR: cannot use mut on a non-variable pattern\n    }\n}\n\nfun mut_on_immut(x: &MyStruct): u64 {\n    match (x) {\n        MyStruct(mut y) => {\n            y = &(*y + 1);\n            *y\n        }\n    }\n}\n\nfun mut_on_value(x: MyStruct): u64 {\n    match (x) {\n        MyStruct(mut y) => {\n            *y = *y + 1;\n            *y\n        },\n    }\n}\n\nfun mut_on_mut(x: &mut MyStruct): u64 {\n    match (x) {\n        MyStruct(mut y) => {\n            *y = *y + 1;\n            *y\n        },\n    }\n}\n\nlet mut x = MyStruct(1);\n\nmut_on_mut(&mut x); // returns 2\nx.0; // returns 2\n\nmut_on_immut(&x); // returns 3\nx.0; // returns 2\n\nmut_on_value(x); // returns 3\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"-usage",children:[(0,a.jsx)(n.code,{children:".."})," Usage"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:".."})," pattern can only be used within a constructor pattern as a wildcard that matches any number\nof fields -- the compiler expands the ",(0,a.jsx)(n.code,{children:".."})," to inserting ",(0,a.jsx)(n.code,{children:"_"})," in any missing fields in the\nconstructor pattern (if any). So ",(0,a.jsx)(n.code,{children:"MyStruct(_, _, _)"})," is the same as ",(0,a.jsx)(n.code,{children:"MyStruct(..)"}),",\n",(0,a.jsx)(n.code,{children:"MyStruct(1, _, _)"})," is the same as ",(0,a.jsx)(n.code,{children:"MyStruct(1, ..)"}),". Because of this, there are some restrictions\non how, and where the ",(0,a.jsx)(n.code,{children:".."})," pattern can be used:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["It can only be used ",(0,a.jsx)(n.strong,{children:"once"})," within the constructor pattern;"]}),"\n",(0,a.jsx)(n.li,{children:"In positional arguments it can be used at the beginning, middle, or end of the patterns within the\nconstructor;"}),"\n",(0,a.jsx)(n.li,{children:"In named arguments it can only be used at the end of the patterns within the constructor;"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"public struct MyStruct(u64, u64, u64, u64) has drop;\n\npublic struct MyStruct2 {\n    x: u64,\n    y: u64,\n    z: u64,\n    w: u64,\n}\n\nfun wild_match(x: MyStruct): u64 {\n    match (x) {\n        MyStruct(.., 1) => 1,\n        // OK! The `..` pattern can be used at the beginning of the constructor pattern\n        MyStruct(1, ..) => 2,\n        // OK! The `..` pattern can be used at the end of the constructor pattern\n        MyStruct(1, .., 1) => 3,\n        // OK! The `..` pattern can be used at the middle of the constructor pattern\n        MyStruct(1, .., 1, 1) => 4,\n        MyStruct(..) => 5,\n    }\n}\n\nfun wild_match2(x: MyStruct2): u64 {\n    match (x) {\n        MyStruct2 { x: 1, .. } => 1,\n        MyStruct2 { x: 1, w: 2 .. } => 2,\n        MyStruct2 { .. } => 3,\n    }\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);