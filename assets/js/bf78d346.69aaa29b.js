"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9999],{1239:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>l,frontMatter:()=>c,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"guides/upgradeability-practices","title":"Upgradeability Practices","description":"To talk about best practices for upgradeability, we need to first understand what can be upgraded in","source":"@site/../book/guides/upgradeability-practices.md","sourceDirName":"guides","slug":"/guides/upgradeability-practices","permalink":"/guides/upgradeability-practices","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"2024 Migration Guide","permalink":"/guides/2024-migration-guide"},"next":{"title":"Building Against Limits","permalink":"/guides/building-against-limits"}}');var i=t(3420),o=t(5521);const c={},s="Upgradeability Practices",r={},d=[{value:"Versioning objects",id:"versioning-objects",level:2},{value:"Versioning configuration with dynamic fields",id:"versioning-configuration-with-dynamic-fields",level:2},{value:"Modular architecture",id:"modular-architecture",level:2}];function u(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"upgradeability-practices",children:"Upgradeability Practices"})}),"\n",(0,i.jsx)(n.p,{children:"To talk about best practices for upgradeability, we need to first understand what can be upgraded in\na package. The base premise of upgradeability is that an upgrade should not break public\ncompatibility with the previous version. The parts of the module which can be used in dependent\npackages should not change their static signature. This applies to modules - a module can not be\nremoved from a package, public structs - they can be used in function signatures and public\nfunctions - they can be called from other packages."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"// module can not be removed from the package\nmodule book::upgradable;\n\n// dependencies can be changed (if they are not used in public signatures)\nuse std::string::String;\nuse sui::event; // can be removed\n\n// public structs can not be removed and can't be changed\npublic struct Book has key {\n    id: UID,\n    title: String,\n}\n\n// public structs can not be removed and can't be changed\npublic struct BookCreated has copy, drop {\n    /* ... */\n}\n\n// public functions can not be removed and their signature can never change\n// but the implementation can be changed\npublic fun create_book(ctx: &mut TxContext): Book {\n    create_book_internal(ctx)\n\n    // can be removed and changed\n    event::emit(BookCreated {\n        /* ... */\n    })\n}\n\n// package-visibility functions can be removed and changed\npublic(package) fun create_book_package(ctx: &mut TxContext): Book {\n    create_book_internal(ctx)\n}\n\n// entry functions can be removed and changed as long as they're not public\nentry fun create_book_entry(ctx: &mut TxContext): Book {\n    create_book_internal(ctx)\n}\n\n// private functions can be removed and changed\nfun create_book_internal(ctx: &mut TxContext): Book {\n    abort 0\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"versioning-objects",children:"Versioning objects"}),"\n",(0,i.jsx)(n.p,{children:"To discard previous versions of the package, the objects can be versioned. As long as the object\ncontains a version field, and the code which uses the object expects and asserts a specific version,\nthe code can be force-migrated to the new version. Normally, after an upgrade, admin functions can\nbe used to update the version of the shared state, so that the new version of code can be used, and\nthe old version aborts with a version mismatch."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module book::versioned_state;\n\nconst EVersionMismatch: u64 = 0;\n\nconst VERSION: u8 = 1;\n\n/// The shared state (can be owned too)\npublic struct SharedState has key {\n    id: UID,\n    version: u8,\n    /* ... */\n}\n\npublic fun mutate(state: &mut SharedState) {\n    assert!(state.version == VERSION, EVersionMismatch);\n    // ...\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"versioning-configuration-with-dynamic-fields",children:"Versioning configuration with dynamic fields"}),"\n",(0,i.jsxs)(n.p,{children:["There's a common pattern in Sui which allows changing the stored configuration of an object while\nretaining the same object signature. This is done by keeping the base object simple and versioned\nand adding an actual configuration object as a dynamic field. Using this ",(0,i.jsx)(n.em,{children:"anchor"})," pattern, the\nconfiguration can be changed with package upgrades while keeping the same base object signature."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module book::versioned_config;\n\nuse sui::vec_map::VecMap;\nuse std::string::String;\n\n/// The base object\npublic struct Config has key {\n    id: UID,\n    version: u16\n}\n\n/// The actual configuration\npublic struct ConfigV1 has store {\n    data: Bag,\n    metadata: VecMap<String, String>\n}\n\n// ...\n"})}),"\n",(0,i.jsx)(n.h2,{id:"modular-architecture",children:"Modular architecture"}),"\n",(0,i.jsx)(n.p,{children:"This section is coming soon!"})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},5521:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>s});var a=t(6672);const i={},o=a.createContext(i);function c(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);