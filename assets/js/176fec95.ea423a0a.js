"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4985],{4811:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(9378);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}},6015:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"index-syntax","title":"Index Syntax | Reference","description":"","source":"@site/../reference/index-syntax.md","sourceDirName":".","slug":"/index-syntax","permalink":"/reference/index-syntax","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Index Syntax | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"14. Method Syntax","permalink":"/reference/method-syntax"},"next":{"title":"16. Packages","permalink":"/reference/packages"}}');var s=t(2714),a=t(4811);const r={title:"Index Syntax | Reference",description:""},o="Index Syntax",l={},c=[{value:"Overview and Summary",id:"overview-and-summary",level:2},{value:"Usage",id:"usage",level:2},{value:"Index Functions Take Flexible Arguments",id:"index-functions-take-flexible-arguments",level:3},{value:"Defining Index Syntax Functions",id:"defining-index-syntax-functions",level:2},{value:"Declaration",id:"declaration",level:3},{value:"Immutable Accessor",id:"immutable-accessor",level:4},{value:"Mutable Accessor",id:"mutable-accessor",level:4},{value:"Visibility",id:"visibility",level:4},{value:"No Duplicates",id:"no-duplicates",level:4},{value:"Type Constraints",id:"type-constraints",level:3},{value:"Type Compatibility",id:"type-compatibility",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"index-syntax",children:"Index Syntax"})}),"\n",(0,s.jsx)(n.p,{children:"Move provides syntax attributes to allow you to define operations that look and feel like native\nMove code, lowering these operations into your user-provided definitions."}),"\n",(0,s.jsxs)(n.p,{children:["Our first syntax method, ",(0,s.jsx)(n.code,{children:"index"}),", allows you to define a group of operations that can be used as\ncustom index accessors for your datatypes, such as accessing a matrix element as ",(0,s.jsx)(n.code,{children:"m[i,j]"}),", by\nannotating functions that should be used for these index operations. Moreover, these definitions are\nbespoke per-type and available implicitly for any programmer using your type."]}),"\n",(0,s.jsx)(n.h2,{id:"overview-and-summary",children:"Overview and Summary"}),"\n",(0,s.jsxs)(n.p,{children:["To start, consider a ",(0,s.jsx)(n.code,{children:"Matrix"})," type that uses a vector of vectors to represent its values. You can\nwrite a small library using ",(0,s.jsx)(n.code,{children:"index"})," syntax annotations on the ",(0,s.jsx)(n.code,{children:"borrow"})," and ",(0,s.jsx)(n.code,{children:"borrow_mut"})," functions as\nfollows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module matrix::matrix;\n\npublic struct Matrix<T> { v: vector<vector<T>> }\n\n#[syntax(index)]\npublic fun borrow<T>(s: &Matrix<T>, i: u64, j: u64): &T {\n    vector::borrow(vector::borrow(&s.v, i), j)\n}\n\n#[syntax(index)]\npublic fun borrow_mut<T>(s: &mut Matrix<T>, i: u64, j: u64): &mut T {\n    vector::borrow_mut(vector::borrow_mut(&mut s.v, i), j)\n}\n\npublic fun make_matrix<T>(v: vector<vector<T>>):  Matrix<T> {\n    Matrix { v }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now anyone using this ",(0,s.jsx)(n.code,{children:"Matrix"})," type has access to index syntax for it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let mut m = matrix::make_matrix(vector[\n    vector[1, 0, 0],\n    vector[0, 1, 0],\n    vector[0, 0, 1],\n]);x\n\nlet mut i = 0;\nwhile (i < 3) {\n    let mut j = 0;\n    while (j < 3) {\n        if (i == j) {\n            assert!(m[i, j] == 1, 1);\n        } else {\n            assert!(m[i, j] == 0, 0);\n        };\n        *(&mut m[i,j]) = 2;\n        j = j + 1;\n    };\n    i = i + 1;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(n.p,{children:"As the example indicates, if you define a datatype and an associated index syntax method, anyone can\ninvoke that method by writing index syntax on a value of that type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let mat = matrix::make_matrix(...);\nlet m_0_0 = mat[0, 0];\n"})}),"\n",(0,s.jsx)(n.p,{children:"During compilation, the compiler translates these into the appropriate function invocations based on\nthe position and mutable usage of the expression:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let mut mat = matrix::make_matrix(...);\n\nlet m_0_0 = mat[0, 0];\n// translates to `copy matrix::borrow(&mat, 0, 0)`\n\nlet m_0_0 = &mat[0, 0];\n// translates to `matrix::borrow(&mat, 0, 0)`\n\nlet m_0_0 = &mut mat[0, 0];\n// translates to `matrix::borrow_mut(&mut mat, 0, 0)`\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can also intermix index expressions with field accesses:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public struct V { v: vector<u64> }\n\npublic struct Vs { vs: vector<V> }\n\nfun borrow_first(input: &Vs): &u64 {\n    &input.vs[0].v[0]\n    // translates to `vector::borrow(&vector::borrow(&input.vs, 0).v, 0)`\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"index-functions-take-flexible-arguments",children:"Index Functions Take Flexible Arguments"}),"\n",(0,s.jsx)(n.p,{children:"Note that, aside from the definition and type limitations described in the rest of this chapter,\nMove places no restrictions on the values your index syntax method takes as parameters. This allows\nyou to implement intricate programmatic behavior when defining index syntax, such as a data\nstructure that takes a default value if the index is out of bounds:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"#[syntax(index)]\npublic fun borrow_or_set<Key: copy, Value: drop>(\n    input: &mut MTable<Key, Value>,\n    key: Key,\n    default: Value\n): &mut Value {\n    if (contains(input, key)) {\n        borrow(input, key)\n    } else {\n        insert(input, key, default);\n        borrow(input, key)\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now, when you index into ",(0,s.jsx)(n.code,{children:"MTable"}),", you must also provide a default value:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let string_key: String = ...;\nlet mut table: MTable<String, u64> = m_table::make_table();\nlet entry: &mut u64 = &mut table[string_key, 0];\n"})}),"\n",(0,s.jsx)(n.p,{children:"This sort of extensible power allows you to write precise index interfaces for your types,\nconcretely enforcing bespoke behavior."}),"\n",(0,s.jsx)(n.h2,{id:"defining-index-syntax-functions",children:"Defining Index Syntax Functions"}),"\n",(0,s.jsx)(n.p,{children:"This powerful syntax form allows all of your user-defined datatypes to behave in this way, assuming\nyour definitions adhere to the following rules:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"#[syntax(index)]"})," attribute is added to the designated functions defined in the same module\nas the subject type."]}),"\n",(0,s.jsxs)(n.li,{children:["The designated functions have ",(0,s.jsx)(n.code,{children:"public"})," visibility."]}),"\n",(0,s.jsxs)(n.li,{children:["The functions take a reference type as its subject type (its first argument) and returns a\nmatching references type (",(0,s.jsx)(n.code,{children:"mut"})," if the subject was ",(0,s.jsx)(n.code,{children:"mut"}),")."]}),"\n",(0,s.jsx)(n.li,{children:"Each type has only a single mutable and single immutable definition."}),"\n",(0,s.jsxs)(n.li,{children:["Immutable and mutable versions have type agreement:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The subject types match, differing only in mutability."}),"\n",(0,s.jsx)(n.li,{children:"The return types match the mutability of their subject types."}),"\n",(0,s.jsx)(n.li,{children:"Type parameters, if present, have identical constraints between both versions."}),"\n",(0,s.jsx)(n.li,{children:"All parameters beyond the subject type are identical."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The following content and additional examples describe these rules in greater detail."}),"\n",(0,s.jsx)(n.h3,{id:"declaration",children:"Declaration"}),"\n",(0,s.jsxs)(n.p,{children:["To declare an index syntax method, add the ",(0,s.jsx)(n.code,{children:"#[syntax(index)]"})," attribute above the relevant function\ndefinition in the same module as the subject type's definition. This signals to the compiler that\nthe function is an index accessor for the specified type."]}),"\n",(0,s.jsx)(n.h4,{id:"immutable-accessor",children:"Immutable Accessor"}),"\n",(0,s.jsxs)(n.p,{children:["The immutable index syntax method is defined for read-only access. It takes an immutable reference\nof the subject type and returns an immutable reference to the element type. The ",(0,s.jsx)(n.code,{children:"borrow"})," function\ndefined in ",(0,s.jsx)(n.code,{children:"std::vector"})," is an example of this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"#[syntax(index)]\npublic native fun borrow<Element>(v: &vector<Element>, i: u64): &Element;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"mutable-accessor",children:"Mutable Accessor"}),"\n",(0,s.jsxs)(n.p,{children:["The mutable index syntax method is the dual of the immutable one, allowing for both read and write\noperations. It takes a mutable reference of the subject type and returns a mutable reference to the\nelement type. The ",(0,s.jsx)(n.code,{children:"borrow_mut"})," function defined in ",(0,s.jsx)(n.code,{children:"std::vector"})," is an example of this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"#[syntax(index)]\npublic native fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"visibility",children:"Visibility"}),"\n",(0,s.jsx)(n.p,{children:"To ensure that indexing functions are available anywhere the type is used, all index syntax methods\nmust have public visibility. This ensures ergonomic usage of indexing across modules and packages in\nMove."}),"\n",(0,s.jsx)(n.h4,{id:"no-duplicates",children:"No Duplicates"}),"\n",(0,s.jsx)(n.p,{children:"In addition to the above requirements, we restrict each subject base type to defining a single index\nsyntax method for immutable references and a single index syntax method for mutable references. For\nexample, you cannot define a specialized version for a polymorphic type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"#[syntax(index)]\npublic fun borrow_matrix_u64(s: &Matrix<u64>, i: u64, j: u64): &u64 { ... }\n\n#[syntax(index)]\npublic fun borrow_matrix<T>(s: &Matrix<T>, i: u64, j: u64): &T { ... }\n    // ERROR! Matrix already has a definition\n    // for its immutable index syntax method\n"})}),"\n",(0,s.jsx)(n.p,{children:"This ensures that you can always tell which method is being invoked, without the need to inspect\ntype instantiation."}),"\n",(0,s.jsx)(n.h3,{id:"type-constraints",children:"Type Constraints"}),"\n",(0,s.jsx)(n.p,{children:"By default, an index syntax method has the following type constraints:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Its subject type (first argument) must be a reference to a single type defined in the same module\nas the marked function."})," This means that you cannot define index syntax methods for tuples, type\nparameters, or values:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"#[syntax(index)]\npublic fun borrow_fst(x: &(u64, u64), ...): &u64 { ... }\n    // ERROR because the subject type is a tuple\n\n#[syntax(index)]\npublic fun borrow_tyarg<T>(x: &T, ...): &T { ... }\n    // ERROR because the subject type is a type parameter\n\n#[syntax(index)]\npublic fun borrow_value(x: Matrix<u64>, ...): &u64 { ... }\n    // ERROR because x is not a reference\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"The subject type must match mutability with the return type."})," This restriction allows you to\nclarify the expected behavior when borrowing an indexed expression as ",(0,s.jsx)(n.code,{children:"&vec[i]"})," versus\n",(0,s.jsx)(n.code,{children:"&mut vec[i]"}),". The Move compiler uses the mutability marker to determine which borrow form to call\nto produce a reference of the appropriate mutability. As a result, we disallow index syntax methods\nwhose subject and return mutability differ:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"#[syntax(index)]\npublic fun borrow_imm(x: &mut Matrix<u64>, ...): &u64 { ... }\n    // ERROR! incompatible mutability\n    // expected a mutable reference '&mut' return type\n"})}),"\n",(0,s.jsx)(n.h3,{id:"type-compatibility",children:"Type Compatibility"}),"\n",(0,s.jsx)(n.p,{children:"When defining an immutable and mutable index syntax method pair, they are subject to a number of\ncompatibility constraints:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"They must take the same number of type parameters, those type parameters must have the same\nconstraints."}),"\n",(0,s.jsxs)(n.li,{children:["Type parameters must be used the same ",(0,s.jsx)(n.em,{children:"by position"}),", not name."]}),"\n",(0,s.jsx)(n.li,{children:"Their subject types must match exactly except for the mutability."}),"\n",(0,s.jsx)(n.li,{children:"Their return types must match exactly except for the mutability."}),"\n",(0,s.jsx)(n.li,{children:"All other parameter types must match exactly."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These constraints are to ensure that index syntax behaves identically regardless of being in a\nmutable or immutable position."}),"\n",(0,s.jsxs)(n.p,{children:["To illustrate some of these errors, recall the previous ",(0,s.jsx)(n.code,{children:"Matrix"})," definition:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"#[syntax(index)]\npublic fun borrow<T>(s: &Matrix<T>, i: u64, j: u64): &T {\n    vector::borrow(vector::borrow(&s.v, i), j)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"All of the following are type-incompatible definitions of the mutable version:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"#[syntax(index)]\npublic fun borrow_mut<T: drop>(s: &mut Matrix<T>, i: u64, j: u64): &mut T { ... }\n    // ERROR! `T` has `drop` here, but no in the immutable version\n\n#[syntax(index)]\npublic fun borrow_mut(s: &mut Matrix<u64>, i: u64, j: u64): &mut u64 { ... }\n    // ERROR! This takes a different number of type parameters\n\n#[syntax(index)]\npublic fun borrow_mut<T, U>(s: &mut Matrix<U>, i: u64, j: u64): &mut U { ... }\n    // ERROR! This takes a different number of type parameters\n\n#[syntax(index)]\npublic fun borrow_mut<U>(s: &mut Matrix<U>, i_j: (u64, u64)): &mut U { ... }\n    // ERROR! This takes a different number of arguments\n\n#[syntax(index)]\npublic fun borrow_mut<U>(s: &mut Matrix<U>, i: u64, j: u32): &mut U { ... }\n    // ERROR! `j` is a different type\n"})}),"\n",(0,s.jsx)(n.p,{children:"Again, the goal here is to make the usage across the immutable and mutable versions consistent. This\nallows index syntax methods to work without changing out the behavior or constraints based on\nmutable versus immutable usage, ultimately ensuring a consistent interface to program against."})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);