"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4074],{5521:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var i=t(6672);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}},9838:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"move-basics/enum-and-match","title":"Enums and Match","description":"An enum is a user-defined data structure that, unlike a struct, can represent multiple","source":"@site/../book/move-basics/enum-and-match.md","sourceDirName":"move-basics","slug":"/move-basics/enum-and-match","permalink":"/move-basics/enum-and-match","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.14. Control Flow","permalink":"/move-basics/control-flow"},"next":{"title":"5.16. Constants","permalink":"/move-basics/constants"}}');var s=t(3420),a=t(5521);const r={},c="Enums and Match",o={},l=[{value:"Definition",id:"definition",level:2},{value:"Instantiating",id:"instantiating",level:2},{value:"Using in Type Definitions",id:"using-in-type-definitions",level:2},{value:"Pattern Matching",id:"pattern-matching",level:2},{value:"Trick #1 - <em>any</em> Condition",id:"trick-1---any-condition",level:3},{value:"Trick #2 - <code>try_into</code> Helpers",id:"trick-2---try_into-helpers",level:3},{value:"Trick #3 - Matching on Primitive Values",id:"trick-3---matching-on-primitive-values",level:3},{value:"The Final Test",id:"the-final-test",level:2},{value:"Summary",id:"summary",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"enums-and-match",children:"Enums and Match"})}),"\n",(0,s.jsxs)(n.p,{children:["An enum is a user-defined data structure that, unlike a ",(0,s.jsx)(n.a,{href:"./struct",children:"struct"}),", can represent multiple\nvariants. Each variant can contain primitive types, structs, or other enums. However, recursive enum\ndefinitions \u2014 similar to recursive struct definitions \u2014 are not allowed."]}),"\n",(0,s.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,s.jsxs)(n.p,{children:["An enum is defined using the ",(0,s.jsx)(n.code,{children:"enum"})," keyword, followed by optional abilities and a block of variant\ndefinitions. Each variant has a tag name and may optionally include either positional values or\nnamed fields. Enum must have at least one variant. The structure of each variant is not flexible,\nand the total number of variants can be relatively large - up to 100."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/enum-and-match.move anchor=definition",children:"module book::segment;\n\nuse std::string::String;\n\n/// `Segment` enum definition.\n/// Defines various string segments.\npublic enum Segment has copy, drop {\n    /// Empty variant, no value.\n    Empty,\n    /// Variant with a value (positional style).\n    String(String),\n    /// Variant with named fields.\n    Special {\n        content: vector<u8>,\n        encoding: u8, // Encoding tag.\n    },\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the code sample above we defined a public ",(0,s.jsx)(n.code,{children:"Segment"})," enum, which has the ",(0,s.jsx)(n.code,{children:"drop"})," and ",(0,s.jsx)(n.code,{children:"copy"}),"\nabilities, and 3 variants:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Empty"}),", which has no fields."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"String"}),", which contains a single positional field of type ",(0,s.jsx)(n.code,{children:"String"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Special"}),", which uses named fields: ",(0,s.jsx)(n.code,{children:"content"})," of type ",(0,s.jsx)(n.code,{children:"vector<u8>"})," and ",(0,s.jsx)(n.code,{children:"encoding"})," of type ",(0,s.jsx)(n.code,{children:"u8"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"instantiating",children:"Instantiating"}),"\n",(0,s.jsxs)(n.p,{children:["Enums are ",(0,s.jsx)(n.em,{children:"internal"})," to the module in which they are defined. This means an enum can only be\nconstructed, read, and unpacked within the same module."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"./struct#create-and-use-an-instance",children:"Similar to structs"}),", enums are instantiated by specifying the\ntype, the variant, and the values for any fields defined in that variant."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/enum-and-match.move anchor=constructors",children:"/// Constructs an `Empty` segment.\npublic fun new_empty(): Segment { Segment::Empty }\n\n/// Constructs a `String` segment with the `str` value.\npublic fun new_string(str: String): Segment { Segment::String(str) }\n\n/// Constructs a `Special` segment with the `content` and `encoding` values.\npublic fun new_special(content: vector<u8>, encoding: u8): Segment {\n    Segment::Special {\n        content,\n        encoding,\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Depending on the use case, you may want to provide public constructors, or instantiate enums\ninternally as a part of application logic."}),"\n",(0,s.jsx)(n.h2,{id:"using-in-type-definitions",children:"Using in Type Definitions"}),"\n",(0,s.jsxs)(n.p,{children:["The biggest benefit of using enums is the ability to represent varying data structures under a\nsingle type. To demonstrate this, let\u2019s define a struct that contains a vector of ",(0,s.jsx)(n.code,{children:"Segment"})," values:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/enum-and-match.move anchor=struct",children:'/// A struct to demonstrate enum capabilities.\npublic struct Segments(vector<Segment>) has copy, drop;\n\n#[test]\nfun test_segments() {\n    let _ = Segments(vector[\n        Segment::Empty,\n        Segment::String(b"hello".to_string()),\n        Segment::String(b" move".to_string()),\n        Segment::Special { content: b"21", encoding: 1 },\n    ]);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["All variants of the Segment enum share the same type \u2013 ",(0,s.jsx)(n.code,{children:"Segment"})," \u2013 which allows us to create a\nhomogeneous vector containing instances of different variants. This kind of flexibility is not\nachievable with structs, as each struct defines a single, fixed shape."]}),"\n",(0,s.jsx)(n.h2,{id:"pattern-matching",children:"Pattern Matching"}),"\n",(0,s.jsxs)(n.p,{children:["Unlike structs, enums require special handling when it comes to accessing the inner value or\nchecking the variant. We simply cannot read the inner fields of an enum using the ",(0,s.jsx)(n.code,{children:"."})," (dot) syntax,\nbecause we need to make sure that the value we are trying to access is the right one. For that Move\noffers ",(0,s.jsx)(n.em,{children:"pattern matching"})," syntax."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["This chapter doesn't intend to cover all the features of pattern matching in Move. Refer to the\n",(0,s.jsx)(n.a,{href:"./../../reference/control-flow/pattern-matching",children:"Pattern Matching"})," section in the Move Reference."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Pattern matching allows conditioning the logic based on the ",(0,s.jsx)(n.em,{children:"pattern"})," of the value. It is performed\nusing the ",(0,s.jsx)(n.code,{children:"match"})," expression, followed by the matched value in parenthesis and the block of ",(0,s.jsx)(n.em,{children:"match\narms"}),", defining the patten and expression to be performed if the pattern is right."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's extend our example by adding a set of ",(0,s.jsx)(n.code,{children:"is_variant"}),"-like functions, so external packages can\ncheck the variant. Starting with ",(0,s.jsx)(n.code,{children:"is_empty"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/enum-and-match.move anchor=is_empty",children:"/// Whether this is an `Empty` segment.\npublic fun is_empty(s: &Segment): bool {\n    // Match is an expression, hence we can use it for return value.\n    match (s) {\n        Segment::Empty => true,\n        Segment::String(_str) => false,\n        Segment::Special { content: _, encoding: _ } => false,\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"match"})," keyword begins the expression, and ",(0,s.jsx)(n.code,{children:"s"})," is the value being tested. Each match arm checks\nfor a specific variant of the ",(0,s.jsx)(n.code,{children:"Segment"})," enum. If ",(0,s.jsx)(n.code,{children:"s"})," matches ",(0,s.jsx)(n.code,{children:"Segment::Empty"}),", the function returns\n",(0,s.jsx)(n.code,{children:"true"}),"; otherwise, it returns ",(0,s.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For variants with fields, we need to bind the inner structure to local variables (even if we don\u2019t\nuse them, marking unused values with ",(0,s.jsx)(n.code,{children:"_"})," to avoid compiler warnings)."]}),"\n",(0,s.jsxs)(n.h3,{id:"trick-1---any-condition",children:["Trick #1 - ",(0,s.jsx)(n.em,{children:"any"})," Condition"]}),"\n",(0,s.jsxs)(n.p,{children:["The Move compiler infers the type of the value used in a ",(0,s.jsx)(n.code,{children:"match"})," expression and ensures that the\n",(0,s.jsx)(n.em,{children:"match arms"})," are exhaustive \u2013 that is, all possible variants or values must be covered."]}),"\n",(0,s.jsxs)(n.p,{children:["However, in some cases, such as matching on a primitive value or a collection like a vector, it's\nnot feasible to list every possible case. For these situations, match supports a wildcard pattern\n(",(0,s.jsx)(n.code,{children:"_"}),"), which acts as a default arm. This arm is executed when no other patterns match."]}),"\n",(0,s.jsxs)(n.p,{children:["We can demonstrate this by simplifying our ",(0,s.jsx)(n.code,{children:"is_empty"})," function and replacing the non-",(0,s.jsx)(n.code,{children:"Empty"}),"\nvariants with a wildcard:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public fun is_empty(s: &Segment): bool { file=packages/samples/sources/move-basics/enum-and anchor=matcmove:is_empty_2}}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Similarly, we can use the same approach to define ",(0,s.jsx)(n.code,{children:"is_special"})," and ",(0,s.jsx)(n.code,{children:"is_string"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/enum-and-match.move anchor=accessors",children:"/// Whether this is a `Special` segment.\npublic fun is_special(s: &Segment): bool {\n    match (s) {\n        // Hint: the `..` ignores inner fields\n        Segment::Special { .. } => true,\n        _ => false,\n    }\n}\n\n/// Whether this is a `String` segment.\npublic fun is_string(s: &Segment): bool {\n    match (s) {\n        Segment::String(_) => true,\n        _ => false,\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"trick-2---try_into-helpers",children:["Trick #2 - ",(0,s.jsx)(n.code,{children:"try_into"})," Helpers"]}),"\n",(0,s.jsxs)(n.p,{children:["With the addition of ",(0,s.jsx)(n.code,{children:"is_variant"})," functions, we enabled external modules to check which variant an\nenum instance represents. However, this is often not enough \u2013 external code still cannot access the\ninner value of a variant due to enums being internal to their module."]}),"\n",(0,s.jsxs)(n.p,{children:["A common pattern for addressing this is to define ",(0,s.jsx)(n.code,{children:"try_into"})," functions. These functions match on the\nvalue and return an ",(0,s.jsx)(n.code,{children:"Option"})," containing the inner contents if the ",(0,s.jsx)(n.code,{children:"match"})," succeeds."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/enum-and-match.move anchor=try_into_inner_string",children:"/// Returns `Some(String)` if the `Segment` is `String`, `None` otherwise.\npublic fun try_into_inner_string(s: Segment): Option<String> {\n    match (s) {\n        Segment::String(str) => option::some(str),\n        _ => option::none(),\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This pattern safely exposes internal data in a controlled way, avoiding abort."}),"\n",(0,s.jsx)(n.h3,{id:"trick-3---matching-on-primitive-values",children:"Trick #3 - Matching on Primitive Values"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"match"})," expression in Move can be used with values of any type \u2013 enums, structs, or primitives.\nTo demonstrate this, let\u2019s implement a ",(0,s.jsx)(n.code,{children:"to_string"})," function that creates a new ",(0,s.jsx)(n.code,{children:"String"})," from a\n",(0,s.jsx)(n.code,{children:"Segment"}),". In the case of the ",(0,s.jsx)(n.code,{children:"Special"})," variant, we will match on the ",(0,s.jsx)(n.code,{children:"encoding"})," field to determine\nhow to decode the content."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/enum-and-match.move anchor=to_string",children:'/// Return a `String` representation of a segment.\npublic fun to_string(s: &Segment): String {\n    match (*s) {\n        // Return an empty string.\n        Segment::Empty => b"".to_string(),\n        // Return the inner string.\n        Segment::String(str) => str,\n        // Return the decoded contents based on the encoding.\n        Segment::Special { content, encoding } => {\n            // Perform a match on the encoding, we only support 0 - ut8, 1 - hex.\n            match (encoding) {\n                // Plain encoding, return content.\n                0 => content.to_string(),\n                // HEX encoding, decode and return.\n                1 => sui::hex::decode(content).to_string(),\n                // We have to provide a wildcard pattern, because values of `u8` are 0-255.\n                _ => abort,\n            }\n        },\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This function demonstrates two key things:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Nested ",(0,s.jsx)(n.code,{children:"match"})," expressions can be used for deeper logic branching."]}),"\n",(0,s.jsxs)(n.li,{children:["Wildcards are essential for covering all possible values in primitive types like ",(0,s.jsx)(n.code,{children:"u8"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"the-final-test",children:"The Final Test"}),"\n",(0,s.jsx)(n.p,{children:"Now we can finalize the test we started before using the features we have added. Let's create a\nscenario where we build enums into a vector."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/enum-and-match-2.move anchor=enum_test",children:'// Note, that the module has changed!\nmodule book::segment_tests;\n\nuse book::segment;\nuse std::unit_test::assert_eq;\n\n#[test]\nfun test_full_enum_cycle() {\n    // Create a vector of different Segment variants.\n    let segments = vector[\n        segment::new_empty(),\n        segment::new_string(b"hello".to_string()),\n        segment::new_special(b" ", 0), // plaintext\n        segment::new_string(b"move".to_string()),\n        segment::new_special(b"21", 1), // hex\n    ];\n\n    // Aggregate all segments into the final string using `vector::fold!` macro.\n    let result = segments.fold!(b"".to_string(), |mut acc, segment| {\n        // Do not append empty, only `Special` and `String`.\n        if (!segment.is_empty()) {\n            acc.append(segment.to_string());\n        };\n        acc\n    });\n\n    // Check that the result is what\'s expected.\n    assert_eq!(result, b"hello move!".to_string());\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This test demonstrates the full enum workflow: instantiating different variants, using public\naccessors, and performing logic with pattern matching. That should be enough to get you started!"}),"\n",(0,s.jsxs)(n.p,{children:["To learn more about enums and pattern matching, refer to the resources listed in the\n",(0,s.jsx)(n.a,{href:"#further-reading",children:"further reading"})," section."]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Enums are user-defined types that can represent multiple variants under a single type."}),"\n",(0,s.jsx)(n.li,{children:"Each variant can contain different types of data (primitives, structs, or other enums)."}),"\n",(0,s.jsx)(n.li,{children:"Enums are internal to their defining module and require pattern matching for access."}),"\n",(0,s.jsxs)(n.li,{children:["Pattern matching is done using the ",(0,s.jsx)(n.code,{children:"match"})," expression, which:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Works with enums, structs, and primitive values;"}),"\n",(0,s.jsx)(n.li,{children:"Must handle all possible cases (be exhaustive);"}),"\n",(0,s.jsxs)(n.li,{children:["Supports the ",(0,s.jsx)(n.code,{children:"_"})," wildcard pattern for remaining cases;"]}),"\n",(0,s.jsx)(n.li,{children:"Can return values and be used in expressions;"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Common patterns for enums include ",(0,s.jsx)(n.code,{children:"is_variant"})," checks and ",(0,s.jsx)(n.code,{children:"try_into"})," helper functions."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"./../../reference/enums",children:"Enums"})," in the Move Reference"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/reference/control-flow/pattern-matching",children:"Pattern Matching"})," in the Move Reference"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);