"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6297],{3277:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"programmability/collections","title":"Collections","description":"Collection types are a fundamental part of any programming language. They are used to store a","source":"@site/../book/programmability/collections.md","sourceDirName":"programmability","slug":"/programmability/collections","permalink":"/programmability/collections","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"8.5. Epoch and Time","permalink":"/programmability/epoch-and-time"},"next":{"title":"8.7. Pattern: Wrapper Type","permalink":"/programmability/wrapper-type-pattern"}}');var i=n(2714),a=n(4811);const o={},r="Collections",c={},l=[{value:"Vector",id:"vector",level:2},{value:"VecSet",id:"vecset",level:2},{value:"VecMap",id:"vecmap",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"collections",children:"Collections"})}),"\n",(0,i.jsxs)(t.p,{children:["Collection types are a fundamental part of any programming language. They are used to store a\ncollection of data, such as a list of items. The ",(0,i.jsx)(t.code,{children:"vector"})," type has already been covered in the\n",(0,i.jsx)(t.a,{href:"./../move-basics/vector",children:"vector section"}),", and in this chapter we will cover the vector-based\ncollection types offered by the ",(0,i.jsx)(t.a,{href:"./sui-framework",children:"Sui Framework"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"vector",children:"Vector"}),"\n",(0,i.jsxs)(t.p,{children:["While we have previously covered the ",(0,i.jsx)(t.code,{children:"vector"})," type in the ",(0,i.jsx)(t.a,{href:"./../move-basics/vector",children:"vector section"}),",\nit is worth going over it again in a new context. This time we will cover the usage of the ",(0,i.jsx)(t.code,{children:"vector"}),"\ntype in objects and how it can be used in an application."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/collections.move anchor=vector",children:"module book::collections_vector;\n\nuse std::string::String;\n\n/// The Book that can be sold by a `BookStore`\npublic struct Book has key, store {\n    id: UID,\n    name: String\n}\n\n/// The BookStore that sells `Book`s\npublic struct BookStore has key, store {\n    id: UID,\n    books: vector<Book>\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"vecset",children:"VecSet"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"VecSet"})," is a collection type that stores a set of unique items. It is similar to a ",(0,i.jsx)(t.code,{children:"vector"}),", but it\ndoes not allow duplicate items. This property makes it useful for storing a collection of unique\nitems, such as a list of IDs or addresses."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/collections-2.move anchor=vec_set",children:"module book::collections_vec_set;\n\nuse sui::vec_set::{Self, VecSet};\n\npublic struct App has drop {\n    /// `VecSet` used in the struct definition\n    subscribers: VecSet<address>\n}\n\n#[test_only]\nuse std::unit_test::assert_eq;\n\n#[test]\nfun vec_set_playground() {\n    let set = vec_set::empty<u8>(); // create an empty set\n    let mut set = vec_set::singleton(1); // create a set with a single item\n\n    set.insert(2); // add an item to the set\n    set.insert(3);\n\n    assert!(set.contains(&1)); // check if an item is in the set\n    assert!(set.length() == 3); // get the number of items in the set\n    assert!(!set.is_empty()); // check if the set is empty\n\n    set.remove(&2); // remove an item from the set\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"VecSet will fail on attempt to insert an item that already exists in the set."}),"\n",(0,i.jsx)(t.h2,{id:"vecmap",children:"VecMap"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"VecMap"})," is a collection type that stores a map of key-value pairs. It is similar to a ",(0,i.jsx)(t.code,{children:"VecSet"}),", but\nit allows you to associate a value with each item in the set. This makes it useful for storing a\ncollection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs\nand their associated data."]}),"\n",(0,i.jsxs)(t.p,{children:["Keys in a ",(0,i.jsx)(t.code,{children:"VecMap"})," are unique, and each key can only be associated with a single value. If you try\nto insert a key-value pair with a key that already exists in the map, the old value will be replaced\nwith the new value."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/collections-3.move anchor=vec_map",children:'module book::collections_vec_map;\n\nuse std::string::String;\nuse sui::vec_map::{Self, VecMap};\n\npublic struct Metadata has drop {\n    name: String,\n    /// `VecMap` used in the struct definition\n    attributes: VecMap<String, String>\n}\n\n#[test]\nfun vec_map_playground() {\n    let mut map = vec_map::empty(); // create an empty map\n\n    map.insert(2, b"two".to_string()); // add a key-value pair to the map\n    map.insert(3, b"three".to_string());\n\n    assert!(map.contains(&2)); // check if a key is in the map\n\n    map.remove(&2); // remove a key-value pair from the map\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"limitations",children:"Limitations"}),"\n",(0,i.jsx)(t.p,{children:"Standard collection types are a great way to store typed data with guaranteed safety and\nconsistency. However, they are limited by the type of data they can store - the type system won't\nallow you to store a wrong type in a collection; and they're limited in size - by the object size\nlimit. They will work for relatively small-sized sets and lists, but for larger collections you may\nneed to use a different approach."}),"\n",(0,i.jsxs)(t.p,{children:["Another limitations on collection types is inability to compare them. Because the order of insertion\nis not guaranteed, an attempt to compare a ",(0,i.jsx)(t.code,{children:"VecSet"})," to another ",(0,i.jsx)(t.code,{children:"VecSet"})," may not yield the expected\nresults."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["This behavior is caught by the linter and will emit a warning: ",(0,i.jsx)(t.em,{children:"Comparing collections of type\n'sui::vec_set::VecSet' may yield unexpected result"})]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/collections-4.move anchor=vec_set_comparison",children:"let mut set1 = vec_set::empty();\nset1.insert(1);\nset1.insert(2);\n\nlet mut set2 = vec_set::empty();\nset2.insert(2);\nset2.insert(1);\n\nassert_eq!(set1, set2); // aborts!\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In the example above, the comparison will fail because the order of insertion is not guaranteed, and\nthe two ",(0,i.jsx)(t.code,{children:"VecSet"})," instances may have different orders of elements. And the comparison will fail even\nif the two ",(0,i.jsx)(t.code,{children:"VecSet"})," instances contain the same elements."]}),"\n",(0,i.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Vector is a native type that allows storing a list of items."}),"\n",(0,i.jsx)(t.li,{children:"VecSet is built on top of vector and allows storing sets of unique items."}),"\n",(0,i.jsx)(t.li,{children:"VecMap is used to store key-value pairs in a map-like structure."}),"\n",(0,i.jsx)(t.li,{children:"Vector-based collections are strictly typed and limited by the object size limit and are best\nsuited for small-sized sets and lists."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(t.p,{children:["In the next section we will cover the ",(0,i.jsx)(t.a,{href:"./wrapper-type-pattern",children:"Wrapper Type Pattern"})," - a design\npattern often used with collection types to extend or restrict their behavior."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},4811:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(9378);const i={},a=s.createContext(i);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);