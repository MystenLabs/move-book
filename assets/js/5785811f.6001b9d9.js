"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7638],{4623:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"uses","title":"Uses and Aliases | Reference","description":"","source":"@site/../reference/uses.md","sourceDirName":".","slug":"/uses","permalink":"/reference/uses","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Uses and Aliases | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"12. Abilities","permalink":"/reference/abilities"},"next":{"title":"14. Method Syntax","permalink":"/reference/method-syntax"}}');var t=s(2714),a=s(4811);const l={title:"Uses and Aliases | Reference",description:""},i="Uses and Aliases",c={},d=[{value:"Syntax",id:"syntax",level:2},{value:"Multiple Aliases",id:"multiple-aliases",level:3},{value:"Self aliases",id:"self-aliases",level:3},{value:"Multiple Aliases for the Same Definition",id:"multiple-aliases-for-the-same-definition",level:3},{value:"Nested imports",id:"nested-imports",level:3},{value:"Inside a <code>module</code>",id:"inside-a-module",level:2},{value:"Inside an expression",id:"inside-an-expression",level:2},{value:"Naming rules",id:"naming-rules",level:2},{value:"Uniqueness",id:"uniqueness",level:2},{value:"Shadowing",id:"shadowing",level:2},{value:"Unused Use or Alias",id:"unused-use-or-alias",level:2}];function r(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"uses-and-aliases",children:"Uses and Aliases"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"use"})," syntax can be used to create aliases to members in other modules. ",(0,t.jsx)(n.code,{children:"use"})," can be used to\ncreate aliases that last either for the entire module, or for a given expression block scope."]}),"\n",(0,t.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,t.jsxs)(n.p,{children:["There are several different syntax cases for ",(0,t.jsx)(n.code,{children:"use"}),". Starting with the most simple, we have the\nfollowing for creating aliases to other modules"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use <address>::<module name>;\nuse <address>::<module name> as <module alias name>;\n"})}),"\n",(0,t.jsx)(n.p,{children:"For example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::vector;\nuse std::option as o;\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"use std::vector;"})," introduces an alias ",(0,t.jsx)(n.code,{children:"vector"})," for ",(0,t.jsx)(n.code,{children:"std::vector"}),". This means that anywhere you\nwould want to use the module name ",(0,t.jsx)(n.code,{children:"std::vector"})," (assuming this ",(0,t.jsx)(n.code,{children:"use"})," is in scope), you could use\n",(0,t.jsx)(n.code,{children:"vector"})," instead. ",(0,t.jsx)(n.code,{children:"use std::vector;"})," is equivalent to ",(0,t.jsx)(n.code,{children:"use std::vector as vector;"})]}),"\n",(0,t.jsxs)(n.p,{children:["Similarly ",(0,t.jsx)(n.code,{children:"use std::option as o;"})," would let you use ",(0,t.jsx)(n.code,{children:"o"})," instead of ",(0,t.jsx)(n.code,{children:"std::option"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::vector;\nuse std::option as o;\n\nfun new_vec(): vector<o::Option<u8>> {\n    let mut v = vector[];\n    vector::push_back(&mut v, o::some(0));\n    vector::push_back(&mut v, o::none());\n    v\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"If you want to import a specific module member (such as a function or struct). You can use the\nfollowing syntax."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use <address>::<module name>::<module member>;\nuse <address>::<module name>::<module member> as <member alias>;\n"})}),"\n",(0,t.jsx)(n.p,{children:"For example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::vector::push_back;\nuse std::option::some as s;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This would let you use the function ",(0,t.jsx)(n.code,{children:"std::vector::push_back"})," without full qualification. Similarly\nfor ",(0,t.jsx)(n.code,{children:"std::option::some"})," with ",(0,t.jsx)(n.code,{children:"s"}),". Instead you could use ",(0,t.jsx)(n.code,{children:"push_back"})," and ",(0,t.jsx)(n.code,{children:"s"})," respectively. Again,\n",(0,t.jsx)(n.code,{children:"use std::vector::push_back;"})," is equivalent to ",(0,t.jsx)(n.code,{children:"use std::vector::push_back as push_back;"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::vector::push_back;\nuse std::option::some as s;\n\nfun new_vec(): vector<std::option::Option<u8>> {\n    let mut v = vector[];\n    vector::push_back(&mut v, s(0));\n    vector::push_back(&mut v, std::option::none());\n    v\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"multiple-aliases",children:"Multiple Aliases"}),"\n",(0,t.jsx)(n.p,{children:"If you want to add aliases for multiple module members at once, you can do so with the following\nsyntax"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use <address>::<module name>::{<module member>, <module member> as <member alias> ... };\n"})}),"\n",(0,t.jsx)(n.p,{children:"For example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::vector::push_back;\nuse std::option::{some as s, none as n};\n\nfun new_vec(): vector<std::option::Option<u8>> {\n    let mut v = vector[];\n    push_back(&mut v, s(0));\n    push_back(&mut v, n());\n    v\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"self-aliases",children:"Self aliases"}),"\n",(0,t.jsxs)(n.p,{children:["If you need to add an alias to the Module itself in addition to module members, you can do that in a\nsingle ",(0,t.jsx)(n.code,{children:"use"})," using ",(0,t.jsx)(n.code,{children:"Self"}),". ",(0,t.jsx)(n.code,{children:"Self"})," is a member of sorts that refers to the module."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::option::{Self, some, none};\n"})}),"\n",(0,t.jsx)(n.p,{children:"For clarity, all of the following are equivalent:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::option;\nuse std::option as option;\nuse std::option::Self;\nuse std::option::Self as option;\nuse std::option::{Self};\nuse std::option::{Self as option};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"multiple-aliases-for-the-same-definition",children:"Multiple Aliases for the Same Definition"}),"\n",(0,t.jsx)(n.p,{children:"If needed, you can have as many aliases for any item as you like"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::vector::push_back;\nuse std::option::{Option, some, none};\n\nfun new_vec(): vector<Option<u8>> {\n    let mut v = vector[];\n    push_back(&mut v, some(0));\n    push_back(&mut v, none());\n    v\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"nested-imports",children:"Nested imports"}),"\n",(0,t.jsxs)(n.p,{children:["In Move, you can also import multiple names with the same ",(0,t.jsx)(n.code,{children:"use"})," declaration. This brings all\nprovided names into scope:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"use std::{\n    vector::{Self as vec, push_back},\n    string::{String, Self as str}\n};\n\nfun example(s: &mut String) {\n    let mut v = vec::empty();\n    push_back(&mut v, 0);\n    push_back(&mut v, 10);\n    str::append_utf8(s, v);\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"inside-a-module",children:["Inside a ",(0,t.jsx)(n.code,{children:"module"})]}),"\n",(0,t.jsxs)(n.p,{children:["Inside of a ",(0,t.jsx)(n.code,{children:"module"})," all ",(0,t.jsx)(n.code,{children:"use"})," declarations are usable regardless of the order of declaration."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"module a::example;\n\nuse std::vector;\n\nfun new_vec(): vector<Option<u8>> {\n    let mut v = vector[];\n    vector::push_back(&mut v, 0);\n    vector::push_back(&mut v, 10);\n    v\n}\n\nuse std::option::{Option, some, none};\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The aliases declared by ",(0,t.jsx)(n.code,{children:"use"})," in the module usable within that module."]}),"\n",(0,t.jsxs)(n.p,{children:["Additionally, the aliases introduced cannot conflict with other module members. See\n",(0,t.jsx)(n.a,{href:"#uniqueness",children:"Uniqueness"})," for more details"]}),"\n",(0,t.jsx)(n.h2,{id:"inside-an-expression",children:"Inside an expression"}),"\n",(0,t.jsxs)(n.p,{children:["You can add ",(0,t.jsx)(n.code,{children:"use"})," declarations to the beginning of any expression block"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"module a::example;\n\nfun new_vec(): vector<Option<u8>> {\n    use std::vector::push_back;\n    use std::option::{Option, some, none};\n\n    let mut v = vector[];\n    push_back(&mut v, some(0));\n    push_back(&mut v, none());\n    v\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As with ",(0,t.jsx)(n.code,{children:"let"}),", the aliases introduced by ",(0,t.jsx)(n.code,{children:"use"})," in an expression block are removed at the end of that\nblock."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"module a::example;\n\nfun new_vec(): vector<Option<u8>> {\n    let result = {\n        use std::vector::push_back;\n        use std::option::{Option, some, none};\n\n        let mut v = vector[];\n        push_back(&mut v, some(0));\n        push_back(&mut v, none());\n        v\n    };\n    result\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Attempting to use the alias after the block ends will result in an error"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"fun new_vec(): vector<Option<u8>> {\n    let mut result = {\n        use std::vector::push_back;\n        use std::option::{Option, some, none};\n\n        let mut v = vector[];\n        push_back(&mut v, some(0));\n        v\n    };\n    push_back(&mut result, std::option::none());\n    // ^^^^^^ ERROR! unbound function 'push_back'\n    result\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Any ",(0,t.jsx)(n.code,{children:"use"})," must be the first item in the block. If the ",(0,t.jsx)(n.code,{children:"use"})," comes after any expression or ",(0,t.jsx)(n.code,{children:"let"}),", it\nwill result in a parsing error"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"{\n    let mut v = vector[];\n    use std::vector; // ERROR!\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This allows you to shorten your import blocks in many situations. Note that these imports, as the\nprevious ones, are all subject to the naming and uniqueness rules described in the following\nsections."}),"\n",(0,t.jsx)(n.h2,{id:"naming-rules",children:"Naming rules"}),"\n",(0,t.jsxs)(n.p,{children:["Aliases must follow the same rules as other module members. This means that aliases to structs (and\nconstants) must start with ",(0,t.jsx)(n.code,{children:"A"})," to ",(0,t.jsx)(n.code,{children:"Z"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"module a::data {\n    public struct S {}\n    const FLAG: bool = false;\n    public fun foo() {}\n}\nmodule a::example {\n    use a::data::{\n        S as s, // ERROR!\n        FLAG as fLAG, // ERROR!\n        foo as FOO,  // valid\n        foo as bar, // valid\n    };\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"uniqueness",children:"Uniqueness"}),"\n",(0,t.jsxs)(n.p,{children:["Inside a given scope, all aliases introduced by ",(0,t.jsx)(n.code,{children:"use"})," declarations must be unique."]}),"\n",(0,t.jsxs)(n.p,{children:["For a module, this means aliases introduced by ",(0,t.jsx)(n.code,{children:"use"})," cannot overlap"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"module a::example;\n\nuse std::option::{none as foo, some as foo}; // ERROR!\n//                                     ^^^ duplicate 'foo'\n\nuse std::option::none as bar;\n\nuse std::option::some as bar; // ERROR!\n//                       ^^^ duplicate 'bar'\n"})}),"\n",(0,t.jsx)(n.p,{children:"And, they cannot overlap with any of the module's other members"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"module a::data {\n    public struct S {}\n}\n\nmodule example {\n    use a::data::S;\n\n    public struct S { value: u64 } // ERROR!\n    //            ^ conflicts with alias 'S' above\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Inside of an expression block, they cannot overlap with each other, but they can\n",(0,t.jsx)(n.a,{href:"#shadowing",children:"shadow"})," other aliases or names from an outer scope"]}),"\n",(0,t.jsx)(n.h2,{id:"shadowing",children:"Shadowing"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"use"})," aliases inside of an expression block can shadow names (module members or aliases) from the\nouter scope. As with shadowing of locals, the shadowing ends at the end of the expression block;"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"module a::example;\n\npublic struct WrappedVector { vec: vector<u64> }\n\npublic fun empty(): WrappedVector {\n    WrappedVector { vec: std::vector::empty() }\n}\n\npublic fun push_back(v: &mut WrappedVector, value: u64) {\n    std::vector::push_back(&mut v.vec, value);\n}\n\nfun example1(): WrappedVector {\n    use std::vector::push_back;\n    // 'push_back' now refers to std::vector::push_back\n    let mut vec = vector[];\n    push_back(&mut vec, 0);\n    push_back(&mut vec, 1);\n    push_back(&mut vec, 10);\n    WrappedVector { vec }\n}\n\nfun example2(): WrappedVector {\n    let vec = {\n        use std::vector::push_back;\n        // 'push_back' now refers to std::vector::push_back\n\n        let mut v = vector[];\n        push_back(&mut v, 0);\n        push_back(&mut v, 1);\n        v\n    };\n    // 'push_back' now refers to Self::push_back\n    let mut res = WrappedVector { vec };\n    push_back(&mut res, 10);\n    res\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"unused-use-or-alias",children:"Unused Use or Alias"}),"\n",(0,t.jsxs)(n.p,{children:["An unused ",(0,t.jsx)(n.code,{children:"use"})," will result in a warning"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"module a::example;\n\nuse std::option::{some, none}; // Warning!\n//                      ^^^^ unused alias 'none'\n\npublic fun example(): std::option::Option<u8> {\n    some(0)\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(r,{...e})}):r(e)}},4811:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>i});var o=s(9378);const t={},a=o.createContext(t);function l(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);