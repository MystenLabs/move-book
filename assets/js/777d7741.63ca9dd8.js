"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5287],{125:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>t,metadata:()=>d,toc:()=>l});const d=JSON.parse('{"id":"primitive-types/address","title":"Address | Reference","description":"","source":"@site/../reference/primitive-types/address.md","sourceDirName":"primitive-types","slug":"/primitive-types/address","permalink":"/reference/primitive-types/address","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Address | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"2.2 Bool","permalink":"/reference/primitive-types/bool"},"next":{"title":"2.4 Vector","permalink":"/reference/primitive-types/vector"}}');var a=n(3420),r=n(5521);const t={title:"Address | Reference",description:""},i="Address",o={},l=[{value:"Addresses and Their Syntax",id:"addresses-and-their-syntax",level:2},{value:"Named Addresses",id:"named-addresses",level:2},{value:"Examples",id:"examples",level:3}];function c(e){const s={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"address",children:"Address"})}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"address"})," is a built-in type in Move that is used to represent locations (sometimes called accounts)\nin storage. An ",(0,a.jsx)(s.code,{children:"address"})," value is a 256-bit (32 byte) identifier. Move uses addresses to\ndifferentiate packages of ",(0,a.jsx)(s.a,{href:"./../modules",children:"modules"}),", where each package has its own address and\nmodules. Specific deployments of Move might also use the ",(0,a.jsx)(s.code,{children:"address"})," value for\n",(0,a.jsx)(s.a,{href:"./../abilities#key",children:"storage"})," operations."]}),"\n",(0,a.jsxs)(s.blockquote,{children:["\n",(0,a.jsxs)(s.p,{children:["For Sui, ",(0,a.jsx)(s.code,{children:"address"}),' is used to represent "accounts", and also objects via strong type wrappers\n(with ',(0,a.jsx)(s.code,{children:"sui::object::UID"})," and ",(0,a.jsx)(s.code,{children:"sui::object::ID"}),")."]}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["Although an ",(0,a.jsx)(s.code,{children:"address"})," is a 256 bit integer under the hood, Move addresses are intentionally\nopaque---they cannot be created from integers, they do not support arithmetic operations, and they\ncannot be modified. Specific deployments of Move might have ",(0,a.jsx)(s.code,{children:"native"})," functions to enable some of\nthese operations (e.g., creating an ",(0,a.jsx)(s.code,{children:"address"})," from bytes ",(0,a.jsx)(s.code,{children:"vector<u8>"}),"), but these are not part of\nthe Move language itself."]}),"\n",(0,a.jsxs)(s.p,{children:["While there are runtime address values (values of type ",(0,a.jsx)(s.code,{children:"address"}),"), they ",(0,a.jsx)(s.em,{children:"cannot"})," be used to access\nmodules at runtime."]}),"\n",(0,a.jsx)(s.h2,{id:"addresses-and-their-syntax",children:"Addresses and Their Syntax"}),"\n",(0,a.jsxs)(s.p,{children:["Addresses come in two flavors, named or numerical. The syntax for a named address follows the same\nrules for any named identifier in Move. The syntax of a numerical address is not restricted to\nhex-encoded values, and any valid ",(0,a.jsxs)(s.a,{href:"./integers",children:[(0,a.jsx)(s.code,{children:"u256"})," numerical value"]})," can be used as an address\nvalue, e.g., ",(0,a.jsx)(s.code,{children:"42"}),", ",(0,a.jsx)(s.code,{children:"0xCAFE"}),", and ",(0,a.jsx)(s.code,{children:"10_000"})," are all valid numerical address literals."]}),"\n",(0,a.jsx)(s.p,{children:"To distinguish when an address is being used in an expression context or not, the syntax when using\nan address differs depending on the context where it's used:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["When an address is used as an expression, the address must be prefixed by the ",(0,a.jsx)(s.code,{children:"@"})," character, i.e.,\n",(0,a.jsx)(s.a,{href:"./integers",children:(0,a.jsx)(s.code,{children:"@<numerical_value>"})})," or ",(0,a.jsx)(s.code,{children:"@<named_address_identifier>"}),"."]}),"\n",(0,a.jsxs)(s.li,{children:["Outside of expression contexts, the address may be written without the leading ",(0,a.jsx)(s.code,{children:"@"})," character,\ni.e., ",(0,a.jsx)(s.a,{href:"./integers",children:(0,a.jsx)(s.code,{children:"<numerical_value>"})})," or ",(0,a.jsx)(s.code,{children:"<named_address_identifier>"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["In general, you can think of ",(0,a.jsx)(s.code,{children:"@"})," as an operator that takes an address from being a namespace item to\nbeing an expression item."]}),"\n",(0,a.jsx)(s.h2,{id:"named-addresses",children:"Named Addresses"}),"\n",(0,a.jsx)(s.p,{children:"Named addresses are a feature that allow identifiers to be used in place of numerical values in any\nspot where addresses are used, and not just at the value level. Named addresses are declared and\nbound as top level elements (outside of modules and scripts) in Move packages, or passed as\narguments to the Move compiler."}),"\n",(0,a.jsxs)(s.p,{children:["Named addresses only exist at the source language level and will be fully substituted for their\nvalue at the bytecode level. Because of this, modules and module members should be accessed through\nthe module's named address and not through the numerical value assigned to the named address during\ncompilation. So while ",(0,a.jsx)(s.code,{children:"use my_addr::foo"})," is equivalent to ",(0,a.jsx)(s.code,{children:"use 0x2::foo"})," (if ",(0,a.jsx)(s.code,{children:"my_addr"})," is assigned\n",(0,a.jsx)(s.code,{children:"0x2"}),"), it is a best practice to always use the ",(0,a.jsx)(s.code,{children:"my_addr"})," name."]}),"\n",(0,a.jsx)(s.h3,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-move",children:"// shorthand for\n// 0x0000000000000000000000000000000000000000000000000000000000000001\nlet a1: address = @0x1;\n// shorthand for\n// 0x0000000000000000000000000000000000000000000000000000000000000042\nlet a2: address = @0x42;\n// shorthand for\n// 0x00000000000000000000000000000000000000000000000000000000DEADBEEF\nlet a3: address = @0xDEADBEEF;\n// shorthand for\n// 0x000000000000000000000000000000000000000000000000000000000000000A\nlet a4: address = @0x0000000000000000000000000000000A;\n// Assigns `a5` the value of the named address `std`\nlet a5: address = @std;\n// Any valid numerical value can be used as an address\nlet a6: address = @66;\nlet a7: address = @42_000;\n\nmodule 66::some_module {   // Not in expression context, so no @ needed\n    use 0x1::other_module; // Not in expression context so no @ needed\n    use std::vector;       // Can use a named address as a namespace item\n    ...\n}\n\nmodule std::other_module {  // Can use a named address when declaring a module\n    ...\n}\n"})})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},5521:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>i});var d=n(6672);const a={},r=d.createContext(a);function t(e){const s=d.useContext(r);return d.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),d.createElement(r.Provider,{value:s},e.children)}}}]);