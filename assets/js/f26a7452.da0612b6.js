"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7692],{4811:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>a});var i=n(9378);const r={},t=i.createContext(r);function l(e){const s=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:s},e.children)}},8160:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"move-basics/primitive-types","title":"Primitive Types","description":"For simple values, Move has a number of built-in primitive types. They\'re the foundation for all","source":"@site/../book/move-basics/primitive-types.md","sourceDirName":"move-basics","slug":"/move-basics/primitive-types","permalink":"/move-basics/primitive-types","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.2. Comments","permalink":"/move-basics/comments"},"next":{"title":"5.4. Address Type","permalink":"/move-basics/address"}}');var r=n(2714),t=n(4811);const l={},a="Primitive Types",o={},d=[{value:"Variables and Assignment",id:"variables-and-assignment",level:2},{value:"Booleans",id:"booleans",level:2},{value:"Integer Types",id:"integer-types",level:2},{value:"Operations",id:"operations",level:3},{value:"Casting with <code>as</code>",id:"casting-with-as",level:3},{value:"Overflow",id:"overflow",level:3},{value:"Further Reading",id:"further-reading",level:2}];function c(e){const s={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"primitive-types",children:"Primitive Types"})}),"\n",(0,r.jsx)(s.p,{children:"For simple values, Move has a number of built-in primitive types. They're the foundation for all\nother types. The primitive types are:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"#booleans",children:"Booleans"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"#integer-types",children:"Unsigned Integers"})}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"./address",children:"Addresses"})," - covered in the next section"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Before we get to the primitive types, let's first take a look at how to declare and assign variables\nin Move."}),"\n",(0,r.jsx)(s.h2,{id:"variables-and-assignment",children:"Variables and Assignment"}),"\n",(0,r.jsxs)(s.p,{children:["Variables are declared using the ",(0,r.jsx)(s.code,{children:"let"})," keyword. They are immutable by default, but can be made\nmutable by adding the ",(0,r.jsx)(s.code,{children:"mut"})," keyword:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"let <variable_name>[: <type>]  = <expression>;\nlet mut <variable_name>[: <type>] = <expression>;\n"})}),"\n",(0,r.jsx)(s.p,{children:"Where:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"<variable_name>"})," - the name of the variable"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"<type>"})," - the type of the variable, optional"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"<expression>"})," - the value to be assigned to the variable"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/primitive-types.move anchor=variables_and_assignment",children:"let x: bool = true;\nlet mut y: u8 = 42;\n"})}),"\n",(0,r.jsxs)(s.p,{children:["A mutable variable can be reassigned using the ",(0,r.jsx)(s.code,{children:"="})," operator."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-move",children:"y = 43;\n"})}),"\n",(0,r.jsx)(s.p,{children:"Variables can also be shadowed by re-declaring them."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/primitive-types.move anchor=shadowing",children:"let x: u8 = 42;\nlet x: u16 = 42;\n"})}),"\n",(0,r.jsx)(s.h2,{id:"booleans",children:"Booleans"}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"bool"})," type represents a boolean value - yes or no, true or false. It has two possible values:\n",(0,r.jsx)(s.code,{children:"true"})," and ",(0,r.jsx)(s.code,{children:"false"}),", which are keywords in Move. For booleans, the compiler can always infer the type\nfrom the value, so there is no need to explicitly specify it."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/primitive-types.move anchor=boolean",children:"let x = true;\nlet y = false;\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Booleans are often used to store flags and to control the flow of the program. Please refer to the\n",(0,r.jsx)(s.a,{href:"./control-flow",children:"Control Flow"})," section for more information."]}),"\n",(0,r.jsx)(s.h2,{id:"integer-types",children:"Integer Types"}),"\n",(0,r.jsx)(s.p,{children:"Move supports unsigned integers of various sizes, from 8-bit to 256-bit. The integer types are:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"u8"})," - 8-bit"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"u16"})," - 16-bit"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"u32"})," - 32-bit"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"u64"})," - 64-bit"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"u128"})," - 128-bit"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"u256"})," - 256-bit"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/primitive-types.move anchor=integers",children:"let x: u8 = 42;\nlet y: u16 = 42;\n// ...\nlet z: u256 = 42;\n"})}),"\n",(0,r.jsxs)(s.p,{children:["While boolean literals like ",(0,r.jsx)(s.code,{children:"true"})," and ",(0,r.jsx)(s.code,{children:"false"})," are clearly booleans, an integer literal like ",(0,r.jsx)(s.code,{children:"42"}),"\ncould be any of the integer types. In most of the cases, the compiler will infer the type from the\nvalue, usually defaulting to ",(0,r.jsx)(s.code,{children:"u64"}),". However, sometimes the compiler is unable to infer the type and\nwill require an explicit type annotation. It can either be provided during assignment or by using a\ntype suffix."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/primitive-types.move anchor=integer_explicit_type",children:"// Both are equivalent\nlet x: u8 = 42;\nlet x = 42u8;\n"})}),"\n",(0,r.jsx)(s.h3,{id:"operations",children:"Operations"}),"\n",(0,r.jsx)(s.p,{children:"Move supports the standard arithmetic operations for integers: addition, subtraction,\nmultiplication, division, and modulus (remainder). The syntax for these operations is:"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Syntax"}),(0,r.jsx)(s.th,{children:"Operation"}),(0,r.jsx)(s.th,{children:"Aborts If"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"+"}),(0,r.jsx)(s.td,{children:"addition"}),(0,r.jsx)(s.td,{children:"Result is too large for the integer type"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"-"}),(0,r.jsx)(s.td,{children:"subtraction"}),(0,r.jsx)(s.td,{children:"Result is less than zero"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"*"}),(0,r.jsx)(s.td,{children:"multiplication"}),(0,r.jsx)(s.td,{children:"Result is too large for the integer type"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"%"}),(0,r.jsx)(s.td,{children:"modulus (remainder)"}),(0,r.jsx)(s.td,{children:"The divisor is 0"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"/"}),(0,r.jsx)(s.td,{children:"truncating division"}),(0,r.jsx)(s.td,{children:"The divisor is 0"})]})]})]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:["For more operations, including bitwise operations, please refer to the\n",(0,r.jsx)(s.a,{href:"./../../reference/primitive-types/integers#bitwise",children:"Move Reference"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["The types of the operands ",(0,r.jsx)(s.em,{children:"must match"}),", or the compiler will raise an error. The result of the\noperation will be of the same type as the operands. To perform operations on different types, the\noperands need to be cast to the same type."]}),"\n",(0,r.jsxs)(s.h3,{id:"casting-with-as",children:["Casting with ",(0,r.jsx)(s.code,{children:"as"})]}),"\n",(0,r.jsx)(s.p,{children:"Move supports explicit casting between integer types. The syntax is as follows:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-move",children:"<expression> as <type>\n"})}),"\n",(0,r.jsx)(s.p,{children:"Note that parentheses around the expression may be required to prevent ambiguity:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/primitive-types.move anchor=cast_as",children:"let x: u8 = 42;\nlet y: u16 = x as u16;\nlet z = 2 * (x as u16); // ambiguous, requires parentheses\n"})}),"\n",(0,r.jsx)(s.p,{children:"A more complex example, preventing overflow:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/primitive-types.move anchor=overflow",children:"let x: u8 = 255;\nlet y: u8 = 255;\nlet z: u16 = (x as u16) + ((y as u16) * 2);\n"})}),"\n",(0,r.jsx)(s.h3,{id:"overflow",children:"Overflow"}),"\n",(0,r.jsx)(s.p,{children:"Move does not support overflow / underflow; an operation that results in a value outside the range\nof the type will raise a runtime error. This is a safety feature to prevent unexpected behavior."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-move",children:"let x = 255u8;\nlet y = 1u8;\n\n// This will raise an error\nlet z = x + y;\n"})}),"\n",(0,r.jsx)(s.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"./../../reference/primitive-types/bool",children:"Bool"})," in the Move Reference."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"./../../reference/primitive-types/integers",children:"Integer"})," in the Move Reference."]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);