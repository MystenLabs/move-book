"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8068],{1897:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"guides/building-against-limits","title":"Building Against Limits","description":"To guarantee the safety and security of the network, Sui has certain limits and restrictions. These","source":"@site/../book/guides/building-against-limits.md","sourceDirName":"guides","slug":"/guides/building-against-limits","permalink":"/guides/building-against-limits","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"Upgradability Practices","permalink":"/guides/upgradeability-practices"},"next":{"title":"Better Error Handling","permalink":"/guides/better-error-handling"}}');var a=t(2714),s=t(4811);const r={},o="Building Against Limits",c={},d=[{value:"Transaction Size",id:"transaction-size",level:2},{value:"Object Size",id:"object-size",level:2},{value:"Single Pure Argument Size",id:"single-pure-argument-size",level:2},{value:"Maximum Number of Objects (and Dynamic Fields) Created",id:"maximum-number-of-objects-and-dynamic-fields-created",level:2},{value:"Maximum Number of Dynamic Fields Accessed",id:"maximum-number-of-dynamic-fields-accessed",level:2},{value:"Maximum Number of Events",id:"maximum-number-of-events",level:2}];function l(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"building-against-limits",children:"Building Against Limits"})}),"\n",(0,a.jsx)(i.p,{children:"To guarantee the safety and security of the network, Sui has certain limits and restrictions. These\nlimits are in place to prevent abuse and to ensure that the network remains stable and efficient.\nThis guide provides an overview of these limits and restrictions, and how to build your application\nto work within them."}),"\n",(0,a.jsx)(i.p,{children:"The limits are defined in the protocol configuration and are enforced by the network. If any of the\nlimits are exceeded, the transaction will either be rejected or aborted. The limits, being a part of\nthe protocol, can only be changed through a network upgrade."}),"\n",(0,a.jsx)(i.h2,{id:"transaction-size",children:"Transaction Size"}),"\n",(0,a.jsx)(i.p,{children:"The size of a transaction is limited to 128KB. This includes the size of the transaction payload,\nthe size of the transaction signature, and the size of the transaction metadata. If a transaction\nexceeds this limit, it will be rejected by the network."}),"\n",(0,a.jsx)(i.h2,{id:"object-size",children:"Object Size"}),"\n",(0,a.jsx)(i.p,{children:"The size of an object is limited to 256KB. This includes the size of the object data. If an object\nexceeds this limit, it will be rejected by the network. While a single object cannot bypass this\nlimit, for more extensive storage options, one could use a combination of a base object with other\nattached to it using dynamic fields (eg Bag)."}),"\n",(0,a.jsx)(i.h2,{id:"single-pure-argument-size",children:"Single Pure Argument Size"}),"\n",(0,a.jsxs)(i.p,{children:["The size of a single pure argument is limited to 16KB. A transaction argument bigger than this limit\nwill result in execution failure. So in order to create a vector of more than ~500 addresses (given\nthat a single address is 32 bytes), it needs to be joined dynamically either in Transaction Block or\nin a Move function. Standard functions like ",(0,a.jsx)(i.code,{children:"vector::append()"})," can join two vectors of ~16KB\nresulting in a ~32KB of data as a single value."]}),"\n",(0,a.jsx)(i.h2,{id:"maximum-number-of-objects-and-dynamic-fields-created",children:"Maximum Number of Objects (and Dynamic Fields) Created"}),"\n",(0,a.jsxs)(i.p,{children:["The maximum number of objects that can be created in a single transaction is 2048. If a transaction\nattempts to create more than 2048 objects, it will be rejected by the network. This also affects\n",(0,a.jsx)(i.a,{href:"/programmability/dynamic-fields",children:"dynamic fields"}),", as both the key and the value are objects.\nSo the maximum number of ",(0,a.jsx)(i.a,{href:"/programmability/dynamic-fields",children:"dynamic fields"})," that can be\ncreated in a single transaction is 1000. The limitation applies to dynamic object fields as well."]}),"\n",(0,a.jsx)(i.h2,{id:"maximum-number-of-dynamic-fields-accessed",children:"Maximum Number of Dynamic Fields Accessed"}),"\n",(0,a.jsx)(i.p,{children:"The maximum number of dynamic fields that can be accessed in a single transaction is 1000. If a\ntransaction attempts to access more than 1000 dynamic fields, it will be rejected by the network."}),"\n",(0,a.jsx)(i.h2,{id:"maximum-number-of-events",children:"Maximum Number of Events"}),"\n",(0,a.jsx)(i.p,{children:"The maximum number of events that can be emitted in a single transaction is 1024. If a transaction\nattempts to emit more than 1024 events, it will be aborted."})]})}function m(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},4811:(e,i,t)=>{t.d(i,{R:()=>r,x:()=>o});var n=t(9378);const a={},s=n.createContext(a);function r(e){const i=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(s.Provider,{value:i},e.children)}}}]);