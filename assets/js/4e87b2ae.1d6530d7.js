"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8851],{5521:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6672);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}},6626:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"move-basics/option","title":"Option","description":"Option is a type that represents an optional value which may or may not exist. The concept of","source":"@site/../book/move-basics/option.md","sourceDirName":"move-basics","slug":"/move-basics/option","permalink":"/move-basics/option","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.11. Vector","permalink":"/move-basics/vector"},"next":{"title":"5.13. String","permalink":"/move-basics/string"}}');var o=t(3420),s=t(5521);const r={},a="Option",c={},d=[{value:"In Practice",id:"in-practice",level:2},{value:"Creating and Using Option values",id:"creating-and-using-option-values",level:2},{value:"Further Reading",id:"further-reading",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"option",children:"Option"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Option"})," is a type that represents an optional value which may or may not exist. The concept of\n",(0,o.jsx)(n.code,{children:"Option"})," in Move is borrowed from Rust, and it is a very useful primitive in Move. ",(0,o.jsx)(n.code,{children:"Option"})," is\ndefined in the ",(0,o.jsx)(n.a,{href:"./standard-library",children:"Standard Library"}),", and is defined as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module std::option;\n\n/// Abstraction of a value that may or may not be present.\npublic struct Option<Element> has copy, drop, store {\n    vec: vector<Element>\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.em,{children:["See ",(0,o.jsx)(n.a,{href:"https://docs.sui.io/references/framework/std/option",children:"full documentation for std::option"})," module."]})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"The 'std::option' module is implicitly imported in every module, so you don't need to add an\nexplicit import."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Option"})," type is a generic type with an ",(0,o.jsx)(n.code,{children:"Element"})," type parameter. It contains a single field,\n",(0,o.jsx)(n.code,{children:"vec"}),", which is a ",(0,o.jsx)(n.code,{children:"vector"})," of ",(0,o.jsx)(n.code,{children:"Element"}),". The vector can have a length of 0 or 1, representing the\nabsence or presence of a value, respectively."]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["Note: You might be surprised that ",(0,o.jsx)(n.code,{children:"Option"})," is a ",(0,o.jsx)(n.code,{children:"struct"})," containing a ",(0,o.jsx)(n.code,{children:"vector"})," instead of an\n",(0,o.jsx)(n.a,{href:"./../../reference/enums",children:"enum"}),". This is for historical reasons: ",(0,o.jsx)(n.code,{children:"Option"})," was added to Move before it had\nsupport for enums."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Option"})," type has two variants: ",(0,o.jsx)(n.code,{children:"Some"})," and ",(0,o.jsx)(n.code,{children:"None"}),". The ",(0,o.jsx)(n.code,{children:"Some"})," variant contains a value, while\nthe ",(0,o.jsx)(n.code,{children:"None"})," variant represents the absence of a value. The ",(0,o.jsx)(n.code,{children:"Option"})," type is used to represent the\nabsence of a value in a type-safe way, avoiding the need for empty or ",(0,o.jsx)(n.code,{children:"undefined"})," values."]}),"\n",(0,o.jsx)(n.h2,{id:"in-practice",children:"In Practice"}),"\n",(0,o.jsxs)(n.p,{children:["To showcase why the ",(0,o.jsx)(n.code,{children:"Option"})," type is necessary, let's look at an example. Consider an application\nwhich takes a user input and stores it in a variable. Some fields are required, and some are\noptional. For example, a user's middle name is optional. While we could use an empty string to\nrepresent the absence of a middle name, it would require extra checks to differentiate between an\nempty string and a missing middle name. Instead, we can use the ",(0,o.jsx)(n.code,{children:"Option"})," type to represent the\nmiddle name."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/option.move anchor=registry",children:"module book::user_registry;\n\nuse std::string::String;\n\n/// A struct representing a user record.\npublic struct User has drop {\n    first_name: String,\n    middle_name: Option<String>,\n    last_name: String,\n}\n\n/// Create a new `User` struct with the given fields.\npublic fun register(\n    first_name: String,\n    middle_name: Option<String>,\n    last_name: String,\n): User {\n    User { first_name, middle_name, last_name }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In the previous example, the ",(0,o.jsx)(n.code,{children:"middle_name"})," field is of type ",(0,o.jsx)(n.code,{children:"Option<String>"}),". This means that the\n",(0,o.jsx)(n.code,{children:"middle_name"})," field can either contain a String value, wrapped in Some, or be explicitly empty,\nrepresented by None. Using the ",(0,o.jsx)(n.code,{children:"Option"})," type makes the optional nature of the field clear, avoiding\nambiguity and the need for extra checks to differentiate between an empty string and a missing\nmiddle name."]}),"\n",(0,o.jsx)(n.h2,{id:"creating-and-using-option-values",children:"Creating and Using Option values"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Option"})," type, along with the ",(0,o.jsx)(n.code,{children:"std::option"})," module, is implicitly imported in Move. This means\nyou can use the ",(0,o.jsx)(n.code,{children:"Option"})," type directly without needing a ",(0,o.jsx)(n.code,{children:"use"})," statement."]}),"\n",(0,o.jsxs)(n.p,{children:["To create a value of the ",(0,o.jsx)(n.code,{children:"Option"})," type, you can use the ",(0,o.jsx)(n.code,{children:"option::some"})," or ",(0,o.jsx)(n.code,{children:"option::none"})," methods.\n",(0,o.jsx)(n.code,{children:"Option"})," values also support several operations (borrowing will be discussed in the\n",(0,o.jsx)(n.a,{href:"references#references-1",children:"references"})," chapter):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/option.move anchor=usage",children:'// `option::some` creates an `Option` value with a value.\nlet mut opt = option::some(b"Alice");\n\n// `option::none` creates an `Option` without a value. We need to specify the\n// type since it can\'t be inferred from context.\nlet empty : Option<u64> = option::none();\n\n// `option.is_some()` returns true if option contains a value.\nassert!(opt.is_some());\nassert!(empty.is_none());\n\n// internal value can be `borrow`ed and `borrow_mut`ed.\nassert!(opt.borrow() == &b"Alice");\n\n// `option.extract` takes the value out of the option, leaving the option empty.\nlet inner = opt.extract();\n\n// `option.is_none()` returns true if option is None.\nassert!(opt.is_none());\n'})}),"\n",(0,o.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"https://docs.sui.io/references/framework/std/option",children:"std::option"})," in the standard library"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);