"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6043],{5521:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var t=s(6672);const r={},a=t.createContext(r);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(a.Provider,{value:n},e.children)}},8349:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"move-basics/references","title":"References","description":"\x3c!--","source":"@site/../book/move-basics/references.md","sourceDirName":"move-basics","slug":"/move-basics/references","permalink":"/move-basics/references","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.22. Ability: Copy","permalink":"/move-basics/copy-ability"},"next":{"title":"5.24. Generics","permalink":"/move-basics/generics"}}');var r=s(3420),a=s(5521);const i={},o="References",c={},l=[{value:"Layout",id:"layout",level:2},{value:"References",id:"references-1",level:2},{value:"Mutable Reference",id:"mutable-reference",level:2},{value:"Passing by Value",id:"passing-by-value",level:2},{value:"Full Example",id:"full-example",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"references",children:"References"})}),"\n",(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.a,{href:"./ownership-and-scope",children:"Ownership and Scope"})," section, we explained that when a value is\npassed to a function, it is ",(0,r.jsx)(n.em,{children:"moved"})," to the function's scope. This means that the function becomes\nthe owner of the value, and the original scope (owner) can no longer use it. This is an important\nconcept in Move, as it ensures that the value is not used in multiple places at the same time.\nHowever, there are use cases when we want to pass a value to a function but retain ownership. This\nis where references come into play."]}),"\n",(0,r.jsx)(n.p,{children:"To illustrate this, let's consider a simple example - an application for a metro (subway) pass. We\nwill look at 4 different scenarios where a card can be:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Purchased at a kiosk for a fixed price"}),"\n",(0,r.jsx)(n.li,{children:"Shown to an inspector to prove that the passenger has a valid pass"}),"\n",(0,r.jsx)(n.li,{children:"Used at the turnstile to enter the metro, and purchase a ride"}),"\n",(0,r.jsx)(n.li,{children:"Recycled after it's empty"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"layout",children:"Layout"}),"\n",(0,r.jsxs)(n.p,{children:["The initial layout of the metro pass application is simple. We define the ",(0,r.jsx)(n.code,{children:"Card"})," type and the ",(0,r.jsx)(n.code,{children:"USES"}),"\n",(0,r.jsx)(n.a,{href:"./constants",children:"constant"})," that represents the number of rides on a single card. We also add\n",(0,r.jsx)(n.a,{href:"./assert-and-abort#error-constants",children:"error constants"})," for the case when the card is empty and when the card is not empty."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/references.move anchor=header_new",children:"module book::metro_pass;\n\n/// Error code for when the card is empty.\nconst ENoUses: u64 = 0;\n/// Error code for when the card is not empty.\nconst EHasUses: u64 = 1;\n\n/// Number of uses for a metro pass card.\nconst USES: u8 = 3;\n\n/// A metro pass card\npublic struct Card { uses: u8 }\n\n/// Purchase a metro pass card.\npublic fun purchase(/* pass a Coin */): Card {\n    Card { uses: USES }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"references-1",children:"References"}),"\n",(0,r.jsxs)(n.p,{children:["References are a way to ",(0,r.jsx)(n.em,{children:"show"})," a value to a function without giving up ownership. In our case, when\nwe show the Card to the inspector, we don't want to give up ownership of it, and we don't allow the\ninspector to use up any of our rides. We just want to allow the ",(0,r.jsx)(n.em,{children:"reading"})," of the value of our Card\nand to prove its ownership."]}),"\n",(0,r.jsxs)(n.p,{children:["To do so, in the function signature, we use the ",(0,r.jsx)(n.code,{children:"&"})," symbol to indicate that we are passing a\n",(0,r.jsx)(n.em,{children:"reference"})," to the value, not the value itself."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/references.move anchor=immutable",children:"/// Show the metro pass card to the inspector.\npublic fun is_valid(card: &Card): bool {\n    card.uses > 0\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Because the function does not take ownership of the Card, it can ",(0,r.jsx)(n.em,{children:"read"})," its data but cannot ",(0,r.jsx)(n.em,{children:"write"}),"\nto it, meaning it cannot modify the number of rides. Additionally, the function signature ensures\nthat it cannot be called without a Card instance. This is an important property that allows the\n",(0,r.jsx)(n.a,{href:"./../programmability/capability",children:"Capability Pattern"}),", which we will cover in the next chapters."]}),"\n",(0,r.jsxs)(n.p,{children:['Creating a reference to a value is often referred to as "borrowing" the value. For example, the\nmethod to get a reference to the value wrapped by an ',(0,r.jsx)(n.code,{children:"Option"})," is called ",(0,r.jsx)(n.code,{children:"borrow"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"mutable-reference",children:"Mutable Reference"}),"\n",(0,r.jsxs)(n.p,{children:["In some cases, we want to allow the function to modify the Card. For example, when using the Card at\na turnstile, we need to deduct a ride. To achieve this, we use the ",(0,r.jsx)(n.code,{children:"&mut"})," keyword in the function\nsignature."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/references.move anchor=mutable",children:"/// Use the metro pass card at the turnstile to enter the metro.\npublic fun enter_metro(card: &mut Card) {\n    assert!(card.uses > 0, ENoUses);\n    card.uses = card.uses - 1;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["As you can see in the function body, the ",(0,r.jsx)(n.code,{children:"&mut"})," reference allows mutating the value, and the\nfunction can spend rides."]}),"\n",(0,r.jsx)(n.h2,{id:"passing-by-value",children:"Passing by Value"}),"\n",(0,r.jsx)(n.p,{children:"Lastly, let's illustrate what happens when we pass the value itself to the function. In this case,\nthe function takes the ownership of the value, making it inaccessible in the original scope. The\nowner of the Card can recycle it and thereby relinquish ownership to the function."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/references.move anchor=move",children:"/// Recycle the metro pass card.\npublic fun recycle(card: Card) {\n    assert!(card.uses == 0, EHasUses);\n    let Card { uses: _ } = card;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.code,{children:"recycle"})," function, the Card is passed by value, transferring ownership to the function. This\nallows it to be unpacked and destroyed."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Note: In Move, ",(0,r.jsx)(n.code,{children:"_"})," is a wildcard pattern used in destructuring to ignore a field while still\nconsuming the value. Destructuring must match all fields in a struct type. If a struct has fields,\nyou must list all of them explicitly or use ",(0,r.jsx)(n.code,{children:"_"})," to ignore unwanted fields."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"full-example",children:"Full Example"}),"\n",(0,r.jsx)(n.p,{children:"To illustrate the full flow of the application, let's put all the pieces together in a test."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/references.move anchor=move_2024",children:"#[test]\nfun test_card_2024() {\n    // declaring variable as mutable because we modify it\n    let mut card = purchase();\n\n    card.enter_metro(); // modify the card but don't move it\n    assert!(card.is_valid()); // read the card!\n\n    card.enter_metro(); // modify the card but don't move it\n    card.enter_metro(); // modify the card but don't move it\n\n    card.recycle(); // move the card out of the scope\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/reference/primitive-types/references",children:"References"})," in the Move\nReference."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);