"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6305],{5521:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>t});var s=o(6672);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}},7801:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"move-basics/ownership-and-scope","title":"Ownership and Scope","description":"Every variable in Move has a scope and an owner. The scope is the range of code where the variable","source":"@site/../book/move-basics/ownership-and-scope.md","sourceDirName":"move-basics","slug":"/move-basics/ownership-and-scope","permalink":"/move-basics/ownership-and-scope","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.20. Visibility Modifiers","permalink":"/move-basics/visibility"},"next":{"title":"5.22. Ability: Copy","permalink":"/move-basics/copy-ability"}}');var r=o(3420),a=o(5521);const i={},t="Ownership and Scope",c={},l=[{value:"Ownership",id:"ownership",level:2},{value:"Returning a Value",id:"returning-a-value",level:2},{value:"Passing by Value",id:"passing-by-value",level:2},{value:"Scopes with Blocks",id:"scopes-with-blocks",level:2},{value:"Copyable Types",id:"copyable-types",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"ownership-and-scope",children:"Ownership and Scope"})}),"\n",(0,r.jsx)(n.p,{children:"Every variable in Move has a scope and an owner. The scope is the range of code where the variable\nis valid, and the owner is the scope that this variable belongs to. Once the owner scope ends, the\nvariable is dropped. This is a fundamental concept in Move, and it is important to understand how it\nworks."}),"\n",(0,r.jsx)(n.h2,{id:"ownership",children:"Ownership"}),"\n",(0,r.jsx)(n.p,{children:"A variable defined in a function scope is owned by this scope. The runtime goes through the function\nscope and executes every expression and statement. After the function scope ends, the variables\ndefined in it are dropped or deallocated."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module book::ownership;\n\npublic fun owner() {\n    let a = 1; // a is owned by the `owner` function\n} // a is dropped here\n\npublic fun other() {\n    let b = 2; // b is owned by the `other` function\n} // b is dropped here\n\n#[test]\nfun test_owner() {\n    owner();\n    other();\n    // a & b are not valid here\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the example above, the variable ",(0,r.jsx)(n.code,{children:"a"})," is owned by the ",(0,r.jsx)(n.code,{children:"owner"})," function, and the variable ",(0,r.jsx)(n.code,{children:"b"})," is\nowned by the ",(0,r.jsx)(n.code,{children:"other"})," function. When each of these functions are called, the variables are defined,\nand when the function ends, the variables are discarded."]}),"\n",(0,r.jsx)(n.h2,{id:"returning-a-value",children:"Returning a Value"}),"\n",(0,r.jsxs)(n.p,{children:["If we changed the ",(0,r.jsx)(n.code,{children:"owner"})," function to return the variable ",(0,r.jsx)(n.code,{children:"a"}),", then the ownership of ",(0,r.jsx)(n.code,{children:"a"})," would be\ntransferred to the caller of the function."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module book::ownership;\n\npublic fun owner(): u8 {\n    let a = 1; // a defined here\n    a // scope ends, a is returned\n}\n\n#[test]\nfun test_owner() {\n    let a = owner();\n    // a is valid here\n} // a is dropped here\n"})}),"\n",(0,r.jsx)(n.h2,{id:"passing-by-value",children:"Passing by Value"}),"\n",(0,r.jsxs)(n.p,{children:["Additionally, if we passed the variable ",(0,r.jsx)(n.code,{children:"a"})," to another function, the ownership of ",(0,r.jsx)(n.code,{children:"a"})," would be\ntransferred to this function. When performing this operation, we ",(0,r.jsx)(n.em,{children:"move"})," the value from one scope to\nanother. This is also called ",(0,r.jsx)(n.em,{children:"move semantics"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module book::ownership;\n\npublic fun owner(): u8 {\n    let a = 10;\n    a\n} // a is returned\n\npublic fun take_ownership(v: u8) {\n    // v is owned by `take_ownership`\n} // v is dropped here\n\n#[test]\nfun test_owner() {\n    let a = owner();\n    take_ownership(a);\n    // a is not valid here\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"scopes-with-blocks",children:"Scopes with Blocks"}),"\n",(0,r.jsx)(n.p,{children:"Each function has a main scope, and it can also have sub-scopes via the use of blocks. A block is a\nsequence of statements and expressions, and it has its own scope. Variables defined in a block are\nowned by this block, and when the block ends, the variables are dropped."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module book::ownership;\n\npublic fun owner() {\n    let a = 1; // a is owned by the `owner` function's scope\n    {\n        let b = 2; // the block that declares b owns it\n        {\n            let c = 3; // the block that declares c owns it\n        }; // c is dropped here\n    }; // b is dropped here\n    // a = b; // error: b is not valid here\n    // a = c; // error: c is not valid here\n} // a is dropped here\n"})}),"\n",(0,r.jsx)(n.p,{children:"However, if we return a value from a block, the ownership of the variable is transferred to the\ncaller of the block."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module book::ownership;\n\npublic fun owner(): u8 {\n    let a = 1; // a is owned by the `owner` function's scope\n    let b = {\n        let c = 2; // the block that declares c owns it\n        c // c is returned from the block and transferred to b\n    };\n    a + b // both a and b are valid here\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"copyable-types",children:"Copyable Types"}),"\n",(0,r.jsxs)(n.p,{children:["Some types in Move are ",(0,r.jsx)(n.em,{children:"copyable"}),", which means that they can be copied without transferring\nownership. This is useful for types that are small and cheap to copy, such as integers and booleans.\nThe Move compiler will automatically copy these types when they are passed to or returned from a\nfunction, or when they're ",(0,r.jsx)(n.em,{children:"moved"})," to another scope and then accessed in their original scope."]}),"\n",(0,r.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"./../../reference/variables",children:"Local Variables and Scopes"})," in the Move Reference."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);