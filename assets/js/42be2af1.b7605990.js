"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3230],{1083:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>i,default:()=>d,frontMatter:()=>c,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"object/fast-path-and-consensus","title":"Fast Path & Consensus","description":"The Object Model allows for variable transaction execution paths, depending on the object\'s","source":"@site/../book/object/fast-path-and-consensus.md","sourceDirName":"object","slug":"/object/fast-path-and-consensus","permalink":"/object/fast-path-and-consensus","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"6.4. Ownership","permalink":"/object/ownership"},"next":{"title":"Using Objects","permalink":"/storage/"}}');var o=t(3420),a=t(5521);const c={},i="Fast Path & Consensus",r={},h=[{value:"Concurrency Challenge",id:"concurrency-challenge",level:2},{value:"Fast Path",id:"fast-path",level:2},{value:"Consensus Path",id:"consensus-path",level:2},{value:"Objects owned by Objects",id:"objects-owned-by-objects",level:2},{value:"Summary",id:"summary",level:2}];function l(e){const n={em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"fast-path--consensus",children:"Fast Path & Consensus"})}),"\n",(0,o.jsx)(n.p,{children:"The Object Model allows for variable transaction execution paths, depending on the object's\nownership type. The transaction execution path determines how the transaction is processed and\nvalidated by the network. In this section, we'll explore the different transaction execution paths\nin Sui and how they interact with the consensus mechanism."}),"\n",(0,o.jsx)(n.h2,{id:"concurrency-challenge",children:"Concurrency Challenge"}),"\n",(0,o.jsx)(n.p,{children:"At its core, blockchain technology faces a fundamental concurrency challenge: multiple parties may\ntry to modify or access the same data simultaneously in a decentralized environment. This requires a\nsystem for sequencing and validating transactions to support the network's consistency. Sui\naddresses this challenge through a consensus mechanism, ensuring all nodes agree on the\ntransactions' sequence and state."}),"\n",(0,o.jsx)(n.p,{children:"Consider a marketplace scenario where Alice and Bob simultaneously attempt to purchase the same\nasset. The network must resolve this conflict to prevent double-spending, ensuring that at most one\ntransaction succeeds while the other is rightfully rejected."}),"\n",(0,o.jsx)(n.h2,{id:"fast-path",children:"Fast Path"}),"\n",(0,o.jsxs)(n.p,{children:["However, not all transactions require the same level of validation and consensus. For example, if\nAlice wants to transfer an object that she owns to Bob, the network can process this transaction\nwithout sequencing it with respect to all other transactions in the network, as only Alice has the\nauthority to access the object. This is known as the ",(0,o.jsx)(n.em,{children:"fast path"})," execution, where transactions\naccessing account-owned objects are processed quickly without the need for extensive consensus. No\nconcurrent data access -> simpler challenge -> fast path."]}),"\n",(0,o.jsxs)(n.p,{children:["Another ownership model that allows for fast path execution is the ",(0,o.jsx)(n.em,{children:"immutable state"}),". Since\nimmutable objects cannot change, transactions involving them can be processed quickly without the\nneed to sequence them."]}),"\n",(0,o.jsx)(n.h2,{id:"consensus-path",children:"Consensus Path"}),"\n",(0,o.jsxs)(n.p,{children:["Transactions that do access shared state - on Sui it is represented with shared objects - require\nsequencing to ensure that the state is updated and consistent across all nodes. This is known as the\nexecution through ",(0,o.jsx)(n.em,{children:"consensus"}),", where transactions accessing shared objects are subject to the\nagreement process to maintain network consistency."]}),"\n",(0,o.jsx)(n.h2,{id:"objects-owned-by-objects",children:"Objects owned by Objects"}),"\n",(0,o.jsxs)(n.p,{children:["Lastly, it is important to mention that objects owned by other objects are subject to the same rules\nas the parent object. If the parent object is ",(0,o.jsx)(n.em,{children:"shared"}),", the child object is also transitively\nshared. If the parent object is immutable, the child object is also immutable."]}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Fast Path:"})," Transactions involving account-owned objects or immutable shared state are\nprocessed quickly without the need for extensive consensus."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Consensus Path:"})," Transactions involving shared objects require sequencing and consensus to\nensure network integrity."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Objects owned by Objects:"})," Child objects inherit the ownership model of the parent object."]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},5521:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>i});var s=t(6672);const o={},a=s.createContext(o);function c(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);