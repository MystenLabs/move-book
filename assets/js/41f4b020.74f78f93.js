"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9620],{3398:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"storage/uid-and-id","title":"UID and ID","description":"The UID type is defined in the sui::object module and is a wrapper around an ID which, in","source":"@site/../book/storage/uid-and-id.md","sourceDirName":"storage","slug":"/storage/uid-and-id","permalink":"/storage/uid-and-id","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"7.3. Ability: Store","permalink":"/storage/store-ability"},"next":{"title":"7.5. Transfer Restrictions","permalink":"/storage/transfer-restrictions"}}');var s=t(3420),r=t(5521);const d={},a="UID and ID",o={},c=[{value:"Fresh UID Generation:",id:"fresh-uid-generation",level:2},{value:"UID Lifecycle",id:"uid-lifecycle",level:2},{value:"Keeping the UID",id:"keeping-the-uid",level:2},{value:"Proof of Deletion",id:"proof-of-deletion",level:2},{value:"ID",id:"id",level:2},{value:"fresh_object_address",id:"fresh_object_address",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"uid-and-id",children:"UID and ID"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"UID"})," type is defined in the ",(0,s.jsx)(n.code,{children:"sui::object"})," module and is a wrapper around an ",(0,s.jsx)(n.code,{children:"ID"})," which, in\nturn, wraps the ",(0,s.jsx)(n.code,{children:"address"})," type. The UIDs on Sui are guaranteed to be unique, and can't be reused\nafter the object was deleted."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module sui::object;\n\n/// UID is a unique identifier of an object\npublic struct UID has store {\n    id: ID\n}\n\n/// ID is a wrapper around an address\npublic struct ID has store, drop {\n    bytes: address\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"fresh-uid-generation",children:"Fresh UID Generation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["UID is derived from the ",(0,s.jsx)(n.code,{children:"tx_hash"})," and an ",(0,s.jsx)(n.code,{children:"index"})," which is incremented for each new UID."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"derive_id"})," function is implemented in the ",(0,s.jsx)(n.code,{children:"sui::tx_context"})," module, and that is why TxContext\nis required for UID generation."]}),"\n",(0,s.jsx)(n.li,{children:"Sui Verifier will not allow using a UID that wasn't created in the same function. That prevents\nUIDs from being pre-generated and reused after the object was unpacked."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["New UID is created with the ",(0,s.jsx)(n.code,{children:"object::new(ctx)"})," function. It takes a mutable reference to TxContext,\nand returns a new UID."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let ctx = &mut tx_context::dummy();\nlet uid = object::new(ctx);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["On Sui, ",(0,s.jsx)(n.code,{children:"UID"})," acts as a representation of an object, and allows defining behaviors and features of\nan object. One of the key features - ",(0,s.jsx)(n.a,{href:"./../programmability/dynamic-fields",children:"Dynamic Fields"})," - is\npossible because of the ",(0,s.jsx)(n.code,{children:"UID"})," type being explicit. Additionally, it allows the\n",(0,s.jsx)(n.a,{href:"https://docs.sui.io/concepts/transfers/transfer-to-object",children:"Transfer to Object (TTO)"}),", which we will\nexplain later in this chapter."]}),"\n",(0,s.jsx)(n.h2,{id:"uid-lifecycle",children:"UID Lifecycle"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"UID"})," type is created with the ",(0,s.jsx)(n.code,{children:"object::new(ctx)"})," function, and it is destroyed with the\n",(0,s.jsx)(n.code,{children:"object::delete(uid)"})," function. The ",(0,s.jsx)(n.code,{children:"object::delete"})," consumes the UID ",(0,s.jsx)(n.em,{children:"by value"}),", and it is\nimpossible to delete it unless the value was unpacked from an Object."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let ctx = &mut tx_context::dummy();\n\nlet char = Character {\n    id: object::new(ctx)\n};\n\nlet Character { id } = char;\nid.delete();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"keeping-the-uid",children:"Keeping the UID"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"UID"})," does not need to be deleted immediately after the object struct is unpacked. Sometimes it\nmay carry ",(0,s.jsx)(n.a,{href:"./../programmability/dynamic-fields",children:"Dynamic Fields"})," or objects transferred to it via\n",(0,s.jsx)(n.a,{href:"./transfer-to-object",children:"Transfer To Object"}),". In such cases, the UID may be kept and stored in a\nseparate object."]}),"\n",(0,s.jsx)(n.h2,{id:"proof-of-deletion",children:"Proof of Deletion"}),"\n",(0,s.jsxs)(n.p,{children:["The ability to return the UID of an object may be utilized in pattern called ",(0,s.jsx)(n.em,{children:"proof of deletion"}),". It\nis a rarely used technique, but it may be useful in some cases, for example, the creator or an\napplication may incentivize the deletion of an object by exchanging the deleted IDs for some reward."]}),"\n",(0,s.jsx)(n.p,{children:'In framework development this method could be used to ignore / bypass certain restrictions on\n"taking" the object. If there\'s a container that enforces certain logic on transfers, like Kiosk\ndoes, there could be a special scenario of skipping the checks by providing a proof of deletion.'}),"\n",(0,s.jsx)(n.p,{children:"This is one of the open topics for exploration and research, and it may be used in various ways."}),"\n",(0,s.jsx)(n.h2,{id:"id",children:"ID"}),"\n",(0,s.jsxs)(n.p,{children:["When talking about ",(0,s.jsx)(n.code,{children:"UID"})," we should also mention the ",(0,s.jsx)(n.code,{children:"ID"})," type. It is a wrapper around the ",(0,s.jsx)(n.code,{children:"address"}),"\ntype, and is used to represent an address-pointer. Usually, ",(0,s.jsx)(n.code,{children:"ID"})," is used to point at an object,\nhowever, there's no restriction, and no guarantee that the ",(0,s.jsx)(n.code,{children:"ID"})," points to an existing object."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["ID can be received as a transaction argument in a\n",(0,s.jsx)(n.a,{href:"./../concepts/what-is-a-transaction",children:"Transaction Block"}),". Alternatively, ID can be created from\nan ",(0,s.jsx)(n.code,{children:"address"})," value using ",(0,s.jsx)(n.code,{children:"to_id()"})," function."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"fresh_object_address",children:"fresh_object_address"}),"\n",(0,s.jsxs)(n.p,{children:["TxContext provides the ",(0,s.jsx)(n.code,{children:"fresh_object_address"})," function which can be utilized to create unique\naddresses and ",(0,s.jsx)(n.code,{children:"ID"})," - it may be useful in some application that assign unique identifiers to user\nactions - for example, an order_id in a marketplace."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},5521:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>a});var i=t(6672);const s={},r=i.createContext(s);function d(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);