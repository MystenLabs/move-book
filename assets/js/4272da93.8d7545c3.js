"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9667],{4773:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"programmability/wrapper-type-pattern","title":"Pattern: Wrapper type","description":"Sometimes, there\u2019s a need to create a new type that behaves similarly to an existing type but with","source":"@site/../book/programmability/wrapper-type-pattern.md","sourceDirName":"programmability","slug":"/programmability/wrapper-type-pattern","permalink":"/programmability/wrapper-type-pattern","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"8.6. Collections","permalink":"/programmability/collections"},"next":{"title":"8.8. Dynamic Fields","permalink":"/programmability/dynamic-fields"}}');var a=n(2714),r=n(4811);const o={},s="Pattern: Wrapper type",c={},l=[{value:"Definition",id:"definition",level:2},{value:"Common Practices",id:"common-practices",level:2},{value:"Advantages",id:"advantages",level:2},{value:"Disadvantages",id:"disadvantages",level:2},{value:"Next Steps",id:"next-steps",level:2}];function p(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"pattern-wrapper-type",children:"Pattern: Wrapper type"})}),"\n",(0,a.jsxs)(t.p,{children:["Sometimes, there\u2019s a need to create a new type that behaves similarly to an existing type but with\ncertain modifications or restrictions. For example, you might want to create a\n",(0,a.jsx)(t.a,{href:"./collections",children:"collection type"})," that behaves like a vector but doesn\u2019t allow modifying the elements\nafter they\u2019ve been inserted. The wrapper type pattern is an effective way to achieve this."]}),"\n",(0,a.jsx)(t.h2,{id:"definition",children:"Definition"}),"\n",(0,a.jsx)(t.p,{children:"The wrapper type pattern is a design pattern in which you create a new type that wraps an existing\ntype. The wrapper type is distinct from the original but can be converted to and from it."}),"\n",(0,a.jsx)(t.p,{children:"Often, it is implemented as a positional struct with a single field."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/wrapper-type-pattern.move anchor=main",children:"module book::wrapper_type_pattern;\n\n/// Very simple stack implementation using the wrapper type pattern. Does not allow\n/// accessing the elements unless they are popped.\npublic struct Stack<T>(vector<T>) has copy, store, drop;\n\n/// Create a new instance by wrapping the value.\npublic fun new<T>(value: vector<T>): Stack<T> {\n    Stack(value)\n}\n\n/// Push an element to the stack.\npublic fun push_back<T>(v: &mut Stack<T>, el: T) {\n    v.0.push_back(el);\n}\n\n/// Pop an element from the stack. Unlike `vector`, this function won't\n/// fail if the stack is empty and will return `None` instead.\npublic fun pop_back<T>(v: &mut Stack<T>): Option<T> {\n    if (v.0.length() == 0) option::none()\n    else option::some(v.0.pop_back())\n}\n\n/// Get the size of the stack.\npublic fun size<T>(v: &Stack<T>): u64 {\n    v.0.length()\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"common-practices",children:"Common Practices"}),"\n",(0,a.jsxs)(t.p,{children:["In cases where the goal is to extend the behavior of an existing type, it is common to provide\naccessors for the wrapped type. This approach allows users to access the underlying type directly\nwhen needed. For example, in the following code, we provide the ",(0,a.jsx)(t.code,{children:"inner()"}),", ",(0,a.jsx)(t.code,{children:"inner_mut()"}),", and\n",(0,a.jsx)(t.code,{children:"into_inner()"})," methods for the Stack type."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/wrapper-type-pattern.move anchor=common",children:"/// Allows reading the contents of the `Stack`.\npublic fun inner<T>(v: &Stack<T>): &vector<T> { &v.0 }\n\n/// Allows mutable access to the contents of the `Stack`.\npublic fun inner_mut<T>(v: &mut Stack<T>): &mut vector<T> { &mut v.0 }\n\n/// Unpacks the `Stack` into the underlying `vector`.\npublic fun into_inner<T>(v: Stack<T>): vector<T> {\n    let Stack(inner) = v;\n    inner\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"advantages",children:"Advantages"}),"\n",(0,a.jsx)(t.p,{children:"The wrapper type pattern offers several benefits:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Custom Functions: It allows you to define custom functions for an existing type."}),"\n",(0,a.jsx)(t.li,{children:"Robust Function Signatures: It constrains function signatures to the new type, thereby making the\ncode more robust."}),"\n",(0,a.jsx)(t.li,{children:"Improved Readability: It often increases the readability of the code by providing a more\ndescriptive type name."}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"disadvantages",children:"Disadvantages"}),"\n",(0,a.jsx)(t.p,{children:"The wrapper type pattern is powerful in two scenarios\u2014when you want to limit the behavior of an\nexisting type while providing a custom interface to the same data structure, and when you want to\nextend the behavior of an existing type. However, it does have some limitations:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Verbosity: It can be verbose to implement, especially if you want to expose all the methods of the\nwrapped type."}),"\n",(0,a.jsx)(t.li,{children:"Sparse Implementation: The implementation can be quite minimal, as it often just forwards calls to\nthe wrapped type."}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(t.p,{children:["The wrapper type pattern is very useful, particularly when used in conjunction with collection\ntypes, as demonstrated in the previous section. In the next section, we will cover\n",(0,a.jsx)(t.a,{href:"./dynamic-fields",children:"Dynamic Fields"})," \u2014 an important primitive that enables\n",(0,a.jsx)(t.a,{href:"./dynamic-collections",children:"Dynamic Collections"}),", a way to store large collections of data in a more\nflexible, albeit more expensive, way."]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},4811:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var i=n(9378);const a={},r=i.createContext(a);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);