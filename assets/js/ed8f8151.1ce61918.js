"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6861],{720:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"variables","title":"Local Variables and Scope | Reference","description":"","source":"@site/../reference/variables.md","sourceDirName":".","slug":"/variables","permalink":"/reference/variables","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Local Variables and Scope | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"2.6 Tuples and Unit","permalink":"/reference/primitive-types/tuples"},"next":{"title":"4. Equality","permalink":"/reference/equality"}}');var i=l(3420),a=l(5521);const r={title:"Local Variables and Scope | Reference",description:""},t="Local Variables and Scope",c={},o=[{value:"Declaring Local Variables",id:"declaring-local-variables",level:2},{value:"<code>let</code> bindings",id:"let-bindings",level:3},{value:"Variables must be assigned before use",id:"variables-must-be-assigned-before-use",level:3},{value:"Valid variable names",id:"valid-variable-names",level:3},{value:"Type annotations",id:"type-annotations",level:3},{value:"When annotations are necessary",id:"when-annotations-are-necessary",level:3},{value:"Multiple declarations with tuples",id:"multiple-declarations-with-tuples",level:3},{value:"Multiple declarations with structs",id:"multiple-declarations-with-structs",level:3},{value:"Destructuring against references",id:"destructuring-against-references",level:3},{value:"Ignoring Values",id:"ignoring-values",level:3},{value:"General <code>let</code> grammar",id:"general-let-grammar",level:3},{value:"Mutations",id:"mutations",level:2},{value:"Assignments",id:"assignments",level:3},{value:"Mutating through a reference",id:"mutating-through-a-reference",level:3},{value:"Scopes",id:"scopes",level:2},{value:"Expression Blocks",id:"expression-blocks",level:3},{value:"Shadowing",id:"shadowing",level:3},{value:"Move and Copy",id:"move-and-copy",level:2},{value:"Safety",id:"safety",level:3},{value:"Inference",id:"inference",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"local-variables-and-scope",children:"Local Variables and Scope"})}),"\n",(0,i.jsxs)(n.p,{children:["Local variables in Move are lexically (statically) scoped. New variables are introduced with the\nkeyword ",(0,i.jsx)(n.code,{children:"let"}),", which will shadow any previous local with the same name. Locals marked as ",(0,i.jsx)(n.code,{children:"mut"})," are\nmutable and can be updated both directly and via a mutable reference."]}),"\n",(0,i.jsx)(n.h2,{id:"declaring-local-variables",children:"Declaring Local Variables"}),"\n",(0,i.jsxs)(n.h3,{id:"let-bindings",children:[(0,i.jsx)(n.code,{children:"let"})," bindings"]}),"\n",(0,i.jsxs)(n.p,{children:["Move programs use ",(0,i.jsx)(n.code,{children:"let"})," to bind variable names to values:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let x = 1;\nlet y = x + x;\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"let"})," can also be used without binding a value to the local."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let x;\n"})}),"\n",(0,i.jsx)(n.p,{children:"The local can then be assigned a value later."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let x;\nif (cond) {\n  x = 1\n} else {\n  x = 0\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This can be very helpful when trying to extract a value from a loop when a default value cannot be\nprovided."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let x;\nlet mut i = 0;\nloop {\n    let (res, cond) = foo(i);\n    if (!cond) {\n        x = res;\n        break\n    };\n    i = i + 1;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To modify a local variable ",(0,i.jsx)(n.em,{children:"after"})," it is assigned, or to borrow it mutably ",(0,i.jsx)(n.code,{children:"&mut"}),", it must be\ndeclared as ",(0,i.jsx)(n.code,{children:"mut"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let mut x = 0;\nif (cond) x = x + 1;\nfoo(&mut x);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For more details see the section on ",(0,i.jsx)(n.a,{href:"#assignments",children:"assignments"})," below."]}),"\n",(0,i.jsx)(n.h3,{id:"variables-must-be-assigned-before-use",children:"Variables must be assigned before use"}),"\n",(0,i.jsx)(n.p,{children:"Move's type system prevents a local variable from being used before it has been assigned."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let x;\n// highlight-error\nx + x // ERROR! x is used before being assigned\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let x;\nif (cond) x = 0;\n// highlight-error\nx + x // ERROR! x does not have a value in all cases\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let x;\nwhile (cond) x = 0;\n// highlight-error\nx + x // ERROR! x does not have a value in all cases\n"})}),"\n",(0,i.jsx)(n.h3,{id:"valid-variable-names",children:"Valid variable names"}),"\n",(0,i.jsxs)(n.p,{children:["Variable names can contain underscores ",(0,i.jsx)(n.code,{children:"_"}),", letters ",(0,i.jsx)(n.code,{children:"a"})," to ",(0,i.jsx)(n.code,{children:"z"}),", letters ",(0,i.jsx)(n.code,{children:"A"})," to ",(0,i.jsx)(n.code,{children:"Z"}),", and digits ",(0,i.jsx)(n.code,{children:"0"}),"\nto ",(0,i.jsx)(n.code,{children:"9"}),". Variable names must start with either an underscore ",(0,i.jsx)(n.code,{children:"_"})," or a letter ",(0,i.jsx)(n.code,{children:"a"})," through ",(0,i.jsx)(n.code,{children:"z"}),". They\n",(0,i.jsx)(n.em,{children:"cannot"})," start with uppercase letters."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"// all valid\nlet x = e;\nlet _x = e;\nlet _A = e;\nlet x0 = e;\nlet xA = e;\nlet foobar_123 = e;\n\n// all invalid\n// highlight-error-start\nlet X = e; // ERROR!\nlet Foo = e; // ERROR!\n// highlight-error-end\n"})}),"\n",(0,i.jsx)(n.h3,{id:"type-annotations",children:"Type annotations"}),"\n",(0,i.jsx)(n.p,{children:"The type of a local variable can almost always be inferred by Move's type system. However, Move\nallows explicit type annotations that can be useful for readability, clarity, or debuggability. The\nsyntax for adding a type annotation is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:'let x: T = e; // "Variable x of type T is initialized to expression e"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Some examples of explicit type annotations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:'module 0::example;\n\npublic struct S { f: u64, g: u64 }\n\nfun annotated() {\n    let u: u8 = 0;\n    let b: vector<u8> = b"hello";\n    let a: address = @0x0;\n    let (x, y): (&u64, &mut u64) = (&0, &mut 1);\n    let S { f, g: f2 }: S = S { f: 0, g: 1 };\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Note that the type annotations must always be to the right of the pattern:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"// highlight-error-start\n// ERROR! should be let (x, y): (&u64, &mut u64) = ...\nlet (x: &u64, y: &mut u64) = (&0, &mut 1);\n// highlight-error-end\n"})}),"\n",(0,i.jsx)(n.h3,{id:"when-annotations-are-necessary",children:"When annotations are necessary"}),"\n",(0,i.jsx)(n.p,{children:"In some cases, a local type annotation is required if the type system cannot infer the type. This\ncommonly occurs when the type argument for a generic type cannot be inferred. For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"// highlight-error-start\nlet _v1 = vector[]; // ERROR!\n//        ^^^^^^^^ Could not infer this type. Try adding an annotation\n// highlight-error-end\nlet v2: vector<u64> = vector[]; // no error\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In a rarer case, the type system might not be able to infer a type for divergent code (where all the\nfollowing code is unreachable). Both ",(0,i.jsx)(n.a,{href:"./functions#return-expression",children:(0,i.jsx)(n.code,{children:"return"})})," and\n",(0,i.jsx)(n.a,{href:"./abort-and-assert",children:(0,i.jsx)(n.code,{children:"abort"})})," are expressions and can have any type. A\n",(0,i.jsx)(n.a,{href:"./control-flow/loops",children:(0,i.jsx)(n.code,{children:"loop"})})," has type ",(0,i.jsx)(n.code,{children:"()"})," if it has a ",(0,i.jsx)(n.code,{children:"break"})," (or ",(0,i.jsx)(n.code,{children:"T"})," if has a ",(0,i.jsx)(n.code,{children:"break e"})," where\n",(0,i.jsx)(n.code,{children:"e: T"}),"), but if there is no break out of the ",(0,i.jsx)(n.code,{children:"loop"}),", it could have any type. If these types cannot\nbe inferred, a type annotation is required. For example, this code:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let a: u8 = return ();\nlet b: bool = abort 0;\nlet c: signer = loop ();\n\n// highlight-error-start\nlet x = return (); // ERROR!\n//  ^ Could not infer this type. Try adding an annotation\nlet y = abort 0; // ERROR!\n//  ^ Could not infer this type. Try adding an annotation\nlet z = loop (); // ERROR!\n//  ^ Could not infer this type. Try adding an annotation\n// highlight-error-end\n"})}),"\n",(0,i.jsx)(n.p,{children:"Adding type annotations to this code will expose other errors about dead code or unused local\nvariables, but the example is still helpful for understanding this problem."}),"\n",(0,i.jsx)(n.h3,{id:"multiple-declarations-with-tuples",children:"Multiple declarations with tuples"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"let"})," can introduce more than one local at a time using tuples. The locals declared inside the\nparenthesis are initialized to the corresponding values from the tuple."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let () = ();\nlet (x0, x1) = (0, 1);\nlet (y0, y1, y2) = (0, 1, 2);\nlet (z0, z1, z2, z3) = (0, 1, 2, 3);\n"})}),"\n",(0,i.jsx)(n.p,{children:"The type of the expression must match the arity of the tuple pattern exactly."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"// highlight-error\nlet (x, y) = (0, 1, 2); // ERROR!\n// highlight-error\nlet (x, y, z, q) = (0, 1, 2); // ERROR!\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You cannot declare more than one local with the same name in a single ",(0,i.jsx)(n.code,{children:"let"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"// highlight-error\nlet (x, x) = 0; // ERROR!\n"})}),"\n",(0,i.jsx)(n.p,{children:"The mutability of the local variables declared can be mixed."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let (mut x, y) = (0, 1);\nx = 1;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"multiple-declarations-with-structs",children:"Multiple declarations with structs"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"let"})," can also introduce more than one local variables at a time when destructuring (or matching\nagainst) a struct. In this form, the ",(0,i.jsx)(n.code,{children:"let"})," creates a set of local variables that are initialized to\nthe values of the fields from a struct. The syntax looks like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"public struct T { f1: u64, f2: u64 }\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };\n// local1: u64\n// local2: u64\n"})}),"\n",(0,i.jsx)(n.p,{children:"Similarly for positional structs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"public struct P(u64, u64)\n"})}),"\n",(0,i.jsx)(n.p,{children:"and"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let P (local1, local2) = P ( 1, 2 );\n// local1: u64\n// local2: u64\n"})}),"\n",(0,i.jsx)(n.p,{children:"Here is a more complicated example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module 0::example;\n\npublic struct X(u64)\npublic struct Y { x1: X, x2: X }\n\nfun new_x(): X {\n    X(1)\n}\n\nfun example() {\n    let Y { x1: X(f), x2 } = Y { x1: new_x(), x2: new_x() };\n    assert!(f + x2.0 == 2, 42);\n\n    let Y { x1: X(f1), x2: X(f2) } = Y { x1: new_x(), x2: new_x() };\n    assert!(f1 + f2 == 2, 42);\n\n    // `struct X` without `drop` ability and needs to be destroyed manually\n    let X(_) = x2;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Fields of structs can serve double duty, identifying the field to bind ",(0,i.jsx)(n.em,{children:"and"})," the name of the\nvariable. This is sometimes referred to as punning."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let Y { x1, x2 } = e;\n"})}),"\n",(0,i.jsx)(n.p,{children:"is equivalent to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let Y { x1: x1, x2: x2 } = e;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As shown with tuples, you cannot declare more than one local with the same name in a single ",(0,i.jsx)(n.code,{children:"let"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"// highlight-error\nlet Y { x1: x, x2: x } = e; // ERROR!\n"})}),"\n",(0,i.jsx)(n.p,{children:"And as with tuples, the mutability of the local variables declared can be mixed."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let Y { x1: mut x1, x2 } = e;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Furthermore, the mutability of annotation can be applied to the punned fields. Giving the equivalent\nexample"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let Y { mut x1, x2 } = e;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"destructuring-against-references",children:"Destructuring against references"}),"\n",(0,i.jsx)(n.p,{children:"In the examples above for structs, the bound value in the let was moved, destroying the struct value\nand binding its fields."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"public struct T { f1: u64, f2: u64 }\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };\n// local1: u64\n// local2: u64\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this scenario the struct value ",(0,i.jsx)(n.code,{children:"T { f1: 1, f2: 2 }"})," no longer exists after the ",(0,i.jsx)(n.code,{children:"let"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"If you wish instead to not move and destroy the struct value, you can borrow each of its fields. For\nexample:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let t = T { f1: 1, f2: 2 };\nlet T { f1: local1, f2: local2 } = &t;\n// local1: &u64\n// local2: &u64\n"})}),"\n",(0,i.jsx)(n.p,{children:"And similarly with mutable references:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let mut t = T { f1: 1, f2: 2 };\nlet T { f1: local1, f2: local2 } = &mut t;\n// local1: &mut u64\n// local2: &mut u64\n"})}),"\n",(0,i.jsx)(n.p,{children:"This behavior can also work with nested structs."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module 0::example;\n\npublic struct X(u64)\npublic struct Y { x1: X, x2: X }\n\nfun new_x(): X {\n    X(1)\n}\n\nfun example() {\n    let mut y = Y { x1: new_x(), x2: new_x() };\n\n    let Y { x1: X(f), x2 } = &y;\n    assert!(*f + x2.0 == 2, 42);\n\n    let Y { x1: X(f1), x2: X(f2) } = &mut y;\n    *f1 = *f1 + 1;\n    *f2 = *f2 + 1;\n    assert!(*f1 + *f2 == 4, 42);\n\n    // `struct X and struct Y` without `drop` ability and needs to be destroyed manually\n    let Y { x1: X(_), x2: X(_) } = y;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"ignoring-values",children:"Ignoring Values"}),"\n",(0,i.jsxs)(n.p,{children:["In ",(0,i.jsx)(n.code,{children:"let"})," bindings, it is often helpful to ignore some values. Local variables that start with ",(0,i.jsx)(n.code,{children:"_"}),"\nwill be ignored and not introduce a new variable"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"fun three(): (u64, u64, u64) {\n    (0, 1, 2)\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let (x1, _, z1) = three();\nlet (x2, _y, z2) = three();\nassert!(x1 + z1 == x2 + z2, 42);\n"})}),"\n",(0,i.jsx)(n.p,{children:"This can be necessary at times as the compiler will warn on unused local variables"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let (x1, y, z1) = three(); // WARNING!\n//       ^ unused local 'y'\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"general-let-grammar",children:["General ",(0,i.jsx)(n.code,{children:"let"})," grammar"]}),"\n",(0,i.jsxs)(n.p,{children:["All of the different structures in ",(0,i.jsx)(n.code,{children:"let"})," can be combined! With that we arrive at this general\ngrammar for ",(0,i.jsx)(n.code,{children:"let"})," statements:"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"let-binding"})," \u2192 ",(0,i.jsx)(n.strong,{children:"let"})," ",(0,i.jsx)(n.em,{children:"pattern-or-list"})," ",(0,i.jsx)(n.em,{children:"type-annotation"}),(0,i.jsx)("sub",{children:(0,i.jsx)(n.em,{children:"opt"})})," >\n",(0,i.jsx)(n.em,{children:"initializer"}),(0,i.jsx)("sub",{children:(0,i.jsx)(n.em,{children:"opt"})})," > ",(0,i.jsx)(n.em,{children:"pattern-or-list"})," \u2192 ",(0,i.jsx)(n.em,{children:"pattern"})," | ",(0,i.jsx)(n.strong,{children:"("})," ",(0,i.jsx)(n.em,{children:"pattern-list"})," ",(0,i.jsx)(n.strong,{children:")"})," >\n",(0,i.jsx)(n.em,{children:"pattern-list"})," \u2192 ",(0,i.jsx)(n.em,{children:"pattern"})," ",(0,i.jsx)(n.strong,{children:","}),(0,i.jsx)("sub",{children:(0,i.jsx)(n.em,{children:"opt"})})," | ",(0,i.jsx)(n.em,{children:"pattern"})," ",(0,i.jsx)(n.strong,{children:","})," ",(0,i.jsx)(n.em,{children:"pattern-list"})," >\n",(0,i.jsx)(n.em,{children:"type-annotation"})," \u2192 ",(0,i.jsx)(n.strong,{children:":"})," ",(0,i.jsx)(n.em,{children:"type"})," ",(0,i.jsx)(n.em,{children:"initializer"})," \u2192 ",(0,i.jsx)(n.strong,{children:"="})," ",(0,i.jsx)(n.em,{children:"expression"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The general term for the item that introduces the bindings is a ",(0,i.jsx)(n.em,{children:"pattern"}),". The pattern serves to\nboth destructure data (possibly recursively) and introduce the bindings. The pattern grammar is as\nfollows:"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"pattern"})," -> ",(0,i.jsx)(n.em,{children:"local-variable"})," | ",(0,i.jsx)(n.em,{children:"struct-type"})," ",(0,i.jsx)(n.strong,{children:"{"})," ",(0,i.jsx)(n.em,{children:"field-binding-list"})," ",(0,i.jsx)(n.strong,{children:"}"})," >\n",(0,i.jsx)(n.em,{children:"field-binding-list"})," \u2192 ",(0,i.jsx)(n.em,{children:"field-binding"})," ",(0,i.jsx)(n.strong,{children:","}),(0,i.jsx)("sub",{children:(0,i.jsx)(n.em,{children:"opt"})})," | ",(0,i.jsx)(n.em,{children:"field-binding"})," ",(0,i.jsx)(n.strong,{children:","})," >\n",(0,i.jsx)(n.em,{children:"field-binding-list"})," > ",(0,i.jsx)(n.em,{children:"field-binding"})," \u2192 ",(0,i.jsx)(n.em,{children:"field"})," | ",(0,i.jsx)(n.em,{children:"field"})," ",(0,i.jsx)(n.strong,{children:":"})," ",(0,i.jsx)(n.em,{children:"pattern"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"A few concrete examples with this grammar applied:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"    let (x, y): (u64, u64) = (0, 1);\n//       ^                           local-variable\n//       ^                           pattern\n//          ^                        local-variable\n//          ^                        pattern\n//          ^                        pattern-list\n//       ^^^^                        pattern-list\n//      ^^^^^^                       pattern-or-list\n//            ^^^^^^^^^^^^           type-annotation\n//                         ^^^^^^^^  initializer\n//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding\n\n    let Foo { f, g: x } = Foo { f: 0, g: 1 };\n//      ^^^                                    struct-type\n//            ^                                field\n//            ^                                field-binding\n//               ^                             field\n//                  ^                          local-variable\n//                  ^                          pattern\n//               ^^^^                          field-binding\n//            ^^^^^^^                          field-binding-list\n//      ^^^^^^^^^^^^^^^                        pattern\n//      ^^^^^^^^^^^^^^^                        pattern-or-list\n//                      ^^^^^^^^^^^^^^^^^^^^   initializer\n//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding\n"})}),"\n",(0,i.jsx)(n.h2,{id:"mutations",children:"Mutations"}),"\n",(0,i.jsx)(n.h3,{id:"assignments",children:"Assignments"}),"\n",(0,i.jsxs)(n.p,{children:["After the local is introduced (either by ",(0,i.jsx)(n.code,{children:"let"})," or as a function parameter), a ",(0,i.jsx)(n.code,{children:"mut"})," local can be\nmodified via an assignment:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"x = e\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Unlike ",(0,i.jsx)(n.code,{children:"let"})," bindings, assignments are expressions. In some languages, assignments return the value\nthat was assigned, but in Move, the type of any assignment is always ",(0,i.jsx)(n.code,{children:"()"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"(x = e: ())\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Practically, assignments being expressions means that they can be used without adding a new\nexpression block with braces (",(0,i.jsx)(n.code,{children:"{"}),"...",(0,i.jsx)(n.code,{children:"}"}),")."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let x;\nif (cond) x = 1 else x = 2;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The assignment uses the similar pattern syntax scheme as ",(0,i.jsx)(n.code,{children:"let"})," bindings, but with absence of ",(0,i.jsx)(n.code,{children:"mut"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module 0::example;\n\npublic struct X { f: u64 }\n\nfun new_x(): X {\n    X { f: 1 }\n}\n\n// Note: this example will complain about unused variables and assignments.\nfun example() {\n    let (mut x, mut y, mut f, mut g) = (0, 0, 0, 0);\n\n    (X { f }, X { f: x }) = (new_x(), new_x());\n    assert!(f + x == 2, 42);\n\n    (x, y, f, _, g) = (0, 0, 0, 0, 0);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Note that a local variable can only have one type, so the type of the local cannot change between\nassignments."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let mut x;\nx = 0;\n// highlight-error\nx = false; // ERROR!\n"})}),"\n",(0,i.jsx)(n.h3,{id:"mutating-through-a-reference",children:"Mutating through a reference"}),"\n",(0,i.jsxs)(n.p,{children:["In addition to directly modifying a local with assignment, a ",(0,i.jsx)(n.code,{children:"mut"})," local can be modified via a\nmutable reference ",(0,i.jsx)(n.code,{children:"&mut"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let mut x = 0;\nlet r = &mut x;\n*r = 1;\nassert!(x == 1, 42);\n"})}),"\n",(0,i.jsx)(n.p,{children:"This is particularly useful if either:"}),"\n",(0,i.jsx)(n.p,{children:"(1) You want to modify different variables depending on some condition."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let mut x = 0;\nlet mut y = 1;\nlet r = if (cond) &mut x else &mut y;\n*r = *r + 1;\n"})}),"\n",(0,i.jsx)(n.p,{children:"(2) You want another function to modify your local value."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let mut x = 0;\nmodify_ref(&mut x);\n"})}),"\n",(0,i.jsx)(n.p,{children:"This sort of modification is how you modify structs and vectors!"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let mut v = vector[];\nvector::push_back(&mut v, 100);\nassert!(*vector::borrow(&v, 0) == 100, 42);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For more details, see ",(0,i.jsx)(n.a,{href:"./primitive-types/references",children:"Move references"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"scopes",children:"Scopes"}),"\n",(0,i.jsxs)(n.p,{children:["Any local declared with ",(0,i.jsx)(n.code,{children:"let"})," is available for any subsequent expression, ",(0,i.jsx)(n.em,{children:"within that scope"}),".\nScopes are declared with expression blocks, ",(0,i.jsx)(n.code,{children:"{"}),"...",(0,i.jsx)(n.code,{children:"}"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Locals cannot be used outside of the declared scope."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let x = 0;\n{\n    let y = 1;\n};\n// highlight-error-start\nx + y // ERROR!\n//  ^ unbound local 'y'\n// highlight-error-end\n"})}),"\n",(0,i.jsxs)(n.p,{children:["But, locals from an outer scope ",(0,i.jsx)(n.em,{children:"can"})," be used in a nested scope."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"{\n    let x = 0;\n    {\n        let y = x + 1; // valid\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Locals can be mutated in any scope where they are accessible. That mutation survives with the local,\nregardless of the scope that performed the mutation."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let mut x = 0;\nx = x + 1;\nassert!(x == 1, 42);\n{\n    x = x + 1;\n    assert!(x == 2, 42);\n};\nassert!(x == 2, 42);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"expression-blocks",children:"Expression Blocks"}),"\n",(0,i.jsxs)(n.p,{children:["An expression block is a series of statements separated by semicolons (",(0,i.jsx)(n.code,{children:";"}),"). The resulting value of\nan expression block is the value of the last expression in the block."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"{ let x = 1; let y = 1; x + y }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, the result of the block is ",(0,i.jsx)(n.code,{children:"x + y"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["A statement can be either a ",(0,i.jsx)(n.code,{children:"let"})," declaration or an expression. Remember that assignments (",(0,i.jsx)(n.code,{children:"x = e"}),")\nare expressions of type ",(0,i.jsx)(n.code,{children:"()"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"{ let x; let y = 1; x = 1; x + y }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Function calls are another common expression of type ",(0,i.jsx)(n.code,{children:"()"}),". Function calls that modify data are\ncommonly used as statements."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"{ let v = vector[]; vector::push_back(&mut v, 1); v }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This is not just limited to ",(0,i.jsx)(n.code,{children:"()"})," types---any expression can be used as a statement in a sequence!"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:'{\n    let x = 0;\n    x + 1; // value is discarded\n    x + 2; // value is discarded\n    b"hello"; // value is discarded\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["But! If the expression contains a resource (a value without the ",(0,i.jsx)(n.code,{children:"drop"})," ",(0,i.jsx)(n.a,{href:"./abilities",children:"ability"}),"), you\nwill get an error. This is because Move's type system guarantees that any value that is dropped has\nthe ",(0,i.jsx)(n.code,{children:"drop"})," ",(0,i.jsx)(n.a,{href:"./abilities",children:"ability"}),". (Ownership must be transferred or the value must be explicitly\ndestroyed within its declaring module.)"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"{\n    let x = 0;\n// highlight-error-start\n    Coin { value: x }; // ERROR!\n//  ^^^^^^^^^^^^^^^^^ unused value without the `drop` ability\n// highlight-error-end\n    x\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If a final expression is not present in a block---that is, if there is a trailing semicolon ",(0,i.jsx)(n.code,{children:";"}),",\nthere is an implicit ",(0,i.jsxs)(n.a,{href:"https://en.wikipedia.org/wiki/Unit_type",children:["unit ",(0,i.jsx)(n.code,{children:"()"})," value"]}),". Similarly, if the\nexpression block is empty, there is an implicit unit ",(0,i.jsx)(n.code,{children:"()"})," value."]}),"\n",(0,i.jsx)(n.p,{children:"Both are equivalent"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"{ x = x + 1; 1 / x; }\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"{ x = x + 1; 1 / x; () }\n"})}),"\n",(0,i.jsx)(n.p,{children:"Similarly both are equivalent"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"{ }\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"{ () }\n"})}),"\n",(0,i.jsx)(n.p,{children:"An expression block is itself an expression and can be used anyplace an expression is used. (Note:\nThe body of a function is also an expression block, but the function body cannot be replaced by\nanother expression.)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:'let my_vector: vector<vector<u8>> = {\n    let mut v = vector[];\n    vector::push_back(&mut v, b"hello");\n    vector::push_back(&mut v, b"goodbye");\n    v\n};\n'})}),"\n",(0,i.jsx)(n.p,{children:"(The type annotation is not needed in this example and only added for clarity.)"}),"\n",(0,i.jsx)(n.h3,{id:"shadowing",children:"Shadowing"}),"\n",(0,i.jsxs)(n.p,{children:["If a ",(0,i.jsx)(n.code,{children:"let"})," introduces a local variable with a name already in scope, that previous variable can no\nlonger be accessed for the rest of this scope. This is called ",(0,i.jsx)(n.em,{children:"shadowing"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let x = 0;\nassert!(x == 0, 42);\n\nlet x = 1; // x is shadowed\nassert!(x == 1, 42);\n"})}),"\n",(0,i.jsx)(n.p,{children:"When a local is shadowed, it does not need to retain the same type as before."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:'let x = 0;\nassert!(x == 0, 42);\n\nlet x = b"hello"; // x is shadowed\nassert!(x == b"hello", 42);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["After a local is shadowed, the value stored in the local still exists, but will no longer be\naccessible. This is important to keep in mind with values of types without the\n",(0,i.jsxs)(n.a,{href:"./abilities",children:[(0,i.jsx)(n.code,{children:"drop"})," ability"]}),", as ownership of the value must be transferred by the end of the\nfunction."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module 0::example;\n\npublic struct Coin has store { value: u64 }\n\nfun unused_coin(): Coin {\n// highlight-error-start\n    let x = Coin { value: 0 }; // ERROR!\n//      ^ This local still contains a value without the `drop` ability\n    x.value = 1;\n    let x = Coin { value: 10 };\n    x\n//  ^ Invalid return\n// highlight-error-end\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"When a local is shadowed inside a scope, the shadowing only remains for that scope. The shadowing is\ngone once that scope ends."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let x = 0;\n{\n    let x = 1;\n    assert!(x == 1, 42);\n};\nassert!(x == 0, 42);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Remember, locals can change type when they are shadowed."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:'let x = 0;\n{\n    let x = b"hello";\n    assert!(x == b"hello", 42);\n};\nassert!(x == 0, 42);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"move-and-copy",children:"Move and Copy"}),"\n",(0,i.jsxs)(n.p,{children:["All local variables in Move can be used in two ways, either by ",(0,i.jsx)(n.code,{children:"move"})," or ",(0,i.jsx)(n.code,{children:"copy"}),". If one or the other\nis not specified, the Move compiler is able to infer whether a ",(0,i.jsx)(n.code,{children:"copy"})," or a ",(0,i.jsx)(n.code,{children:"move"})," should be used.\nThis means that in all of the examples above, a ",(0,i.jsx)(n.code,{children:"move"})," or a ",(0,i.jsx)(n.code,{children:"copy"})," would be inserted by the\ncompiler. A local variable cannot be used without the use of ",(0,i.jsx)(n.code,{children:"move"})," or ",(0,i.jsx)(n.code,{children:"copy"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"copy"})," will likely feel the most familiar coming from other programming languages, as it creates a\nnew copy of the value inside of the variable to use in that expression. With ",(0,i.jsx)(n.code,{children:"copy"}),", the local\nvariable can be used more than once."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let x = 0;\nlet y = copy x + 1;\nlet z = copy x + 2;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Any value with the ",(0,i.jsx)(n.code,{children:"copy"})," ",(0,i.jsx)(n.a,{href:"./abilities",children:"ability"})," can be copied in this way, and will be copied\nimplicitly unless a ",(0,i.jsx)(n.code,{children:"move"})," is specified."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"move"})," takes the value out of the local variable ",(0,i.jsx)(n.em,{children:"without"})," copying the data. After a ",(0,i.jsx)(n.code,{children:"move"})," occurs,\nthe local variable is unavailable, even if the value's type has the ",(0,i.jsx)(n.code,{children:"copy"})," ",(0,i.jsx)(n.a,{href:"./abilities",children:"ability"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let x = 1;\n// highlight-error-start\nlet y = move x + 1;\n//      ------ Local was moved here\nlet z = move x + 2; // Error!\n//      ^^^^^^ Invalid usage of local 'x'\n// highlight-error-end\ny + z\n"})}),"\n",(0,i.jsx)(n.h3,{id:"safety",children:"Safety"}),"\n",(0,i.jsxs)(n.p,{children:["Move's type system will prevent a value from being used after it is moved. This is the same safety\ncheck described in ",(0,i.jsxs)(n.a,{href:"#let-bindings",children:[(0,i.jsx)(n.code,{children:"let"})," declaration"]})," that prevents local variables from being used\nbefore it is assigned a value."]}),"\n",(0,i.jsx)(n.h3,{id:"inference",children:"Inference"}),"\n",(0,i.jsxs)(n.p,{children:["As mentioned above, the Move compiler will infer a ",(0,i.jsx)(n.code,{children:"copy"})," or ",(0,i.jsx)(n.code,{children:"move"})," if one is not indicated. The\nalgorithm for doing so is quite simple:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Any value with the ",(0,i.jsx)(n.code,{children:"copy"})," ",(0,i.jsx)(n.a,{href:"./abilities",children:"ability"})," is given a ",(0,i.jsx)(n.code,{children:"copy"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Any reference (both mutable ",(0,i.jsx)(n.code,{children:"&mut"})," and immutable ",(0,i.jsx)(n.code,{children:"&"}),") is given a ",(0,i.jsx)(n.code,{children:"copy"}),".","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Except under special circumstances where it is made a ",(0,i.jsx)(n.code,{children:"move"})," for predictable borrow checker\nerrors. This will happen once the reference is no longer used."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Any other value is given a ",(0,i.jsx)(n.code,{children:"move"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Given the structs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"public struct Foo has copy, drop, store { f: u64 }\npublic struct Coin has store { value: u64 }\n"})}),"\n",(0,i.jsx)(n.p,{children:"we have the following example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:'let s = b"hello";\nlet foo = Foo { f: 0 };\nlet coin = Coin { value: 0 };\nlet coins = vector[Coin { value: 0 }, Coin { value: 0 }];\n\nlet s2 = s; // copy\nlet foo2 = foo; // copy\nlet coin2 = coin; // move\nlet coins2 = coins; // move\n\nlet x = 0;\nlet b = false;\nlet addr = @0x42;\nlet x_ref = &x;\nlet coin_ref = &mut coin2;\n\nlet x2 = x; // copy\nlet b2 = b; // copy\nlet addr2 = @0x42; // copy\nlet x_ref2 = x_ref; // copy\nlet coin_ref2 = coin_ref; // copy\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},5521:(e,n,l)=>{l.d(n,{R:()=>r,x:()=>t});var s=l(6672);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);