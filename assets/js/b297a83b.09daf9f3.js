"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1091],{3381:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"move-basics/assert-and-abort","title":"Aborting Execution","description":"\x3c!--","source":"@site/../book/move-basics/assert-and-abort.md","sourceDirName":"move-basics","slug":"/move-basics/assert-and-abort","permalink":"/move-basics/assert-and-abort","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.16. Constants","permalink":"/move-basics/constants"},"next":{"title":"5.18. Functions","permalink":"/move-basics/function"}}');var a=r(3420),t=r(5521);const o={},i="Aborting Execution",c={},d=[{value:"Abort",id:"abort",level:2},{value:"assert!",id:"assert",level:2},{value:"Error constants",id:"error-constants",level:2},{value:"Error messages",id:"error-messages",level:2},{value:"Further Reading",id:"further-reading",level:2}];function l(e){const s={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"aborting-execution",children:"Aborting Execution"})}),"\n",(0,a.jsxs)(s.p,{children:["A transaction can either succeed or fail. Successful execution applies all changes made to objects\nand on-chain data, and the transaction is committed to the blockchain. Alternatively, if a\ntransaction aborts, changes are not applied. Use the ",(0,a.jsx)(s.code,{children:"abort"})," keyword to abort a transaction and\nrevert any changes that were made."]}),"\n",(0,a.jsxs)(s.blockquote,{children:["\n",(0,a.jsx)(s.p,{children:"It is important to note that there is no catch mechanism in Move. If a transaction aborts, the\nchanges made so far are reverted, and the transaction is considered failed."}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"abort",children:"Abort"}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.code,{children:"abort"})," keyword is used to abort the execution of a transaction. It is used in combination with\nan abort code, which is returned to the caller of the transaction. The abort code is an\n",(0,a.jsx)(s.a,{href:"./primitive-types",children:"integer"})," of type ",(0,a.jsx)(s.code,{children:"u64"}),"."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/assert-and-abort.move anchor=abort",children:"let user_has_access = false;\n\n// abort with a predefined constant if `user_has_access` is false\nif (!user_has_access) {\n    abort 1\n};\n"})}),"\n",(0,a.jsxs)(s.p,{children:["The code above will, of course, abort with abort code ",(0,a.jsx)(s.code,{children:"1"}),"."]}),"\n",(0,a.jsx)(s.h2,{id:"assert",children:"assert!"}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.code,{children:"assert!"})," macro is a built-in macro that can be used to assert a condition. If the condition is\nfalse, the transaction will abort with the given abort code. The ",(0,a.jsx)(s.code,{children:"assert!"})," macro is a convenient way\nto abort a transaction if a condition is not met. The macro shortens the code otherwise written with\nan ",(0,a.jsx)(s.code,{children:"if"})," expression + ",(0,a.jsx)(s.code,{children:"abort"}),". The ",(0,a.jsx)(s.code,{children:"code"})," argument is optional, but has to be a ",(0,a.jsx)(s.code,{children:"u64"})," value or an\n",(0,a.jsx)(s.code,{children:"#[error]"})," (see below for more information)."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/assert-and-abort.move anchor=assert",children:"// aborts if `user_has_access` is `false` with abort code 0\nassert!(user_has_access, 0);\n\n// expands into:\nif (!user_has_access) {\n    abort 0\n};\n"})}),"\n",(0,a.jsx)(s.h2,{id:"error-constants",children:"Error constants"}),"\n",(0,a.jsxs)(s.p,{children:["To make error codes more descriptive, it is a good practice to define\n",(0,a.jsx)(s.a,{href:"./constants",children:"error constants"}),". Error constants are defined as ",(0,a.jsx)(s.code,{children:"const"})," declarations and are usually\nprefixed with ",(0,a.jsx)(s.code,{children:"E"})," followed by a camel case name. Error constants are similar to other constants and\ndo not have any special handling. However, they are commonly used to improve code readability and\nmake abort scenarios easier to understand."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/assert-and-abort.move anchor=error_const",children:"/// Error code for when the user has no access.\nconst ENoAccess: u64 = 0;\n/// Trying to access a field that does not exist.\nconst ENoField: u64 = 1;\n\n/// Updates a record.\npublic fun update_record(/* ... , */ user_has_access: bool, field_exists: bool) {\n    // asserts are way more readable now\n    assert!(user_has_access, ENoAccess);\n    assert!(field_exists, ENoField);\n\n    /* ... */\n}\n"})}),"\n",(0,a.jsx)(s.h2,{id:"error-messages",children:"Error messages"}),"\n",(0,a.jsxs)(s.p,{children:["Move 2024 introduces a special type of error constant, marked with the ",(0,a.jsx)(s.code,{children:"#[error]"})," attribute. This\nattribute allows the error constant to be of type ",(0,a.jsx)(s.code,{children:"vector<u8>"})," and can be used to store an error\nmessage."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/assert-and-abort.move anchor=error_attribute",children:'#[error]\nconst ENotAuthorized: vector<u8> = b"The user is not authorized to perform this action";\n\n#[error]\nconst EValueTooLow: vector<u8> = b"The value is too low, it should be at least 10";\n\n/// Performs an action on behalf of the user.\npublic fun update_value(user: &mut User, value: u64) {\n    assert!(user.is_authorized, ENotAuthorized);\n    assert!(value >= 10, EValueTooLow);\n\n    user.value = value;\n}\n'})}),"\n",(0,a.jsx)(s.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"./../../reference/abort-and-assert",children:"Abort and Assert"})," in the Move Reference."]}),"\n",(0,a.jsxs)(s.li,{children:["We suggest reading the ",(0,a.jsx)(s.a,{href:"./../guides/better-error-handling",children:"Better Error Handling"})," guide to learn\nabout best practices for error handling in Move."]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},5521:(e,s,r)=>{r.d(s,{R:()=>o,x:()=>i});var n=r(6672);const a={},t=n.createContext(a);function o(e){const s=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(t.Provider,{value:s},e.children)}}}]);