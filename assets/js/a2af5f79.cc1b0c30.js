"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[646],{4811:(e,s,r)=>{r.d(s,{R:()=>t,x:()=>i});var n=r(9378);const a={},d=n.createContext(a);function t(e){const s=n.useContext(d);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),n.createElement(d.Provider,{value:s},e.children)}},8845:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>t,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"move-basics/address","title":"Address Type","description":"\x3c!--","source":"@site/../book/move-basics/address.md","sourceDirName":"move-basics","slug":"/move-basics/address","permalink":"/move-basics/address","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.3. Primitive Types","permalink":"/move-basics/primitive-types"},"next":{"title":"5.5. Expressions","permalink":"/move-basics/expression"}}');var a=r(2714),d=r(4811);const t={},i="Address Type",o={},c=[{value:"Conversion",id:"conversion",level:2},{value:"Further Reading",id:"further-reading",level:2}];function l(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,d.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"address-type",children:"Address Type"})}),"\n",(0,a.jsxs)(s.p,{children:["Move uses a special type called ",(0,a.jsx)(s.a,{href:"./../concepts/address",children:"address"})," to represent addresses. It is a\n32-byte value that can represent any address on the blockchain. Addresses can be written in two\nforms: hexadecimal addresses prefixed with 0x and named addresses."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/address.move anchor=address_literal",children:"// address literal\nlet value: address = @0x1;\n\n// named address registered in Move.toml\nlet value = @std;\nlet other = @sui;\n"})}),"\n",(0,a.jsxs)(s.p,{children:["An address literal starts with the ",(0,a.jsx)(s.code,{children:"@"})," symbol followed by a hexadecimal number or an identifier. The\nhexadecimal number is interpreted as a 32 byte value. The identifier is looked up in the\n",(0,a.jsx)(s.a,{href:"./../concepts/manifest",children:"Move.toml"})," file and replaced with the corresponding address by the\ncompiler. If the identifier is not found in the Move.toml file, the compiler will throw an error."]}),"\n",(0,a.jsx)(s.h2,{id:"conversion",children:"Conversion"}),"\n",(0,a.jsxs)(s.p,{children:["Sui Framework offers a set of helper functions to work with addresses. Given that the address type\nis a 32 byte value, it can be converted to a ",(0,a.jsx)(s.code,{children:"u256"})," type and vice versa. It can also be converted to\nand from a ",(0,a.jsx)(s.code,{children:"vector<u8>"})," type."]}),"\n",(0,a.jsxs)(s.p,{children:["Example: Convert an address to a ",(0,a.jsx)(s.code,{children:"u256"})," type and back."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/address.move anchor=to_u256",children:"use sui::address;\n\nlet addr_as_u256: u256 = address::to_u256(@0x1);\nlet addr = address::from_u256(addr_as_u256);\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Example: Convert an address to a ",(0,a.jsx)(s.code,{children:"vector<u8>"})," type and back."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/address.move anchor=to_bytes",children:"use sui::address;\n\nlet addr_as_u8: vector<u8> = address::to_bytes(@0x1);\nlet addr = address::from_bytes(addr_as_u8);\n"})}),"\n",(0,a.jsx)(s.p,{children:"Example: Convert an address into a string."}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/address.move anchor=to_string",children:"use sui::address;\nuse std::string::String;\n\nlet addr_as_string: String = address::to_string(@0x1);\n"})}),"\n",(0,a.jsx)(s.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"./../../reference/primitive-types/address",children:"Address"})," in the Move Reference."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"https://docs.sui.io/references/framework/sui/address",children:"sui::address"})," module documentation."]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,d.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);