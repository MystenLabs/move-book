"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6101],{5521:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>d});var i=t(6672);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}},7667:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"extensions","title":"Module Extensions | Reference","description":"","source":"@site/../reference/extensions.md","sourceDirName":".","slug":"/extensions","permalink":"/reference/extensions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Module Extensions | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"18. Compilation Modes","permalink":"/reference/modes"},"next":{"title":"20. Coding Conventions","permalink":"/reference/coding-conventions"}}');var s=t(3420),o=t(5521);const r={title:"Module Extensions | Reference",description:""},d="Module Extensions",c={},l=[{value:"Example",id:"example",level:3},{value:"Extension Syntax",id:"extension-syntax",level:2},{value:"Applying Extensions",id:"applying-extensions",level:2}];function a(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"module-extensions",children:"Module Extensions"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Module Extensions"})," let a package add new declarations to an existing module ",(0,s.jsx)(n.strong,{children:"as if"})," they were\ndefined inside that module. Extensions are opt-in via a mode attribute and never modify or remove\nexisting items."]}),"\n",(0,s.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.p,{children:"Imagine you have an off-the-shelf module that you want to test in your package, but it\nlacks some internal accessors or testing operations that would allow you to write full tests over\nit. As a toy example, consider a simple counter module defined as a library:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module counter::counter {\n    public struct Counter has drop { value: u64 }\n\n    public fun new(): Counter { Counter { value: 0 } }\n\n    public fun incr(mut c: Counter): Counter {\n        c.value = c.value + 1;\n        c\n    }\n\n    public fun destroy(c: Counter): u64 {\n        let Counter { value } = c;\n        value\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"You might use this module in your own package to implement a step counter:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module app::step_counter {\n    use counter::counter::{Counter, new, incr, destroy};\n    enum Step { Once, Many(u64) }\n\n    public fun step(c: Counter, s: Step): Counter {\n        match s {\n            Step::Once => incr(c),\n            Step::Many(n) => {\n                let mut c = c;\n                let mut i = 0;\n                while (i < n) {\n                    c = incr(c);\n                    i = i + 1;\n                }\n                c\n            }\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Suppose you wanted to write additional tests for this counter behavior, including ensuring\ninvariants and the ability to peek at the current value without consuming the counter. Extensions\nallow you to add this behavior as test definitions in your own package without forking and updating\nthe downstream dependency."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"#[test_only]\nextend module counter::counter {\n    /// Peek at the current value without consuming the counter.\n    public fun peek(c: &Counter): u64 { c.value }\n}\n\n#[test_only]\nextend module app::step_counter {\n    use counter::counter::{Counter, new, incr, peek};\n\n    // Local test helper to keep assertions tidy.\n    fun expect_value(c: &Counter, want: u64) { assert!(c.peek() == want, 0); }\n\n    /// Equivalence: Once == Many(1).\n    #[test]\n    fun once_equals_many1() {\n        let c1a = step(new(), Step::Once);\n        let c1b = step(new(), Step::Many(1));\n        expect_value(&c1a, 1);\n        expect_value(&c1b, 1);\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this usage, you extend both the ",(0,s.jsx)(n.code,{children:"counter::counter"})," module (to add helpers and tests) and the\n",(0,s.jsx)(n.code,{children:"app::step_counter"})," module (to add tests for the step logic). All of this code lives in your\npackage, and it only affects test builds. The publishable code remains unchanged."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": Extensions can only add new items; they cannot modify or remove existing items. In >\naddition, only extensions defined in the root package are applied (extensions in dependencies are\nnot)."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"extension-syntax",children:"Extension Syntax"}),"\n",(0,s.jsxs)(n.p,{children:["Extension are defined by adding the ",(0,s.jsx)(n.code,{children:"extend"})," keyword before the ",(0,s.jsx)(n.code,{children:"module"})," keyword:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"#[mode(name1, name2, ...)]      // or #[test_only]\nextend module <address>::<identifier> {\n    (<use> | <type> | <function> | <constant>)*\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Extensions are allowed for single-file module forms:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"#[mode(test)]\nextend module p<address>::<identifier>;\n\n(<use> | <type> | <function> | <constant>)*\n"})}),"\n",(0,s.jsx)(n.p,{children:"In both cases:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The extension must define a mode attribute."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<address>::<identifier>"})," is the package and module name."]}),"\n",(0,s.jsxs)(n.li,{children:["The module elements are as in a standard ",(0,s.jsx)(n.a,{href:"modules",children:"module"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"The extension block is compiled into the target module under the enabled modes."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<address>::<identifier>"})," must resolve to an existing module in the current build."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"applying-extensions",children:"Applying Extensions"}),"\n",(0,s.jsxs)(n.p,{children:["Let ",(0,s.jsx)(n.code,{children:"M"})," be a module in the current build. Let ",(0,s.jsx)(n.code,{children:"E1, E2, ... En"})," be all extensions targeting ",(0,s.jsx)(n.code,{children:"M"})," such\nthat:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Ei"})," is defined in the root package of the current build (others are ignored)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Ei"})," targets ",(0,s.jsx)(n.code,{children:"M"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Ei"})," has an active mode attribute."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["During expansion, the effective contents of ",(0,s.jsx)(n.code,{children:"M"})," are transformed into:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"module M {\n    ... original contents of M ...\n    ... contents of E1 ...\n    ... contents of E2 ...\n    ...\n    ... contents of En ...\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Name resolution, visibility, edition rules, type checking, etc., are applied to the resultant\nmodule as a whole. This means each declaration in an extension is treated as if it were written\ndirectly in the target module, and subject to the same visibility, edition features, duplicate\ndefinition errors, name conflicts, etc."}),"\n",(0,s.jsxs)(n.p,{children:["This means that extensions may not modify or override existing declarations, and may not shadow\nexisting ",(0,s.jsx)(n.code,{children:"use"})," definitions, etc. New use definitions may be added, but their compilation is still\nsubject to decidable dependency ordering, as described in the ",(0,s.jsx)(n.a,{href:"uses",children:(0,s.jsx)(n.code,{children:"use"})})," section."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Tip"}),": Extension code is subject of the same edition features as the target module. If the\ntarget module is in an older edition, the extension code must also be compatible with that\nedition."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}}}]);