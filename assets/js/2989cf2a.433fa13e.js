"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7741],{52:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>h,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>r});const s=JSON.parse('{"id":"move-basics/struct-methods","title":"Struct Methods","description":"Move Compiler supports receiver syntax e.f(), which allows defining methods which can be called","source":"@site/../book/move-basics/struct-methods.md","sourceDirName":"move-basics","slug":"/move-basics/struct-methods","permalink":"/move-basics/struct-methods","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.18. Functions","permalink":"/move-basics/function"},"next":{"title":"5.20. Visibility Modifiers","permalink":"/move-basics/visibility"}}');var i=n(3420),a=n(5521);const o={},h="Struct Methods",l={},r=[{value:"Method syntax",id:"method-syntax",level:2},{value:"Method Aliases",id:"method-aliases",level:2},{value:"Further Reading",id:"further-reading",level:2}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"struct-methods",children:"Struct Methods"})}),"\n",(0,i.jsxs)(t.p,{children:["Move Compiler supports ",(0,i.jsx)(t.em,{children:"receiver syntax"})," ",(0,i.jsx)(t.code,{children:"e.f()"}),', which allows defining methods which can be called\non instances of a struct. The term "receiver" specifically refers to the instance that receives the\nmethod call. This is like the method syntax in other programming languages. It is a convenient way\nto define functions that operate on the fields of a struct, providing direct access to the struct\'s\nfields and creating cleaner, more intuitive code than passing the struct as a parameter.']}),"\n",(0,i.jsx)(t.h2,{id:"method-syntax",children:"Method syntax"}),"\n",(0,i.jsxs)(t.p,{children:["If the first argument of a function is a struct internal to the module that defines the function,\nthen the function can be called using the ",(0,i.jsx)(t.code,{children:"."})," operator. However, if the type of the first argument\nis defined in another module, then method won't be associated with the struct by default. In this\ncase, the ",(0,i.jsx)(t.code,{children:"."})," operator syntax is not available, and the function must be called using standard\nfunction call syntax."]}),"\n",(0,i.jsx)(t.p,{children:"When a module is imported, its methods are automatically associated with the struct."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/struct-methods.move anchor=hero",children:"module book::hero;\n\n/// A struct representing a hero.\npublic struct Hero has drop {\n    health: u8,\n    mana: u8,\n}\n\n/// Create a new Hero.\npublic fun new(): Hero { Hero { health: 100, mana: 100 } }\n\n/// A method which casts a spell, consuming mana.\npublic fun heal_spell(hero: &mut Hero) {\n    hero.health = hero.health + 10;\n    hero.mana = hero.mana - 10;\n}\n\n/// A method which returns the health of the hero.\npublic fun health(hero: &Hero): u8 { hero.health }\n\n/// A method which returns the mana of the hero.\npublic fun mana(hero: &Hero): u8 { hero.mana }\n\n#[test_only]\nuse std::unit_test::assert_eq;\n\n#[test]\n// Test the methods of the `Hero` struct.\nfun test_methods() {\n    let mut hero = new();\n    hero.heal_spell();\n\n    assert_eq!(hero.health(), 110);\n    assert_eq!(hero.mana(), 90);\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"method-aliases",children:"Method Aliases"}),"\n",(0,i.jsx)(t.p,{children:"Method aliases help avoid name conflicts when modules define multiple structs and their methods.\nThey can also provide more descriptive method names for structs."}),"\n",(0,i.jsx)(t.p,{children:"Here's the syntax:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-move",children:"// for local method association\nuse fun function_path as Type.method_name;\n\n// exported alias\npublic use fun function_path as Type.method_name;\n"})}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Public aliases are only allowed for structs defined in the same module. For structs defined in\nother modules, aliases can still be created but cannot be made public."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["In the example below, we changed the ",(0,i.jsx)(t.code,{children:"hero"})," module and added another type - ",(0,i.jsx)(t.code,{children:"Villain"}),". Both ",(0,i.jsx)(t.code,{children:"Hero"}),"\nand ",(0,i.jsx)(t.code,{children:"Villain"})," have similar field names and methods. To avoid name conflicts, we prefixed methods\nwith ",(0,i.jsx)(t.code,{children:"hero_"})," and ",(0,i.jsx)(t.code,{children:"villain_"})," respectively. However, using aliases allows these methods to be called\non struct instances without the prefix:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/struct-methods-2.move anchor=hero_and_villain",children:"module book::hero_and_villain;\n\n/// A struct representing a hero.\npublic struct Hero has drop {\n    health: u8,\n}\n\n/// A struct representing a villain.\npublic struct Villain has drop {\n    health: u8,\n}\n\n/// Create a new Hero.\npublic fun new_hero(): Hero { Hero { health: 100 } }\n\n/// Create a new Villain.\npublic fun new_villain(): Villain { Villain { health: 200 } }\n\n// Alias for the `hero_health` method. It will be imported automatically when\n// the module is imported.\npublic use fun hero_health as Hero.health;\n\npublic fun hero_health(hero: &Hero): u8 { hero.health }\n\n// Alias for the `villain_health` method. Will be imported automatically\n// when the module is imported.\npublic use fun villain_health as Villain.health;\n\npublic fun villain_health(villain: &Villain): u8 { villain.health }\n\n#[test_only]\nuse std::unit_test::assert_eq;\n\n#[test]\n// Test the methods of the `Hero` and `Villain` structs.\nfun test_associated_methods() {\n    let hero = new_hero();\n    assert_eq!(hero.health(), 100);\n\n    let villain = new_villain();\n    assert_eq!(villain.health(), 200);\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In the test function, the ",(0,i.jsx)(t.code,{children:"health"})," method is called directly on the ",(0,i.jsx)(t.code,{children:"Hero"})," and ",(0,i.jsx)(t.code,{children:"Villain"})," instances\nwithout the prefix, as the compiler automatically associates the methods with their respective\nstructs."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["Note: In the test function, ",(0,i.jsx)(t.code,{children:"hero.health()"})," is calling the aliased method, not directly accessing\nthe private ",(0,i.jsx)(t.code,{children:"health"})," field. While the ",(0,i.jsx)(t.code,{children:"Hero"})," and ",(0,i.jsx)(t.code,{children:"Villain"})," structs are public, their fields remain\nprivate to the module. The method call ",(0,i.jsx)(t.code,{children:"hero.health()"})," uses the public alias defined by\n",(0,i.jsx)(t.code,{children:"public use fun hero_health as Hero.health"}),", which provides controlled access to the private\nfield."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"./../../reference/method-syntax",children:"Method Syntax"})," in the Move Reference."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},5521:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>h});var s=n(6672);const i={},a=s.createContext(i);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function h(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);