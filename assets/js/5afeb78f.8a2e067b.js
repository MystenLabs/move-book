"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3581],{5521:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>l});var d=i(6672);const o={},s=d.createContext(o);function t(e){const n=d.useContext(s);return d.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),d.createElement(s.Provider,{value:n},e.children)}},6242:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>m,frontMatter:()=>t,metadata:()=>d,toc:()=>c});const d=JSON.parse('{"id":"modes","title":"Compilation Modes | Reference","description":"","source":"@site/../reference/modes.md","sourceDirName":".","slug":"/modes","permalink":"/reference/modes","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Compilation Modes | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"17. Unit Testing","permalink":"/reference/unit-testing"},"next":{"title":"19. Coding Conventions","permalink":"/reference/coding-conventions"}}');var o=i(3420),s=i(5521);const t={title:"Compilation Modes | Reference",description:""},l="Compilation Modes",a={},c=[{value:"Mode Basics",id:"mode-basics",level:2},{value:"Mode Annotations",id:"mode-annotations",level:3},{value:"Mode Names",id:"mode-names",level:2},{value:"Inclusion model",id:"inclusion-model",level:2},{value:"Module scope",id:"module-scope",level:3},{value:"Multiple modes on one attribute",id:"multiple-modes-on-one-attribute",level:3},{value:"Name resolution &amp; duplicates",id:"name-resolution--duplicates",level:2},{value:"Usage Tooling &amp; flags",id:"usage-tooling--flags",level:2},{value:"Publishability",id:"publishability",level:2}];function r(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"compilation-modes",children:"Compilation Modes"})}),"\n",(0,o.jsx)(n.p,{children:"A mode is a named, compile-time switch that controls which declarations are included in a build."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"#[mode(name1, name2, ...)]"})," filters declarations by enabled mode names."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"#[test_only] \u2261 #[mode(test)]"}),"."]}),"\n",(0,o.jsx)(n.li,{children:"Unannotated declarations are always included."}),"\n",(0,o.jsx)(n.li,{children:"Annotated declarations are included if and only if any listed name is enabled."}),"\n",(0,o.jsx)(n.li,{children:"Enabling any mode (including test) mean the build is not publishable."}),"\n",(0,o.jsx)(n.li,{children:"Modes affect compile-time inclusion only; other than publishability, they are erased at the\nbytecode level."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"mode-basics",children:"Mode Basics"}),"\n",(0,o.jsx)(n.p,{children:"Modes are expressed with the attributes:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"#[mode(name1, name2, ...)]\n\n#[test_only] // (shorthand for #[mode(test)])\n"})}),"\n",(0,o.jsx)(n.p,{children:"Code compiled with any mode enabled (including test) is not publishable."}),"\n",(0,o.jsx)(n.p,{children:"This section defines the syntax, inclusion rules, scope, and tool interactions for modes. (For an\nintroductory tutorial with examples, see the guide page.)"}),"\n",(0,o.jsx)(n.h3,{id:"mode-annotations",children:"Mode Annotations"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"#[mode(...)]"})," may be placed on modules and module members (functions, structs, constants,\netc.)."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"#[mode(name1, name2, ...)]\nmodule <addr_opt>::<ident> { ... }\n\nmodule <addr_opt>::<ident> {\n    #[mode(name1, name2, ...)]\n    <decl>\n}\n"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Note"}),": ",(0,o.jsx)(n.code,{children:"#[test_only]"})," is exactly equivalent to ",(0,o.jsx)(n.code,{children:"#[mode(test)]"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"mode-names",children:"Mode Names"}),"\n",(0,o.jsx)(n.p,{children:"Each name is a nonempty identifier. Mode names are compared case-sensitively."}),"\n",(0,o.jsx)(n.h2,{id:"inclusion-model",children:"Inclusion model"}),"\n",(0,o.jsxs)(n.p,{children:["Let ",(0,o.jsx)(n.code,{children:"M"})," be the set of enabled modes for a build. Let ",(0,o.jsx)(n.code,{children:"S(m)"})," be the set of modes listed on\ndeclaration ",(0,o.jsx)(n.code,{children:"m"}),", where ",(0,o.jsx)(n.code,{children:"#[test_only]"})," contributes ",(0,o.jsx)(n.code,{children:"{test}"}),", and unannotated declarations have ",(0,o.jsx)(n.code,{children:"S(x) = \u2205"}),". A declaration x is included in the compilation unit if and only if one of the following is\ntrue:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"S(x) = \u2205"})," (unannotated)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"S(x) \u2229 M \u2260 \u2205:"})," (annotation included)"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"That is: unannotated declarations are always included; annotated declarations are included if and\nonly if at least one of their listed names is enabled in the build, and otherwise they are excluded."}),"\n",(0,o.jsx)(n.h3,{id:"module-scope",children:"Module scope"}),"\n",(0,o.jsxs)(n.p,{children:["If a module is excluded, all of its members are excluded implicitly. If a module is included, an\nannotated member may still be excluded if its own ",(0,o.jsx)(n.code,{children:"S(m)"})," does not intersect ",(0,o.jsx)(n.code,{children:"M"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"multiple-modes-on-one-attribute",children:"Multiple modes on one attribute"}),"\n",(0,o.jsxs)(n.p,{children:["The list in ",(0,o.jsx)(n.code,{children:"#[mode(a, b, c)]"})," is disjunctive (logical OR): inclusion occurs if any listed name\nmatches."]}),"\n",(0,o.jsx)(n.h2,{id:"name-resolution--duplicates",children:"Name resolution & duplicates"}),"\n",(0,o.jsx)(n.p,{children:"Modes are a compile-time filter only. They do not introduce runtime conditionals and have no\nrepresentation in bytecode. All verification is performed on the included subset of the source."}),"\n",(0,o.jsx)(n.p,{children:"Standard name resolution rules apply when duplicates are present. That means two modes may not\nenable different modules or members with the same name in the same build. Similarly, a\nmode-annotated definition may not override an unannotated declaration with the same name."}),"\n",(0,o.jsx)(n.p,{children:"To provide mode-specific alternatives, place them in separate modules gated by modes, or use\ndistinct names and select them in tests or drivers."}),"\n",(0,o.jsx)(n.h2,{id:"usage-tooling--flags",children:"Usage Tooling & flags"}),"\n",(0,o.jsxs)(n.p,{children:["For building and testing, ",(0,o.jsx)(n.code,{children:"move build --mode <name>"})," adds ",(0,o.jsx)(n.code,{children:"<name>"})," to ",(0,o.jsx)(n.code,{children:"M"}),". Multiple modes may be\nenabled by passing ",(0,o.jsx)(n.code,{children:"--mode"})," repeatedly; ",(0,o.jsx)(n.code,{children:"M "})," is the union of all names passed, e.g., ",(0,o.jsx)(n.code,{children:"move build --mode test --mode debug"}),". This will enable all modules and members annotated with either\n",(0,o.jsx)(n.code,{children:"#[mode(test)]"})," or ",(0,o.jsx)(n.code,{children:"#[mode(debug)]"}),". Note that ",(0,o.jsx)(n.code,{children:"move test"})," implicitly supplies ",(0,o.jsx)(n.code,{children:"--mode test"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"publishability",children:"Publishability"}),"\n",(0,o.jsx)(n.p,{children:"Any build that enables at least one mode (including test) produces non-publishable outputs. To\ncreate publishable artifacts, no modes may be enabled."})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(r,{...e})}):r(e)}}}]);