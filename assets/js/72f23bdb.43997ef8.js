"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4489],{1158:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"programmability/one-time-witness","title":"One Time Witness","description":"While regular Witness is a great way to statically prove the ownership of a","source":"@site/../book/programmability/one-time-witness.md","sourceDirName":"programmability","slug":"/programmability/one-time-witness","permalink":"/programmability/one-time-witness","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"8.10. Pattern: Witness","permalink":"/programmability/witness-pattern"},"next":{"title":"8.12. Publisher Authority","permalink":"/programmability/publisher"}}');var s=t(3420),o=t(5521);const r={},a="One Time Witness",l={},c=[{value:"Definition",id:"definition",level:2},{value:"Enforcing the OTW",id:"enforcing-the-otw",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"one-time-witness",children:"One Time Witness"})}),"\n",(0,s.jsxs)(n.p,{children:["While regular ",(0,s.jsx)(n.a,{href:"./witness-pattern",children:"Witness"})," is a great way to statically prove the ownership of a\ntype, there are cases where we need to ensure that a Witness is instantiated only once. And this is\nthe purpose of the One Time Witness (OTW)."]}),"\n",(0,s.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,s.jsx)(n.p,{children:"The OTW is a special type of Witness that can be used only once. It cannot be manually created and\nit is guaranteed to be unique per module. Sui Adapter treats a type as an OTW if it follows these\nrules:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Has only ",(0,s.jsx)(n.code,{children:"drop"})," ability."]}),"\n",(0,s.jsx)(n.li,{children:"Has no fields."}),"\n",(0,s.jsx)(n.li,{children:"Is not a generic type."}),"\n",(0,s.jsx)(n.li,{children:"Named after the module with all uppercase letters."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Here is an example of an OTW:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/one-time-witness.move anchor=definition",children:"module book::one_time;\n\n/// The OTW for the `book::one_time` module.\n/// Only `drop`, no fields, no generics, all uppercase.\npublic struct ONE_TIME has drop {}\n\n/// Receive the instance of `ONE_TIME` as the first argument.\nfun init(otw: ONE_TIME, ctx: &mut TxContext) {\n    // do something with the OTW\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The OTW cannot be constructed manually, and any code attempting to do so will result in a\ncompilation error. The OTW can be received as the first argument in the\n",(0,s.jsx)(n.a,{href:"./module-initializer",children:"module initializer"}),". And because the ",(0,s.jsx)(n.code,{children:"init"})," function is called only once per\nmodule, the OTW is guaranteed to be instantiated only once."]}),"\n",(0,s.jsx)(n.h2,{id:"enforcing-the-otw",children:"Enforcing the OTW"}),"\n",(0,s.jsxs)(n.p,{children:["To check if a type is an OTW, ",(0,s.jsx)(n.code,{children:"sui::types"})," module of the ",(0,s.jsx)(n.a,{href:"./sui-framework",children:"Sui Framework"})," offers a\nspecial function ",(0,s.jsx)(n.code,{children:"is_one_time_witness"})," that can be used to check if the type is an OTW."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/one-time-witness.move anchor=usage",children:"use sui::types;\n\nconst ENotOneTimeWitness: u64 = 1;\n\n/// Takes an OTW as an argument, aborts if the type is not OTW.\npublic fun takes_witness<T: drop>(otw: T) {\n    assert!(types::is_one_time_witness(&otw), ENotOneTimeWitness);\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(n.p,{children:["The OTW pattern is a great way to ensure that a type is used only once. Most of the developers\nshould understand how to define and receive the OTW, while the OTW checks and enforcement is mostly\nneeded in libraries and frameworks. For example, the ",(0,s.jsx)(n.code,{children:"sui::coin"})," module requires an OTW in the\n",(0,s.jsx)(n.code,{children:"coin::create_currency"})," method, therefore enforcing that the ",(0,s.jsx)(n.code,{children:"coin::TreasuryCap"})," is created only\nonce."]}),"\n",(0,s.jsxs)(n.p,{children:["OTW is a powerful tool that lays the foundation for the ",(0,s.jsx)(n.a,{href:"./publisher",children:"Publisher"})," object, which we\nwill cover in the next section."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},5521:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6672);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);