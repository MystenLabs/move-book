"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3362],{2042:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"abilities","title":"Abilities | Reference","description":"","source":"@site/../reference/abilities.md","sourceDirName":".","slug":"/abilities","permalink":"/reference/abilities","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Abilities | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"11. Generics","permalink":"/reference/generics"},"next":{"title":"13. Uses and Aliases","permalink":"/reference/uses"}}');var t=i(3420),o=i(5521);const a={title:"Abilities | Reference",description:""},l="Abilities",r={},d=[{value:"The Four Abilities",id:"the-four-abilities",level:2},{value:"<code>copy</code>",id:"copy",level:3},{value:"<code>drop</code>",id:"drop",level:3},{value:"<code>store</code>",id:"store",level:3},{value:"<code>key</code>",id:"key",level:3},{value:"Builtin Types",id:"builtin-types",level:2},{value:"Annotating Structs and Enums",id:"annotating-structs-and-enums",level:2},{value:"Conditional Abilities and Generic Types",id:"conditional-abilities-and-generic-types",level:2},{value:"Example: conditional <code>copy</code>",id:"example-conditional-copy",level:3},{value:"Example: conditional <code>drop</code>",id:"example-conditional-drop",level:3},{value:"Example: conditional <code>store</code>",id:"example-conditional-store",level:3},{value:"Example: conditional <code>key</code>",id:"example-conditional-key",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"abilities",children:"Abilities"})}),"\n",(0,t.jsx)(n.p,{children:'Abilities are a typing feature in Move that control what actions are permissible for values of a\ngiven type. This system grants fine grained control over the "linear" typing behavior of values, as\nwell as if and how values are used in storage (as defined by the specific deployment of Move, e.g.\nthe notion of storage for the blockchain). This is implemented by gating access to certain bytecode\ninstructions so that for a value to be used with the bytecode instruction, it must have the ability\nrequired (if one is required at all\u2014not every instruction is gated by an ability).'}),"\n",(0,t.jsxs)(n.p,{children:["For Sui, ",(0,t.jsx)(n.code,{children:"key"})," is used to signify an ",(0,t.jsx)(n.a,{href:"./abilities/object",children:"object"}),". Objects are the basic unit of\nstorage where each object has a unique, 32-byte ID. ",(0,t.jsx)(n.code,{children:"store"})," is then used to both indicate what data\ncan be stored inside of an object, and is also used to indicate what types can be transferred\noutside of their defining module."]}),"\n",(0,t.jsx)(n.h2,{id:"the-four-abilities",children:"The Four Abilities"}),"\n",(0,t.jsx)(n.p,{children:"The four abilities are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#copy",children:(0,t.jsx)(n.code,{children:"copy"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Allows values of types with this ability to be copied."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#drop",children:(0,t.jsx)(n.code,{children:"drop"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Allows values of types with this ability to be popped/dropped."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#store",children:(0,t.jsx)(n.code,{children:"store"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Allows values of types with this ability to exist inside a value in storage."}),"\n",(0,t.jsxs)(n.li,{children:["For Sui, ",(0,t.jsx)(n.code,{children:"store"})," controls what data can be stored inside of an ",(0,t.jsx)(n.a,{href:"./abilities/object",children:"object"}),".\n",(0,t.jsx)(n.code,{children:"store"})," also controls what types can be transferred outside of their defining module."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#key",children:(0,t.jsx)(n.code,{children:"key"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'Allows the type to serve as a "key" for storage. Ostensibly this means the value can be a\ntop-level value in storage; in other words, it does not need to be contained in another value to\nbe in storage.'}),"\n",(0,t.jsxs)(n.li,{children:["For Sui, ",(0,t.jsx)(n.code,{children:"key"})," is used to signify an ",(0,t.jsx)(n.a,{href:"./abilities/object",children:"object"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"copy",children:(0,t.jsx)(n.code,{children:"copy"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"copy"})," ability allows values of types with that ability to be copied. It gates the ability to\ncopy values out of local variables with the ",(0,t.jsx)(n.a,{href:"./variables#move-and-copy",children:(0,t.jsx)(n.code,{children:"copy"})})," operator and to copy\nvalues via references with\n",(0,t.jsxs)(n.a,{href:"./primitive-types/references#reading-and-writing-through-references",children:["dereference ",(0,t.jsx)(n.code,{children:"*e"})]}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["If a value has ",(0,t.jsx)(n.code,{children:"copy"}),", all values contained inside of that value have ",(0,t.jsx)(n.code,{children:"copy"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"drop",children:(0,t.jsx)(n.code,{children:"drop"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"drop"})," ability allows values of types with that ability to be dropped. By dropped, we mean that\nvalue is not transferred and is effectively destroyed as the Move program executes. As such, this\nability gates the ability to ignore values in a multitude of locations, including:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"not using the value in a local variable or parameter"}),"\n",(0,t.jsxs)(n.li,{children:["not using the value in a ",(0,t.jsxs)(n.a,{href:"./variables#expression-blocks",children:["sequence via ",(0,t.jsx)(n.code,{children:";"})]})]}),"\n",(0,t.jsxs)(n.li,{children:["overwriting values in variables in ",(0,t.jsx)(n.a,{href:"./variables#assignments",children:"assignments"})]}),"\n",(0,t.jsxs)(n.li,{children:["overwriting values via references when\n",(0,t.jsxs)(n.a,{href:"./primitive-types/references#reading-and-writing-through-references",children:["writing ",(0,t.jsx)(n.code,{children:"*e1 = e2"})]}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If a value has ",(0,t.jsx)(n.code,{children:"drop"}),", all values contained inside of that value have ",(0,t.jsx)(n.code,{children:"drop"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"store",children:(0,t.jsx)(n.code,{children:"store"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"store"})," ability allows values of types with this ability to exist inside of a value in storage,\n",(0,t.jsx)(n.em,{children:"but"})," not necessarily as a top-level value in storage. This is the only ability that does not\ndirectly gate an operation. Instead it gates the existence in storage when used in tandem with\n",(0,t.jsx)(n.code,{children:"key"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["If a value has ",(0,t.jsx)(n.code,{children:"store"}),", all values contained inside of that value have ",(0,t.jsx)(n.code,{children:"store"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["For Sui, ",(0,t.jsx)(n.code,{children:"store"})," serves double duty. It controls what values can appear inside of an\n",(0,t.jsx)(n.a,{href:"/storage/store-ability",children:"object"}),", and what objects can be\n",(0,t.jsx)(n.a,{href:"./abilities/object#transfer-rules",children:"transferred"})," outside of their defining module."]}),"\n",(0,t.jsx)(n.h3,{id:"key",children:(0,t.jsx)(n.code,{children:"key"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"key"})," ability allows the type to serve as a key for storage operations as defined by the\ndeployment of Move. While it is specific per Move instance, it serves to gates all storage\noperations, so in order for a type to be used with storage primitives, the type must have the ",(0,t.jsx)(n.code,{children:"key"}),"\nability."]}),"\n",(0,t.jsxs)(n.p,{children:["If a value has ",(0,t.jsx)(n.code,{children:"key"}),", all values contained inside of that value have ",(0,t.jsx)(n.code,{children:"store"}),". This is the only\nability with this sort of asymmetry."]}),"\n",(0,t.jsxs)(n.p,{children:["For Sui, ",(0,t.jsx)(n.code,{children:"key"})," is used to signify an ",(0,t.jsx)(n.a,{href:"./abilities/object",children:"object"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"builtin-types",children:"Builtin Types"}),"\n",(0,t.jsxs)(n.p,{children:["All primitive, builtin types have ",(0,t.jsx)(n.code,{children:"copy"}),", ",(0,t.jsx)(n.code,{children:"drop"}),", and ",(0,t.jsx)(n.code,{children:"store"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"bool"}),", ",(0,t.jsx)(n.code,{children:"u8"}),", ",(0,t.jsx)(n.code,{children:"u16"}),", ",(0,t.jsx)(n.code,{children:"u32"}),", ",(0,t.jsx)(n.code,{children:"u64"}),", ",(0,t.jsx)(n.code,{children:"u128"}),", ",(0,t.jsx)(n.code,{children:"u256"}),", and ",(0,t.jsx)(n.code,{children:"address"})," all have ",(0,t.jsx)(n.code,{children:"copy"}),", ",(0,t.jsx)(n.code,{children:"drop"}),", and\n",(0,t.jsx)(n.code,{children:"store"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"vector<T>"})," may have ",(0,t.jsx)(n.code,{children:"copy"}),", ",(0,t.jsx)(n.code,{children:"drop"}),", and ",(0,t.jsx)(n.code,{children:"store"})," depending on the abilities of ",(0,t.jsx)(n.code,{children:"T"}),".","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["See ",(0,t.jsx)(n.a,{href:"#conditional-abilities-and-generic-types",children:"Conditional Abilities and Generic Types"})," for more\ndetails."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Immutable references ",(0,t.jsx)(n.code,{children:"&"})," and mutable references ",(0,t.jsx)(n.code,{children:"&mut"})," both have ",(0,t.jsx)(n.code,{children:"copy"})," and ",(0,t.jsx)(n.code,{children:"drop"}),".","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"This refers to copying and dropping the reference itself, not what they refer to."}),"\n",(0,t.jsxs)(n.li,{children:["References cannot appear in global storage, hence they do not have ",(0,t.jsx)(n.code,{children:"store"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Note that none of the primitive types have ",(0,t.jsx)(n.code,{children:"key"}),", meaning none of them can be used directly with\nstorage operations."]}),"\n",(0,t.jsx)(n.h2,{id:"annotating-structs-and-enums",children:"Annotating Structs and Enums"}),"\n",(0,t.jsxs)(n.p,{children:["To declare that a ",(0,t.jsx)(n.code,{children:"struct"})," or ",(0,t.jsx)(n.code,{children:"enum"})," has an ability, it is declared with ",(0,t.jsx)(n.code,{children:"has <ability>"})," after the\ndatatype name and either before or after the fields/variants. For example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",metastring:"file=packages/reference/sources/abilities.move anchor=annotating_datatypes",children:"public struct Ignorable has drop { f: u64 }\npublic struct Pair has copy, drop, store { x: u64, y: u64 }\npublic struct MyVec(vector<u64>) has copy, drop, store;\n\npublic enum IgnorableEnum has drop { Variant }\npublic enum PairEnum has copy, drop, store { Variant }\npublic enum MyVecEnum { Variant } has copy, drop, store;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this case: ",(0,t.jsx)(n.code,{children:"Ignorable*"})," has the ",(0,t.jsx)(n.code,{children:"drop"})," ability. ",(0,t.jsx)(n.code,{children:"Pair*"})," and ",(0,t.jsx)(n.code,{children:"MyVec*"})," both have ",(0,t.jsx)(n.code,{children:"copy"}),", ",(0,t.jsx)(n.code,{children:"drop"}),",\nand ",(0,t.jsx)(n.code,{children:"store"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"All of these abilities have strong guarantees over these gated operations. The operation can be\nperformed on the value only if it has that ability; even if the value is deeply nested inside of\nsome other collection!"}),"\n",(0,t.jsx)(n.p,{children:"As such: when declaring a struct\u2019s abilities, certain requirements are placed on the fields. All\nfields must satisfy these constraints. These rules are necessary so that structs satisfy the\nreachability rules for the abilities given above. If a struct is declared with the ability..."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"copy"}),", all fields must have ",(0,t.jsx)(n.code,{children:"copy"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"drop"}),", all fields must have ",(0,t.jsx)(n.code,{children:"drop"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"store"}),", all fields must have ",(0,t.jsx)(n.code,{children:"store"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"key"}),", all fields must have ",(0,t.jsx)(n.code,{children:"store"}),".","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"key"})," is the only ability currently that doesn\u2019t require itself."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["An enum can have any of these abilities with the exception of ",(0,t.jsx)(n.code,{children:"key"}),", which enums cannot have because\nthey cannot be top-level values (objects) in storage. The same rules apply to fields of enum\nvariants as they do for struct fields though. In particular, if an enum is declared with the\nability..."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"copy"}),", all fields of all variants must have ",(0,t.jsx)(n.code,{children:"copy"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"drop"}),", all fields of all variants must have ",(0,t.jsx)(n.code,{children:"drop"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"store"}),", all fields of all variants must have ",(0,t.jsx)(n.code,{children:"store"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"key"}),", is not allowed on enums as previously mentioned."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"// A struct without any abilities\npublic struct NoAbilities {}\n\npublic struct WantsCopy has copy {\n    f: NoAbilities, // ERROR 'NoAbilities' does not have 'copy'\n}\n\npublic enum WantsCopyEnum has copy {\n    Variant1\n    Variant2(NoAbilities), // ERROR 'NoAbilities' does not have 'copy'\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"and similarly:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"// A struct without any abilities\npublic struct NoAbilities {}\n\npublic struct MyData has key {\n    f: NoAbilities, // Error 'NoAbilities' does not have 'store'\n}\n\npublic struct MyDataEnum has store {\n    Variant1,\n    Variant2(NoAbilities), // Error 'NoAbilities' does not have 'store'\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"conditional-abilities-and-generic-types",children:"Conditional Abilities and Generic Types"}),"\n",(0,t.jsx)(n.p,{children:"When abilities are annotated on a generic type, not all instances of that type are guaranteed to\nhave that ability. Consider this struct declaration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"public struct Cup<T> has copy, drop, store, key { item: T }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["It might be very helpful if ",(0,t.jsx)(n.code,{children:"Cup"})," could hold any type, regardless of its abilities. The type system\ncan ",(0,t.jsx)(n.em,{children:"see"})," the type parameter, so it should be able to remove abilities from ",(0,t.jsx)(n.code,{children:"Cup"})," if it ",(0,t.jsx)(n.em,{children:"sees"})," a\ntype parameter that would violate the guarantees for that ability."]}),"\n",(0,t.jsxs)(n.p,{children:["This behavior might sound a bit confusing at first, but it might be more understandable if we think\nabout collection types. We could consider the builtin type ",(0,t.jsx)(n.code,{children:"vector"})," to have the following type\ndeclaration:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"vector<T> has copy, drop, store;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We want ",(0,t.jsx)(n.code,{children:"vector"}),"s to work with any type. We don't want separate ",(0,t.jsx)(n.code,{children:"vector"})," types for different\nabilities. So what are the rules we would want? Precisely the same that we would want with the field\nrules above. So, it would be safe to copy a ",(0,t.jsx)(n.code,{children:"vector"})," value only if the inner elements can be copied.\nIt would be safe to ignore a ",(0,t.jsx)(n.code,{children:"vector"})," value only if the inner elements can be ignored/dropped. And,\nit would be safe to put a ",(0,t.jsx)(n.code,{children:"vector"})," in storage only if the inner elements can be in storage."]}),"\n",(0,t.jsxs)(n.p,{children:["To have this extra expressiveness, a type might not have all the abilities it was declared with\ndepending on the instantiation of that type; instead, the abilities a type will have depends on both\nits declaration ",(0,t.jsx)(n.strong,{children:"and"})," its type arguments. For any type, type parameters are pessimistically\nassumed to be used inside of the struct, so the abilities are only granted if the type parameters\nmeet the requirements described above for fields. Taking ",(0,t.jsx)(n.code,{children:"Cup"})," from above as an example:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Cup"})," has the ability ",(0,t.jsx)(n.code,{children:"copy"})," only if ",(0,t.jsx)(n.code,{children:"T"})," has ",(0,t.jsx)(n.code,{children:"copy"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["It has ",(0,t.jsx)(n.code,{children:"drop"})," only if ",(0,t.jsx)(n.code,{children:"T"})," has ",(0,t.jsx)(n.code,{children:"drop"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["It has ",(0,t.jsx)(n.code,{children:"store"})," only if ",(0,t.jsx)(n.code,{children:"T"})," has ",(0,t.jsx)(n.code,{children:"store"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["It has ",(0,t.jsx)(n.code,{children:"key"})," only if ",(0,t.jsx)(n.code,{children:"T"})," has ",(0,t.jsx)(n.code,{children:"store"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here are examples for this conditional system for each ability:"}),"\n",(0,t.jsxs)(n.h3,{id:"example-conditional-copy",children:["Example: conditional ",(0,t.jsx)(n.code,{children:"copy"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"public struct NoAbilities {}\npublic struct S has copy, drop { f: bool }\npublic struct Cup<T> has copy, drop, store { item: T }\n\nfun example(c_x: Cup<u64>, c_s: Cup<S>) {\n    // Valid, 'Cup<u64>' has 'copy' because 'u64' has 'copy'\n    let c_x2 = copy c_x;\n    // Valid, 'Cup<S>' has 'copy' because 'S' has 'copy'\n    let c_s2 = copy c_s;\n}\n\nfun invalid(c_account: Cup<signer>, c_n: Cup<NoAbilities>) {\n    // Invalid, 'Cup<signer>' does not have 'copy'.\n    // Even though 'Cup' was declared with copy, the instance does not have 'copy'\n    // because 'signer' does not have 'copy'\n    let c_account2 = copy c_account;\n    // Invalid, 'Cup<NoAbilities>' does not have 'copy'\n    // because 'NoAbilities' does not have 'copy'\n    let c_n2 = copy c_n;\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"example-conditional-drop",children:["Example: conditional ",(0,t.jsx)(n.code,{children:"drop"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"public struct NoAbilities {}\npublic struct S has copy, drop { f: bool }\npublic struct Cup<T> has copy, drop, store { item: T }\n\nfun unused() {\n    Cup<bool> { item: true }; // Valid, 'Cup<bool>' has 'drop'\n    Cup<S> { item: S { f: false }}; // Valid, 'Cup<S>' has 'drop'\n}\n\nfun left_in_local(c_account: Cup<signer>): u64 {\n    let c_b = Cup<bool> { item: true };\n    let c_s = Cup<S> { item: S { f: false }};\n    // Valid return: 'c_account', 'c_b', and 'c_s' have values\n    // but 'Cup<signer>', 'Cup<bool>', and 'Cup<S>' have 'drop'\n    0\n}\n\nfun invalid_unused() {\n    // Invalid, Cannot ignore 'Cup<NoAbilities>' because it does not have 'drop'.\n    // Even though 'Cup' was declared with 'drop', the instance does not have 'drop'\n    // because 'NoAbilities' does not have 'drop'\n    Cup<NoAbilities> { item: NoAbilities {} };\n}\n\nfun invalid_left_in_local(): u64 {\n    let n = Cup<NoAbilities> { item: NoAbilities {} };\n    // Invalid return: 'c_n' has a value\n    // and 'Cup<NoAbilities>' does not have 'drop'\n    0\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"example-conditional-store",children:["Example: conditional ",(0,t.jsx)(n.code,{children:"store"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"public struct Cup<T> has copy, drop, store { item: T }\n\n// 'MyInnerData is declared with 'store' so all fields need 'store'\nstruct MyInnerData has store {\n    yes: Cup<u64>, // Valid, 'Cup<u64>' has 'store'\n    // no: Cup<signer>, Invalid, 'Cup<signer>' does not have 'store'\n}\n\n// 'MyData' is declared with 'key' so all fields need 'store'\nstruct MyData has key {\n    yes: Cup<u64>, // Valid, 'Cup<u64>' has 'store'\n    inner: Cup<MyInnerData>, // Valid, 'Cup<MyInnerData>' has 'store'\n    // no: Cup<signer>, Invalid, 'Cup<signer>' does not have 'store'\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"example-conditional-key",children:["Example: conditional ",(0,t.jsx)(n.code,{children:"key"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"public struct NoAbilities {}\npublic struct MyData<T> has key { f: T }\n\nfun valid(addr: address) acquires MyData {\n    // Valid, 'MyData<u64>' has 'key'\n    transfer(addr, MyData<u64> { f: 0 });\n}\n\nfun invalid(addr: address) {\n   // Invalid, 'MyData<NoAbilities>' does not have 'key'\n   transfer(addr, MyData<NoAbilities> { f: NoAbilities {} })\n   // Invalid, 'MyData<NoAbilities>' does not have 'key'\n   borrow<NoAbilities>(addr);\n   // Invalid, 'MyData<NoAbilities>' does not have 'key'\n   borrow_mut<NoAbilities>(addr);\n}\n\n// Mock storage operation\nnative public fun transfer<T: key>(addr: address, value: T);\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},5521:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var s=i(6672);const t={},o=s.createContext(t);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);