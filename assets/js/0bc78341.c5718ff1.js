"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6045],{1294:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"move-basics/string","title":"String","description":"While Move does not have a built-in type to represent strings, it does have two standard","source":"@site/../book/move-basics/string.md","sourceDirName":"move-basics","slug":"/move-basics/string","permalink":"/move-basics/string","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.12. Option","permalink":"/move-basics/option"},"next":{"title":"5.14. Control Flow","permalink":"/move-basics/control-flow"}}');var i=t(2714),r=t(4811);const o={},a="String",c={},d=[{value:"Strings are bytes",id:"strings-are-bytes",level:2},{value:"Working with UTF-8 Strings",id:"working-with-utf-8-strings",level:2},{value:"Definition",id:"definition",level:3},{value:"Creating a String",id:"creating-a-string",level:3},{value:"Common Operations",id:"common-operations",level:3},{value:"Safe UTF-8 Operations",id:"safe-utf-8-operations",level:3},{value:"UTF-8 Limitations",id:"utf-8-limitations",level:3},{value:"ASCII Strings",id:"ascii-strings",level:2},{value:"Further Reading",id:"further-reading",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"string",children:"String"})}),"\n",(0,i.jsxs)(n.p,{children:["While Move does not have a built-in type to represent strings, it does have two standard\nimplementations for strings in the ",(0,i.jsx)(n.a,{href:"./standard-library",children:"Standard Library"}),". The ",(0,i.jsx)(n.code,{children:"std::string"})," module\ndefines a ",(0,i.jsx)(n.code,{children:"String"})," type and methods for UTF-8 encoded strings, and the second module, ",(0,i.jsx)(n.code,{children:"std::ascii"}),",\nprovides an ASCII ",(0,i.jsx)(n.code,{children:"String"})," type and its methods."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["The Sui execution environment automatically converts bytevector into ",(0,i.jsx)(n.code,{children:"String"})," in transaction\ninputs. As a result, in many cases, constructing a String directly within the\n",(0,i.jsx)(n.a,{href:"./../concepts/what-is-a-transaction",children:"Transaction Block"})," is unnecessary."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"strings-are-bytes",children:"Strings are bytes"}),"\n",(0,i.jsxs)(n.p,{children:["No matter which type of string you use, it is important to know that strings are just bytes. The\nwrappers provided by the ",(0,i.jsx)(n.code,{children:"string"})," and ",(0,i.jsx)(n.code,{children:"ascii"})," modules are just that: wrappers. They do provide\nsafety checks and methods to work with strings, but at the end of the day, they are just vectors of\nbytes."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/string.move anchor=custom",children:"module book::custom_string;\n\n/// Anyone can implement a custom string-like type by wrapping a vector.\npublic struct MyString {\n    bytes: vector<u8>,\n}\n\n/// Implement a `from_bytes` function to convert a vector of bytes to a string.\npublic fun from_bytes(bytes: vector<u8>): MyString {\n    MyString { bytes }\n}\n\n/// Implement a `bytes` function to convert a string to a vector of bytes.\npublic fun bytes(self: &MyString): &vector<u8> {\n    &self.bytes\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"working-with-utf-8-strings",children:"Working with UTF-8 Strings"}),"\n",(0,i.jsxs)(n.p,{children:["While there are two types of strings (",(0,i.jsx)(n.code,{children:"string"})," and ",(0,i.jsx)(n.code,{children:"ascii"}),") in the standard library, the ",(0,i.jsx)(n.code,{children:"string"}),"\nmodule should be considered the default. It has native implementations of many common operations,\nleveraging low-level, optimized runtime code for superior performance. In contrast, the ",(0,i.jsx)(n.code,{children:"ascii"}),"\nmodule is fully implemented in Move, relying on higher-level abstractions and making it less\nsuitable for performance-critical tasks."]}),"\n",(0,i.jsx)(n.h3,{id:"definition",children:"Definition"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"String"})," type in the ",(0,i.jsx)(n.code,{children:"std::string"})," module is defined as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module std::string;\n\n/// A `String` holds a sequence of bytes which is guaranteed to be in utf8 format.\npublic struct String has copy, drop, store {\n    bytes: vector<u8>,\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["See ",(0,i.jsx)(n.a,{href:"https://docs.sui.io/references/framework/std/string",children:"full documentation for std::string"})," module."]})}),"\n",(0,i.jsx)(n.h3,{id:"creating-a-string",children:"Creating a String"}),"\n",(0,i.jsxs)(n.p,{children:["To create a new UTF-8 ",(0,i.jsx)(n.code,{children:"String"})," instance, you can use the ",(0,i.jsx)(n.code,{children:"string::utf8"})," method. The\n",(0,i.jsx)(n.a,{href:"./standard-library",children:"Standard Library"})," provides an alias ",(0,i.jsx)(n.code,{children:".to_string()"})," on the ",(0,i.jsx)(n.code,{children:"vector<u8>"})," for\nconvenience."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/string.move anchor=utf8",children:'// the module is `std::string` and the type is `String`\nuse std::string::{Self, String};\n\n// strings are normally created using the `utf8` function\n// type declaration is not necessary, we put it here for clarity\nlet hello: String = string::utf8(b"Hello");\n\n// The `.to_string()` alias on the `vector<u8>` is more convenient\nlet hello = b"Hello".to_string();\n'})}),"\n",(0,i.jsx)(n.h3,{id:"common-operations",children:"Common Operations"}),"\n",(0,i.jsxs)(n.p,{children:["UTF8 String provides a number of methods to work with strings. The most common operations on strings\nare: concatenation, slicing, and getting the length. Additionally, for custom string operations, the\n",(0,i.jsx)(n.code,{children:"bytes()"})," method can be used to get the underlying byte vector."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:'let mut str = b"Hello,".to_string();\nlet another = b" World!".to_string();\n\n// append(String) adds the content to the end of the string\nstr.append(another);\n\n// `sub_string(start, end)` copies a slice of the string\nstr.sub_string(0, 5); // "Hello"\n\n// `length()` returns the number of bytes in the string\nstr.length(); // 12 (bytes)\n\n// methods can also be chained! Get a length of a substring\nstr.sub_string(0, 5).length(); // 5 (bytes)\n\n// whether the string is empty\nstr.is_empty(); // false\n\n// get the underlying byte vector for custom operations\nlet bytes: &vector<u8> = str.bytes();\n'})}),"\n",(0,i.jsx)(n.h3,{id:"safe-utf-8-operations",children:"Safe UTF-8 Operations"}),"\n",(0,i.jsxs)(n.p,{children:["The default ",(0,i.jsx)(n.code,{children:"utf8"})," method may abort if the bytes passed into it are not valid UTF-8. If you are not\nsure that the bytes you are passing are valid, you should use the ",(0,i.jsx)(n.code,{children:"try_utf8"})," method instead. It\nreturns an ",(0,i.jsx)(n.code,{children:"Option<String>"}),", which contains no value if the bytes are not valid UTF-8, and a string\notherwise."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Hint: Functions with names starting with ",(0,i.jsx)(n.code,{children:"try_*"})," typically return an ",(0,i.jsx)(n.code,{children:"Option"}),". If the operation\nsucceeds, the result is wrapped in ",(0,i.jsx)(n.code,{children:"Some"}),". If it fails, the function returns ",(0,i.jsx)(n.code,{children:"None"}),". This naming\nconvention, commonly used in Move, is inspired by Rust."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/string.move anchor=safe_utf8",children:'// this is a valid UTF-8 string\nlet hello = b"Hello".try_to_string();\n\nassert!(hello.is_some()); // abort if the value is not valid UTF-8\n\n// this is not a valid UTF-8 string\nlet invalid = b"\\xFF".try_to_string();\n\nassert!(invalid.is_none()); // abort if the value is valid UTF-8\n'})}),"\n",(0,i.jsx)(n.h3,{id:"utf-8-limitations",children:"UTF-8 Limitations"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"string"})," module does not provide a way to access individual characters in a string. This is\nbecause UTF-8 is a variable-length encoding, and the length of a character can be anywhere from 1 to\n4 bytes. Similarly, the ",(0,i.jsx)(n.code,{children:"length()"})," method returns the number of bytes in the string, not the number\nof characters."]}),"\n",(0,i.jsxs)(n.p,{children:["However, methods like ",(0,i.jsx)(n.code,{children:"sub_string"})," and ",(0,i.jsx)(n.code,{children:"insert"})," validate character boundaries and abort if the\nspecified index falls within the middle of a character."]}),"\n",(0,i.jsx)(n.h2,{id:"ascii-strings",children:"ASCII Strings"}),"\n",(0,i.jsx)(n.p,{children:"This section is coming soon!"}),"\n",(0,i.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://docs.sui.io/references/framework/std/string",children:"std::string"})," module documentation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://docs.sui.io/references/framework/std/ascii",children:"std::ascii"})," module documentation."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},4811:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(9378);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);