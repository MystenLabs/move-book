"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8599],{2309:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"move-basics/generics","title":"Generics","description":"Generics are a way to define a type or function that can work with any type. This is useful when you","source":"@site/../book/move-basics/generics.md","sourceDirName":"move-basics","slug":"/move-basics/generics","permalink":"/move-basics/generics","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.23. References","permalink":"/move-basics/references"},"next":{"title":"5.25. Type Reflection","permalink":"/move-basics/type-reflection"}}');var i=t(3420),r=t(5521);const s={},c="Generics",o={},l=[{value:"In the Standard Library",id:"in-the-standard-library",level:2},{value:"Generic Syntax",id:"generic-syntax",level:2},{value:"Multiple Type Parameters",id:"multiple-type-parameters",level:2},{value:"Why Generics?",id:"why-generics",level:2},{value:"Phantom Type Parameters",id:"phantom-type-parameters",level:2},{value:"Constraints on Type Parameters",id:"constraints-on-type-parameters",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"generics",children:"Generics"})}),"\n",(0,i.jsx)(n.p,{children:"Generics are a way to define a type or function that can work with any type. This is useful when you\nwant to write a function which can be used with different types, or when you want to define a type\nthat can hold any other type. Generics are the foundation of many advanced features in Move\nincluding collections, abstract implementations, and more."}),"\n",(0,i.jsx)(n.h2,{id:"in-the-standard-library",children:"In the Standard Library"}),"\n",(0,i.jsxs)(n.p,{children:["In this chapter we already mentioned the ",(0,i.jsx)(n.a,{href:"./vector",children:"vector"})," type, which is a generic type that can\nhold any other type. Another example of a generic type in the standard library is the\n",(0,i.jsx)(n.a,{href:"./option",children:"Option"})," type, which is used to represent a value that may or may not be present."]}),"\n",(0,i.jsx)(n.h2,{id:"generic-syntax",children:"Generic Syntax"}),"\n",(0,i.jsxs)(n.p,{children:["To define a generic type or function, a type signature needs to have a list of generic parameters\nenclosed in angle brackets (",(0,i.jsx)(n.code,{children:"<"})," and ",(0,i.jsx)(n.code,{children:">"}),"). The generic parameters are separated by commas."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/generics.move anchor=container",children:"/// Container for any type `T`.\npublic struct Container<T> has drop {\n    value: T,\n}\n\n/// Function that creates a new `Container` with a generic value `T`.\npublic fun new<T>(value: T): Container<T> {\n    Container { value }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, ",(0,i.jsx)(n.code,{children:"Container"})," is a generic type with a single type parameter ",(0,i.jsx)(n.code,{children:"T"}),", the ",(0,i.jsx)(n.code,{children:"value"}),"\nfield of the container stores the ",(0,i.jsx)(n.code,{children:"T"}),". The ",(0,i.jsx)(n.code,{children:"new"})," function is a generic function with a single type\nparameter ",(0,i.jsx)(n.code,{children:"T"}),", and it returns a ",(0,i.jsx)(n.code,{children:"Container"})," with the given value. Generic types must be initialized\nwith a concrete type, and generic functions must be called with a concrete type, although in some\ncases the Move compiler can infer the correct type."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/generics.move anchor=test_container",children:"#[test]\nfun test_container() {\n    // these three lines are equivalent\n    let container: Container<u8> = new(10); // type inference\n    let container = new<u8>(10); // create a new `Container` with a `u8` value\n    let container = new(10u8);\n\n    assert!(container.value == 10, 0x0);\n\n    // Value can be ignored only if it has the `drop` ability.\n    let Container { value: _ } = container;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the test function ",(0,i.jsx)(n.code,{children:"test_generic"}),", we demonstrate three equivalent ways to create a new\n",(0,i.jsx)(n.code,{children:"Container"})," with a ",(0,i.jsx)(n.code,{children:"u8"})," value. Because numeric constants have ambiguous types, we must specify the\ntype of the number literal somewhere (in the type of the container, the parameter to ",(0,i.jsx)(n.code,{children:"new"}),", or the\nnumber literal itself); once we specify one of these the compiler can infer the others."]}),"\n",(0,i.jsx)(n.h2,{id:"multiple-type-parameters",children:"Multiple Type Parameters"}),"\n",(0,i.jsx)(n.p,{children:"You can define a type or function with multiple type parameters. The type parameters are separated\nby commas."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/generics.move anchor=pair",children:"/// A pair of values of any type `T` and `U`.\npublic struct Pair<T, U> {\n    first: T,\n    second: U,\n}\n\n/// Function that creates a new `Pair` with two generic values `T` and `U`.\npublic fun new_pair<T, U>(first: T, second: U): Pair<T, U> {\n    Pair { first, second }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, ",(0,i.jsx)(n.code,{children:"Pair"})," is a generic type with two type parameters ",(0,i.jsx)(n.code,{children:"T"})," and ",(0,i.jsx)(n.code,{children:"U"}),", and the\n",(0,i.jsx)(n.code,{children:"new_pair"})," function is a generic function with two type parameters ",(0,i.jsx)(n.code,{children:"T"})," and ",(0,i.jsx)(n.code,{children:"U"}),". The function returns\na ",(0,i.jsx)(n.code,{children:"Pair"})," with the given values. The order of the type parameters is important, and should match the\norder of the type parameters in the type signature."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/generics.move anchor=test_pair",children:"#[test]\nfun test_generic() {\n    // these three lines are equivalent\n    let pair_1: Pair<u8, bool> = new_pair(10, true); // type inference\n    let pair_2 = new_pair<u8, bool>(10, true); // create a new `Pair` with a `u8` and `bool` values\n    let pair_3 = new_pair(10u8, true);\n\n    assert!(pair_1.first == 10, 0x0);\n    assert!(pair_1.second, 0x0);\n\n    // Unpacking is identical.\n    let Pair { first: _, second: _ } = pair_1;\n    let Pair { first: _, second: _ } = pair_2;\n    let Pair { first: _, second: _ } = pair_3;\n\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If we added another instance where we swapped type parameters in the ",(0,i.jsx)(n.code,{children:"new_pair"})," function, and tried\nto compare two types, we'd see that the type signatures are different, and cannot be compared."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/generics.move anchor=test_pair_swap",children:"#[test]\nfun test_swap_type_params() {\n    let pair1: Pair<u8, bool> = new_pair(10u8, true);\n    let pair2: Pair<bool, u8> = new_pair(true, 10u8);\n\n    // this line will not compile\n    // assert!(pair1 == pair2, 0x0);\n\n    let Pair { first: pf1, second: ps1 } = pair1; // first1: u8, second1: bool\n    let Pair { first: pf2, second: ps2 } = pair2; // first2: bool, second2: u8\n\n    assert!(pf1 == ps2); // 10 == 10\n    assert!(ps1 == pf2); // true == true\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Since the types for ",(0,i.jsx)(n.code,{children:"pair1"})," and ",(0,i.jsx)(n.code,{children:"pair2"})," are different, the comparison ",(0,i.jsx)(n.code,{children:"pair1 == pair2"})," will not\ncompile."]}),"\n",(0,i.jsx)(n.h2,{id:"why-generics",children:"Why Generics?"}),"\n",(0,i.jsx)(n.p,{children:"In the examples above we focused on instantiating generic types and calling generic functions to\ncreate instances of these types. However, the real power of generics lies in their ability to define\nshared behavior for the base, generic type, and then use it independently of the concrete types.\nThis is especially useful when working with collections, abstract implementations, and other\nadvanced features in Move."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/generics.move anchor=user",children:"/// A user record with name, age, and some generic metadata\npublic struct User<T> {\n    name: String,\n    age: u8,\n    /// Varies depending on application.\n    metadata: T,\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, ",(0,i.jsx)(n.code,{children:"User"})," is a generic type with a single type parameter ",(0,i.jsx)(n.code,{children:"T"}),", with shared fields\n",(0,i.jsx)(n.code,{children:"name"}),", ",(0,i.jsx)(n.code,{children:"age"}),", and the generic ",(0,i.jsx)(n.code,{children:"metadata"})," field, which can store any type. No matter what ",(0,i.jsx)(n.code,{children:"metadata"}),"\nis, all instances of ",(0,i.jsx)(n.code,{children:"User"})," will contain the same fields and methods."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/generics.move anchor=update_user",children:"/// Updates the name of the user.\npublic fun update_name<T>(user: &mut User<T>, name: String) {\n    user.name = name;\n}\n\n/// Updates the age of the user.\npublic fun update_age<T>(user: &mut User<T>, age: u8) {\n    user.age = age;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"phantom-type-parameters",children:"Phantom Type Parameters"}),"\n",(0,i.jsxs)(n.p,{children:["In some cases, you may want to define a generic type with a type parameter that is not used in the\nfields or methods of the type. This is called a ",(0,i.jsx)(n.em,{children:"phantom type parameter"}),". Phantom type parameters\nare useful when you want to define a type that can hold any other type, but you want to enforce some\nconstraints on the type parameter."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/generics.move anchor=phantom",children:"/// A generic type with a phantom type parameter.\npublic struct Coin<phantom T> {\n    value: u64\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Coin"})," type here does not contain any fields or methods that use the type parameter ",(0,i.jsx)(n.code,{children:"T"}),". It is\nused to differentiate between different types of coins, and to enforce some constraints on the type\nparameter ",(0,i.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/generics.move anchor=test_phantom",children:"public struct USD {}\npublic struct EUR {}\n\n#[test]\nfun test_phantom_type() {\n    let coin1: Coin<USD> = Coin { value: 10 };\n    let coin2: Coin<EUR> = Coin { value: 20 };\n\n    // Unpacking is identical because the phantom type parameter is not used.\n    let Coin { value: _ } = coin1;\n    let Coin { value: _ } = coin2;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, we demonstrate how to create two different instances of ",(0,i.jsx)(n.code,{children:"Coin"})," with different\nphantom type parameters ",(0,i.jsx)(n.code,{children:"USD"})," and ",(0,i.jsx)(n.code,{children:"EUR"}),". The type parameter ",(0,i.jsx)(n.code,{children:"T"})," is not used in the fields or methods\nof the ",(0,i.jsx)(n.code,{children:"Coin"})," type, but it is used to differentiate between different types of coins. This helps\nensure that the ",(0,i.jsx)(n.code,{children:"USD"})," and ",(0,i.jsx)(n.code,{children:"EUR"})," coins are not mistakenly mixed up."]}),"\n",(0,i.jsx)(n.h2,{id:"constraints-on-type-parameters",children:"Constraints on Type Parameters"}),"\n",(0,i.jsxs)(n.p,{children:["Type parameters can be constrained to have certain abilities. This is useful when you need the inner\ntype to allow certain behaviors, such as ",(0,i.jsx)(n.em,{children:"copy"})," or ",(0,i.jsx)(n.em,{children:"drop"}),". The syntax for constraining a type\nparameter is ",(0,i.jsx)(n.code,{children:"T: <ability> + <ability>"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/generics.move anchor=constraints",children:"/// A generic type with a type parameter that has the `drop` ability.\npublic struct Droppable<T: drop> {\n    value: T,\n}\n\n/// A generic struct with a type parameter that has the `copy` and `drop` abilities.\npublic struct CopyableDroppable<T: copy + drop> {\n    value: T, // T must have the `copy` and `drop` abilities\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The Move Compiler will enforce that the type parameter ",(0,i.jsx)(n.code,{children:"T"})," has the specified abilities. If the type\nparameter does not have the specified abilities, the code will not compile."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/generics.move anchor=test_constraints",children:"/// Type without any abilities.\npublic struct NoAbilities {}\n\n#[test]\nfun test_constraints() {\n    // Fails - `NoAbilities` does not have the `drop` ability\n    // let droppable = Droppable<NoAbilities> { value: 10 };\n\n    // Fails - `NoAbilities` does not have the `copy` and `drop` abilities\n    // let copyable_droppable = CopyableDroppable<NoAbilities> { value: 10 };\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"./../../reference/generics",children:"Generics"})," in the Move Reference."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},5521:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var a=t(6672);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);