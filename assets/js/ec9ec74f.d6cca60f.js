"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2121],{3473:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"storage/storage-functions","title":"Storage Functions","description":"The module that defines main storage operations is sui::transfer. It is implicitly imported in all","source":"@site/../book/storage/storage-functions.md","sourceDirName":"storage","slug":"/storage/storage-functions","permalink":"/storage/storage-functions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"7.3. Ability: Store","permalink":"/storage/store-ability"},"next":{"title":"7.5. UID and ID","permalink":"/storage/uid-and-id"}}');var i=t(3420),r=t(5521);const a={},c="Storage Functions",o={},d=[{value:"Overview",id:"overview",level:2},{value:"Ownership and References: a Quick Recap",id:"ownership-and-references-a-quick-recap",level:2},{value:"Internal Rule in Transfer Functions",id:"internal-rule-in-transfer-functions",level:2},{value:"Transfer",id:"transfer",level:2},{value:"Transfer Example",id:"transfer-example",level:3},{value:"Public Transfer",id:"public-transfer",level:3},{value:"Quick Recap",id:"quick-recap",level:3},{value:"Freeze",id:"freeze",level:2},{value:"Owned -&gt; Frozen",id:"owned---frozen",level:2},{value:"Share",id:"share",level:2},{value:"Special Case: Shared Object Deletion",id:"special-case-shared-object-deletion",level:2},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"storage-functions",children:"Storage Functions"})}),"\n",(0,i.jsxs)(n.p,{children:["The module that defines main storage operations is ",(0,i.jsx)(n.code,{children:"sui::transfer"}),". It is implicitly imported in all\npackages that depend on the ",(0,i.jsx)(n.a,{href:"./../programmability/sui-framework",children:"Sui Framework"}),", so, like other\nimplicitly imported modules (e.g. ",(0,i.jsx)(n.code,{children:"std::option"})," or ",(0,i.jsx)(n.code,{children:"std::vector"}),"), it does not require adding a use\nstatement."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["For quick reference, ",(0,i.jsx)(n.a,{href:"/appendix/transfer-functions",children:"Appendix C: Transfer Functions"}),"\ncontains a list of all storage functions and object states."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"transfer"})," module provides functions to perform storage operations for each of the\n",(0,i.jsx)(n.a,{href:"./../object/ownership",children:"ownership types"}),"."]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#transfer",children:"Transfer"})," - send an object to an address, put it into ",(0,i.jsx)(n.em,{children:"address owned"})," state;"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#freeze",children:"Freeze"})," - put an object into ",(0,i.jsx)(n.em,{children:"immutable"})," state, so it becomes a ",(0,i.jsx)(n.em,{children:"public constant"})," and\ncan never change."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#share",children:"Share"})," - put an object into a ",(0,i.jsx)(n.em,{children:"shared"})," state, so it is available to everyone;"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"transfer"})," module is a go-to for most of the storage operations, except a special case with\n",(0,i.jsx)(n.a,{href:"./../programmability/dynamic-fields",children:"Dynamic Fields"})," which are covered in the next chapter."]}),"\n",(0,i.jsx)(n.h2,{id:"ownership-and-references-a-quick-recap",children:"Ownership and References: a Quick Recap"}),"\n",(0,i.jsxs)(n.p,{children:["In the ",(0,i.jsx)(n.a,{href:"./../move-basics/ownership-and-scope",children:"Ownership and Scope"})," and\n",(0,i.jsx)(n.a,{href:"./../move-basics/references",children:"References"})," chapters, we covered the basics of ownership and\nreferences in Move. It is important that you understand these concepts when using storage functions.\nHere is a quick recap of the most important points:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.em,{children:"move"})," semantics in Move means that the value is ",(0,i.jsx)(n.em,{children:"moved"})," from one scope to another. In other\nwords, if an instance of a type is passed to a function ",(0,i.jsx)(n.em,{children:"by value"}),", it is ",(0,i.jsx)(n.em,{children:"moved"})," to the function\nscope and can't be accessed in the caller scope anymore."]}),"\n",(0,i.jsxs)(n.li,{children:["To maintain the ownership of the value, you can pass it ",(0,i.jsx)(n.em,{children:"by reference"}),". Either by ",(0,i.jsx)(n.em,{children:"immutable\nreference"})," ",(0,i.jsx)(n.code,{children:"&T"})," or ",(0,i.jsx)(n.em,{children:"mutable reference"})," ",(0,i.jsx)(n.code,{children:"&mut T"}),". Then the value is ",(0,i.jsx)(n.em,{children:"borrowed"})," and can be accessed\nin the callee scope, however the owner stays the same."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"/// Moved by value\npublic fun take<T>(value: T) { /* value is moved here! */ abort }\n\n/// For immutable reference, value stays in parent scope.\npublic fun borrow<T>(value: &T) { /* value is borrowed here! can be read */ abort }\n\n/// For mutable reference, value stays in parent scope but can be mutated.\npublic fun borrow_mut<T>(value: &mut T) { /* value is mutably borrowed here! */ abort }\n"})}),"\n",(0,i.jsx)(n.h2,{id:"internal-rule-in-transfer-functions",children:"Internal Rule in Transfer Functions"}),"\n",(0,i.jsxs)(n.p,{children:["Storage operations can only be performed on objects, and come in two forms: ",(0,i.jsx)(n.em,{children:"internal"})," and ",(0,i.jsx)(n.em,{children:"public"}),".\nInternal, or sometimes called ",(0,i.jsx)(n.em,{children:"restricted"}),", transfer functions can be performed on ",(0,i.jsx)(n.a,{href:"/storage/key-ability",children:(0,i.jsx)(n.code,{children:"key"})}),"-only\ntypes, and - comes with the name - enforce ",(0,i.jsx)(n.a,{href:"/storage/internal-constraint",children:"internal constraint"}),". Public\nversions can be called on any object that has ",(0,i.jsx)(n.code,{children:"key"})," and ",(0,i.jsx)(n.a,{href:"/storage/store-ability",children:(0,i.jsx)(n.code,{children:"store"})}),". Hence, ",(0,i.jsx)(n.code,{children:"key"}),"-only types'\nstorage is fully governed by their defining module, and ",(0,i.jsx)(n.code,{children:"store"})," allows calling public transfer\nfunctions in other modules."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"/// T: internal, can be called only in the module which defines the `T`.\npublic fun transfer<T: key>(obj: T, recipient: address);\n\n/// No requirement for `T` to be internal to the caller, but requires `store`.\npublic fun public_transfer<T: key + store>(obj: T, recipient: address);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, the ",(0,i.jsx)(n.code,{children:"transfer"})," function can only be called from the module that defines the\n",(0,i.jsx)(n.code,{children:"T"}),", and has a type constraint ",(0,i.jsx)(n.code,{children:"T: key"}),". While ",(0,i.jsx)(n.code,{children:"public_transfer"})," - clearly indicated in the name -\ncan be called from any module, but requires ",(0,i.jsx)(n.code,{children:"T"})," to have ",(0,i.jsx)(n.code,{children:"key"})," and ",(0,i.jsx)(n.code,{children:"store"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Knowing this rule is critical for understanding application design in Move. Choice between making\nobject publicly transferable (",(0,i.jsx)(n.code,{children:"key"})," and ",(0,i.jsx)(n.code,{children:"store"}),") and keeping it internal (",(0,i.jsx)(n.code,{children:"key"}),"-only) may\ndrastically affect application logic and further development."]}),"\n",(0,i.jsx)(n.h2,{id:"transfer",children:"Transfer"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"transfer::transfer"})," function is a function used to transfer an object to an address. Its\nsignature is as follows, only accepts a type with the ",(0,i.jsxs)(n.a,{href:"/storage/key-ability",children:[(0,i.jsx)(n.code,{children:"key"})," ability"]})," and an\n",(0,i.jsx)(n.a,{href:"/move-basics/address",children:"address"})," of the recipient. Note that the object is passed into the\nfunction ",(0,i.jsx)(n.em,{children:"by value"}),", therefore it is ",(0,i.jsx)(n.em,{children:"moved"})," to the function scope and then moved to the recipient\naddress."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module sui::transfer;\n\n// Transfer `obj` to `recipient`.\npublic fun transfer<T: key>(obj: T, recipient: address);\n\n// Public version of the `transfer` function.\npublic fun public_transfer<T: key + store>(obj: T, recipient: address);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"transfer-example",children:"Transfer Example"}),"\n",(0,i.jsx)(n.p,{children:"In the following example, you can see how it can be used in a module that defines and sends an\nobject to the transaction sender."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module book::transfer_to_sender;\n\n/// A struct with `key` is an object. The first field is `id: UID`!\npublic struct AdminCap has key { id: UID }\n\n/// `init` function is a special function that is called when the module\n/// is published. It is a good place to do a setup for an application.\nfun init(ctx: &mut TxContext) {\n    // Create a new `AdminCap` object, in this scope.\n    let admin_cap = AdminCap { id: object::new(ctx) };\n\n    // Transfer the object to the transaction sender.\n    transfer::transfer(admin_cap, ctx.sender());\n}\n\n/// Transfers the `AdminCap` object to the `recipient`. Thus, the recipient\n/// becomes the owner of the object, and only they can access it.\npublic fun transfer_admin_cap(cap: AdminCap, recipient: address) {\n    transfer::transfer(cap, recipient);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When the module is published, the ",(0,i.jsx)(n.code,{children:"init"})," function will get called, and the ",(0,i.jsx)(n.code,{children:"AdminCap"})," object which\nwe created in it will be ",(0,i.jsx)(n.em,{children:"transferred"})," to the transaction sender. The ",(0,i.jsx)(n.code,{children:"ctx.sender()"})," function\nreturns the sender address for the current transaction."]}),"\n",(0,i.jsxs)(n.p,{children:["Once the ",(0,i.jsx)(n.code,{children:"AdminCap"})," has been transferred to the sender, for example, to ",(0,i.jsx)(n.code,{children:"0xa11ce"}),", the sender, and\nonly the sender, will be able to access the object. This type of ownership is called ",(0,i.jsx)(n.em,{children:"address\nownership"}),"."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Address owned objects are a subject to ",(0,i.jsx)(n.em,{children:"true ownership"})," - only owner address can access them. This\nis a fundamental concept in the Sui storage model."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"public-transfer",children:"Public Transfer"}),"\n",(0,i.jsxs)(n.p,{children:["Let's extend the example with a function that uses ",(0,i.jsx)(n.code,{children:"AdminCap"})," to authorize a mint of a new object\nand its transfer to an address:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"/// Some `Gift` object that the admin can `mint_and_transfer` to an address.\npublic struct Gift has key, store { id: UID }\n\n/// Creates a new `Gift` object and transfers it to the `recipient`.\npublic fun mint_and_transfer(\n    _: &AdminCap, recipient: address, ctx: &mut TxContext\n) {\n    let gift = Gift { id: object::new(ctx) };\n    transfer::public_transfer(gift, recipient);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"mint_and_transfer"})," function is a ",(0,i.jsx)(n.em,{children:"public"}),' function that "could" be called by anyone, but it\nrequires a reference to an ',(0,i.jsx)(n.code,{children:"AdminCap"})," as the first argument. Without it, the function will not be\ncallable. This is a simple and very explicit way to restrict access to privileged functions called\n",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.a,{href:"./../programmability/capability",children:"Capability"})}),". Because the ",(0,i.jsx)(n.code,{children:"AdminCap"})," object is ",(0,i.jsx)(n.em,{children:"address owned"}),",\nonly ",(0,i.jsx)(n.code,{children:"0xa11ce"})," will be able to call the ",(0,i.jsx)(n.code,{children:"mint_and_transfer"})," function."]}),"\n",(0,i.jsxs)(n.p,{children:["Unlike ",(0,i.jsx)(n.code,{children:"AdminCap"})," where we restricted transferability as well as usability by adding only ",(0,i.jsx)(n.code,{children:"key"}),"\nability, ",(0,i.jsx)(n.code,{children:"Gift"})," has a ",(0,i.jsx)(n.code,{children:"key"})," and ",(0,i.jsx)(n.code,{children:"store"})," combination, which means, that whoever owns a ",(0,i.jsx)(n.code,{children:"Gift"})," can\nfreely call ",(0,i.jsx)(n.code,{children:"transfer::public_transfer"})," and send it to anyone else. Without ",(0,i.jsx)(n.code,{children:"store"}),", in our current\nimplementation, ",(0,i.jsx)(n.code,{children:"Gift"})," would've been ",(0,i.jsx)(n.em,{children:'"soulbound"'})," meaning that the happy owner of the ",(0,i.jsx)(n.code,{children:"Gift"})," would\nnot be able to do anything with it."]}),"\n",(0,i.jsx)(n.h3,{id:"quick-recap",children:"Quick Recap"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"transfer"})," function is used to send an object to an address;"]}),"\n",(0,i.jsxs)(n.li,{children:["The object becomes ",(0,i.jsx)(n.em,{children:"address owned"})," and can only be accessed by the recipient;"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Address owned"})," object can be used by reference or by value, including being transferred to\nanother address;"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Public"})," version of it is ",(0,i.jsx)(n.code,{children:"public_transfer"})," and requires ",(0,i.jsx)(n.code,{children:"store"})]}),"\n",(0,i.jsxs)(n.li,{children:["Functions can be gated by requiring an object to be passed as an argument, creating a\n",(0,i.jsx)(n.em,{children:"capability"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"freeze",children:"Freeze"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"transfer::freeze_object"})," function is a function that is used to put an object into an\n",(0,i.jsx)(n.em,{children:"immutable"})," state. Once an object is ",(0,i.jsx)(n.em,{children:"frozen"}),", it can never change, and it can be accessed by anyone\nby immutable reference."]}),"\n",(0,i.jsxs)(n.p,{children:["The function signature is as follows, only accepts a type with the ",(0,i.jsxs)(n.a,{href:"./key-ability",children:[(0,i.jsx)(n.code,{children:"key"})," ability"]}),".\nJust like all other storage functions, it takes the object ",(0,i.jsx)(n.em,{children:"by value"}),". The public version of this\nfunction is ",(0,i.jsx)(n.code,{children:"public_freeze_object"}),", and requires ",(0,i.jsx)(n.code,{children:"T"})," to have ",(0,i.jsx)(n.code,{children:"store"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module sui::transfer;\n\n// Make object immutable and allow anyone to read it.\npublic fun freeze_object<T: key>(obj: T);\n\n// Public version of the `freeze_object` function.\npublic fun public_freeze_object<T: key + store>(obj: T);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's extend the previous example and add a function that allows the admin to create a ",(0,i.jsx)(n.code,{children:"Config"}),"\nobject and freeze it:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"/// Some `Config` object that the admin can `create_and_freeze`.\npublic struct Config has key {\n    id: UID,\n    message: String\n}\n\n/// Creates a new `Config` object and freezes it.\npublic fun create_and_freeze(\n    _: &AdminCap,\n    message: String,\n    ctx: &mut TxContext\n) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Freeze the object so it becomes immutable.\n    transfer::freeze_object(config);\n}\n\n/// Returns the message from the `Config` object.\n/// Can access the object by immutable reference!\npublic fun message(c: &Config): String { c.message }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Config is an object that has a ",(0,i.jsx)(n.code,{children:"message"})," field, and the ",(0,i.jsx)(n.code,{children:"create_and_freeze"})," function creates a new\n",(0,i.jsx)(n.code,{children:"Config"})," and freezes it. Once the object is frozen, it can be accessed by anyone by immutable\nreference. The ",(0,i.jsx)(n.code,{children:"message"})," function is a public function that returns the message from the ",(0,i.jsx)(n.code,{children:"Config"}),"\nobject. Config is now publicly available by its ID, and the message can be read by anyone."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Function definitions are not connected to object's state. It is possible to define a function that\ntakes a mutable reference to a type that is always frozen. However, it will not be callable on a\nfrozen object."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"message"})," function in the example above can be called on an immutable ",(0,i.jsx)(n.code,{children:"Config"})," object. However,\ntwo functions shown below are not callable on a frozen object:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"// === These can't be called on a frozen object! ===\n\n/// The function can be defined, but it won't be callable on a frozen object.\n/// Only immutable references are allowed.\npublic fun message_mut(c: &mut Config): &mut String { &mut c.message }\n\n/// Deletes the `Config` object, takes it by value.\n/// Can't be called on a frozen object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"To summarize:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"transfer::freeze_object"})," function is used to put an object into an ",(0,i.jsx)(n.em,{children:"immutable"})," state;"]}),"\n",(0,i.jsxs)(n.li,{children:["Once an object is ",(0,i.jsx)(n.em,{children:"frozen"}),", it can never be changed, deleted or transferred, and it can be\naccessed by anyone by immutable reference;"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Public"})," version of the ",(0,i.jsx)(n.code,{children:"freeze_object"})," function is ",(0,i.jsx)(n.code,{children:"public_freeze_object"})," and requires the ",(0,i.jsx)(n.code,{children:"T"})," to\nhave ",(0,i.jsx)(n.code,{children:"store"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"owned---frozen",children:"Owned -> Frozen"}),"\n",(0,i.jsxs)(n.p,{children:["Since the ",(0,i.jsx)(n.code,{children:"transfer::freeze_object"})," signature accepts any type with the ",(0,i.jsx)(n.code,{children:"key"})," ability, it can take\nan object that was created in the same scope, but it can also take an object that was owned by an\naccount. This means that the ",(0,i.jsx)(n.code,{children:"freeze_object"})," function can be used to ",(0,i.jsx)(n.em,{children:"freeze"})," an object that was\n",(0,i.jsx)(n.em,{children:"transferred"})," to the sender. For security concerns, we would not want to freeze the ",(0,i.jsx)(n.code,{children:"AdminCap"}),"\nobject - it would be a security risk, since anyone would be able to access it. However, we can\nfreeze the ",(0,i.jsx)(n.code,{children:"Gift"})," object that was minted and transferred to the recipient:"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Single Owner -> Immutable conversion is possible!"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"/// Freezes the `Gift` object so it becomes immutable.\n/// Gift has `key` and `store`, so `public_freeze_object` can be used!\npublic fun freeze_gift(gift: Gift) {\n    transfer::public_freeze_object(gift);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"share",children:"Share"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"transfer::share_object"})," function is a function used to put an object into a ",(0,i.jsx)(n.em,{children:"shared"})," state.\nOnce an object is ",(0,i.jsx)(n.em,{children:"shared"}),", it can be accessed by anyone by a mutable reference (hence, immutable\ntoo). The function signature is as follows, only accepts a type with the\n",(0,i.jsxs)(n.a,{href:"./key-ability",children:[(0,i.jsx)(n.code,{children:"key"})," ability"]}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module sui::transfer;\n\n/// Put an object to a Shared state - can be accessed mutably and immutably.\npublic fun share_object<T: key>(obj: T);\n\n/// Public version of `share_object` function.\npublic fun public_share_object<T: key + store>(obj: T);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Like other transfer functions, ",(0,i.jsx)(n.code,{children:"share_object"})," has its ",(0,i.jsx)(n.em,{children:"public"})," version which requires ",(0,i.jsx)(n.code,{children:"T"})," to have\n",(0,i.jsx)(n.code,{children:"store"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Once an object is ",(0,i.jsx)(n.em,{children:"shared"}),", it is publicly available as a mutable reference."]}),"\n",(0,i.jsx)(n.h2,{id:"special-case-shared-object-deletion",children:"Special Case: Shared Object Deletion"}),"\n",(0,i.jsx)(n.p,{children:"While the shared object can't normally be taken by value, there is one special case where it can -\nif the function that takes it deletes the object. This is a special case in the Sui storage model,\nand it is used to allow the deletion of shared objects. To show how it works, we will create a\nfunction that creates and shares a Config object and then another one that deletes it:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"/// Creates a new `Config` object and shares it.\npublic fun create_and_share(message: String, ctx: &mut TxContext) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Share the object so it becomes shared.\n    transfer::share_object(config);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"create_and_share"})," function creates a new ",(0,i.jsx)(n.code,{children:"Config"})," object and shares it. The object is now\npublicly available as a mutable reference. Let's create a function that deletes the shared object:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"/// Deletes the `Config` object, takes it by value.\n/// Can be called on a shared object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"delete_config"})," function takes the ",(0,i.jsx)(n.code,{children:"Config"})," object by value and deletes it, and the Sui Verifier\nwould allow this call. However, if the function returned the ",(0,i.jsx)(n.code,{children:"Config"})," object back or attempted to\n",(0,i.jsx)(n.code,{children:"freeze"})," or ",(0,i.jsx)(n.code,{children:"transfer"})," it, the Sui Verifier would reject the transaction."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"// Won't work!\npublic fun transfer_shared(c: Config, to: address) {\n    transfer::transfer(c, to);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"To summarize:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"share_object"})," function is used to put an object into a ",(0,i.jsx)(n.em,{children:"shared"})," state;"]}),"\n",(0,i.jsxs)(n.li,{children:["Once an object is ",(0,i.jsx)(n.em,{children:"shared"}),", it can be accessed by anyone by a mutable reference;"]}),"\n",(0,i.jsx)(n.li,{children:"Shared objects can be deleted, but they can't be transferred or frozen;"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Public"})," version of the ",(0,i.jsx)(n.code,{children:"share_object"})," function is ",(0,i.jsx)(n.code,{children:"public_share_object"})," and requires the ",(0,i.jsx)(n.code,{children:"T"})," to\nhave ",(0,i.jsx)(n.code,{children:"store"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.p,{children:["Now that you know main features of the ",(0,i.jsx)(n.code,{children:"transfer"})," module, you can start building more complex\napplications on Sui that involve storage operations. In the next chapter, we will cover the\n",(0,i.jsx)(n.a,{href:"./store-ability",children:"Store Ability"})," which allows storing data inside objects and relaxes transfer\nrestrictions which we barely touched on here. And after that we will cover the\n",(0,i.jsx)(n.a,{href:"./uid-and-id",children:"UID and ID"})," types which are the most important types in the Sui storage model."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},5521:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var s=t(6672);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);