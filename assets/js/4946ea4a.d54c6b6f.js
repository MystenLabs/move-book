"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3979],{5521:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var a=t(6672);const s={},o=a.createContext(s);function r(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(o.Provider,{value:n},e.children)}},9222:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"functions/macros","title":"Macro Functions | Reference","description":"","source":"@site/../reference/functions/macros.md","sourceDirName":"functions","slug":"/functions/macros","permalink":"/reference/functions/macros","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Macro Functions | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"Functions | Reference","permalink":"/reference/functions"},"next":{"title":"8. Structs","permalink":"/reference/structs"}}');var s=t(3420),o=t(5521);const r={title:"Macro Functions | Reference",description:""},i="Macro Functions",l={},c=[{value:"Syntax",id:"syntax",level:2},{value:"Lambdas",id:"lambdas",level:2},{value:"Capturing",id:"capturing",level:3},{value:"Limitations",id:"limitations",level:3},{value:"Typing",id:"typing",level:2},{value:"Type Parameters",id:"type-parameters",level:3},{value:"<code>_</code> Type",id:"_-type",level:3},{value:"Expansion and Substitution",id:"expansion-and-substitution",level:2},{value:"Hygiene",id:"hygiene",level:3},{value:"Control Flow",id:"control-flow",level:3},{value:"Method Syntax",id:"method-syntax",level:3},{value:"Parameter Limitations",id:"parameter-limitations",level:3},{value:"Examples",id:"examples",level:2},{value:"Lazy arguments: assert_eq",id:"lazy-arguments-assert_eq",level:3},{value:"Any integer square root",id:"any-integer-square-root",level:3},{value:"Iterating over a vector",id:"iterating-over-a-vector",level:3},{value:"Non-loop lambda usage",id:"non-loop-lambda-usage",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"macro-functions",children:"Macro Functions"})}),"\n",(0,s.jsxs)(n.p,{children:["Macro functions are a way of defining functions that are expanded during compilation at each call\nsite. The arguments of the macro are not evaluated eagerly like a normal function, and instead are\nsubstituted by expression. In addition, the caller can supply code to the macro via\n",(0,s.jsx)(n.a,{href:"#lambdas",children:"lambdas"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["These expression substitution mechanics make ",(0,s.jsx)(n.code,{children:"macro"})," functions similar\n",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Macro_(computer_science)",children:"to macros found in other programming languages"}),";\nhowever, they are more constrained in Move than you might expect from other languages. The\nparameters and return values of ",(0,s.jsx)(n.code,{children:"macro"})," functions are still typed--though this can be partially\nrelaxed with the ",(0,s.jsxs)(n.a,{href:"./../generics#_-type",children:[(0,s.jsx)(n.code,{children:"_"})," type"]}),". The upside of this restriction however, is that\n",(0,s.jsx)(n.code,{children:"macro"})," functions can be used anywhere a normal function can be used, which is notably helpful with\n",(0,s.jsx)(n.a,{href:"./../method-syntax",children:"method syntax"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A more extensive\n",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Macro_(computer_science)#Syntactic_macros",children:"syntactic macro"})," system\nmay come in the future."]}),"\n",(0,s.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"macro"})," functions have a similar syntax to normal functions. However, all type parameter names and\nall parameter names must start with a ",(0,s.jsx)(n.code,{children:"$"}),". Note that ",(0,s.jsx)(n.code,{children:"_"})," can still be used by itself, but not as a\nprefix, and ",(0,s.jsx)(n.code,{children:"$_"})," must be used instead."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"<visibility>? macro fun <identifier><[$type_parameters: constraint],*>([$identifier: type],*): <return_type> <function_body>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For example, the following ",(0,s.jsx)(n.code,{children:"macro"})," function takes a vector and a lambda, and applies the lambda to\neach element of the vector to construct a new vector."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun map<$T, $U>($v: vector<$T>, $f: |$T| -> $U): vector<$U> {\n    let mut v = $v;\n    v.reverse();\n    let mut i = 0;\n    let mut result = vector[];\n    while (!v.is_empty()) {\n        result.push_back($f(v.pop_back()));\n        i = i + 1;\n    };\n    result\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"$"})," is there to indicate that the parameters (both type and value parameters) do not behave like\ntheir normal, non-macro counterparts. For type parameters, they can be instantiated with any type\n(even a reference type ",(0,s.jsx)(n.code,{children:"&"})," or ",(0,s.jsx)(n.code,{children:"&mut"}),"), and they will satisfy any constraint. Similarly for\nparameters, they will not be evaluated eagerly, and instead the argument expression will be\nsubstituted at each usage."]}),"\n",(0,s.jsx)(n.h2,{id:"lambdas",children:"Lambdas"}),"\n",(0,s.jsxs)(n.p,{children:["Lambdas are a new type of expression that can only be used with ",(0,s.jsx)(n.code,{children:"macro"}),"s. These are used to pass\ncode from the caller into the body of the ",(0,s.jsx)(n.code,{children:"macro"}),". While the substitution is done at compile time,\nthey are used similarly to ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Anonymous_function",children:"anonymous functions"}),",\n",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Lambda_calculus",children:"lambdas"}),", or\n",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Closure_(computer_programming)",children:"closures"})," in other languages."]}),"\n",(0,s.jsxs)(n.p,{children:["As seen in the example above (",(0,s.jsx)(n.code,{children:"$f: |$T| -> $U"}),"), lambda types are defined with the syntax"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"|<type>,*| (-> <type>)?\n"})}),"\n",(0,s.jsx)(n.p,{children:"A few examples"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"|u64, u64| -> u128 // a lambda that takes two u64s and returns a u128\n|&mut vector<u8>| -> &mut u8 // a lambda that takes a &mut vector<u8> and returns a &mut u8\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If the return type is not annotated, it is unit ",(0,s.jsx)(n.code,{children:"()"})," by default."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// the following are equivalent\n|&mut vector<u8>, u64|\n|&mut vector<u8>, u64| -> ()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Lambda expressions are then defined at the call site of the ",(0,s.jsx)(n.code,{children:"macro"})," with the syntax"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"|(<identifier> (: <type>)?),*| <expression>\n|(<identifier> (: <type>)?),*| -> <type> { <expression> }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that if the return type is annotated, the body of the lambda must be enclosed in ",(0,s.jsx)(n.code,{children:"{}"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Using the ",(0,s.jsx)(n.code,{children:"map"})," macro defined above"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let v = vector[1, 2, 3];\nlet doubled: vector<u64> = map!(v, |x| 2 * x);\nlet bytes: vector<vector<u8>> = map!(v, |x| std::bcs::to_bytes(&x));\n"})}),"\n",(0,s.jsx)(n.p,{children:"And with type annotations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let doubled: vector<u64> = map!(v, |x: u64| 2 * x); // return type annotation optional\nlet bytes: vector<vector<u8>> = map!(v, |x: u64| -> vector<u8> { std::bcs::to_bytes(&x) });\n"})}),"\n",(0,s.jsx)(n.h3,{id:"capturing",children:"Capturing"}),"\n",(0,s.jsx)(n.p,{children:'Lambda expressions can also refer to variables in the scope where the lambda is defined. This is\nsometimes called "capturing".'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let res = foo();\nlet incremented = map!(vector[1, 2, 3], |x| x + res);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Any variable can be captured, including mutable and immutable references."}),"\n",(0,s.jsxs)(n.p,{children:["See the ",(0,s.jsx)(n.a,{href:"#iterating-over-a-vector",children:"Examples"})," section for more complicated usages."]}),"\n",(0,s.jsx)(n.h3,{id:"limitations",children:"Limitations"}),"\n",(0,s.jsxs)(n.p,{children:["Currently, lambdas can only be used directly in the call of a ",(0,s.jsx)(n.code,{children:"macro"})," function. They cannot be bound\nto a variable. For example, the following is code will produce an error:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let f = |x| 2 * x;\n//      ^^^^^^^^^ Error! Lambdas must be used directly in 'macro' calls\nlet doubled: vector<u64> = map!(vector[1, 2, 3], f);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"typing",children:"Typing"}),"\n",(0,s.jsxs)(n.p,{children:["Like normal functions, ",(0,s.jsx)(n.code,{children:"macro"})," functions are typed--the types of the parameters and return value\nmust be annotated. However, the body of the function is not type checked until the macro is\nexpanded. This means that not all usages of a given macro may be valid. For example"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun add_one<$T>($x: $T): $T {\n    $x + 1\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The above macro will not type check if ",(0,s.jsx)(n.code,{children:"$T"})," is not a primitive integer type."]}),"\n",(0,s.jsxs)(n.p,{children:["This can be particularly useful in conjunction with ",(0,s.jsx)(n.a,{href:"./../method-syntax",children:"method syntax"}),", where the\nfunction is not resolved until after the macro is expanded."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun call_foo<$T, $U>($x: $T): &$U {\n    $x.foo()\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This macro will only expand successfully if ",(0,s.jsx)(n.code,{children:"$T"})," has a method ",(0,s.jsx)(n.code,{children:"foo"})," that returns a reference ",(0,s.jsx)(n.code,{children:"&$U"}),".\nAs described in the ",(0,s.jsx)(n.a,{href:"#hygiene",children:"hygiene"})," section, ",(0,s.jsx)(n.code,{children:"foo"})," will be resolved based on the scope where\n",(0,s.jsx)(n.code,{children:"call_foo"})," was defined--not where it was expanded."]}),"\n",(0,s.jsx)(n.h3,{id:"type-parameters",children:"Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["Type parameters can be instantiated with any type, including reference types ",(0,s.jsx)(n.code,{children:"&"})," and ",(0,s.jsx)(n.code,{children:"&mut"}),". They\ncan also be instantiated with ",(0,s.jsx)(n.a,{href:"./../primitive-types/tuples",children:"tuple types"}),", though the utility of this\nis limited currently since tuples cannot be bound to a variable."]}),"\n",(0,s.jsx)(n.p,{children:"This relaxation forces the constraints of a type parameter to be satisfied at the call site in a way\nthat does not normally occur. It is generally recommended however to add all necessary constraints\nto a type parameter. For example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public struct NoAbilities()\npublic struct CopyBox<T: copy> has copy, drop { value: T }\nmacro fun make_box<$T>($x: $T): CopyBox<$T> {\n    CopyBox { value: $x }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This macro will expand only if ",(0,s.jsx)(n.code,{children:"$T"})," is instantiated with a type with the ",(0,s.jsx)(n.code,{children:"copy"})," ability."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"make_box!(1); // Valid!\nmake_box!(NoAbilities()); // Error! 'NoAbilities' does not have the copy ability\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The suggested declaration of ",(0,s.jsx)(n.code,{children:"make_box"})," would be to add the ",(0,s.jsx)(n.code,{children:"copy"})," constraint to the type parameter.\nThis then communicates to the caller that the type must have the ",(0,s.jsx)(n.code,{children:"copy"})," ability."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun make_box<$T: copy>($x: $T): CopyBox<$T> {\n    CopyBox { value: $x }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["One might reasonably ask then, why have this relaxation if the recommendation is not to use it? The\nconstraints on type parameters simply cannot be enforced in all cases because the bodies are not\nchecked until expansion. In the following example, the ",(0,s.jsx)(n.code,{children:"copy"})," constraint on ",(0,s.jsx)(n.code,{children:"$T"})," is not necessary in\nthe signature, but is necessary in the body."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun read_ref<$T>($r: &$T): $T {\n    *$r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If however, you want to have an extremely relaxed type signature, it is instead recommended to use\nthe ",(0,s.jsxs)(n.a,{href:"#_-type",children:[(0,s.jsx)(n.code,{children:"_"})," type"]}),"."]}),"\n",(0,s.jsxs)(n.h3,{id:"_-type",children:[(0,s.jsx)(n.code,{children:"_"})," Type"]}),"\n",(0,s.jsxs)(n.p,{children:["Normally, the ",(0,s.jsxs)(n.a,{href:"./../generics#_-type",children:[(0,s.jsx)(n.code,{children:"_"})," placeholder type"]})," is used in expressions to allow for\npartial annotations of type arguments. However, with ",(0,s.jsx)(n.code,{children:"macro"})," functions, the ",(0,s.jsx)(n.code,{children:"_"}),' type can be used in\nplace of type parameters to relax the signature for any type. This should increase the ergonomics of\ndeclaring "generic" ',(0,s.jsx)(n.code,{children:"macro"})," functions."]}),"\n",(0,s.jsx)(n.p,{children:"For example, we could take any combination of integers and add them together."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun add($x: _, $y: _, $z: _): u256 {\n    ($x as u256) + ($y as u256) + ($z as u256)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Additionally, the ",(0,s.jsx)(n.code,{children:"_"})," type can be instantiated ",(0,s.jsx)(n.em,{children:"multiple"})," times with different types. For example"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public struct Box<T> has copy, drop, store { value: T }\nmacro fun create_two($f: |_| -> Box<_>): (Box<u8>, Box<u16>) {\n    ($f(0u8), $f(0u16))\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"If we declared the function with type parameters instead, the types would have to unify to a common\ntype, which is not possible in this case."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun create_two<$T>($f: |$T| -> Box<$T>): (Box<u8>, Box<u16>) {\n    ($f(0u8), $f(0u16))\n    //           ^^^^ Error! expected `u8` but found `u16`\n}\n...\nlet (a, b) = create_two!(|value| Box { value });\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this case, ",(0,s.jsx)(n.code,{children:"$T"})," must be instantiated with a single type, but inference finds that ",(0,s.jsx)(n.code,{children:"$T"})," must be\nbound to both ",(0,s.jsx)(n.code,{children:"u8"})," and ",(0,s.jsx)(n.code,{children:"u16"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["There is a tradeoff however, as the ",(0,s.jsx)(n.code,{children:"_"})," type conveys less meaning and intention for the caller.\nConsider ",(0,s.jsx)(n.code,{children:"map"})," macro from above re-declared with ",(0,s.jsx)(n.code,{children:"_"})," instead of ",(0,s.jsx)(n.code,{children:"$T"})," and ",(0,s.jsx)(n.code,{children:"$U"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun map($v: vector<_>, $f: |_| -> _): vector<_> {\n"})}),"\n",(0,s.jsxs)(n.p,{children:["There is no longer any indication of behavior of ",(0,s.jsx)(n.code,{children:"$f"})," at the type level. The caller must gain\nunderstanding from comments or the body of the macro."]}),"\n",(0,s.jsx)(n.h2,{id:"expansion-and-substitution",children:"Expansion and Substitution"}),"\n",(0,s.jsxs)(n.p,{children:["The body of the ",(0,s.jsx)(n.code,{children:"macro"})," is substituted into the call site at compile time. Each parameter is\nreplaced by the ",(0,s.jsx)(n.em,{children:"expression"}),", not the value, of its argument. For lambdas, additional local\nvariables can have values bound within the context of the ",(0,s.jsx)(n.code,{children:"macro"})," body."]}),"\n",(0,s.jsx)(n.p,{children:"Taking a very simple example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun apply($f: |u64| -> u64, $x: u64): u64 {\n    $f($x)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"With the call site"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let incremented = apply!(|x| x + 1, 5);\n"})}),"\n",(0,s.jsx)(n.p,{children:"This will roughly be expanded to"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let incremented = {\n    let x = { 5 };\n    { x + 1 }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Again, the value of ",(0,s.jsx)(n.code,{children:"x"})," is not substituted, but the expression ",(0,s.jsx)(n.code,{children:"5"})," is. This might mean that an\nargument is evaluated multiple times, or not at all, depending on the body of the ",(0,s.jsx)(n.code,{children:"macro"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun dup($f: |u64, u64| -> u64, $x: u64): u64 {\n    $f($x, $x)\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let sum = dup!(|x, y| x + y, foo());\n"})}),"\n",(0,s.jsx)(n.p,{children:"is expanded to"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let sum = {\n    let x = { foo() };\n    let y = { foo() };\n    { x + y }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that ",(0,s.jsx)(n.code,{children:"foo()"})," will be called twice. Which would not happen if ",(0,s.jsx)(n.code,{children:"dup"})," were a normal function."]}),"\n",(0,s.jsx)(n.p,{children:"It is often recommended to create predictable evaluation behavior by binding arguments to local\nvariables."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun dup($f: |u64, u64| -> u64, $x: u64): u64 {\n    let a = $x;\n    $f(a, a)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now that same call site will expand to"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let sum = {\n    let a = { foo() };\n    {\n        let x = { a };\n        let y = { a };\n        { x + y }\n    }\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"hygiene",children:"Hygiene"}),"\n",(0,s.jsxs)(n.p,{children:["In the example above, the ",(0,s.jsx)(n.code,{children:"dup"})," macro had a local variable ",(0,s.jsx)(n.code,{children:"a"})," that was used to bind the argument\n",(0,s.jsx)(n.code,{children:"$x"}),". You might ask, what would happen if the variable was instead named ",(0,s.jsx)(n.code,{children:"x"}),"? Would that conflict\nwith the ",(0,s.jsx)(n.code,{children:"x"})," in the lambda?"]}),"\n",(0,s.jsxs)(n.p,{children:["The short answer is, no. ",(0,s.jsx)(n.code,{children:"macro"})," functions are\n",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Hygienic_macro",children:"hygienic"}),", meaning that the expansion of ",(0,s.jsx)(n.code,{children:"macro"}),"s and\nlambdas will not accidentally capture variables from another scope."]}),"\n",(0,s.jsxs)(n.p,{children:["The compiler does this by associating a unique number with each scope. When the ",(0,s.jsx)(n.code,{children:"macro"})," is expanded,\nthe macro body gets its own scope. Additionally, the arguments are re-scoped on each usage."]}),"\n",(0,s.jsxs)(n.p,{children:["Modifying the ",(0,s.jsx)(n.code,{children:"dup"})," macro to use ",(0,s.jsx)(n.code,{children:"x"})," instead of ",(0,s.jsx)(n.code,{children:"a"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun dup($f: |u64, u64| -> u64, $x: u64): u64 {\n    let a = $x;\n    $f(a, a)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The expansion of the call site"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// let sum = dup!(|x, y| x + y, foo());\nlet sum = {\n    let x#1 = { foo() };\n    {\n        let x#2 = { x#1 };\n        let y#2 = { x#1 };\n        { x#2 + y#2 }\n    }\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"This is an approximation of the compiler's internal representation, some details are omitted for the\nsimplicity of this example."}),"\n",(0,s.jsx)(n.p,{children:"And each usage of an argument is re-scoped so that the different usages do not conflict."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun apply_twice($f: |u64| -> u64, $x: u64): u64 {\n    $f($x) + $f($x)\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let result = apply_twice!(|x| x + 1, { let x = 5; x });\n"})}),"\n",(0,s.jsx)(n.p,{children:"Expands to"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let result = {\n    {\n        let x#1 = { let x#2 = { 5 }; x#2 };\n        { x#1 + x#1 }\n    }\n    +\n    {\n        let x#3 = { let x#4 = { 5 }; x#4 };\n        { x#3 + x#3 }\n    }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Similar to variable hygiene, ",(0,s.jsx)(n.a,{href:"./../method-syntax",children:"method resolution"})," is also scoped to the macro\ndefinition. For example"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public struct S { f: u64, g: u64 }\n\nfun f(s: &S): u64 {\n    s.f\n}\nfun g(s: &S): u64 {\n    s.g\n}\n\nuse fun f as foo;\nmacro fun call_foo($s: &S): u64 {\n    let s = $s;\n    s.foo()\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The method call ",(0,s.jsx)(n.code,{children:"foo"})," will in this case always resolve to the function ",(0,s.jsx)(n.code,{children:"f"}),", even if ",(0,s.jsx)(n.code,{children:"call_foo"})," is\nused in a scope where ",(0,s.jsx)(n.code,{children:"foo"})," is bound to a different function, such as ",(0,s.jsx)(n.code,{children:"g"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun example(s: &S): u64 {\n    use fun g as foo;\n    call_foo!(s) // expands to 'f(s)', not 'g(s)'\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Due to this though, unused ",(0,s.jsx)(n.code,{children:"use fun"})," declarations might not get warnings in modules with ",(0,s.jsx)(n.code,{children:"macro"}),"\nfunctions."]}),"\n",(0,s.jsx)(n.h3,{id:"control-flow",children:"Control Flow"}),"\n",(0,s.jsx)(n.p,{children:"Similar to variable hygiene, control flow constructs are also always scoped to where they are\ndefined, not to where they are expanded."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun maybe_div($x: u64, $y: u64): u64 {\n    let x = $x;\n    let y = $y;\n    if (y == 0) return 0;\n    x / y\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["At the call site, ",(0,s.jsx)(n.code,{children:"return"})," will always return from the ",(0,s.jsx)(n.code,{children:"macro"})," body, not from the caller."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let result: vector<u64> = vector[maybe_div!(10, 0)];\n"})}),"\n",(0,s.jsx)(n.p,{children:"Will expand to"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let result: vector<u64> = vector['a: {\n    let x = { 10 };\n    let y = { 0 };\n    if (y == 0) return 'a 0;\n    x / y\n}];\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Where ",(0,s.jsx)(n.code,{children:"return 'a 0"})," will return to the block ",(0,s.jsx)(n.code,{children:"'a: { ... }"})," and not to the caller's body. See the\nsection on ",(0,s.jsx)(n.a,{href:"./../control-flow/labeled-control-flow",children:"labeled control flow"})," for more details."]}),"\n",(0,s.jsxs)(n.p,{children:["Similarly, ",(0,s.jsx)(n.code,{children:"return"})," in a lambda will return from the lambda, not from the ",(0,s.jsx)(n.code,{children:"macro"})," body and not from\nthe outer function."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun apply($f: |u64| -> u64, $x: u64): u64 {\n    $f($x)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"and"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let result = apply!(|x| { if (x == 0) return 0; x + 1 }, 100);\n"})}),"\n",(0,s.jsx)(n.p,{children:"will expand to"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let result = {\n    let x = { 100 };\n    'a: {\n        if (x == 0) return 'a 0;\n        x + 1\n    }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In addition to returning from the lambda, a label can be used to return to the outer function. In\nthe ",(0,s.jsx)(n.code,{children:"vector::any"})," macro, a ",(0,s.jsx)(n.code,{children:"return"})," with a label is used to return from the entire ",(0,s.jsx)(n.code,{children:"macro"})," early"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public macro fun any<$T>($v: &vector<$T>, $f: |&$T| -> bool): bool {\n    let v = $v;\n    'any: {\n        v.do_ref!(|e| if ($f(e)) return 'any true);\n        false\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"return 'any true"}),' exits from the "loop" early when the condition is met. Otherwise, the macro\n"returns" ',(0,s.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"method-syntax",children:"Method Syntax"}),"\n",(0,s.jsxs)(n.p,{children:["When applicable, ",(0,s.jsx)(n.code,{children:"macro"})," functions can be called using ",(0,s.jsx)(n.a,{href:"./../method-syntax",children:"method syntax"}),'. When\nusing method syntax, the evaluation of the arguments will change in that the first argument (the\n"receiver" of the method) will be evaluated outside of the macro expansion. This example is\ncontrived, but will concisely demonstrate the behavior.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public struct S() has copy, drop;\npublic fun foo(): S { abort 0 }\npublic macro fun maybe_s($s: S, $cond: bool): S {\n    if ($cond) $s\n    else S()\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Even though ",(0,s.jsx)(n.code,{children:"foo()"})," will abort, its return type can be used to start a method call."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"$s"})," will not be evaluated if ",(0,s.jsx)(n.code,{children:"$cond"})," is ",(0,s.jsx)(n.code,{children:"false"}),", and under a normal non-method call, an argument of\n",(0,s.jsx)(n.code,{children:"foo()"})," would not be evaluated and would not abort. The following example demonstrates ",(0,s.jsx)(n.code,{children:"$s"})," not\nbeing evaluated with an argument of ",(0,s.jsx)(n.code,{children:"foo()"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"maybe_s!(foo(), false) // does not abort\n"})}),"\n",(0,s.jsx)(n.p,{children:"It becomes more clear as to why it does not abort when looking at the expanded form"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"if (false) foo()\nelse S()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["However, when using method syntax, the first argument is evaluated before the macro is expanded. So\nthe same argument of ",(0,s.jsx)(n.code,{children:"foo()"})," for ",(0,s.jsx)(n.code,{children:"$s"})," will now be evaluated and will abort."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"foo().maybe_s!(false) // aborts\n"})}),"\n",(0,s.jsx)(n.p,{children:"We can see this more clearly when looking the expanded form"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let tmp = foo(); // aborts\nif (false) tmp\nelse S()\n"})}),"\n",(0,s.jsx)(n.p,{children:"Conceptually, the receiver for a method call is bound to a temporary variable before the macro is\nexpanded, which forces the evaluation and thus the abort."}),"\n",(0,s.jsx)(n.h3,{id:"parameter-limitations",children:"Parameter Limitations"}),"\n",(0,s.jsxs)(n.p,{children:["The parameters of a ",(0,s.jsx)(n.code,{children:"macro"})," function must always be used as expressions. They cannot be used in\nsituations where the argument might be re-interpreted. For example, the following is not allowed"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun no($x: _): _ {\n    $x.f\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The reason is that if the argument ",(0,s.jsx)(n.code,{children:"$x"})," was not a reference, it would be borrowed first, which would\ncould re-interpret the argument. To get around this limitation, you should bind the argument to a\nlocal variable."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun yes($x: _): _ {\n    let x = $x;\n    x.f\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.h3,{id:"lazy-arguments-assert_eq",children:"Lazy arguments: assert_eq"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:'macro fun assert_eq<$T>($left: $T, $right: $T, $code: u64) {\n    let left = $left;\n    let right = $right;\n    if (left != right) {\n        std::debug::print(&b"assertion failed.\\n left: ");\n        std::debug::print(&left);\n        std::debug::print(&b"\\n does not equal right: ");\n        std::debug::print(&right);\n        abort $code;\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In this case the argument to ",(0,s.jsx)(n.code,{children:"$code"})," is not evaluated unless the assertion fails."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"assert_eq!(vector[true, false], vector[true, false], 1 / 0); // division by zero is not evaluated\n"})}),"\n",(0,s.jsx)(n.h3,{id:"any-integer-square-root",children:"Any integer square root"}),"\n",(0,s.jsxs)(n.p,{children:["This macro calculates the integer square root for any integer type, besides ",(0,s.jsx)(n.code,{children:"u256"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"$T"})," is the type of the input and ",(0,s.jsx)(n.code,{children:"$bitsize"})," is the number of bits in that type, for example ",(0,s.jsx)(n.code,{children:"u8"}),"\nhas 8 bits. ",(0,s.jsx)(n.code,{children:"$U"})," should be set to the next larger integer type, for example ",(0,s.jsx)(n.code,{children:"u16"})," for ",(0,s.jsx)(n.code,{children:"u8"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["In this ",(0,s.jsx)(n.code,{children:"macro"}),", the type of the integer literals are ",(0,s.jsx)(n.code,{children:"1"})," and ",(0,s.jsx)(n.code,{children:"0"})," are annotated, e.g. ",(0,s.jsx)(n.code,{children:"(1: $U)"}),"\nallowing for the type of the literal to differ with each call. Similarly, ",(0,s.jsx)(n.code,{children:"as"})," can be used with the\ntype parameters ",(0,s.jsx)(n.code,{children:"$T"})," and ",(0,s.jsx)(n.code,{children:"$U"}),". This macro will then only successfully expand if ",(0,s.jsx)(n.code,{children:"$T"})," and ",(0,s.jsx)(n.code,{children:"$U"})," are\ninstantiated with the integer types."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun num_sqrt<$T, $U>($x: $T, $bitsize: u8): $T {\n    let x = $x;\n    let mut bit = (1: $U) << $bitsize;\n    let mut res = (0: $U);\n    let mut x = x as $U;\n\n    while (bit != 0) {\n        if (x >= res + bit) {\n            x = x - (res + bit);\n            res = (res >> 1) + bit;\n        } else {\n            res = res >> 1;\n        };\n        bit = bit >> 2;\n    };\n\n    res as $T\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"iterating-over-a-vector",children:"Iterating over a vector"}),"\n",(0,s.jsxs)(n.p,{children:["The two ",(0,s.jsx)(n.code,{children:"macro"}),"s iterate over a vector, immutably and mutably respectively."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun for_imm<$T>($v: &vector<$T>, $f: |&$T|) {\n    let v = $v;\n    let n = v.length();\n    let mut i = 0;\n    while (i < n) {\n        $f(&v[i]);\n        i = i + 1;\n    }\n}\n\nmacro fun for_mut<$T>($v: &mut vector<$T>, $f: |&mut $T|) {\n    let v = $v;\n    let n = v.length();\n    let mut i = 0;\n    while (i < n) {\n        $f(&mut v[i]);\n        i = i + 1;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"A few examples of usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun imm_examples(v: &vector<u64>) {\n    // print all elements\n    for_imm!(v, |x| std::debug::print(x));\n\n    // sum all elements\n    let mut sum = 0;\n    for_imm!(v, |x| sum = sum + x);\n\n    // find the max element\n    let mut max = 0;\n    for_imm!(v, |x| if (x > max) max = x);\n}\n\nfun mut_examples(v: &mut vector<u64>) {\n    // increment each element\n    for_mut!(v, |x| *x = *x + 1);\n\n    // set each element to the previous value, and the first to last value\n    let mut prev = v[v.length() - 1];\n    for_mut!(v, |x| {\n        let tmp = *x;\n        *x = prev;\n        prev = tmp;\n    });\n\n    // set the max element to 0\n    let mut max = &mut 0;\n    for_mut!(v, |x| if (*x > *max) max = x);\n    *max = 0;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"non-loop-lambda-usage",children:"Non-loop lambda usage"}),"\n",(0,s.jsx)(n.p,{children:"Lambdas do not need to be used in loops, and are often useful for conditionally applying code."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun inspect<$T>($opt: &Option<$T>, $f: |&$T|) {\n    let opt = $opt;\n    if (opt.is_some()) $f(opt.borrow())\n}\n\nmacro fun is_some_and<$T>($opt: &Option<$T>, $f: |&$T| -> bool): bool {\n    let opt = $opt;\n    if (opt.is_some()) $f(opt.borrow())\n    else false\n}\n\nmacro fun map<$T, $U>($opt: Option<$T>, $f: |$T| -> $U): Option<$U> {\n    let opt = $opt;\n    if (opt.is_some()) {\n        option::some($f(opt.destroy_some()))\n    } else {\n        opt.destroy_none();\n        option::none()\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"And some examples of usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun examples(opt: Option<u64>) {\n    // print the value if it exists\n    inspect!(&opt, |x| std::debug::print(x));\n\n    // check if the value is 0\n    let is_zero = is_some_and!(&opt, |x| *x == 0);\n\n    // upcast the u64 to a u256\n    let str_opt = map!(opt, |x| x as u256);\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);