"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9909],{2892:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"guides/better-error-handling","title":"Better Error Handling","description":"Whenever execution encounters an abort, transaction fails and abort code is returned to the caller.","source":"@site/../book/guides/better-error-handling.md","sourceDirName":"guides","slug":"/guides/better-error-handling","permalink":"/guides/better-error-handling","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"Building Against Limits","permalink":"/guides/building-against-limits"},"next":{"title":"Code Quality Checklist","permalink":"/guides/code-quality-checklist"}}');var r=o(3420),l=o(5521);const i={},s="Better Error Handling",a={},d=[{value:"Rule 1: Handle All Possible Scenarios",id:"rule-1-handle-all-possible-scenarios",level:2},{value:"Rule 2: Abort with Different Codes",id:"rule-2-abort-with-different-codes",level:2},{value:"Rule 3: Return <code>bool</code> Instead of <code>assert</code>",id:"rule-3-return-bool-instead-of-assert",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"better-error-handling",children:"Better Error Handling"})}),"\n",(0,r.jsx)(n.p,{children:"Whenever execution encounters an abort, transaction fails and abort code is returned to the caller.\nMove VM returns the module name that aborted the transaction and the abort code. This behavior is\nnot fully transparent to the caller of the transaction, especially when a single function contains\nmultiple calls to the same function which may abort. In this case, the caller will not know which\ncall aborted the transaction, and it will be hard to debug the issue or provide meaningful error\nmessage to the user."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module book::module_a;\n\nuse book::module_b;\n\npublic fun do_something() {\n    let field_1 = module_b::get_field(1); // may abort with 0\n    /* ... a lot of logic ... */\n    let field_2 = module_b::get_field(2); // may abort with 0\n    /* ... some more logic ... */\n    let field_3 = module_b::get_field(3); // may abort with 0\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The example above illustrates the case when a single function contains multiple calls which may\nabort. If the caller of the ",(0,r.jsx)(n.code,{children:"do_something"})," function receives an abort code ",(0,r.jsx)(n.code,{children:"0"}),", it will be hard to\nunderstand which call to ",(0,r.jsx)(n.code,{children:"module_b::get_field"})," aborted the transaction. To address this problem,\nthere are common patterns that can be used to improve error handling."]}),"\n",(0,r.jsx)(n.h2,{id:"rule-1-handle-all-possible-scenarios",children:"Rule 1: Handle All Possible Scenarios"}),"\n",(0,r.jsxs)(n.p,{children:['It is considered a good practice to provide a safe "check" function that returns a boolean value\nindicating whether an operation can be performed safely. If the ',(0,r.jsx)(n.code,{children:"module_b"})," provides a function\n",(0,r.jsx)(n.code,{children:"has_field"})," that returns a boolean value indicating whether a field exists, the ",(0,r.jsx)(n.code,{children:"do_something"}),"\nfunction can be rewritten as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module book::module_a;\n\nuse book::module_b;\n\nconst ENoField: u64 = 0;\n\npublic fun do_something() {\n    assert!(module_b::has_field(1), ENoField);\n    let field_1 = module_b::get_field(1);\n    /* ... */\n    assert!(module_b::has_field(2), ENoField);\n    let field_2 = module_b::get_field(2);\n    /* ... */\n    assert!(module_b::has_field(3), ENoField);\n    let field_3 = module_b::get_field(3);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["By adding custom checks before each call to ",(0,r.jsx)(n.code,{children:"module_b::get_field"}),", the developer of the ",(0,r.jsx)(n.code,{children:"module_a"}),"\ntakes control over the error handling. And it allows implementing the second rule."]}),"\n",(0,r.jsx)(n.h2,{id:"rule-2-abort-with-different-codes",children:"Rule 2: Abort with Different Codes"}),"\n",(0,r.jsxs)(n.p,{children:["The second trick, once the abort codes are handled by the caller module, is to use different abort\ncodes for different scenarios. This way, the caller module can provide a meaningful error message to\nthe user. The ",(0,r.jsx)(n.code,{children:"module_a"})," can be rewritten as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module book::module_a;\n\nuse book::module_b;\n\nconst ENoFieldA: u64 = 0;\nconst ENoFieldB: u64 = 1;\nconst ENoFieldC: u64 = 2;\n\npublic fun do_something() {\n    assert!(module_b::has_field(1), ENoFieldA);\n    let field_1 = module_b::get_field(1);\n    /* ... */\n    assert!(module_b::has_field(2), ENoFieldB);\n    let field_2 = module_b::get_field(2);\n    /* ... */\n    assert!(module_b::has_field(3), ENoFieldC);\n    let field_3 = module_b::get_field(3);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Now, the caller module can provide a meaningful error message to the user. If the caller receives an\nabort code ",(0,r.jsx)(n.code,{children:"0"}),', it can be translated to "Field 1 does not exist". If the caller receives an abort\ncode ',(0,r.jsx)(n.code,{children:"1"}),', it can be translated to "Field 2 does not exist". And so on.']}),"\n",(0,r.jsxs)(n.h2,{id:"rule-3-return-bool-instead-of-assert",children:["Rule 3: Return ",(0,r.jsx)(n.code,{children:"bool"})," Instead of ",(0,r.jsx)(n.code,{children:"assert"})]}),"\n",(0,r.jsx)(n.p,{children:"A developer is often tempted to add a public function that would assert all the conditions and abort\nthe execution. However, it is a better practice to create a function that returns a boolean value\ninstead. This way, the caller module can handle the error and provide a meaningful error message to\nthe user."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module book::some_app_assert;\n\nconst ENotAuthorized: u64 = 0;\n\npublic fun do_a() {\n    assert_is_authorized();\n    // ...\n}\n\npublic fun do_b() {\n    assert_is_authorized();\n    // ...\n}\n\n/// Don't do this\npublic fun assert_is_authorized() {\n    assert!(/* some condition */ true, ENotAuthorized);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This module can be rewritten as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module book::some_app;\n\nconst ENotAuthorized: u64 = 0;\n\npublic fun do_a() {\n    assert!(is_authorized(), ENotAuthorized);\n    // ...\n}\n\npublic fun do_b() {\n    assert!(is_authorized(), ENotAuthorized);\n    // ...\n}\n\npublic fun is_authorized(): bool {\n    /* some condition */ true\n}\n\n// a private function can still be used to avoid code duplication for a case\n// when the same condition with the same abort code is used in multiple places\nfun assert_is_authorized() {\n    assert!(is_authorized(), ENotAuthorized);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Utilizing these three rules will make the error handling more transparent to the caller of the\ntransaction, and it will allow other developers to use custom abort codes in their modules."})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},5521:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>s});var t=o(6672);const r={},l=t.createContext(r);function i(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);