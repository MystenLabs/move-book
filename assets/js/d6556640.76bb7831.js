"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3327],{2575:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"guides/code-quality-checklist","title":"Code Quality Checklist","description":"The rapid evolution of the Move language and its ecosystem has rendered many older practices","source":"@site/../book/guides/code-quality-checklist.md","sourceDirName":"guides","slug":"/guides/code-quality-checklist","permalink":"/guides/code-quality-checklist","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"Better Error Handling","permalink":"/guides/better-error-handling"},"next":{"title":"A. Glossary","permalink":"/appendix/glossary"}}');var s=t(3420),a=t(5521);const i={},l="Code Quality Checklist",c={},d=[{value:"Code Organization",id:"code-organization",level:2},{value:"Package Manifest",id:"package-manifest",level:2},{value:"Use Right Edition",id:"use-right-edition",level:3},{value:"Implicit Framework Dependency",id:"implicit-framework-dependency",level:3},{value:"Prefix Named Addresses",id:"prefix-named-addresses",level:3},{value:"Imports, Module and Constants",id:"imports-module-and-constants",level:2},{value:"Using Module Label",id:"using-module-label",level:3},{value:"No Single <code>Self</code> in <code>use</code> Statements",id:"no-single-self-in-use-statements",level:3},{value:"Group <code>use</code> Statements with <code>Self</code>",id:"group-use-statements-with-self",level:3},{value:"Error Constants are in <code>EPascalCase</code>",id:"error-constants-are-in-epascalcase",level:3},{value:"Regular Constant are <code>ALL_CAPS</code>",id:"regular-constant-are-all_caps",level:3},{value:"Structs",id:"structs",level:2},{value:"Capabilities are Suffixed with <code>Cap</code>",id:"capabilities-are-suffixed-with-cap",level:3},{value:"No <code>Potato</code> in Names",id:"no-potato-in-names",level:3},{value:"Events Should Be Named in Past Tense",id:"events-should-be-named-in-past-tense",level:3},{value:"Use Positional Structs for Dynamic Field Keys + <code>Key</code> Suffix",id:"use-positional-structs-for-dynamic-field-keys--key-suffix",level:3},{value:"Functions",id:"functions",level:2},{value:"No <code>public entry</code>, Only <code>public</code> or <code>entry</code>",id:"no-public-entry-only-public-or-entry",level:3},{value:"Write Composable Functions for PTBs",id:"write-composable-functions-for-ptbs",level:3},{value:"Objects Go First (Except for Clock)",id:"objects-go-first-except-for-clock",level:3},{value:"Capabilities Go Second",id:"capabilities-go-second",level:3},{value:"Getters Named After Field + <code>_mut</code>",id:"getters-named-after-field--_mut",level:3},{value:"Function Body: Struct Methods",id:"function-body-struct-methods",level:2},{value:"Common Coin Operations",id:"common-coin-operations",level:3},{value:"Do Not Import <code>std::string::utf8</code>",id:"do-not-import-stdstringutf8",level:3},{value:"UID has <code>delete</code>",id:"uid-has-delete",level:3},{value:"<code>ctx</code> has <code>sender()</code>",id:"ctx-has-sender",level:3},{value:"Vector Has a Literal. And Associated Functions",id:"vector-has-a-literal-and-associated-functions",level:3},{value:"Collections Support Index Syntax",id:"collections-support-index-syntax",level:3},{value:"Option -&gt; Macros",id:"option---macros",level:2},{value:"Destroy And Call Function",id:"destroy-and-call-function",level:3},{value:"Destroy Some With Default",id:"destroy-some-with-default",level:3},{value:"Loops -&gt; Macros",id:"loops---macros",level:2},{value:"Do Operation N Times",id:"do-operation-n-times",level:3},{value:"New Vector From Iteration",id:"new-vector-from-iteration",level:3},{value:"Do Operation on Every Element of a Vector",id:"do-operation-on-every-element-of-a-vector",level:3},{value:"Destroy a Vector and Call a Function on Each Element",id:"destroy-a-vector-and-call-a-function-on-each-element",level:3},{value:"Fold Vector Into a Single Value",id:"fold-vector-into-a-single-value",level:3},{value:"Filter Elements of the Vector",id:"filter-elements-of-the-vector",level:3},{value:"Other",id:"other",level:2},{value:"Ignored Values In Unpack Can Be Ignored Altogether",id:"ignored-values-in-unpack-can-be-ignored-altogether",level:3},{value:"Testing",id:"testing",level:2},{value:"Merge <code>#[test]</code> and <code>#[expected_failure(...)]</code>",id:"merge-test-and-expected_failure",level:3},{value:"Do Not Clean Up <code>expected_failure</code> Tests",id:"do-not-clean-up-expected_failure-tests",level:3},{value:"Do Not Prefix Tests With <code>test_</code> in Testing Modules",id:"do-not-prefix-tests-with-test_-in-testing-modules",level:3},{value:"Do Not Use <code>TestScenario</code> Where Not Necessary",id:"do-not-use-testscenario-where-not-necessary",level:3},{value:"Do Not Use Abort Codes in <code>assert!</code> in Tests",id:"do-not-use-abort-codes-in-assert-in-tests",level:3},{value:"Use <code>assert_eq!</code> Whenever Possible",id:"use-assert_eq-whenever-possible",level:3},{value:"Use &quot;Black Hole&quot; <code>destroy</code> Function",id:"use-black-hole-destroy-function",level:3},{value:"Comments",id:"comments",level:2},{value:"Doc Comments Start With <code>///</code>",id:"doc-comments-start-with-",level:3},{value:"Complex Logic? Leave a Comment <code>//</code>",id:"complex-logic-leave-a-comment-",level:3}];function r(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"code-quality-checklist",children:"Code Quality Checklist"})}),"\n",(0,s.jsx)(n.p,{children:"The rapid evolution of the Move language and its ecosystem has rendered many older practices\noutdated. This guide serves as a checklist for developers to review their code and ensure it aligns\nwith current best practices in Move development. Please read carefully and apply as many\nrecommendations as possible to your code."}),"\n",(0,s.jsx)(n.h2,{id:"code-organization",children:"Code Organization"}),"\n",(0,s.jsxs)(n.p,{children:["Some of the issues mentioned in this guide can be fixed by using\n",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/@mysten/prettier-plugin-move",children:"Move Formatter"})," either as a CLI tool,\nor ",(0,s.jsx)(n.a,{href:"https://github.com/marketplace/actions/move-formatter",children:"as a CI check"}),", or\n",(0,s.jsx)(n.a,{href:"https://marketplace.visualstudio.com/items?itemName=mysten.prettier-move",children:"as a plugin for VSCode (Cursor)"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"package-manifest",children:"Package Manifest"}),"\n",(0,s.jsx)(n.h3,{id:"use-right-edition",children:"Use Right Edition"}),"\n",(0,s.jsx)(n.p,{children:"All of the features in this guide require Move 2024 Edition, and it has to be specified in the\npackage manifest."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'[package]\nname = "my_package"\nedition = "2024.beta" # or (just) "2024"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"implicit-framework-dependency",children:"Implicit Framework Dependency"}),"\n",(0,s.jsxs)(n.p,{children:["Starting with Sui 1.45 you no longer need to specify framework dependency in the ",(0,s.jsx)(n.code,{children:"Move.toml"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:"# old, pre 1.45\n[dependencies]\nSui = { ... }\n\n# modern day, Sui, Bridge, MoveStdlib and SuiSystem are imported implicitly!\n[dependencies]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"prefix-named-addresses",children:"Prefix Named Addresses"}),"\n",(0,s.jsxs)(n.p,{children:["If your package has a generic name (e.g., ",(0,s.jsx)(n.code,{children:"token"}),") \u2013 especially if your project includes multiple\npackages \u2013 make sure to add a prefix to the named address:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'# bad! not indicative of anything, and can conflict\n[addresses]\nmath = "0x0"\n\n# good! clearly states project, unlikely to conflict\n[addresses]\nmy_protocol_math = "0x0"\n'})}),"\n",(0,s.jsx)(n.h2,{id:"imports-module-and-constants",children:"Imports, Module and Constants"}),"\n",(0,s.jsx)(n.h3,{id:"using-module-label",children:"Using Module Label"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad: increases indentation, legacy style\nmodule my_package::my_module {\n    public struct A {}\n}\n\n// good!\nmodule my_package::my_module;\n\npublic struct A {}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"no-single-self-in-use-statements",children:["No Single ",(0,s.jsx)(n.code,{children:"Self"})," in ",(0,s.jsx)(n.code,{children:"use"})," Statements"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// correct, member + self import\nuse my_package::other::{Self, OtherMember};\n\n// bad! `{Self}` is redundant\nuse my_package::my_module::{Self};\n\n// good!\nuse my_package::my_module;\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"group-use-statements-with-self",children:["Group ",(0,s.jsx)(n.code,{children:"use"})," Statements with ",(0,s.jsx)(n.code,{children:"Self"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad!\nuse my_package::my_module;\nuse my_package::my_module::OtherMember;\n\n// good!\nuse my_package::my_module::{Self, OtherMember};\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"error-constants-are-in-epascalcase",children:["Error Constants are in ",(0,s.jsx)(n.code,{children:"EPascalCase"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! all-caps are used for regular constants\nconst NOT_AUTHORIZED: u64 = 0;\n\n// good! clear indication it's an error constant\nconst ENotAuthorized: u64 = 0;\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"regular-constant-are-all_caps",children:["Regular Constant are ",(0,s.jsx)(n.code,{children:"ALL_CAPS"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:'// bad! PascalCase is associated with error consts\nconst MyConstant: vector<u8> = b"my const";\n\n// good! clear indication that it\'s a constant value\nconst MY_CONSTANT: vector<u8> = b"my const";\n'})}),"\n",(0,s.jsx)(n.h2,{id:"structs",children:"Structs"}),"\n",(0,s.jsxs)(n.h3,{id:"capabilities-are-suffixed-with-cap",children:["Capabilities are Suffixed with ",(0,s.jsx)(n.code,{children:"Cap"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! if it's a capability, add a `Cap` suffix\npublic struct Admin has key, store {\n    id: UID,\n}\n\n// good! reviewer knows what to expect from type\npublic struct AdminCap has key, store {\n    id: UID,\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"no-potato-in-names",children:["No ",(0,s.jsx)(n.code,{children:"Potato"})," in Names"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! it has no abilities, we already know it's a Hot-Potato type\npublic struct PromisePotato {}\n\n// good!\npublic struct Promise {}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"events-should-be-named-in-past-tense",children:"Events Should Be Named in Past Tense"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! not clear what this struct does\npublic struct RegisterUser has copy, drop { user: address }\n\n// good! clear, it's an event\npublic struct UserRegistered has copy, drop { user: address }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"use-positional-structs-for-dynamic-field-keys--key-suffix",children:["Use Positional Structs for Dynamic Field Keys + ",(0,s.jsx)(n.code,{children:"Key"})," Suffix"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// not as bad, but goes against canonical style\npublic struct DynamicField has copy, drop, store {}\n\n// good! canonical style, Key suffix\npublic struct DynamicFieldKey() has copy, drop, store;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,s.jsxs)(n.h3,{id:"no-public-entry-only-public-or-entry",children:["No ",(0,s.jsx)(n.code,{children:"public entry"}),", Only ",(0,s.jsx)(n.code,{children:"public"})," or ",(0,s.jsx)(n.code,{children:"entry"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! entry is not required for a function to be callable in a transaction\npublic entry fun do_something() { /* ... */ }\n\n// good! public functions are more permissive, can return value\npublic fun do_something_2(): T { /* ... */ }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"write-composable-functions-for-ptbs",children:"Write Composable Functions for PTBs"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! not composable, harder to test!\npublic fun mint_and_transfer(ctx: &mut TxContext) {\n    /* ... */\n    transfer::transfer(nft, ctx.sender());\n}\n\n// good! composable!\npublic fun mint(ctx: &mut TxContext): NFT { /* ... */ }\n\n// good! intentionally not composable\nentry fun mint_and_keep(ctx: &mut TxContext) { /* ... */ }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"objects-go-first-except-for-clock",children:"Objects Go First (Except for Clock)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! hard to read!\npublic fun call_app(\n    value: u8,\n    app: &mut App,\n    is_smth: bool,\n    cap: &AppCap,\n    clock: &Clock,\n    ctx: &mut TxContext,\n) { /* ... */ }\n\n// good!\npublic fun call_app(\n    app: &mut App,\n    cap: &AppCap,\n    value: u8,\n    is_smth: bool,\n    clock: &Clock,\n    ctx: &mut TxContext,\n) { /* ... */ }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"capabilities-go-second",children:"Capabilities Go Second"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! breaks method associativity\npublic fun authorize_action(cap: &AdminCap, app: &mut App) { /* ... */ }\n\n// good! keeps Cap visible in the signature and maintains `.calls()`\npublic fun authorize_action(app: &mut App, cap: &AdminCap) { /* ... */ }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"getters-named-after-field--_mut",children:["Getters Named After Field + ",(0,s.jsx)(n.code,{children:"_mut"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! unnecessary `get_`\npublic fun get_name(u: &User): String { /* ... */ }\n\n// good! clear that it accesses field `name`\npublic fun name(u: &User): String { /* ... */ }\n\n// good! for mutable references use `_mut`\npublic fun details_mut(u: &mut User): &mut Details { /* ... */ }\n"})}),"\n",(0,s.jsx)(n.h2,{id:"function-body-struct-methods",children:"Function Body: Struct Methods"}),"\n",(0,s.jsx)(n.h3,{id:"common-coin-operations",children:"Common Coin Operations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! legacy code, hard to read!\nlet paid = coin::split(&mut payment, amount, ctx);\nlet balance = coin::into_balance(paid);\n\n// good! struct methods make it easier!\nlet balance = payment.split(amount, ctx).into_balance();\n\n// even better (in this example - no need to create temporary coin)\nlet balance = payment.balance_mut().split(amount);\n\n// also can do this!\nlet coin = balance.into_coin(ctx);\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"do-not-import-stdstringutf8",children:["Do Not Import ",(0,s.jsx)(n.code,{children:"std::string::utf8"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:'// bad! unfortunately, very common!\nuse std::string::utf8;\n\nlet str = utf8(b"hello, world!");\n\n// good!\nlet str = b"hello, world!".to_string();\n\n// also, for ASCII string\nlet ascii = b"hello, world!".to_ascii_string();\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"uid-has-delete",children:["UID has ",(0,s.jsx)(n.code,{children:"delete"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad!\nobject::delete(id);\n\n// good!\nid.delete();\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"ctx-has-sender",children:[(0,s.jsx)(n.code,{children:"ctx"})," has ",(0,s.jsx)(n.code,{children:"sender()"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad!\ntx_context::sender(ctx);\n\n// good!\nctx.sender()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"vector-has-a-literal-and-associated-functions",children:"Vector Has a Literal. And Associated Functions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad!\nlet mut my_vec = vector::empty();\nvector::push_back(&mut my_vec, 10);\nlet first_el = vector::borrow(&my_vec);\nassert!(vector::length(&my_vec) == 1);\n\n// good!\nlet mut my_vec = vector[10];\nlet first_el = my_vec[0];\nassert!(my_vec.length() == 1);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"collections-support-index-syntax",children:"Collections Support Index Syntax"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let x: VecMap<u8, String> = /* ... */;\n\n// bad!\nx.get(&10);\nx.get_mut(&10);\n\n// good!\n&x[&10];\n&mut x[&10];\n"})}),"\n",(0,s.jsx)(n.h2,{id:"option---macros",children:"Option -> Macros"}),"\n",(0,s.jsx)(n.h3,{id:"destroy-and-call-function",children:"Destroy And Call Function"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad!\nif (opt.is_some()) {\n    let inner = opt.destroy_some();\n    call_function(inner);\n};\n\n// good! there's a macro for it!\nopt.do!(|value| call_function(value));\n"})}),"\n",(0,s.jsx)(n.h3,{id:"destroy-some-with-default",children:"Destroy Some With Default"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let opt = option::none();\n\n// bad!\nlet value = if (opt.is_some()) {\n    opt.destroy_some()\n} else {\n    abort EError\n};\n\n// good! there's a macro!\nlet value = opt.destroy_or!(default_value);\n\n// you can even do abort on `none`\nlet value = opt.destroy_or!(abort ECannotBeEmpty);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"loops---macros",children:"Loops -> Macros"}),"\n",(0,s.jsx)(n.h3,{id:"do-operation-n-times",children:"Do Operation N Times"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! hard to read!\nlet mut i = 0;\nwhile (i < 32) {\n    do_action();\n    i = i + 1;\n};\n\n// good! any uint has this macro!\n32u8.do!(|_| do_action());\n"})}),"\n",(0,s.jsx)(n.h3,{id:"new-vector-from-iteration",children:"New Vector From Iteration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// harder to read!\nlet mut i = 0;\nlet mut elements = vector[];\nwhile (i < 32) {\n    elements.push_back(i);\n    i = i + 1;\n};\n\n// easy to read!\nvector::tabulate!(32, |i| i);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"do-operation-on-every-element-of-a-vector",children:"Do Operation on Every Element of a Vector"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad!\nlet mut i = 0;\nwhile (i < vec.length()) {\n    call_function(&vec[i]);\n    i = i + 1;\n};\n\n// good!\nvec.do_ref!(|e| call_function(e));\n"})}),"\n",(0,s.jsx)(n.h3,{id:"destroy-a-vector-and-call-a-function-on-each-element",children:"Destroy a Vector and Call a Function on Each Element"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad!\nwhile (!vec.is_empty()) {\n    call(vec.pop_back());\n};\n\n// good!\nvec.destroy!(|e| call(e));\n"})}),"\n",(0,s.jsx)(n.h3,{id:"fold-vector-into-a-single-value",children:"Fold Vector Into a Single Value"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad!\nlet mut aggregate = 0;\nlet mut i = 0;\n\nwhile (i < source.length()) {\n    aggregate = aggregate + source[i];\n    i = i + 1;\n};\n\n// good!\nlet aggregate = source.fold!(0, |acc, v| {\n    acc + v\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"filter-elements-of-the-vector",children:"Filter Elements of the Vector"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Note: ",(0,s.jsx)(n.code,{children:"T: drop"})," in the ",(0,s.jsx)(n.code,{children:"source"})," vector"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad!\nlet mut filtered = [];\nlet mut i = 0;\nwhile (i < source.length()) {\n    if (source[i] > 10) {\n        filtered.push_back(source[i]);\n    };\n    i = i + 1;\n};\n\n// good!\nlet filtered = source.filter!(|e| e > 10);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"other",children:"Other"}),"\n",(0,s.jsx)(n.h3,{id:"ignored-values-in-unpack-can-be-ignored-altogether",children:"Ignored Values In Unpack Can Be Ignored Altogether"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! very sparse!\nlet MyStruct { id, field_1: _, field_2: _, field_3: _ } = value;\nid.delete();\n\n// good! 2024 syntax\nlet MyStruct { id, .. } = value;\nid.delete();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,s.jsxs)(n.h3,{id:"merge-test-and-expected_failure",children:["Merge ",(0,s.jsx)(n.code,{children:"#[test]"})," and ",(0,s.jsx)(n.code,{children:"#[expected_failure(...)]"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad!\n#[test]\n#[expected_failure]\nfun value_passes_check() {\n    abort\n}\n\n// good!\n#[test, expected_failure]\nfun value_passes_check() {\n    abort\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"do-not-clean-up-expected_failure-tests",children:["Do Not Clean Up ",(0,s.jsx)(n.code,{children:"expected_failure"})," Tests"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! clean up is not necessary\n#[test, expected_failure(abort_code = my_app::EIncorrectValue)]\nfun try_take_missing_object_fail() {\n    let mut test = test_scenario::begin(@0);\n    my_app::call_function(test.ctx());\n    test.end();\n}\n\n// good! easy to see where test is expected to fail\n#[test, expected_failure(abort_code = my_app::EIncorrectValue)]\nfun try_take_missing_object_fail() {\n    let mut test = test_scenario::begin(@0);\n    my_app::call_function(test.ctx());\n\n    abort // will differ from EIncorrectValue\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"do-not-prefix-tests-with-test_-in-testing-modules",children:["Do Not Prefix Tests With ",(0,s.jsx)(n.code,{children:"test_"})," in Testing Modules"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! the module is already called _tests\nmodule my_package::my_module_tests;\n\n#[test]\nfun test_this_feature() { /* ... */ }\n\n// good! better function name as the result\n#[test]\nfun this_feature_works() { /* ... */ }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"do-not-use-testscenario-where-not-necessary",children:["Do Not Use ",(0,s.jsx)(n.code,{children:"TestScenario"})," Where Not Necessary"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! no need, only using ctx\nlet mut test = test_scenario::begin(@0);\nlet nft = app::mint(test.ctx());\napp::destroy(nft);\ntest.end();\n\n// good! there's a dummy context for simple cases\nlet ctx = &mut tx_context::dummy();\napp::mint(ctx).destroy();\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"do-not-use-abort-codes-in-assert-in-tests",children:["Do Not Use Abort Codes in ",(0,s.jsx)(n.code,{children:"assert!"})," in Tests"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! may match application error codes by accident\nassert!(is_success, 0);\n\n// good!\nassert!(is_success);\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"use-assert_eq-whenever-possible",children:["Use ",(0,s.jsx)(n.code,{children:"assert_eq!"})," Whenever Possible"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:'// bad! old-style code\nassert!(result == b"expected_value", 0);\n\n// good! will print both values if fails\nuse std::unit_test::assert_eq;\n\nassert_eq!(result, expected_value);\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"use-black-hole-destroy-function",children:['Use "Black Hole" ',(0,s.jsx)(n.code,{children:"destroy"})," Function"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad!\nnft.destroy_for_testing();\napp.destroy_for_testing();\n\n// good! - no need to define special functions for cleanup\nuse sui::test_utils::destroy;\n\ndestroy(nft);\ndestroy(app);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"comments",children:"Comments"}),"\n",(0,s.jsxs)(n.h3,{id:"doc-comments-start-with-",children:["Doc Comments Start With ",(0,s.jsx)(n.code,{children:"///"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// bad! tooling doesn't support JavaDoc-style comments\n/**\n * Cool method\n * @param ...\n */\npublic fun do_something() { /* ... */ }\n\n// good! will be rendered as a doc comment in docgen and IDE's\n/// Cool method!\npublic fun do_something() { /* ... */ }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"complex-logic-leave-a-comment-",children:["Complex Logic? Leave a Comment ",(0,s.jsx)(n.code,{children:"//"})]}),"\n",(0,s.jsx)(n.p,{children:"Being friendly and helping reviewers understand the code!"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// good!\n// Note: can underflow if a value is smaller than 10.\n// TODO: add an `assert!` here\nlet value = external_call(value, ctx);\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(r,{...e})}):r(e)}},5521:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var o=t(6672);const s={},a=o.createContext(s);function i(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);