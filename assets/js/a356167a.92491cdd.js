"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9391],{4510:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"move-basics/drop-ability","title":"Abilities: Drop","description":"\x3c!-- TODO:","source":"@site/../book/move-basics/drop-ability.md","sourceDirName":"move-basics","slug":"/move-basics/drop-ability","permalink":"/move-basics/drop-ability","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.7. Abilities Introduction","permalink":"/move-basics/abilities-introduction"},"next":{"title":"5.9. Importing Modules","permalink":"/move-basics/importing-modules"}}');var s=n(3420),r=n(5521);const o={},l="Abilities: Drop",d={},c=[{value:"Types with the <code>drop</code> Ability",id:"types-with-the-drop-ability",level:2},{value:"Further Reading",id:"further-reading",level:2}];function a(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"abilities-drop",children:"Abilities: Drop"})}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"drop"})," ability - the simplest of them - allows the instance of a struct to be ",(0,s.jsx)(i.em,{children:"ignored"})," or\n",(0,s.jsx)(i.em,{children:"discarded"}),". In many programming languages this behavior is considered default. However, in Move, a\nstruct without the ",(0,s.jsx)(i.code,{children:"drop"})," ability is not allowed to be ignored. This is a safety feature of the Move\nlanguage, which ensures that all assets are properly handled. An attempt to ignore a struct without\nthe ",(0,s.jsx)(i.code,{children:"drop"})," ability will result in a compilation error."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/drop-ability.move anchor=main",children:"module book::drop_ability;\n\n/// This struct has the `drop` ability.\npublic struct IgnoreMe has drop {\n    a: u8,\n    b: u8,\n}\n\n/// This struct does not have the `drop` ability.\npublic struct NoDrop {}\n\n#[test]\n// Create an instance of the `IgnoreMe` struct and ignore it.\n// Even though we constructed the instance, we don't need to unpack it.\nfun test_ignore() {\n    let no_drop = NoDrop {};\n    let _ = IgnoreMe { a: 1, b: 2 }; // no need to unpack\n\n    // The value must be unpacked for the code to compile.\n    let NoDrop {} = no_drop; // OK\n}\n"})}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"drop"})," ability is often used on custom collection types to eliminate the need for special\nhandling of the collection when it is no longer needed. For example, a ",(0,s.jsx)(i.code,{children:"vector"})," type has the ",(0,s.jsx)(i.code,{children:"drop"}),"\nability, which allows the vector to be ignored when it is no longer needed. However, the biggest\nfeature of Move's type system is the ability to not have ",(0,s.jsx)(i.code,{children:"drop"}),". This ensures that the assets are\nproperly handled and not ignored."]}),"\n",(0,s.jsxs)(i.p,{children:["A struct with a single ",(0,s.jsx)(i.code,{children:"drop"})," ability is called a ",(0,s.jsx)(i.em,{children:"Witness"}),". We explain the concept of a ",(0,s.jsx)(i.em,{children:"Witness"}),"\nin the ",(0,s.jsx)(i.a,{href:"./../programmability/witness-pattern",children:"Witness and Abstract Implementation"})," section."]}),"\n",(0,s.jsxs)(i.h2,{id:"types-with-the-drop-ability",children:["Types with the ",(0,s.jsx)(i.code,{children:"drop"})," Ability"]}),"\n",(0,s.jsxs)(i.p,{children:["All native types in Move have the ",(0,s.jsx)(i.code,{children:"drop"})," ability. This includes:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"./../move-basics/primitive-types#booleans",children:(0,s.jsx)(i.code,{children:"bool"})})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"./../move-basics/primitive-types#integer-types",children:"unsigned integers"})}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"./../move-basics/vector",children:(0,s.jsx)(i.code,{children:"vector<T>"})})," when ",(0,s.jsx)(i.code,{children:"T"})," has ",(0,s.jsx)(i.code,{children:"drop"})]}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"./../move-basics/address",children:(0,s.jsx)(i.code,{children:"address"})})}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["All of the types defined in the standard library have the ",(0,s.jsx)(i.code,{children:"drop"})," ability as well. This includes:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"./../move-basics/option",children:(0,s.jsx)(i.code,{children:"Option<T>"})})," when ",(0,s.jsx)(i.code,{children:"T"})," has ",(0,s.jsx)(i.code,{children:"drop"})]}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"./../move-basics/string",children:(0,s.jsx)(i.code,{children:"String"})})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"./../move-basics/type-reflection",children:(0,s.jsx)(i.code,{children:"TypeName"})})}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"./../../reference/abilities",children:"Type Abilities"})," in the Move Reference."]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},5521:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>l});var t=n(6672);const s={},r=t.createContext(s);function o(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);