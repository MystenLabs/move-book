"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3203],{5521:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>i});var r=s(6672);const t={},d=r.createContext(t);function a(e){const n=r.useContext(d);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(d.Provider,{value:n},e.children)}},7746:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"modules","title":"Modules | Reference","description":"","source":"@site/../reference/modules.md","sourceDirName":".","slug":"/modules","permalink":"/reference/modules","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Modules | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"The Move Reference","permalink":"/reference/"},"next":{"title":"Primitive Types | Reference","permalink":"/reference/primitive-types"}}');var t=s(3420),d=s(5521);const a={title:"Modules | Reference",description:""},i="Modules",l={},c=[{value:"Syntax",id:"syntax",level:2},{value:"Names",id:"names",level:2},{value:"Members",id:"members",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,d.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"modules",children:"Modules"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Modules"})," are the core program unit that define types along with functions that operate on these\ntypes. Struct types define the schema of Move's ",(0,t.jsx)(n.a,{href:"./abilities#key",children:"storage"}),', and module functions\ndefine the rules interacting with values of those types. While modules themselves are also stored in\nstorage, they are not accessible from within a Move program. In a blockchain environment, the\nmodules are stored on chain in a process typically referred to as "publishing". After being\npublished, ',(0,t.jsx)(n.a,{href:"./functions#entry-modifier",children:(0,t.jsx)(n.code,{children:"entry"})})," and ",(0,t.jsx)(n.a,{href:"./functions#visibility",children:(0,t.jsx)(n.code,{children:"public"})}),"\nfunctions can be invoked according to the rules of that particular Move instance."]}),"\n",(0,t.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,t.jsx)(n.p,{children:"A module has the following syntax:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"module <address>::<identifier> {\n    (<use> | <type> | <function> | <constant>)*\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["where ",(0,t.jsx)(n.code,{children:"<address>"})," is a valid ",(0,t.jsx)(n.a,{href:"./primitive-types/address",children:"address"})," specifying the module's\npackage."]}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"module 0::test;\n\nuse std::debug;\n\nconst ONE: u64 = 1;\n\npublic struct Example has copy, drop { i: u64 }\n\npublic fun print(x: u64) {\n    let sum = x + ONE;\n    let example = Example { i: sum };\n    debug::print(&sum)\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"names",children:"Names"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"module test_addr::test"})," part specifies that the module ",(0,t.jsx)(n.code,{children:"test"})," will be published under the\nnumerical ",(0,t.jsx)(n.a,{href:"./primitive-types/address",children:"address"})," value assigned for the name ",(0,t.jsx)(n.code,{children:"test_addr"})," in the\n",(0,t.jsx)(n.a,{href:"./packages",children:"package settings"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Modules should normally be declared using ",(0,t.jsx)(n.a,{href:"./primitive-types/address",children:"named addresses"})," (as\nopposed to using the numerical value directly). For example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"module test_addr::test;\n\nuse std::debug;\nuse test_addr::another_test;\n\npublic struct Example has copy, drop { a: address }\n\npublic fun print() {\n    let example = Example { a: @test_addr };\n    debug::print(&example)\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["These named addresses commonly match the name of the ",(0,t.jsx)(n.a,{href:"./packages",children:"package"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Because named addresses only exist at the source language level and during compilation, named\naddresses will be fully substituted for their value at the bytecode level. For example if we had the\nfollowing code:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"fun example() {\n    my_addr::m::foo(@my_addr);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["and we compiled it with ",(0,t.jsx)(n.code,{children:"my_addr"})," set to ",(0,t.jsx)(n.code,{children:"0xC0FFEE"}),", then it would be operationally equivalent to\nthe following:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"fun example() {\n    0xC0FFEE::m::foo(@0xC0FFEE);\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"While at the source level these two different accesses are equivalent, it is a best practice to\nalways use the named address and not the numerical value assigned to that address."}),"\n",(0,t.jsxs)(n.p,{children:["Module names can start with a lowercase letter from ",(0,t.jsx)(n.code,{children:"a"})," to ",(0,t.jsx)(n.code,{children:"z"})," or an uppercase letter from ",(0,t.jsx)(n.code,{children:"A"})," to\n",(0,t.jsx)(n.code,{children:"Z"}),". After the first character, module names can contain underscores ",(0,t.jsx)(n.code,{children:"_"}),", letters ",(0,t.jsx)(n.code,{children:"a"})," to ",(0,t.jsx)(n.code,{children:"z"}),",\nletters ",(0,t.jsx)(n.code,{children:"A"})," to ",(0,t.jsx)(n.code,{children:"Z"}),", or digits ",(0,t.jsx)(n.code,{children:"0"})," to ",(0,t.jsx)(n.code,{children:"9"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"module a::my_module {}\nmodule a::foo_bar_42 {}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Typically, module names start with a lowercase letter. A module named ",(0,t.jsx)(n.code,{children:"my_module"})," should be stored\nin a source file named ",(0,t.jsx)(n.code,{children:"my_module.move"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"members",children:"Members"}),"\n",(0,t.jsxs)(n.p,{children:["All members inside a ",(0,t.jsx)(n.code,{children:"module"})," block can appear in any order. Fundamentally, a module is a collection\nof ",(0,t.jsx)(n.a,{href:"./structs",children:(0,t.jsx)(n.code,{children:"types"})})," and ",(0,t.jsx)(n.a,{href:"./functions",children:(0,t.jsx)(n.code,{children:"functions"})}),". The ",(0,t.jsx)(n.a,{href:"./uses",children:(0,t.jsx)(n.code,{children:"use"})})," keyword refers\nto members from other modules. The ",(0,t.jsx)(n.a,{href:"./constants",children:(0,t.jsx)(n.code,{children:"const"})})," keyword defines constants that can be\nused in the functions of a module."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"./friends",children:(0,t.jsx)(n.code,{children:"friend"})})," syntax is a deprecated concept for specifying a list of trusted\nmodules. The concept has been superseded by ",(0,t.jsx)(n.a,{href:"./functions#visibility",children:(0,t.jsx)(n.code,{children:"public(package)"})})]})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}}}]);