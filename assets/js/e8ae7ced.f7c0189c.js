"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[247],{2963:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>r,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"packages","title":"Packages | Reference","description":"","source":"@site/../reference/packages.md","sourceDirName":".","slug":"/packages","permalink":"/reference/packages","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Packages | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"15. Index Syntax","permalink":"/reference/index-syntax"},"next":{"title":"17. Unit Testing","permalink":"/reference/unit-testing"}}');var d=a(3420),i=a(5521);const o={title:"Packages | Reference",description:""},t="Packages",r={},c=[{value:"Package Layout and Manifest Syntax",id:"package-layout-and-manifest-syntax",level:2},{value:"Move.toml",id:"movetoml",level:3},{value:"Named Addresses During Compilation",id:"named-addresses-during-compilation",level:2},{value:"Declaring Named Addresses",id:"declaring-named-addresses",level:3},{value:"Scope and Renaming of Named Addresses",id:"scope-and-renaming-of-named-addresses",level:2},{value:"Instantiating Named Addresses",id:"instantiating-named-addresses",level:3},{value:"Usage and Artifacts",id:"usage-and-artifacts",level:2},{value:"Artifacts",id:"artifacts",level:3},{value:"Move.lock",id:"movelock",level:2},{value:"The <code>[move]</code> Section",id:"the-move-section",level:3},{value:"The <code>[move.package]</code> Sections",id:"the-movepackage-sections",level:3},{value:"The <code>[move.toolchain-version]</code> Section",id:"the-movetoolchain-version-section",level:3}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.header,{children:(0,d.jsx)(n.h1,{id:"packages",children:"Packages"})}),"\n",(0,d.jsx)(n.p,{children:"Packages allow Move programmers to more easily re-use code and share it across projects. The Move\npackage system allows programmers to easily:"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"Define a package containing Move code;"}),"\n",(0,d.jsxs)(n.li,{children:["Parameterize a package by ",(0,d.jsx)(n.a,{href:"./primitive-types/address",children:"named addresses"}),";"]}),"\n",(0,d.jsx)(n.li,{children:"Import and use packages in other Move code and instantiate named addresses;"}),"\n",(0,d.jsx)(n.li,{children:"Build packages and generate associated compilation artifacts from packages; and"}),"\n",(0,d.jsx)(n.li,{children:"Work with a common interface around compiled Move artifacts."}),"\n"]}),"\n",(0,d.jsx)(n.h2,{id:"package-layout-and-manifest-syntax",children:"Package Layout and Manifest Syntax"}),"\n",(0,d.jsxs)(n.p,{children:["A Move package source directory contains a ",(0,d.jsx)(n.code,{children:"Move.toml"})," package manifest file, a generated\n",(0,d.jsx)(n.code,{children:"Move.lock"})," file, and a set of subdirectories:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-plaintext",children:"a_move_package\n\u251c\u2500\u2500 Move.toml      (required)\n\u251c\u2500\u2500 Move.lock      (generated)\n\u251c\u2500\u2500 sources        (required)\n\u251c\u2500\u2500 doc_templates  (optional)\n\u251c\u2500\u2500 examples       (optional, test & dev mode)\n\u2514\u2500\u2500 tests          (optional, test mode)\n"})}),"\n",(0,d.jsxs)(n.p,{children:['The directories and files labeled "required" must be present for a directory to be considered a Move\npackage and built. Optional directories may be present, and if so, they will be included in the\ncompilation process depending on the mode used to build the package. For instance, when built in\n"dev" or "test" modes, the ',(0,d.jsx)(n.code,{children:"tests"})," and ",(0,d.jsx)(n.code,{children:"examples"})," directories will also be included."]}),"\n",(0,d.jsx)(n.p,{children:"Going through each of these in turn:"}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsxs)(n.li,{children:["The ",(0,d.jsx)(n.a,{href:"#movetoml",children:(0,d.jsx)(n.code,{children:"Move.toml"})})," file is the package manifest and is required for a directory to be\nconsidered a Move package. This file contains metadata about the package, such as name,\ndependencies, and so on."]}),"\n",(0,d.jsxs)(n.li,{children:["The ",(0,d.jsx)(n.a,{href:"#movelock",children:(0,d.jsx)(n.code,{children:"Move.lock"})})," file is generated by the Move CLI and contains the fixed build\nversions of the package and its dependencies. It is used to ensure consistent versions are used\nacross different builds and that changes in dependencies are apparent as a change in this file."]}),"\n",(0,d.jsxs)(n.li,{children:["The ",(0,d.jsx)(n.code,{children:"sources"})," directory is required and contains the Move modules that make up the package.\nModules in this directory will always be included in the compilation process."]}),"\n",(0,d.jsxs)(n.li,{children:["The ",(0,d.jsx)(n.code,{children:"doc_templates"})," directory can contain documentation templates that will be used when\ngenerating documentation for the package."]}),"\n",(0,d.jsxs)(n.li,{children:["The ",(0,d.jsx)(n.code,{children:"examples"})," directory can hold additional code to be used only for development and/or\ntutorials, this will not be included when compiled outside of ",(0,d.jsx)(n.code,{children:"test"})," or ",(0,d.jsx)(n.code,{children:"dev"})," modes."]}),"\n",(0,d.jsxs)(n.li,{children:["The ",(0,d.jsx)(n.code,{children:"tests"})," directory can contain Move modules that are only included when compiled in ",(0,d.jsx)(n.code,{children:"test"}),"\nmode or when ",(0,d.jsx)(n.a,{href:"./unit-testing",children:"Move unit tests"})," are run."]}),"\n"]}),"\n",(0,d.jsx)(n.h3,{id:"movetoml",children:"Move.toml"}),"\n",(0,d.jsxs)(n.p,{children:["The Move package manifest is defined within the ",(0,d.jsx)(n.code,{children:"Move.toml"})," file and has the following syntax.\nOptional fields are marked with ",(0,d.jsx)(n.code,{children:"*"}),", ",(0,d.jsx)(n.code,{children:"+"})," denotes one or more elements:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-toml",children:'[package]\nname = <string>\nedition* = <string>      # e.g., "2024.alpha" to use the Move 2024 edition,\n                         # currently in alpha. Will default to the latest stable edition if not specified.\nlicense* = <string>              # e.g., "MIT", "GPL", "Apache 2.0"\nauthors* = [<string>,+]  # e.g., ["Joe Smith (joesmith@noemail.com)", "John Snow (johnsnow@noemail.com)"]\n\n# Additional fields may be added to this section by external tools. E.g., on Sui the following sections are added:\npublished-at* = "<hex-address>" # The address that the package is published at. Should be set after the first publication.\n\n[dependencies] # (Optional section) Paths to dependencies\n# One or more lines declaring dependencies in the following format\n\n# ##### Local Dependencies #####\n# For local dependencies use `local = path`. Path is relative to the package root\n# Local = { local = "../path/to" }\n# To resolve a version conflict and force a specific version for dependency\n# override you can use `override = true`\n# Override = { local = "../conflicting/version", override = true }\n# To instantiate address values in a dependency, use `addr_subst`\n<string> = {\n    local = <string>,\n    override* = <bool>,\n    addr_subst* = { (<string> = (<string> | "<hex_address>"))+ }\n}\n\n# ##### Git Dependencies #####\n# For remote import, use the `{ git = "...", subdir = "...", rev = "..." }`.\n# Revision must be supplied, it can be a branch, a tag, or a commit hash.\n# If no `subdir` is specified, the root of the repository is used.\n# MyRemotePackage = { git = "https://some.remote/host.git", subdir = "remote/path", rev = "main" }\n<string> = {\n    git = <URL ending in .git>,\n    subdir=<path to dir containing Move.toml inside git repo>,\n    rev=<git commit hash>,\n    override* = <bool>,\n    addr_subst* = { (<string> = (<string> | "<hex_address>"))+ }\n}\n\n[addresses]  # (Optional section) Declares named addresses in this package\n# One or more lines declaring named addresses in the following format\n# Addresses that match the name of the package must be set to `"0x0"` or they will be unable to be published.\n<addr_name> = "_" | "<hex_address>" # e.g., std = "_" or my_addr = "0xC0FFEECAFE"\n\n# Named addresses will be accessible in Move as `@name`. They\'re also exported:\n# for example, `std = "0x1"` is exported by the Standard Library.\n# alice = "0xA11CE"\n\n[dev-dependencies] # (Optional section) Same as [dependencies] section, but only included in "dev" and "test" modes\n# The dev-dependencies section allows overriding dependencies for `--test` and\n# `--dev` modes. You can e.g., introduce test-only dependencies here.\n# Local = { local = "../path/to/dev-build" }\n<string> = {\n    local = <string>,\n    override* = <bool>,\n    addr_subst* = { (<string> = (<string> | "<hex_address>"))+ }\n}\n<string> = {\n    git = <URL ending in .git>,\n    subdir=<path to dir containing Move.toml inside git repo>,\n    rev=<git commit hash>,\n    override* = <bool>,\n    addr_subst* = { (<string> = (<string> | "<hex_address>"))+ }\n}\n\n[dev-addresses] # (Optional section) Same as [addresses] section, but only included in "dev" and "test" modes\n# The dev-addresses section allows overwriting named addresses for the `--test`\n# and `--dev` modes.\n<addr_name> = "<hex_address>" # e.g., alice = "0xB0B"\n'})}),"\n",(0,d.jsx)(n.p,{children:"An example of a minimal package manifest:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-toml",children:'[package]\nname = "AName"\n'})}),"\n",(0,d.jsxs)(n.p,{children:["An example of a more standard package manifest that also includes the Move standard library and\ninstantiates the named address ",(0,d.jsx)(n.code,{children:"std"})," from the ",(0,d.jsx)(n.code,{children:"LocalDep"})," package with the address value ",(0,d.jsx)(n.code,{children:"0x1"}),":"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-toml",children:'[package]\nname = "AName"\nlicense = "Apache 2.0"\n\n[addresses]\naddress_to_be_filled_in = "_"\nspecified_address = "0xB0B"\n\n[dependencies]\n# Local dependency\nLocalDep = { local = "projects/move-awesomeness", addr_subst = { "std" = "0x1" } }\n# Git dependency\nMoveStdlib = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/move-stdlib", rev = "framework/mainnet" }\n\n[dev-addresses] # For use when developing this module\naddress_to_be_filled_in = "0x101010101"\n'})}),"\n",(0,d.jsxs)(n.p,{children:["Most of the sections in the package manifest are self explanatory, but named addresses can be a bit\ndifficult to understand so we examine them in more detail in\n",(0,d.jsx)(n.a,{href:"#named-addresses-during-compilation",children:"Named Addresses During Compilation"}),"."]}),"\n",(0,d.jsx)(n.h2,{id:"named-addresses-during-compilation",children:"Named Addresses During Compilation"}),"\n",(0,d.jsxs)(n.p,{children:["Recall that Move has ",(0,d.jsx)(n.a,{href:"./primitive-types/address",children:"named addresses"})," and that named addresses cannot be\ndeclared in Move. Instead they are declared at the package level: in the manifest file (",(0,d.jsx)(n.code,{children:"Move.toml"}),")\nfor a Move package you declare named addresses in the package, instantiate other named addresses,\nand rename named addresses from other packages within the Move package system."]}),"\n",(0,d.jsx)(n.p,{children:"Let's go through each of these actions, and how they are performed in the package's manifest\none-by-one:"}),"\n",(0,d.jsx)(n.h3,{id:"declaring-named-addresses",children:"Declaring Named Addresses"}),"\n",(0,d.jsxs)(n.p,{children:["Let's say we have a Move module in ",(0,d.jsx)(n.code,{children:"example_pkg/sources/A.move"})," as follows:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-move",children:"module named_addr::a {\n    public fun x(): address { @named_addr }\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["We could in ",(0,d.jsx)(n.code,{children:"example_pkg/Move.toml"})," declare the named address ",(0,d.jsx)(n.code,{children:"named_addr"})," in two different ways.\nThe first:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-toml",children:'[package]\nname = "example_pkg"\n...\n[addresses]\nnamed_addr = "_"\n'})}),"\n",(0,d.jsxs)(n.p,{children:["Declares ",(0,d.jsx)(n.code,{children:"named_addr"})," as a named address in the package ",(0,d.jsx)(n.code,{children:"example_pkg"})," and that ",(0,d.jsx)(n.em,{children:"this address can be\nany valid address value"}),". In particular, an importing package can pick the value of the named\naddress ",(0,d.jsx)(n.code,{children:"named_addr"})," to be any address it wishes. Intuitively you can think of this as\nparameterizing the package ",(0,d.jsx)(n.code,{children:"example_pkg"})," by the named address ",(0,d.jsx)(n.code,{children:"named_addr"}),", and the package can then\nbe instantiated later on by an importing package."]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"named_addr"})," can also be declared as:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-toml",children:'[package]\nname = "example_pkg"\n...\n[addresses]\nnamed_addr = "0xCAFE"\n'})}),"\n",(0,d.jsxs)(n.p,{children:["which states that the named address ",(0,d.jsx)(n.code,{children:"named_addr"})," is exactly ",(0,d.jsx)(n.code,{children:"0xCAFE"})," and cannot be changed. This is\nuseful so other importing packages can use this named address without needing to worry about the\nexact value assigned to it."]}),"\n",(0,d.jsx)(n.p,{children:"With these two different declaration methods, there are two ways that information about named\naddresses can flow in the package graph:"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:'The former ("unassigned named addresses") allows named address values to flow from the importation\nsite to the declaration site.'}),"\n",(0,d.jsx)(n.li,{children:'The latter ("assigned named addresses") allows named address values to flow from the declaration\nsite upwards in the package graph to usage sites.'}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"With these two methods for flowing named address information throughout the package graph the rules\naround scoping and renaming become important to understand."}),"\n",(0,d.jsx)(n.h2,{id:"scope-and-renaming-of-named-addresses",children:"Scope and Renaming of Named Addresses"}),"\n",(0,d.jsxs)(n.p,{children:["A named address ",(0,d.jsx)(n.code,{children:"N"})," in a package ",(0,d.jsx)(n.code,{children:"P"})," is in scope if:"]}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"P"})," declares a named address ",(0,d.jsx)(n.code,{children:"N"}),"; or"]}),"\n",(0,d.jsxs)(n.li,{children:["A package in one of ",(0,d.jsx)(n.code,{children:"P"}),"'s transitive dependencies declares the named address ",(0,d.jsx)(n.code,{children:"N"})," and there is a\ndependency path in the package graph between ",(0,d.jsx)(n.code,{children:"P"})," and the declaring package of ",(0,d.jsx)(n.code,{children:"N"})," with no\nrenaming of ",(0,d.jsx)(n.code,{children:"N"}),"."]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["Additionally, every named address in a package is exported. Because of this and the above scoping\nrules each package can be viewed as coming with a set of named addresses that will be brought into\nscope when the package is imported, e.g., if you import ",(0,d.jsx)(n.code,{children:"example_pkg"}),", that import will also bring\nthe ",(0,d.jsx)(n.code,{children:"named_addr"})," named address into scope. Because of this, if ",(0,d.jsx)(n.code,{children:"P"})," imports two packages ",(0,d.jsx)(n.code,{children:"P1"})," and\n",(0,d.jsx)(n.code,{children:"P2"})," both of which declare a named address ",(0,d.jsx)(n.code,{children:"N"})," an issue arises in ",(0,d.jsx)(n.code,{children:"P"}),': which "',(0,d.jsx)(n.code,{children:"N"}),'" is meant when ',(0,d.jsx)(n.code,{children:"N"}),"\nis referred to in ",(0,d.jsx)(n.code,{children:"P"}),"? The one from ",(0,d.jsx)(n.code,{children:"P1"})," or ",(0,d.jsx)(n.code,{children:"P2"}),"? To prevent this ambiguity around which package a\nnamed address is coming from, we enforce that the sets of scopes introduced by all dependencies in a\npackage are disjoint, and provide a way to ",(0,d.jsx)(n.em,{children:"rename named addresses"})," when the package that brings\nthem into scope is imported."]}),"\n",(0,d.jsxs)(n.p,{children:["Renaming a named address when importing can be done as follows in our ",(0,d.jsx)(n.code,{children:"P"}),", ",(0,d.jsx)(n.code,{children:"P1"}),", and ",(0,d.jsx)(n.code,{children:"P2"})," example\nabove:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-toml",children:'[package]\nname = "P"\n...\n[dependencies]\nP1 = { local = "some_path_to_P1", addr_subst = { "P1N" = "N" } }\nP2 = { local = "some_path_to_P2"  }\n'})}),"\n",(0,d.jsxs)(n.p,{children:["With this renaming ",(0,d.jsx)(n.code,{children:"N"})," refers to the ",(0,d.jsx)(n.code,{children:"N"})," from ",(0,d.jsx)(n.code,{children:"P2"})," and ",(0,d.jsx)(n.code,{children:"P1N"})," will refer to ",(0,d.jsx)(n.code,{children:"N"})," coming from ",(0,d.jsx)(n.code,{children:"P1"}),":"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-move",children:"module N::A {\n    public fun x(): address { @P1N }\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["It is important to note that ",(0,d.jsx)(n.em,{children:"renaming is not local"}),": once a named address ",(0,d.jsx)(n.code,{children:"N"})," has been renamed to\n",(0,d.jsx)(n.code,{children:"N2"})," in a package ",(0,d.jsx)(n.code,{children:"P"})," all packages that import ",(0,d.jsx)(n.code,{children:"P"})," will not see ",(0,d.jsx)(n.code,{children:"N"})," but only ",(0,d.jsx)(n.code,{children:"N2"})," unless ",(0,d.jsx)(n.code,{children:"N"})," is\nreintroduced from outside of ",(0,d.jsx)(n.code,{children:"P"}),'. This is why rule (2) in the scoping rules at the start of this\nsection specifies a "dependency path in the package graph between ',(0,d.jsx)(n.code,{children:"P"})," and the declaring\npackage of ",(0,d.jsx)(n.code,{children:"N"})," with no renaming of ",(0,d.jsx)(n.code,{children:"N"}),'."']}),"\n",(0,d.jsx)(n.h3,{id:"instantiating-named-addresses",children:"Instantiating Named Addresses"}),"\n",(0,d.jsx)(n.p,{children:"Named addresses can be instantiated multiple times across the package graph as long as it is always\nwith the same value. It is an error if the same named address (regardless of renaming) is\ninstantiated with differing values across the package graph."}),"\n",(0,d.jsxs)(n.p,{children:["A Move package can only be compiled if all named addresses resolve to a value. This presents issues\nif the package wishes to expose an uninstantiated named address. This is what the ",(0,d.jsx)(n.code,{children:"[dev-addresses]"}),"\nsection solves in part. This section can set values for named addresses, but cannot introduce any\nnamed addresses. Additionally, only the ",(0,d.jsx)(n.code,{children:"[dev-addresses]"})," in the root package are included in ",(0,d.jsx)(n.code,{children:"dev"}),"\nmode. For example a root package with the following manifest would not compile outside of ",(0,d.jsx)(n.code,{children:"dev"})," mode\nsince ",(0,d.jsx)(n.code,{children:"named_addr"})," would be uninstantiated:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-toml",children:'[package]\nname = "example_pkg"\n...\n[addresses]\nnamed_addr = "_"\n\n[dev-addresses]\nnamed_addr = "0xC0FFEE"\n'})}),"\n",(0,d.jsx)(n.h2,{id:"usage-and-artifacts",children:"Usage and Artifacts"}),"\n",(0,d.jsxs)(n.p,{children:["The Move package system comes with a command line option as part of the CLI:\n",(0,d.jsx)(n.code,{children:"sui move <command> <command_flags>"}),". Unless a particular path is provided, all package commands\nwill run in the current enclosing Move package. The full list of commands and flags for the Move CLI\ncan be found by running ",(0,d.jsx)(n.code,{children:"sui move --help"}),"."]}),"\n",(0,d.jsx)(n.h3,{id:"artifacts",children:"Artifacts"}),"\n",(0,d.jsxs)(n.p,{children:["A package can be compiled using CLI commands. This will create a ",(0,d.jsx)(n.code,{children:"build"})," directory containing\nbuild-related artifacts (including bytecode binaries, source maps, and documentation). The general\nlayout of the ",(0,d.jsx)(n.code,{children:"build"})," directory is as follows:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-plaintext",children:"a_move_package\n\u251c\u2500\u2500 BuildInfo.yaml\n\u251c\u2500\u2500 bytecode_modules\n\u2502\xa0\xa0 \u251c\u2500\u2500 dependencies\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 <dep_pkg_name>\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500 *.mv\n\u2502\xa0\xa0 \u2502\xa0\xa0 ...\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500  <dep_pkg_name>\n\u2502\xa0\xa0 \u2502\xa0\xa0  \xa0\xa0 \u2514\u2500\u2500 *.mv\n\u2502\xa0\xa0 ...\n\u2502\xa0\xa0 \u2514\u2500\u2500 *.mv\n\u251c\u2500\u2500 docs\n\u2502\xa0\xa0 \u251c\u2500\u2500 dependencies\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 <dep_pkg_name>\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500 *.md\n\u2502\xa0\xa0 \u2502\xa0\xa0 ...\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500  <dep_pkg_name>\n\u2502\xa0\xa0 \u2502\xa0\xa0  \xa0\xa0 \u2514\u2500\u2500 *.md\n\u2502\xa0\xa0 ...\n\u2502\xa0\xa0 \u2514\u2500\u2500 *.md\n\u251c\u2500\u2500 source_maps\n\u2502\xa0\xa0 \u251c\u2500\u2500 dependencies\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 <dep_pkg_name>\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500 *.mvsm\n\u2502\xa0\xa0 \u2502\xa0\xa0 ...\n\u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500  <dep_pkg_name>\n\u2502\xa0\xa0 \u2502\xa0\xa0  \xa0\xa0 \u2514\u2500\u2500 *.mvsm\n\u2502\xa0\xa0 ...\n\u2502\xa0\xa0 \u2514\u2500\u2500 *.mvsm\n\u2514\u2500\u2500 sources\n \xa0\xa0 ...\n \xa0\xa0 \u2514\u2500\u2500 *.move\n \xa0\xa0 \u251c\u2500\u2500 dependencies\n \xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 <dep_pkg_name>\n \xa0\xa0 \u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500 *.move\n \xa0\xa0 \u2502\xa0\xa0 ...\n \xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500  <dep_pkg_name>\n \xa0\xa0 \u2502\xa0\xa0  \xa0\xa0 \u2514\u2500\u2500 *.move\n \xa0\xa0 ...\n \xa0\xa0 \u2514\u2500\u2500 *.move\n"})}),"\n",(0,d.jsx)(n.h2,{id:"movelock",children:"Move.lock"}),"\n",(0,d.jsxs)(n.p,{children:["The ",(0,d.jsx)(n.code,{children:"Move.lock"})," file is generated at the root of the Move package when the package is built. The\n",(0,d.jsx)(n.code,{children:"Move.lock"})," file contains information about your package and its build configuration, and acts as a\ncommunication layer between the Move compiler and other tools, like chain-specific command line\ninterfaces and third-party package managers."]}),"\n",(0,d.jsxs)(n.p,{children:["Like the ",(0,d.jsx)(n.code,{children:"Move.toml"})," file, the ",(0,d.jsx)(n.code,{children:"Move.lock"})," file is a text-based TOML file. Unlike the package\nmanifest however, the ",(0,d.jsx)(n.code,{children:"Move.lock"})," file is not intended for you to edit directly. Processes on the\ntoolchain, like the Move compiler, access and edit the file to read and append relevant information\nto it. You also must not move the file from the root, as it needs to be at the same level as the\n",(0,d.jsx)(n.code,{children:"Move.toml"})," manifest in the package."]}),"\n",(0,d.jsxs)(n.p,{children:["If you are using source control for your package, it's recommended practice to check in the\n",(0,d.jsx)(n.code,{children:"Move.lock"})," file that corresponds with your desired built or published package. This ensures that\nevery build of your package is an exact replica of the original, and that changes to the build will\nbe apparent as changes to the ",(0,d.jsx)(n.code,{children:"Move.lock"})," file."]}),"\n",(0,d.jsxs)(n.p,{children:["The ",(0,d.jsx)(n.code,{children:"Move.lock"})," file is a TOML file that currently contains the following fields."]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.strong,{children:"Note"}),": other fields may be added to the lock file either in the future, or by third-party\npackage managers as well."]}),"\n",(0,d.jsxs)(n.h3,{id:"the-move-section",children:["The ",(0,d.jsx)(n.code,{children:"[move]"})," Section"]}),"\n",(0,d.jsx)(n.p,{children:"This section contains the core information needed in the lockfile:"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"The version of the lockfile (needed for backwards compatibility checking, and versioning lockfile\nchanges in the future)."}),"\n",(0,d.jsxs)(n.li,{children:["The hash of the ",(0,d.jsx)(n.code,{children:"Move.toml"})," file that was used to generate this lock file."]}),"\n",(0,d.jsxs)(n.li,{children:["The hash of the ",(0,d.jsx)(n.code,{children:"Move.lock"})," file of all dependencies. If no dependencies are present, this will be\nan empty string."]}),"\n",(0,d.jsx)(n.li,{children:"The list of dependencies."}),"\n"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-toml",children:"[move]\nversion = <string> # Lock file version, used for backwards compatibility checking.\nmanifest_digest = <hash> # Sha3-256 hash of the Move.toml file that was used to generate this lock file.\ndeps_digest = <hash> # Sha3-256 hash of the Move.lock file of all dependencies. If no dependencies are present, this will be an empty string.\ndependencies = { (name = <string>)* } # List of dependencies. Not present if there are no dependencies.\n"})}),"\n",(0,d.jsxs)(n.h3,{id:"the-movepackage-sections",children:["The ",(0,d.jsx)(n.code,{children:"[move.package]"})," Sections"]}),"\n",(0,d.jsxs)(n.p,{children:["After the Move compiler resolves each of the dependencies for the package it writes the location of\nthe dependency to the ",(0,d.jsx)(n.code,{children:"Move.lock"})," file. If a dependency failed to resolve, the compiler will not\nwrite the ",(0,d.jsx)(n.code,{children:"Move.lock"})," file and the build fails. If all dependencies resolve, the ",(0,d.jsx)(n.code,{children:"Move.lock"})," file\ncontains the locations (local and remote) of all of the package's transitive dependencies. These\nwill be stored in the ",(0,d.jsx)(n.code,{children:"Move.lock"})," file in the following format:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-toml",children:'# ...\n\n[[move.package]]\nname = "A"\nsource = { git = "https://github.com/b/c.git", subdir = "e/f", rev = "a1b2c3" }\n\n[[move.package]]\nname = "B"\nsource = { local = "../local-dep" }\n'})}),"\n",(0,d.jsxs)(n.h3,{id:"the-movetoolchain-version-section",children:["The ",(0,d.jsx)(n.code,{children:"[move.toolchain-version]"})," Section"]}),"\n",(0,d.jsx)(n.p,{children:"As mentioned above, additional fields may be added to the lock file by external tools. For example,\nthe Sui package manager adds toolchain version information to the lock file that can then be used\nfor on-chain source verification:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-toml",children:'# ...\n\n[move.toolchain-version]\ncompiler-version = <string> # The version of the Move compiler used to build the package, e.g. "1.21.0"\nedition = <string> # The edition of the Move language used to build the package, e.g. "2024.alpha"\nflavor = <string> # The flavor of the Move compiler used to build the package, e.g. "sui"\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(l,{...e})}):l(e)}},5521:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>t});var s=a(6672);const d={},i=s.createContext(d);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);