"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7281],{4388:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"move-basics/constants","title":"Constants","description":"\x3c!--","source":"@site/../book/move-basics/constants.md","sourceDirName":"move-basics","slug":"/move-basics/constants","permalink":"/move-basics/constants","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.15. Enums and Match","permalink":"/move-basics/enum-and-match"},"next":{"title":"5.17. Aborting Execution","permalink":"/move-basics/assert-and-abort"}}');var a=t(2714),o=t(4811);const i={},c="Constants",r={},l=[{value:"Naming Convention",id:"naming-convention",level:2},{value:"Constants are Immutable",id:"constants-are-immutable",level:2},{value:"Using Config Pattern",id:"using-config-pattern",level:2},{value:"Links",id:"links",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"constants",children:"Constants"})}),"\n",(0,a.jsx)(n.p,{children:"Constants are immutable values that are defined at the module level. They often serve as a way to\ngive names to static values that are used throughout a module. For example, if there's a default\nprice for a product, you might define a constant for it. Constants are stored in the module's\nbytecode, and each time they are used, the value is copied."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/constants-shop-price.move anchor=shop_price",children:"module book::shop_price;\n\nuse sui::{coin::Coin, sui::SUI};\n\n/// Trying to purchase an item at an incorrect price.\nconst EWrongPrice: u64 = 0;\n\n/// The price of an item in the shop.\nconst ITEM_PRICE: u64 = 100;\n/// The owner of the shop, an address.\nconst SHOP_OWNER: address = @0xa11ce;\n\n/// An item sold in the shop.\npublic struct Item {}\n\n/// Purchase an item from the shop.\npublic fun purchase(coin: Coin<SUI>): Item {\n    assert!(coin.value() == ITEM_PRICE, EWrongPrice);\n\n    transfer::public_transfer(coin, SHOP_OWNER);\n\n    Item {}\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"naming-convention",children:"Naming Convention"}),"\n",(0,a.jsxs)(n.p,{children:["Constants must start with a capital letter - this is enforced at the compiler level. For constants\nused as a value, the convention is to use all uppercase letters and underscores between words, which\nmakes constants stand out from other identifiers in the code. An exception is made for\n",(0,a.jsx)(n.a,{href:"./assert-and-abort#error-constants",children:"error constants"}),", which are written in ECamelCase."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/constants-naming.move anchor=naming",children:"/// Price of the item used at the shop.\nconst ITEM_PRICE: u64 = 100;\n\n/// Error constant.\nconst EItemNotFound: u64 = 1;\n"})}),"\n",(0,a.jsx)(n.h2,{id:"constants-are-immutable",children:"Constants are Immutable"}),"\n",(0,a.jsx)(n.p,{children:"Constants can't be changed and assigned new values. As part of the package bytecode, they are\ninherently immutable."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"module book::immutable_constants;\n\nconst ITEM_PRICE: u64 = 100;\n\n// emits an error\nfun change_price() {\n    ITEM_PRICE = 200;\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"using-config-pattern",children:"Using Config Pattern"}),"\n",(0,a.jsx)(n.p,{children:'A common use case for an application is to define a set of constants that are used throughout the\ncodebase. But due to constants being private to the module, they can\'t be accessed from other\nmodules. One way to solve this is to define a "config" module that exports the constants.'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/constants-config.move anchor=config",children:"module book::config;\n\nconst ITEM_PRICE: u64 = 100;\nconst TAX_RATE: u64 = 10;\nconst SHIPPING_COST: u64 = 5;\n\n/// Returns the price of an item.\npublic fun item_price(): u64 { ITEM_PRICE }\n/// Returns the tax rate.\npublic fun tax_rate(): u64 { TAX_RATE }\n/// Returns the shipping cost.\npublic fun shipping_cost(): u64 { SHIPPING_COST }\n"})}),"\n",(0,a.jsx)(n.p,{children:"This way other modules can import and read the constants, and the update process is simplified. If\nthe constants need to be changed, only the config module needs to be updated during the package\nupgrade."}),"\n",(0,a.jsx)(n.h2,{id:"links",children:"Links"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"./../../reference/constants",children:"Constants"})," in the Move Reference"]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"./../guides/code-quality-checklist#regular-constant-are-all_caps",children:"Coding conventions for constants"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},4811:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var s=t(9378);const a={},o=s.createContext(a);function i(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);