"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4869],{1010:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"programmability/witness-pattern","title":"Pattern: Witness","description":"Witness is a pattern of proving an existence by constructing a proof. In the context of programming,","source":"@site/../book/programmability/witness-pattern.md","sourceDirName":"programmability","slug":"/programmability/witness-pattern","permalink":"/programmability/witness-pattern","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"8.9. Dynamic Collections","permalink":"/programmability/dynamic-collections"},"next":{"title":"8.11. One-Time Witness","permalink":"/programmability/one-time-witness"}}');var i=t(3420),a=t(5521);const r={},o="Pattern: Witness",c={},l=[{value:"Witness in Move",id:"witness-in-move",level:2},{value:"Instantiating a Generic Type",id:"instantiating-a-generic-type",level:2},{value:"One Time Witness",id:"one-time-witness",level:2},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"pattern-witness",children:"Pattern: Witness"})}),"\n",(0,i.jsx)(n.p,{children:"Witness is a pattern of proving an existence by constructing a proof. In the context of programming,\nwitness is a way to prove a certain property of a system by providing a value that can only be\nconstructed if the property holds."}),"\n",(0,i.jsx)(n.h2,{id:"witness-in-move",children:"Witness in Move"}),"\n",(0,i.jsxs)(n.p,{children:["In the ",(0,i.jsx)(n.a,{href:"./../move-basics/struct",children:"Struct"})," section we have shown that a struct can only be created -\nor ",(0,i.jsx)(n.em,{children:"packed"})," - by the module defining it. Hence, in Move, a module proves ownership of the type by\nconstructing it. This is one of the most important patterns in Move, and it is widely used for\ngeneric type instantiation and authorization."]}),"\n",(0,i.jsxs)(n.p,{children:["Practically speaking, for the witness to be used, there has to be a function that expects a witness\nas an argument. In the example below it is the ",(0,i.jsx)(n.code,{children:"new"})," function that expects a witness of the ",(0,i.jsx)(n.code,{children:"T"})," type\nto create a ",(0,i.jsx)(n.code,{children:"Instance<T>"})," instance."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["It is often the case that the witness struct is not stored, and for that the function may require\nthe ",(0,i.jsx)(n.a,{href:"./../move-basics/drop-ability",children:"Drop"})," ability for the type."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module book::witness;\n\n/// A struct that requires a witness to be created.\npublic struct Instance<T> { t: T }\n\n/// Create a new instance of `Instance<T>` with the provided T.\npublic fun new<T>(witness: T): Instance<T> {\n    Instance { t: witness }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The only way to construct an ",(0,i.jsx)(n.code,{children:"Instance<T>"})," is to call the ",(0,i.jsx)(n.code,{children:"new"})," function with an instance of the\ntype ",(0,i.jsx)(n.code,{children:"T"}),". This is a basic example of the witness pattern in Move. A module providing a witness often\nhas a matching implementation, like the module ",(0,i.jsx)(n.code,{children:"book::witness_source"})," below:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module book::witness_source;\n\nuse book::witness::{Self, Instance};\n\n/// A struct used as a witness.\npublic struct W {}\n\n/// Create a new instance of `Instance<W>`.\npublic fun new_instance(): Instance<W> {\n    witness::new(W {})\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The instance of the struct ",(0,i.jsx)(n.code,{children:"W"})," is passed into the ",(0,i.jsx)(n.code,{children:"new_instance"})," function to create an\n",(0,i.jsx)(n.code,{children:"Instance<W>"}),", thereby proving that the module ",(0,i.jsx)(n.code,{children:"book::witness_source"})," owns the type ",(0,i.jsx)(n.code,{children:"W"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"instantiating-a-generic-type",children:"Instantiating a Generic Type"}),"\n",(0,i.jsx)(n.p,{children:"Witness allows generic types to be instantiated with a concrete type. This is useful for inheriting\nassociated behaviors from the type with an option to extend them, if the module provides the ability\nto do so."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module sui::balance;\n\n/// A Supply of T. Used for minting and burning.\npublic struct Supply<phantom T> has store {\n    value: u64,\n}\n\n/// Create a new supply for type T with the provided witness.\npublic fun create_supply<T: drop>(_w: T): Supply<T> {\n    Supply { value: 0 }\n}\n\n/// Get the `Supply` value.\npublic fun supply_value<T>(supply: &Supply<T>): u64 {\n    supply.value\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, which is borrowed from the ",(0,i.jsxs)(n.a,{href:"https://docs.sui.io/references/framework/sui/balance",children:[(0,i.jsx)(n.code,{children:"balance"})," module"]})," of the\n",(0,i.jsx)(n.a,{href:"./sui-framework",children:"Sui Framework"}),", the ",(0,i.jsx)(n.code,{children:"Supply"})," a generic struct that can be constructed only by\nsupplying a witness of the type ",(0,i.jsx)(n.code,{children:"T"}),". The witness is taken by value and ",(0,i.jsx)(n.em,{children:"discarded"})," - hence the ",(0,i.jsx)(n.code,{children:"T"}),"\nmust have the ",(0,i.jsx)(n.a,{href:"./../move-basics/drop-ability",children:"drop"})," ability."]}),"\n",(0,i.jsxs)(n.p,{children:["The instantiated ",(0,i.jsx)(n.code,{children:"Supply<T>"})," can then be used to mint new ",(0,i.jsx)(n.code,{children:"Balance<T>"}),"'s, where ",(0,i.jsx)(n.code,{children:"T"})," is the type of\nthe supply."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module sui::balance;\n\n/// Storable balance.\npublic struct Balance<phantom T> has store {\n    value: u64,\n}\n\n/// Increase supply by `value` and create a new `Balance<T>` with this value.\npublic fun increase_supply<T>(self: &mut Supply<T>, value: u64): Balance<T> {\n    assert!(value < (18446744073709551615u64 - self.value), EOverflow);\n    self.value = self.value + value;\n    Balance { value }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"one-time-witness",children:"One Time Witness"}),"\n",(0,i.jsxs)(n.p,{children:['While a struct can be created any number of times, there are cases where a struct should be\nguaranteed to be created only once. For this purpose, Sui provides the "One-Time Witness" - a\nspecial witness that can only be used once. We explain it in more detail in the\n',(0,i.jsx)(n.a,{href:"./one-time-witness",children:"next section"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Witness is a pattern of proving a certain property by constructing a proof."}),"\n",(0,i.jsx)(n.li,{children:"In Move, a module proves ownership of a type by constructing it."}),"\n",(0,i.jsx)(n.li,{children:"Witness is often used for generic type instantiation and authorization."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.p,{children:["In the next section, we will learn about the ",(0,i.jsx)(n.a,{href:"./one-time-witness",children:"One Time Witness"})," pattern."]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},5521:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(6672);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);