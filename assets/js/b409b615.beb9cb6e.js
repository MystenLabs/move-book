"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[438],{5521:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>i});var t=r(6672);const o={},a=t.createContext(o);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:n},e.children)}},6481:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"abort-and-assert/clever-errors","title":"Clever Errors | Reference","description":"Clever errors are a feature that allows for more informative error messages when an assertion fails or an abort is raised","source":"@site/../reference/abort-and-assert/clever-errors.md","sourceDirName":"abort-and-assert","slug":"/abort-and-assert/clever-errors","permalink":"/reference/abort-and-assert/clever-errors","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Clever Errors | Reference","description":"Clever errors are a feature that allows for more informative error messages when an assertion fails or an abort is raised"},"sidebar":"referenceSidebar","previous":{"title":"Abort and Assert | Reference","permalink":"/reference/abort-and-assert"},"next":{"title":"Control Flow | Reference","permalink":"/reference/control-flow"}}');var o=r(3420),a=r(5521);const s={title:"Clever Errors | Reference",description:"Clever errors are a feature that allows for more informative error messages when an assertion fails or an abort is raised"},i="Clever Errors",l={},c=[{value:"Clever Abort Codes",id:"clever-abort-codes",level:2},{value:"Assertions with no Abort Codes",id:"assertions-with-no-abort-codes",level:2},{value:"Clever Errors and Macros",id:"clever-errors-and-macros",level:2},{value:"Inflating Clever Abort Codes",id:"inflating-clever-abort-codes",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"clever-errors",children:"Clever Errors"})}),"\n",(0,o.jsxs)(n.p,{children:["Clever errors are a feature that allows for more informative error messages when an assertion fails\nor an abort is raised. They are a source feature and compile to a ",(0,o.jsx)(n.code,{children:"u64"})," abort code value that\ncontains the information needed to access the line number, constant name, and constant value given\nthe clever error code and the module that the clever error constant was declared in. Because of this\ncompilation, post-processing is required to go from the ",(0,o.jsx)(n.code,{children:"u64"})," abort code value to a human-readable\nerror message. The post-processing is automatically performed by the Sui GraphQL server, as well as\nthe Sui CLI. If you want to manually decode a clever abort code, you can use the process outlined in\n",(0,o.jsx)(n.a,{href:"#inflating-clever-abort-codes",children:"Inflating Clever Abort Codes"})," to do so."]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Clever errors include source line information amongst other data. Because of this their value may\nchange due to any changes in the source file (e.g., due to auto-formatting, adding a new module\nmember, or adding a newline)."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"clever-abort-codes",children:"Clever Abort Codes"}),"\n",(0,o.jsxs)(n.p,{children:["Clever abort codes allow you to use non-u64 constants as abort codes as long as the constants are\nannotated with the ",(0,o.jsx)(n.code,{children:"#[error]"})," attribute. They can be used both in assertions, and as codes to\n",(0,o.jsx)(n.code,{children:"abort"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:'module 0x42::a_module;\n\n#[error]\nconst EIsThree: vector<u8> = b"The value is three";\n\n// Will abort with `EIsThree` if `x` is 3\npublic fun double_except_three(x: u64): u64 {\n    assert!(x != 3, EIsThree);\n    x * x\n}\n\n// Will always abort with `EIsThree`\npublic fun clever_abort() {\n    abort EIsThree\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, the ",(0,o.jsx)(n.code,{children:"EIsThree"})," constant is a ",(0,o.jsx)(n.code,{children:"vector<u8>"}),", which is not a ",(0,o.jsx)(n.code,{children:"u64"}),". However, the\n",(0,o.jsx)(n.code,{children:"#[error]"})," attribute allows the constant to be used as an abort code, and will at runtime produce a\n",(0,o.jsx)(n.code,{children:"u64"})," abort code value that holds:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"A set tag-bit that indicates that the abort code is a clever abort code."}),"\n",(0,o.jsx)(n.li,{children:"The line number of where the abort occurred in the source file (e.g., 7)."}),"\n",(0,o.jsxs)(n.li,{children:["The index in the module's identifier table for the constant's name (e.g., ",(0,o.jsx)(n.code,{children:"EIsThree"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:["The index of the constant's value in the module's constant table (e.g., ",(0,o.jsx)(n.code,{children:'b"The value is three"'}),")."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["In hex, if ",(0,o.jsx)(n.code,{children:"double_except_three(3)"})," is called, it will abort with a ",(0,o.jsx)(n.code,{children:"u64"})," abort code as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'0x8000_0007_0001_0000\n  ^       ^    ^    ^\n  |       |    |    |\n  |       |    |    |\n  |       |    |    +-- Constant value index = 0 (b"The value is three")\n  |       |    +-- Constant name index = 1 (EIsThree)\n  |       +-- Line number = 7 (line of the assertion)\n  +-- Tag bit = 0b1000_0000_0000_0000\n'})}),"\n",(0,o.jsx)(n.p,{children:"And could be rendered as a human-readable error message as (e.g.)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Error from '0x42::a_module::double_except_three' (line 7), abort 'EIsThree': \"The value is three\"\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The exact formatting of this message may vary depending on the tooling used to decode the clever\nerror however all of the information needed to generate a human-readable error message like the\nabove is present in the ",(0,o.jsx)(n.code,{children:"u64"})," abort code when coupled with the module where the error occurred."]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["Clever abort code values do ",(0,o.jsx)(n.em,{children:"not"})," need to be a ",(0,o.jsx)(n.code,{children:"vector<u8>"})," -- it can be any valid constant type\nin Move."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"assertions-with-no-abort-codes",children:"Assertions with no Abort Codes"}),"\n",(0,o.jsxs)(n.p,{children:["Assertions and ",(0,o.jsx)(n.code,{children:"abort"})," statements without an abort code will automatically derive an abort code from\nthe source line number and will be encoded in the clever error format with the constant name and\nconstant value information will be filled with sentinel values of ",(0,o.jsx)(n.code,{children:"0xffff"})," each. E.g.,"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module 0x42::a_module;\n\n#[test]\nfun assert_false(x: bool) {\n    assert!(false);\n}\n\n#[test]\nfun abort_no_code() {\n    abort\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Both of these will produce a ",(0,o.jsx)(n.code,{children:"u64"})," abort code value that holds:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"A set tag-bit that indicates that the abort code is a clever abort code."}),"\n",(0,o.jsx)(n.li,{children:"The line number of where the abort occurred in the source file (e.g., 6)."}),"\n",(0,o.jsxs)(n.li,{children:["A sentinel value of ",(0,o.jsx)(n.code,{children:"0xffff"})," for the index into the module's identifier table for the constant's\nname."]}),"\n",(0,o.jsxs)(n.li,{children:["A sentinel value of ",(0,o.jsx)(n.code,{children:"0xffff"})," for the index of the constant's value in the module's constant\ntable."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["In hex, if ",(0,o.jsx)(n.code,{children:"assert_false(3)"})," is called, it will abort with a ",(0,o.jsx)(n.code,{children:"u64"})," abort code as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"0x8000_0004_ffff_ffff\n  ^       ^    ^    ^\n  |       |    |    |\n  |       |    |    |\n  |       |    |    +-- Constant value index = 0xffff (sentinel value)\n  |       |    +-- Constant name index = 0xffff (sentinel value)\n  |       +-- Line number = 4 (link of the assertion)\n  +-- Tag bit = 0b1000_0000_0000_0000\n"})}),"\n",(0,o.jsx)(n.h2,{id:"clever-errors-and-macros",children:"Clever Errors and Macros"}),"\n",(0,o.jsx)(n.p,{children:"The line number information in clever abort codes are derived from the source file at the location\nwhere the abort occurs. In particular, for a function this will be the line number within in the\nfunction, however for macros, this will be the location where the macro is invoked. This can be\nquite useful when writing macros as it provides a way for users to use macros that may raise abort\nconditions and still get useful error messages."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module 0x42::macro_exporter;\n\npublic macro fun assert_false() {\n    assert!(false);\n}\n\npublic macro fun abort_always() {\n    abort\n}\n\npublic fun assert_false_fun() {\n    assert!(false); // Will always abort with the line number of this invocation\n}\n\npublic fun abort_always_fun() {\n    abort // Will always abort with the line number of this invocation\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Then in a module that uses these macros:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module 0x42::user_module;\n\nuse 0x42::macro_exporter::{\n    assert_false,\n    abort_always,\n    assert_false_fun,\n    abort_always_fun\n};\n\nfun invoke_assert_false() {\n    assert_false!(); // Will abort with the line number of this invocation\n}\n\nfun invoke_abort_always() {\n    abort_always!(); // Will abort with the line number of this invocation\n}\n\nfun invoke_assert_false_fun() {\n    assert_false_fun(); // Will abort with the line number of the assertion in `assert_false_fun`\n}\n\nfun invoke_abort_always_fun() {\n    abort_always_fun(); // Will abort with the line number of the `abort` in `abort_always_fun`\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"inflating-clever-abort-codes",children:"Inflating Clever Abort Codes"}),"\n",(0,o.jsx)(n.p,{children:"Precisely, the layout of a clever abort code is as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"\n|<tagbit>|<reserved>|<source line number>|<module identifier index>|<module constant index>|\n+--------+----------+--------------------+-------------------------+-----------------------+\n| 1-bit  | 15-bits  |       16-bits      |     16-bits             |        16-bits        |\n\n"})}),"\n",(0,o.jsx)(n.p,{children:"Note that the Move abort will come with some additional information -- importantly in our case the\nmodule where the error occurred. This is important because the identifier index, and constant index\nare relative to the module's identifier and constant tables (if not set the sentinel values)."}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["To decode a clever abort code, you will need to know the module where the error occurred if either\nthe identifier index or constant index are not set to the sentinel value of ",(0,o.jsx)(n.code,{children:"0xffff"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"In pseudo-code, you can decode a clever abort code as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"// Information available in the MoveAbort\nlet clever_abort_code: u64 = ...;\nlet (package_id, module_name): (PackageStorageId, ModuleName) = ...;\n\nlet is_clever_abort = (clever_abort_code & 0x8000_0000_0000_0000) != 0;\n\nif is_clever_abort {\n    // Get line number, identifier index, and constant index\n    // Identifier and constant index are sentinel values if set to '0xffff'\n    let line_number = ((clever_abort_code & 0x0000_ffff_0000_0000) >> 32) as u16;\n    let identifier_index = ((clever_abort_code & 0x0000_0000_ffff_0000) >> 16) as u16;\n    let constant_index = ((clever_abort_code & 0x0000_0000_0000_ffff)) as u16;\n\n    // Print the line error message\n    print!(\"Error from '{}::{}' (line {})\", package_id, module_name, line_number);\n\n    // No need to print anything or load the module if both are sentinel values\n    if identifier_index == 0xffff && constant_index == 0xffff {\n        return;\n    }\n\n    // Only needed if constant name and value are not 0xffff\n    let module: CompiledModule = fetch_module(package_id, module_name);\n\n    // Print the constant name (if any)\n    if identifier_index != 0xffff {\n        let constant_name = module.get_identifier_at_table_index(identifier_index);\n        print!(\", '{}'\", constant_name);\n    }\n\n    // Print the constant value (if any)\n    if constant_index != 0xffff {\n        let constant_value = module.get_constant_at_table_index(constant_index).deserialize_on_constant_type().to_string();\n        print!(\": {}\", constant_value);\n    }\n\n    return;\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);