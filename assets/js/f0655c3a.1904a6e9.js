"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[86],{5521:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>a});var s=n(6672);const i={},o=s.createContext(i);function c(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(o.Provider,{value:t},e.children)}},5707:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"programmability/epoch-and-time","title":"Epoch and Time","description":"Sui has two ways of accessing the current time: Epoch and Time. The former represents","source":"@site/../book/programmability/epoch-and-time.md","sourceDirName":"programmability","slug":"/programmability/epoch-and-time","permalink":"/programmability/epoch-and-time","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"8.3. Pattern: Capability","permalink":"/programmability/capability"},"next":{"title":"8.5. Collections","permalink":"/programmability/collections"}}');var i=n(3420),o=n(5521);const c={},a="Epoch and Time",r={},l=[{value:"Epoch",id:"epoch",level:2},{value:"Time",id:"time",level:2},{value:"Testing",id:"testing",level:2}];function m(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"epoch-and-time",children:"Epoch and Time"})}),"\n",(0,i.jsxs)(t.p,{children:["Sui has two ways of accessing the current time: ",(0,i.jsx)(t.code,{children:"Epoch"})," and ",(0,i.jsx)(t.code,{children:"Time"}),". The former represents\noperational periods in the system and changed roughly every 24 hours. The latter represents the\ncurrent time in milliseconds since the Unix Epoch. Both can be accessed freely in the program."]}),"\n",(0,i.jsx)(t.h2,{id:"epoch",children:"Epoch"}),"\n",(0,i.jsx)(t.p,{children:"Epochs are used to separate the system into operational periods. During an epoch the validator set\nis fixed, however, at the epoch boundary, the validator set can be changed. Epochs play a crucial\nrole in the consensus algorithm and are used to determine the current validator set. They are also\nused as measurement in the staking mechanism."}),"\n",(0,i.jsxs)(t.p,{children:["Epoch can be read from the ",(0,i.jsx)(t.a,{href:"./transaction-context",children:"transaction context"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/epoch-and-time.move anchor=epoch",children:"public fun current_epoch(ctx: &TxContext) {\n    let epoch = ctx.epoch();\n    // ...\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"It is also possible to get the unix timestamp of the epoch start:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/epoch-and-time.move anchor=epoch_start",children:"public fun current_epoch_start(ctx: &TxContext) {\n    let epoch_start = ctx.epoch_timestamp_ms();\n    // ...\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Normally, epochs are used in staking and system operations, however, in custom scenarios they can be\nused to emulate 24h periods. They are critical if an application relies on the staking logic or\nneeds to know the current validator set."}),"\n",(0,i.jsx)(t.h2,{id:"time",children:"Time"}),"\n",(0,i.jsxs)(t.p,{children:["For a more precise time measurement, Sui provides the ",(0,i.jsx)(t.code,{children:"Clock"})," object. It is a system object that is\nupdated during checkpoints by the system, which stores the current time in milliseconds since the\nUnix Epoch. The ",(0,i.jsx)(t.code,{children:"Clock"})," object is defined in the ",(0,i.jsx)(t.code,{children:"sui::clock"})," module and has a reserved address\n",(0,i.jsx)(t.code,{children:"0x6"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Clock is a shared object, but a transaction attempting to access it mutably will fail. This\nlimitation allows parallel access to the ",(0,i.jsx)(t.code,{children:"Clock"})," object, which is important for maintaining\nperformance."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-move",children:"module sui::clock;\n\n/// Singleton shared object that exposes time to Move calls.  This\n/// object is found at address 0x6, and can only be read (accessed\n/// via an immutable reference) by entry functions.\n///\n/// Entry Functions that attempt to accept `Clock` by mutable\n/// reference or value will fail to verify, and honest validators\n/// will not sign or execute transactions that use `Clock` as an\n/// input parameter, unless it is passed by immutable reference.\npublic struct Clock has key {\n    id: UID,\n    /// The clock's timestamp, which is set automatically by a\n    /// system transaction every time consensus commits a\n    /// schedule, or by `sui::clock::increment_for_testing` during\n    /// testing.\n    timestamp_ms: u64,\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["There is only one public function available in the ",(0,i.jsx)(t.code,{children:"Clock"})," module - ",(0,i.jsx)(t.code,{children:"timestamp_ms"}),". It returns the\ncurrent time in milliseconds since the Unix Epoch."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/epoch-and-time.move anchor=clock",children:"use sui::clock::Clock;\n\n/// Clock needs to be passed as an immutable reference.\npublic fun current_time(clock: &Clock) {\n    let time = clock.timestamp_ms();\n    // ...\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"testing",children:"Testing"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"Clock"})," module provides a number of methods for use in testing."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/epoch-and-time.move anchor=test",children:"#[test_only]\nuse sui::clock;\n#[test_only]\nuse std::unit_test::assert_eq;\n\n#[test]\nfun use_clock_in_test() {\n    // Get `ctx` and create `Clock` for testing\n    let ctx = &mut tx_context::dummy();\n    let mut clock = clock::create_for_testing(ctx);\n    assert_eq!(clock.timestamp_ms(), 0);\n\n    // Add a value to the timestamp stored in `Clock`\n    clock.increment_for_testing(2_000_000_000);\n    assert_eq!(clock.timestamp_ms(), 2_000_000_000);\n\n    // Set the timestamp, but the time set must be no less than the value stored in `Clock`\n    clock.set_for_testing(3_000_000_000);\n    assert_eq!(clock.timestamp_ms(), 3_000_000_000);\n\n    // The following setting will fail because the time set must be at least the timestamp stored in `Clock`\n    // clock.set_for_testing(1_000_000_000);\n    // assert_eq!(clock.timestamp_ms(), 1_000_000_000);\n\n    // If need a shared `Clock` for testing, you can set it through this function\n    // clock.share_for_testing();\n\n    // `Clock` does not have a `drop` capability, so it needs to be destroyed manually at the end of the test\n    clock.destroy_for_testing();\n}\n"})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}}}]);