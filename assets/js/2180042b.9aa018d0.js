"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5964],{4140:(e,n,d)=>{d.r(n),d.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"friends","title":"Friends | Reference","description":"","source":"@site/../reference/friends.md","sourceDirName":".","slug":"/friends","permalink":"/reference/friends","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Friends | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"18. Coding Conventions","permalink":"/reference/coding-conventions"}}');var r=d(3420),s=d(5521);const l={title:"Friends | Reference",description:""},c="DEPRECATED: Friends",a={},o=[{value:"Friend declaration",id:"friend-declaration",level:2},{value:"Friend declaration rules",id:"friend-declaration-rules",level:3}];function t(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"deprecated-friends",children:"DEPRECATED: Friends"})}),"\n",(0,r.jsxs)(n.p,{children:["NOTE: this feature has been superseded by ",(0,r.jsx)(n.a,{href:"./functions#visibility",children:(0,r.jsx)(n.code,{children:"public(package)"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"friend"})," syntax was used to declare modules that are trusted by the current module. A trusted\nmodule is allowed to call any function defined in the current module that have the ",(0,r.jsx)(n.code,{children:"public(friend)"}),"\nvisibility. For details on function visibilities, refer to the ",(0,r.jsx)(n.em,{children:"Visibility"})," section in\n",(0,r.jsx)(n.a,{href:"./functions",children:"Functions"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"friend-declaration",children:"Friend declaration"}),"\n",(0,r.jsx)(n.p,{children:"A module can declare other modules as friends via friend declaration statements, in the format of"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"friend <address::name>"})," \u2014 friend declaration using fully qualified module name like the example\nbelow, or"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module 0x42::a {\n    friend 0x42::b;\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"friend <module-name-alias>"})," \u2014 friend declaration using a module name alias, where the module\nalias is introduced via the ",(0,r.jsx)(n.code,{children:"use"})," statement."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module 0x42::a {\n    use 0x42::b;\n    friend b;\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["A module may have multiple friend declarations, and the union of all the friend modules forms the\nfriend list. In the example below, both ",(0,r.jsx)(n.code,{children:"0x42::B"})," and ",(0,r.jsx)(n.code,{children:"0x42::C"})," are considered as friends of\n",(0,r.jsx)(n.code,{children:"0x42::A"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module 0x42::a;\n\nfriend 0x42::b;\nfriend 0x42::c;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Unlike ",(0,r.jsx)(n.code,{children:"use"})," statements, ",(0,r.jsx)(n.code,{children:"friend"})," can only be declared in the module scope and not in the expression\nblock scope. ",(0,r.jsx)(n.code,{children:"friend"})," declarations may be located anywhere a top-level construct (e.g., ",(0,r.jsx)(n.code,{children:"use"}),",\n",(0,r.jsx)(n.code,{children:"function"}),", ",(0,r.jsx)(n.code,{children:"struct"}),", etc.) is allowed. However, for readability, it is advised to place friend\ndeclarations near the beginning of the module definition."]}),"\n",(0,r.jsx)(n.h3,{id:"friend-declaration-rules",children:"Friend declaration rules"}),"\n",(0,r.jsx)(n.p,{children:"Friend declarations are subject to the following rules:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"A module cannot declare itself as a friend."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module 0x42::m { friend Self; // ERROR! }\n//                      ^^^^ Cannot declare the module itself as a friend\n\nmodule 0x43::m { friend 0x43::M; // ERROR! }\n//                      ^^^^^^^ Cannot declare the module itself as a friend\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Friend modules must be known by the compiler"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module 0x42::m { friend 0x42::nonexistent; // ERROR! }\n//                      ^^^^^^^^^^^^^^^^^ Unbound module '0x42::nonexistent'\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Friend modules must be within the same account address."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module 0x42::m {}\n\nmodule 0x42::n { friend 0x42::m; // ERROR! }\n//                      ^^^^^^^ Cannot declare modules out of the current address as a friend\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Friends relationships cannot create cyclic module dependencies."}),"\n",(0,r.jsxs)(n.p,{children:["Cycles are not allowed in the friend relationships, e.g., the relation ",(0,r.jsx)(n.code,{children:"0x2::a"})," friends ",(0,r.jsx)(n.code,{children:"0x2::b"}),"\nfriends ",(0,r.jsx)(n.code,{children:"0x2::c"})," friends ",(0,r.jsx)(n.code,{children:"0x2::a"})," is not allowed. More generally, declaring a friend module adds a\ndependency upon the current module to the friend module (because the purpose is for the friend to\ncall functions in the current module). If that friend module is already used, either directly or\ntransitively, a cycle of dependencies would be created."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module 0x2::a {\n    use 0x2::c;\n    friend 0x2::b;\n\n    public fun a() {\n        c::c()\n    }\n}\n\nmodule 0x2::b {\n    friend 0x2::c; // ERROR!\n//         ^^^^^^ This friend relationship creates a dependency cycle: '0x2::b' is a friend of '0x2::a' uses '0x2::c' is a friend of '0x2::b'\n}\n\nmodule 0x2::c {\n    public fun c() {}\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The friend list for a module cannot contain duplicates."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"module 0x42::a {}\n\nmodule 0x42::m {\n    use 0x42::a as aliased_a;\n    friend 0x42::A;\n    friend aliased_a; // ERROR!\n//         ^^^^^^^^^ Duplicate friend declaration '0x42::a'. Friend declarations in a module must be unique\n}\n"})}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}},5521:(e,n,d)=>{d.d(n,{R:()=>l,x:()=>c});var i=d(6672);const r={},s=i.createContext(r);function l(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);