"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[386],{4811:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(9378);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}},9591:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"enums","title":"Enumerations | Reference","description":"","source":"@site/../reference/enums.md","sourceDirName":".","slug":"/enums","permalink":"/reference/enums","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Enumerations | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"8. Structs","permalink":"/reference/structs"},"next":{"title":"10. Constants","permalink":"/reference/constants"}}');var i=t(2714),r=t(4811);const s={title:"Enumerations | Reference",description:""},o="Enumerations",l={},c=[{value:"Defining Enums",id:"defining-enums",level:2},{value:"Visibility",id:"visibility",level:2},{value:"Abilities",id:"abilities",level:3},{value:"Naming",id:"naming",level:2},{value:"Using Enums",id:"using-enums",level:2},{value:"Creating Enum Variants",id:"creating-enum-variants",level:3},{value:"Pattern Matching Enum Variants and Destructuring",id:"pattern-matching-enum-variants-and-destructuring",level:3},{value:"Overwriting to Enum Values",id:"overwriting-to-enum-values",level:3}];function u(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"enumerations",children:"Enumerations"})}),"\n",(0,i.jsxs)(n.p,{children:["An ",(0,i.jsx)(n.em,{children:"enum"})," is a user-defined data structure containing one or more ",(0,i.jsx)(n.em,{children:"variants"}),". Each variant can\noptionally contain typed fields. The number, and types of these fields can differ for each variant\nin the enumeration. Fields in enums can store any non-reference, non-tuple type, including other\nstructs or enums."]}),"\n",(0,i.jsx)(n.p,{children:"As a simple example, consider the following enum definition in Move:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"public enum Action {\n    Stop,\n    Pause { duration: u32 },\n    MoveTo { x: u64, y: u64 },\n    Jump(u64),\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This declares an enum ",(0,i.jsx)(n.code,{children:"Action"})," that represents different actions that can be taken by a game -- you\ncan ",(0,i.jsx)(n.code,{children:"Stop"}),", ",(0,i.jsx)(n.code,{children:"Pause"})," for a given duration, ",(0,i.jsx)(n.code,{children:"MoveTo"})," a specific location, or ",(0,i.jsx)(n.code,{children:"Jump"})," to a specific\nheight."]}),"\n",(0,i.jsxs)(n.p,{children:["Similar to structs, enums can have ",(0,i.jsx)(n.a,{href:"./abilities",children:"abilities"})," that control what operations can be\nperformed on them. It is important to note however that enums cannot have the ",(0,i.jsx)(n.code,{children:"key"})," ability since\nthey cannot be top-level objects."]}),"\n",(0,i.jsx)(n.h2,{id:"defining-enums",children:"Defining Enums"}),"\n",(0,i.jsx)(n.p,{children:"Enums must be defined in a module, an enum must contain at least one variant, and each variant of an\nenum can either have no fields, positional fields, or named fields. Here are some examples of each:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic enum Foo has drop {\n    VariantWithNoFields,\n    //                 ^ note: it is fine to have a trailing comma after variant declarations\n}\npublic enum Bar has copy, drop {\n    VariantWithPositionalFields(u64, bool),\n}\npublic enum Baz has drop {\n    VariantWithNamedFields { x: u64, y: bool, z: Bar },\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Enums cannot be recursive in any of their variants, so the following definitions of an enum are not\nallowed because they would be recursive in at least one variant."}),"\n",(0,i.jsx)(n.p,{children:"Incorrect:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic enum Foo {\n    Recursive(Foo),\n    //        ^ error: recursive enum variant\n}\npublic enum List {\n    Nil,\n    Cons { head: u64, tail: List },\n    //                      ^ error: recursive enum variant\n}\npublic enum BTree<T> {\n    Leaf(T),\n    Node { left: BTree<T>, right: BTree<T> },\n    //           ^ error: recursive enum variant\n}\n\n// Mutually recursive enums are also not allowed\npublic enum MutuallyRecursiveA {\n    Base,\n    Other(MutuallyRecursiveB),\n    //    ^^^^^^^^^^^^^^^^^^ error: recursive enum variant\n}\n\npublic enum MutuallyRecursiveB {\n    Base,\n    Other(MutuallyRecursiveA),\n    //    ^^^^^^^^^^^^^^^^^^ error: recursive enum variant\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"visibility",children:"Visibility"}),"\n",(0,i.jsxs)(n.p,{children:["All enums are declared as ",(0,i.jsx)(n.code,{children:"public"}),". This means that the type of the enum can be referred to from any\nother module. However, the variants of the enum, the fields within each variant, and the ability to\ncreate or destroy variants of the enum are internal to the module that defines the enum."]}),"\n",(0,i.jsx)(n.h3,{id:"abilities",children:"Abilities"}),"\n",(0,i.jsxs)(n.p,{children:["Just like with structs, by default an enum declaration is linear and ephemeral. To use an enum value\nin a non-linear or non-ephemeral way -- i.e., copied, dropped, or stored in an\n",(0,i.jsx)(n.a,{href:"./abilities/object",children:"object"})," -- you need to grant it additional ",(0,i.jsx)(n.a,{href:"./abilities",children:"abilities"})," by\nannotating them with ",(0,i.jsx)(n.code,{children:"has <ability>"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic enum Foo has copy, drop {\n    VariantWithNoFields,\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The ability declaration can occur either before or after the enum's variants, however only one or\nthe other can be used, and not both. If declared after the variants, the ability declaration must be\nterminated with a semicolon:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic enum PreNamedAbilities has copy, drop { Variant }\npublic enum PostNamedAbilities { Variant } has copy, drop;\npublic enum PostNamedAbilitiesInvalid { Variant } has copy, drop\n//                                                              ^ ERROR! missing semicolon\n\npublic enum NamedInvalidAbilities has copy { Variant } has drop;\n//                                                     ^ ERROR! duplicate ability declaration\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For more details, see the section on\n",(0,i.jsx)(n.a,{href:"./abilities#annotating-structs-and-enums",children:"annotating abilities"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"naming",children:"Naming"}),"\n",(0,i.jsxs)(n.p,{children:["Enums and variants within enums must start with a capital letter ",(0,i.jsx)(n.code,{children:"A"})," to ",(0,i.jsx)(n.code,{children:"Z"}),". After the first letter,\nenum names can contain underscores ",(0,i.jsx)(n.code,{children:"_"}),", lowercase letters ",(0,i.jsx)(n.code,{children:"a"})," to ",(0,i.jsx)(n.code,{children:"z"}),", uppercase letters ",(0,i.jsx)(n.code,{children:"A"})," to ",(0,i.jsx)(n.code,{children:"Z"}),",\nor digits ",(0,i.jsx)(n.code,{children:"0"})," to ",(0,i.jsx)(n.code,{children:"9"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"public enum Foo { Variant }\npublic enum BAR { Variant }\npublic enum B_a_z_4_2 { V_a_riant_0 }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This naming restriction of starting with ",(0,i.jsx)(n.code,{children:"A"})," to ",(0,i.jsx)(n.code,{children:"Z"})," is in place to give room for future language\nfeatures."]}),"\n",(0,i.jsx)(n.h2,{id:"using-enums",children:"Using Enums"}),"\n",(0,i.jsx)(n.h3,{id:"creating-enum-variants",children:"Creating Enum Variants"}),"\n",(0,i.jsx)(n.p,{children:'Values of an enum type can be created (or "packed") by indicating a variant of the enum, followed by\na value for each field in the variant. The variant name must always be qualified by the enum\'s name.'}),"\n",(0,i.jsxs)(n.p,{children:["Similarly to structs, for a variant with named fields, the order of the fields does not matter but\nthe field names need to be provided. For a variant with positional fields, the order of the fields\nmatters and the order of the fields must match the order in the variant declaration. It must also be\ncreated using ",(0,i.jsx)(n.code,{children:"()"})," instead of ",(0,i.jsx)(n.code,{children:"{}"}),". If the variant has no fields, the variant name is sufficient and\nno ",(0,i.jsx)(n.code,{children:"()"})," or ",(0,i.jsx)(n.code,{children:"{}"})," needs to be used."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic enum Action has drop {\n    Stop,\n    Pause { duration: u32 },\n    MoveTo { x: u64, y: u64 },\n    Jump(u64),\n}\npublic enum Other has drop {\n    Stop(u64),\n}\n\nfun example() {\n    // Note: The `Stop` variant of `Action` doesn't have fields so no parentheses or curlies are needed.\n    let stop = Action::Stop;\n    let pause = Action::Pause { duration: 10 };\n    let move_to = Action::MoveTo { x: 10, y: 20 };\n    let jump = Action::Jump(10);\n    // Note: The `Stop` variant of `Other` does have positional fields so we need to supply them.\n    let other_stop = Other::Stop(10);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"For variants with named fields you can also use the shorthand syntax that you might be familiar with\nfrom structs to create the variant:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let duration = 10;\n\nlet pause = Action::Pause { duration: duration };\n// is equivalent to\nlet pause = Action::Pause { duration };\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-matching-enum-variants-and-destructuring",children:"Pattern Matching Enum Variants and Destructuring"}),"\n",(0,i.jsx)(n.p,{children:"Since enum values can take on different shapes, dot access to fields of variants is not allowed like\nit is for struct fields. Instead, to access fields within a variant -- either by value, or immutable\nor mutable reference -- you must use pattern matching."}),"\n",(0,i.jsxs)(n.p,{children:["You can pattern match on Move values by value, immutable reference, and mutable reference. When\npattern matching by value, the value is moved into the match arm. When pattern matching by\nreference, the value is borrowed into the match arm (either immutably or mutably). We'll go through\na brief description of pattern matching using ",(0,i.jsx)(n.code,{children:"match"})," here, but for more information on pattern\nmatching using ",(0,i.jsx)(n.code,{children:"match"})," in Move see the ",(0,i.jsx)(n.a,{href:"./control-flow/pattern-matching",children:"Pattern Matching"})," section."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"match"})," statement is used to pattern match on a Move value and consists of a number of ",(0,i.jsx)(n.em,{children:"match\narms"}),". Each match arm consists of a pattern, an arrow ",(0,i.jsx)(n.code,{children:"=>"}),", and an expression, followed by a comma\n",(0,i.jsx)(n.code,{children:","}),". The pattern can be a struct, enum variant, binding (",(0,i.jsx)(n.code,{children:"x"}),", ",(0,i.jsx)(n.code,{children:"y"}),"), wildcard (",(0,i.jsx)(n.code,{children:"_"})," or ",(0,i.jsx)(n.code,{children:".."}),"), constant\n(",(0,i.jsx)(n.code,{children:"ConstValue"}),"), or literal value (",(0,i.jsx)(n.code,{children:"true"}),", ",(0,i.jsx)(n.code,{children:"42"}),", and so on). The value is matched against each\npattern from the top-down, and will match the first pattern that structurally matches the value.\nOnce the value is matched, the expression on the right hand side of the ",(0,i.jsx)(n.code,{children:"=>"})," is executed."]}),"\n",(0,i.jsxs)(n.p,{children:["Additionally, match arms can have optional ",(0,i.jsx)(n.em,{children:"guards"})," that are checked after the pattern matches but\n",(0,i.jsx)(n.em,{children:"before"})," the expression is executed. Guards are specified by the ",(0,i.jsx)(n.code,{children:"if"})," keyword followed by an\nexpression that must evaluate to a boolean value before the ",(0,i.jsx)(n.code,{children:"=>"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic enum Action has drop {\n    Stop,\n    Pause { duration: u32 },\n    MoveTo { x: u64, y: u64 },\n    Jump(u64),\n}\n\npublic struct GameState {\n    // Fields containing a game state\n    character_x: u64,\n    character_y: u64,\n    character_height: u64,\n    // ...\n}\n\nfun perform_action(stat: &mut GameState, action: Action) {\n    match (action) {\n        // Handle the `Stop` variant\n        Action::Stop => state.stop(),\n        // Handle the `Pause` variant\n        // If the duration is 0, do nothing\n        Action::Pause { duration: 0 } => (),\n        Action::Pause { duration } => state.pause(duration),\n        // Handle the `MoveTo` variant\n        Action::MoveTo { x, y } => state.move_to(x, y),\n        // Handle the `Jump` variant\n        // if the game disallows jumps then do nothing\n        Action::Jump(_) if (state.jumps_not_allowed()) => (),\n        // otherwise, jump to the specified height\n        Action::Jump(height) => state.jump(height),\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"To see how to pattern match on an enum to update values within it mutably, let's take the following\nexample of a simple enum that has two variants, each with a single field. We can then write two\nfunctions, one that only increments the value of the first variant, and another that only increments\nthe value of the second variant:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic enum SimpleEnum {\n    Variant1(u64),\n    Variant2(u64),\n}\n\npublic fun incr_enum_variant1(simple_enum: &mut SimpleEnum) {\n    match (simple_enum) {\n        SimpleEnum::Variant1(mut value) => *value += 1,\n        _ => (),\n    }\n}\n\npublic fun incr_enum_variant2(simple_enum: &mut SimpleEnum) {\n    match (simple_enum) {\n        SimpleEnum::Variant2(mut value) => *value += 1,\n        _ => (),\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, if we have a value of ",(0,i.jsx)(n.code,{children:"SimpleEnum"})," we can use the functions to increment the value of this\nvariant:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let mut x = SimpleEnum::Variant1(10);\nincr_enum_variant1(&mut x);\nassert!(x == SimpleEnum::Variant1(11));\n// Doesn't increment since it increments a different variant\nincr_enum_variant2(&mut x);\nassert!(x == SimpleEnum::Variant1(11));\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When pattern matching on a Move value that does not have the ",(0,i.jsx)(n.code,{children:"drop"})," ability, the value must be\nconsumed or destructured in each match arm. If the value is not consumed or destructured in a match\narm, the compiler will raise an error. This is to ensure that all possible values are handled in the\nmatch statement."]}),"\n",(0,i.jsx)(n.p,{children:"As an example, consider the following code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic enum X { Variant { x: u64 } }\n\npublic fun bad(x: X) {\n    match (x) {\n        _ => (),\n    // ^ ERROR! value of type `X` is not consumed or destructured in this match arm\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To properly handle this, you will need to destructure ",(0,i.jsx)(n.code,{children:"X"})," and all its variants in the match's\narm(s):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic enum X { Variant { x: u64 } }\n\npublic fun good(x: X) {\n    match (x) {\n        // OK! Compiles since the value is destructured\n        X::Variant { x: _ } => (),\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"overwriting-to-enum-values",children:"Overwriting to Enum Values"}),"\n",(0,i.jsxs)(n.p,{children:["As long as the enum has the ",(0,i.jsx)(n.code,{children:"drop"})," ability, you can overwrite the value of an enum with a new value\nof the same type just as you might with other values in Move."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic enum X has drop {\n    A(u64),\n    B(u64),\n}\n\npublic fun overwrite_enum(x: &mut X) {\n    *x = X::A(10);\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"let mut x = X::B(20);\noverwrite_enum(&mut x);\nassert!(x == X::A(10));\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);