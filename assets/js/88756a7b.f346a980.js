"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2811],{4828:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"generics","title":"Generics | Reference","description":"","source":"@site/../reference/generics.md","sourceDirName":".","slug":"/generics","permalink":"/reference/generics","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Generics | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"10. Constants","permalink":"/reference/constants"},"next":{"title":"12. Abilities","permalink":"/reference/abilities"}}');var s=t(3420),a=t(5521);const r={title:"Generics | Reference",description:""},o="Generics",c={},l=[{value:"Declaring Type Parameters",id:"declaring-type-parameters",level:2},{value:"Generic Functions",id:"generic-functions",level:3},{value:"Generic Structs",id:"generic-structs",level:3},{value:"Type Arguments",id:"type-arguments",level:2},{value:"Calling Generic Functions",id:"calling-generic-functions",level:3},{value:"Using Generic Structs",id:"using-generic-structs",level:3},{value:"Type Argument Mismatch",id:"type-argument-mismatch",level:3},{value:"Type Inference",id:"type-inference",level:2},{value:"<code>_</code> Type",id:"_-type",level:3},{value:"Integers",id:"integers",level:2},{value:"Unused Type Parameters",id:"unused-type-parameters",level:2},{value:"Phantom Type Parameters",id:"phantom-type-parameters",level:3},{value:"Declaration",id:"declaration",level:4},{value:"Instantiation",id:"instantiation",level:4},{value:"Phantom Type Parameters with Ability Constraints",id:"phantom-type-parameters-with-ability-constraints",level:4},{value:"Constraints",id:"constraints",level:2},{value:"Declaring Constraints",id:"declaring-constraints",level:3},{value:"Verifying Constraints",id:"verifying-constraints",level:3},{value:"Limitations on Recursions",id:"limitations-on-recursions",level:2},{value:"Recursive Structs",id:"recursive-structs",level:3},{value:"Advanced Topic: Type-level Recursions",id:"advanced-topic-type-level-recursions",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"generics",children:"Generics"})}),"\n",(0,s.jsxs)(n.p,{children:["Generics can be used to define functions and structs over different input data types. This language\nfeature is sometimes referred to as parametric polymorphism. In Move, we will often use the term\ngenerics interchangeably with ",(0,s.jsx)(n.em,{children:"type parameters"})," and ",(0,s.jsx)(n.em,{children:"type arguments"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Generics are commonly used in library code, such as in ",(0,s.jsx)(n.a,{href:"./primitive-types/vector",children:"vector"}),", to\ndeclare code that works over any possible type (that satisfies the specified constraints). This sort\nof parameterization allows you to reuse the same implementation across multiple types and\nsituations."]}),"\n",(0,s.jsx)(n.h2,{id:"declaring-type-parameters",children:"Declaring Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["Both functions and structs can take a list of type parameters in their signatures, enclosed by a\npair of angle brackets ",(0,s.jsx)(n.code,{children:"<...>"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"generic-functions",children:"Generic Functions"}),"\n",(0,s.jsx)(n.p,{children:"Type parameters for functions are placed after the function name and before the (value) parameter\nlist. The following code defines a generic identity function that takes a value of any type and\nreturns that value unchanged."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun id<T>(x: T): T {\n    // this type annotation is unnecessary but valid\n    (x: T)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Once defined, the type parameter ",(0,s.jsx)(n.code,{children:"T"})," can be used in parameter types, return types, and inside the\nfunction body."]}),"\n",(0,s.jsx)(n.h3,{id:"generic-structs",children:"Generic Structs"}),"\n",(0,s.jsx)(n.p,{children:"Type parameters for structs are placed after the struct name, and can be used to name the types of\nthe fields."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public struct Foo<T> has copy, drop { x: T }\n\npublic struct Bar<T1, T2> has copy, drop {\n    x: T1,\n    y: vector<T2>,\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that ",(0,s.jsx)(n.a,{href:"#unused-type-parameters",children:"type parameters do not have to be used"})]}),"\n",(0,s.jsx)(n.h2,{id:"type-arguments",children:"Type Arguments"}),"\n",(0,s.jsx)(n.h3,{id:"calling-generic-functions",children:"Calling Generic Functions"}),"\n",(0,s.jsx)(n.p,{children:"When calling a generic function, one can specify the type arguments for the function's type\nparameters in a list enclosed by a pair of angle brackets."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun foo() {\n    let x = id<bool>(true);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you do not specify the type arguments, Move's ",(0,s.jsx)(n.a,{href:"#type-inference",children:"type inference"})," will supply them\nfor you."]}),"\n",(0,s.jsx)(n.h3,{id:"using-generic-structs",children:"Using Generic Structs"}),"\n",(0,s.jsx)(n.p,{children:"Similarly, one can attach a list of type arguments for the struct's type parameters when\nconstructing or destructing values of generic types."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun foo() {\n    // type arguments on construction\n    let foo = Foo<bool> { x: true };\n    let bar = Bar<u64, u8> { x: 0, y: vector<u8>[] };\n\n    // type arguments on destruction\n    let Foo<bool> { x } = foo;\n    let Bar<u64, u8> { x, y } = bar;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In any case if you do not specify the type arguments, Move's ",(0,s.jsx)(n.a,{href:"#type-inference",children:"type inference"})," will\nsupply them for you."]}),"\n",(0,s.jsx)(n.h3,{id:"type-argument-mismatch",children:"Type Argument Mismatch"}),"\n",(0,s.jsx)(n.p,{children:"If you specify the type arguments and they conflict with the actual values supplied, an error will\nbe given:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun foo() {\n    let x = id<u64>(true); // ERROR! true is not a u64\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"and similarly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun foo() {\n    let foo = Foo<bool> { x: 0 }; // ERROR! 0 is not a bool\n    let Foo<address> { x } = foo; // ERROR! bool is incompatible with address\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"type-inference",children:"Type Inference"}),"\n",(0,s.jsx)(n.p,{children:"In most cases, the Move compiler will be able to infer the type arguments so you don't have to write\nthem down explicitly. Here's what the examples above would look like if we omit the type arguments:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun foo() {\n    let x = id(true);\n    //        ^ <bool> is inferred\n\n    let foo = Foo { x: true };\n    //           ^ <bool> is inferred\n\n    let Foo { x } = foo;\n    //     ^ <bool> is inferred\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Note: when the compiler is unable to infer the types, you'll need annotate them manually. A common\nscenario is to call a function with type parameters appearing only at return positions."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module a::m;\n\nfun foo() {\n    let v = vector[]; // ERROR!\n    //            ^ The compiler cannot figure out the element type, since it is never used\n\n    let v = vector<u64>[];\n    //            ^~~~~ Must annotate manually in this case.\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that these cases are a bit contrived since the ",(0,s.jsx)(n.code,{children:"vector[]"})," is never used, ad as such, Move's\ntype inference cannot infer the type."]}),"\n",(0,s.jsx)(n.p,{children:"However, the compiler will be able to infer the type if that value is used later in that function:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module a::m;\n\nfun foo() {\n    let v = vector[];\n    //            ^ <u64> is inferred\n    vector::push_back(&mut v, 42);\n    //               ^ <u64> is inferred\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"_-type",children:[(0,s.jsx)(n.code,{children:"_"})," Type"]}),"\n",(0,s.jsxs)(n.p,{children:["In some cases, you might want to explicitly annotate some of the type arguments, but let the\ncompiler infer the others. The ",(0,s.jsx)(n.code,{children:"_"})," type serves as such a placeholder for the compiler to infer the\ntype."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:'let bar = Bar<u64, _> { x: 0, y: vector[b"hello"] };\n//                 ^ vector<u8> is inferred\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The placeholder ",(0,s.jsx)(n.code,{children:"_"})," may only appear in expressions and macro function definitions, not signatures.\nThis means you cannot use ",(0,s.jsx)(n.code,{children:"_"})," as part of the definition of a function parameter, function return\ntype, constant definition type, and datatype field."]}),"\n",(0,s.jsx)(n.h2,{id:"integers",children:"Integers"}),"\n",(0,s.jsxs)(n.p,{children:["In Move, the integer types ",(0,s.jsx)(n.code,{children:"u8"}),", ",(0,s.jsx)(n.code,{children:"u16"}),", ",(0,s.jsx)(n.code,{children:"u32"}),", ",(0,s.jsx)(n.code,{children:"u64"}),", ",(0,s.jsx)(n.code,{children:"u128"}),", and ",(0,s.jsx)(n.code,{children:"u256"})," are all distinct types.\nHowever, each one of these types can be created with the same numerical value syntax. In other\nwords, if a type suffix is not provided, the compiler will infer the integer type based on the usage\nof the value."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let x8: u8 = 0;\nlet x16: u16 = 0;\nlet x32: u32 = 0;\nlet x64: u64 = 0;\nlet x128: u128 = 0;\nlet x256: u256 = 0;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If the value is not used in a context that requires a specific integer type, ",(0,s.jsx)(n.code,{children:"u64"})," is taken as a\ndefault."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let x = 0;\n//      ^ u64 is used by default\n"})}),"\n",(0,s.jsx)(n.p,{children:"If the value however is too large for the inferred type, an error will be given"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let i: u8 = 256; // ERROR!\n//          ^^^ too large for u8\nlet x = 340282366920938463463374607431768211454;\n//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ too large for u64\n"})}),"\n",(0,s.jsx)(n.p,{children:"In cases where the number is too large, you might need to annotate it explicitly"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let x = 340282366920938463463374607431768211454u128;\n//                                             ^^^^ valid!\n"})}),"\n",(0,s.jsx)(n.h2,{id:"unused-type-parameters",children:"Unused Type Parameters"}),"\n",(0,s.jsx)(n.p,{children:"For a struct definition, an unused type parameter is one that does not appear in any field defined\nin the struct, but is checked statically at compile time. Move allows unused type parameters so the\nfollowing struct definition is valid:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public struct Foo<T> {\n    foo: u64\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This can be convenient when modeling certain concepts. Here is an example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module a::m;\n\n// Currency Specifiers\npublic struct A {}\npublic struct B {}\n\n// A generic coin type that can be instantiated using a currency\n// specifier type.\n//   e.g. Coin<A>, Coin<B> etc.\npublic struct Coin<Currency> has store {\n    value: u64\n}\n\n// Write code generically about all currencies\npublic fun mint_generic<Currency>(value: u64): Coin<Currency> {\n    Coin { value }\n}\n\n// Write code concretely about one currency\npublic fun mint_a(value: u64): Coin<A> {\n    mint_generic(value)\n}\npublic fun mint_b(value: u64): Coin<B> {\n    mint_generic(value)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, ",(0,s.jsx)(n.code,{children:"Coin<Currency>"})," is generic on the ",(0,s.jsx)(n.code,{children:"Currency"})," type parameter, which specifies the\ncurrency of the coin and allows code to be written either generically on any currency or concretely\non a specific currency. This generality applies even when the ",(0,s.jsx)(n.code,{children:"Currency"})," type parameter does not\nappear in any of the fields defined in ",(0,s.jsx)(n.code,{children:"Coin"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"phantom-type-parameters",children:"Phantom Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["In the example above, although ",(0,s.jsx)(n.code,{children:"struct Coin"})," asks for the ",(0,s.jsx)(n.code,{children:"store"})," ability, neither ",(0,s.jsx)(n.code,{children:"Coin<A>"})," nor\n",(0,s.jsx)(n.code,{children:"Coin<B>"})," will have the ",(0,s.jsx)(n.code,{children:"store"})," ability. This is because of the rules for\n",(0,s.jsx)(n.a,{href:"./abilities#conditional-abilities-and-generic-types",children:"Conditional Abilities and Generic Types"})," and\nthe fact that ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"})," don't have the ",(0,s.jsx)(n.code,{children:"store"})," ability, despite the fact that they are not even\nused in the body of ",(0,s.jsx)(n.code,{children:"struct Coin"}),". This might cause some unpleasant consequences. For example, we\nare unable to put ",(0,s.jsx)(n.code,{children:"Coin<A>"})," into a wallet in storage."]}),"\n",(0,s.jsxs)(n.p,{children:["One possible solution would be to add spurious ability annotations to ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"})," (i.e.,\n",(0,s.jsx)(n.code,{children:"public struct Currency1 has store {}"}),"). But, this might lead to bugs or security vulnerabilities\nbecause it weakens the types with unnecessary ability declarations. For example, we would never\nexpect a value in the storage to have a field in type ",(0,s.jsx)(n.code,{children:"A"}),", but this would be possible with the\nspurious ",(0,s.jsx)(n.code,{children:"store"})," ability. Moreover, the spurious annotations would be infectious, requiring many\nfunctions generic on the unused type parameter to also include the necessary constraints."]}),"\n",(0,s.jsxs)(n.p,{children:["Phantom type parameters solve this problem. Unused type parameters can be marked as ",(0,s.jsx)(n.em,{children:"phantom"})," type\nparameters, which do not participate in the ability derivation for structs. In this way, arguments\nto phantom type parameters are not considered when deriving the abilities for generic types, thus\navoiding the need for spurious ability annotations. For this relaxed rule to be sound, Move's type\nsystem guarantees that a parameter declared as ",(0,s.jsx)(n.code,{children:"phantom"})," is either not used at all in the struct\ndefinition, or it is only used as an argument to type parameters also declared as ",(0,s.jsx)(n.code,{children:"phantom"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"declaration",children:"Declaration"}),"\n",(0,s.jsxs)(n.p,{children:["In a struct definition a type parameter can be declared as phantom by adding the ",(0,s.jsx)(n.code,{children:"phantom"})," keyword\nbefore its declaration."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public struct Coin<phantom Currency> has store {\n    value: u64\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"If a type parameter is declared as phantom we say it is a phantom type parameter. When defining a\nstruct, Move's type checker ensures that every phantom type parameter is either not used inside the\nstruct definition or it is only used as an argument to a phantom type parameter."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public struct S1<phantom T1, T2> { f: u64 }\n//               ^^^^^^^ valid, T1 does not appear inside the struct definition\n\npublic struct S2<phantom T1, T2> { f: S1<T1, T2> }\n//               ^^^^^^^ valid, T1 appears in phantom position\n"})}),"\n",(0,s.jsx)(n.p,{children:"The following code shows examples of violations of the rule:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public struct S1<phantom T> { f: T }\n//               ^^^^^^^ ERROR!  ^ Not a phantom position\n\npublic struct S2<T> { f: T }\npublic struct S3<phantom T> { f: S2<T> }\n//               ^^^^^^^ ERROR!     ^ Not a phantom position\n"})}),"\n",(0,s.jsxs)(n.p,{children:["More formally, if a type is used as an argument to a phantom type parameter we say the type appears\nin ",(0,s.jsx)(n.em,{children:"phantom position"}),". With this definition in place, the rule for the correct use of phantom\nparameters can be specified as follows: ",(0,s.jsx)(n.strong,{children:"A phantom type parameter can only appear in phantom\nposition"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that specifying ",(0,s.jsx)(n.code,{children:"phantom"})," is not required, but the compiler will warn if a type parameter could\nbe ",(0,s.jsx)(n.code,{children:"phantom"})," but was not marked as such."]}),"\n",(0,s.jsx)(n.h4,{id:"instantiation",children:"Instantiation"}),"\n",(0,s.jsx)(n.p,{children:"When instantiating a struct, the arguments to phantom parameters are excluded when deriving the\nstruct abilities. For example, consider the following code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public struct S<T1, phantom T2> has copy { f: T1 }\npublic struct NoCopy {}\npublic struct HasCopy has copy {}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Consider now the type ",(0,s.jsx)(n.code,{children:"S<HasCopy, NoCopy>"}),". Since ",(0,s.jsx)(n.code,{children:"S"})," is defined with ",(0,s.jsx)(n.code,{children:"copy"})," and all non-phantom\narguments have ",(0,s.jsx)(n.code,{children:"copy"})," then ",(0,s.jsx)(n.code,{children:"S<HasCopy, NoCopy>"})," also has ",(0,s.jsx)(n.code,{children:"copy"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"phantom-type-parameters-with-ability-constraints",children:"Phantom Type Parameters with Ability Constraints"}),"\n",(0,s.jsx)(n.p,{children:"Ability constraints and phantom type parameters are orthogonal features in the sense that phantom\nparameters can be declared with ability constraints."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public struct S<phantom T: copy> {}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When instantiating a phantom type parameter with an ability constraint, the type argument has to\nsatisfy that constraint, even though the parameter is phantom. The usual restrictions apply and ",(0,s.jsx)(n.code,{children:"T"}),"\ncan only be instantiated with arguments having ",(0,s.jsx)(n.code,{children:"copy"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"constraints",children:"Constraints"}),"\n",(0,s.jsxs)(n.p,{children:['In the examples above, we have demonstrated how one can use type parameters to define "unknown"\ntypes that can be plugged in by callers at a later time. This however means the type system has\nlittle information about the type and has to perform checks in a very conservative way. In some\nsense, the type system must assume the worst case scenario for an unconstrained generic--a type with\nno ',(0,s.jsx)(n.a,{href:"./abilities",children:"abilities"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Constraints offer a way to specify what properties these unknown types have so the type system can\nallow operations that would otherwise be unsafe."}),"\n",(0,s.jsx)(n.h3,{id:"declaring-constraints",children:"Declaring Constraints"}),"\n",(0,s.jsx)(n.p,{children:"Constraints can be imposed on type parameters using the following syntax."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"// T is the name of the type parameter\nT: <ability> (+ <ability>)*\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"<ability>"})," can be any of the four ",(0,s.jsx)(n.a,{href:"./abilities",children:"abilities"}),", and a type parameter can be\nconstrained with multiple abilities at once. So all of the following would be valid type parameter\ndeclarations:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"T: copy\nT: copy + drop\nT: copy + drop + store + key\n"})}),"\n",(0,s.jsx)(n.h3,{id:"verifying-constraints",children:"Verifying Constraints"}),"\n",(0,s.jsx)(n.p,{children:"Constraints are checked at instantiation sites"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public struct Foo<T: copy> { x: T }\n\npublic struct Bar { x: Foo<u8> }\n//                         ^^ valid, u8 has `copy`\n\npublic struct Baz<T> { x: Foo<T> }\n//                            ^ ERROR! T does not have 'copy'\n"})}),"\n",(0,s.jsx)(n.p,{children:"And similarly for functions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun unsafe_consume<T>(x: T) {\n    // ERROR! x does not have 'drop'\n}\n\nfun consume<T: drop>(x: T) {\n    // valid, x will be dropped automatically\n}\n\npublic struct NoAbilities {}\n\nfun foo() {\n    let r = NoAbilities {};\n    consume<NoAbilities>(NoAbilities);\n    //      ^^^^^^^^^^^ ERROR! NoAbilities does not have 'drop'\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["And some similar examples, but with ",(0,s.jsx)(n.code,{children:"copy"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun unsafe_double<T>(x: T) {\n    (copy x, x)\n    // ERROR! T does not have 'copy'\n}\n\nfun double<T: copy>(x: T) {\n    (copy x, x) // valid, T has 'copy'\n}\n\npublic struct NoAbilities {}\n\nfun foo(): (NoAbilities, NoAbilities) {\n    let r = NoAbilities {};\n    double<NoAbilities>(r)\n    //     ^ ERROR! NoAbilities does not have 'copy'\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For more information, see the abilities section on\n",(0,s.jsx)(n.a,{href:"./abilities#conditional-abilities-and-generic-types",children:"conditional abilities and generic types"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"limitations-on-recursions",children:"Limitations on Recursions"}),"\n",(0,s.jsx)(n.h3,{id:"recursive-structs",children:"Recursive Structs"}),"\n",(0,s.jsx)(n.p,{children:"Generic structs can not contain fields of the same type, either directly or indirectly, even with\ndifferent type arguments. All of the following struct definitions are invalid:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public struct Foo<T> {\n    x: Foo<u64> // ERROR! 'Foo' containing 'Foo'\n}\n\npublic struct Bar<T> {\n    x: Bar<T> // ERROR! 'Bar' containing 'Bar'\n}\n\n// ERROR! 'A' and 'B' forming a cycle, which is not allowed either.\npublic struct A<T> {\n    x: B<T, u64>\n}\n\npublic struct B<T1, T2> {\n    x: A<T1>\n    y: A<T2>\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"advanced-topic-type-level-recursions",children:"Advanced Topic: Type-level Recursions"}),"\n",(0,s.jsx)(n.p,{children:"Move allows generic functions to be called recursively. However, when used in combination with\ngeneric structs, this could create an infinite number of types in certain cases, and allowing this\nmeans adding unnecessary complexity to the compiler, vm and other language components. Therefore,\nsuch recursions are forbidden."}),"\n",(0,s.jsx)(n.p,{children:"This restriction might be relaxed in the future, but for now, the following examples should give you\nan idea of what is allowed and what is not."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic struct A<T> {}\n\n// Finitely many types -- allowed.\n// foo<T> -> foo<T> -> foo<T> -> ... is valid\nfun foo<T>() {\n    foo<T>();\n}\n\n// Finitely many types -- allowed.\n// foo<T> -> foo<A<u64>> -> foo<A<u64>> -> ... is valid\nfun foo<T>() {\n    foo<A<u64>>();\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Not allowed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic struct A<T> {}\n\n// Infinitely many types -- NOT allowed.\n// error!\n// foo<T> -> foo<A<T>> -> foo<A<A<T>>> -> ...\nfun foo<T>() {\n    foo<Foo<T>>();\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"And similarly, not allowed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module a::n;\n\npublic struct A<T> {}\n\n// Infinitely many types -- NOT allowed.\n// error!\n// foo<T1, T2> -> bar<T2, T1> -> foo<T2, A<T1>>\n//   -> bar<A<T1>, T2> -> foo<A<T1>, A<T2>>\n//   -> bar<A<T2>, A<T1>> -> foo<A<T2>, A<A<T1>>>\n//   -> ...\nfun foo<T1, T2>() {\n    bar<T2, T1>();\n}\n\nfun bar<T1, T2> {\n    foo<T1, A<T2>>();\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Note, the check for type level recursions is based on a conservative analysis on the call sites and\ndoes NOT take control flow or runtime values into account."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic struct A<T> {}\n\n// Infinitely many types -- NOT allowed.\n// error!\nfun foo<T>(n: u64) {\n    if (n > 0) foo<A<T>>(n - 1);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The function in the example above will technically terminate for any given input and therefore only\ncreating finitely many types, but it is still considered invalid by Move's type system."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},5521:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(6672);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);