"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7080],{975:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"programmability/bcs","title":"Binary Canonical Serialization","description":"Binary Canonical Serialization (BCS) is a binary encoding format for structured data. It was","source":"@site/../book/programmability/bcs.md","sourceDirName":"programmability","slug":"/programmability/bcs","permalink":"/programmability/bcs","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"8.16. Pattern: Hot Potato","permalink":"/programmability/hot-potato-pattern"},"next":{"title":"2024 Migration Guide","permalink":"/guides/2024-migration-guide"}}');var i=s(3420),o=s(5521);const a={},r="Binary Canonical Serialization",c={},l=[{value:"Format",id:"format",level:2},{value:"Using BCS",id:"using-bcs",level:2},{value:"Encoding",id:"encoding",level:2},{value:"Encoding a Struct",id:"encoding-a-struct",level:3},{value:"Decoding",id:"decoding",level:2},{value:"Wrapper API",id:"wrapper-api",level:3},{value:"Decoding Vectors",id:"decoding-vectors",level:3},{value:"Decoding Option",id:"decoding-option",level:3},{value:"Decoding Structs",id:"decoding-structs",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"binary-canonical-serialization",children:"Binary Canonical Serialization"})}),"\n",(0,i.jsx)(n.p,{children:"Binary Canonical Serialization (BCS) is a binary encoding format for structured data. It was\noriginally designed in Diem, and became the standard serialization format for Move. BCS is simple,\nefficient, deterministic, and easy to implement in any programming language."}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["The full format specification is available in the\n",(0,i.jsx)(n.a,{href:"https://github.com/zefchain/bcs",children:"BCS repository"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"format",children:"Format"}),"\n",(0,i.jsx)(n.p,{children:"BCS is a binary format that supports unsigned integers up to 256 bits, options, booleans, unit\n(empty value), fixed and variable-length sequences, and maps. The format is designed to be\ndeterministic, meaning that the same data will always be serialized to the same bytes."}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:['"BCS is not a self-describing format. As such, in order to deserialize a message, one must know\nthe message type and layout ahead of time" from the ',(0,i.jsx)(n.a,{href:"https://github.com/zefchain/bcs",children:"README"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Integers are stored in little-endian format, and variable-length integers are encoded using a\nvariable-length encoding scheme. Sequences are prefixed with their length as ULEB128, enumerations\nare stored as the index of the variant followed by the data, and maps are stored as an ordered\nsequence of key-value pairs."}),"\n",(0,i.jsx)(n.p,{children:"Structs are treated as a sequence of fields, and the fields are serialized in the order they are\ndefined in the struct. The fields are serialized using the same rules as the top-level data."}),"\n",(0,i.jsx)(n.h2,{id:"using-bcs",children:"Using BCS"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"./sui-framework",children:"Sui Framework"})," includes the sui::bcs module for encoding and decoding data.\nEncoding functions are native to the VM, and decoding functions are implemented in Move."]}),"\n",(0,i.jsx)(n.h2,{id:"encoding",children:"Encoding"}),"\n",(0,i.jsxs)(n.p,{children:["To encode data, use the ",(0,i.jsx)(n.code,{children:"bcs::to_bytes"})," function, which converts data references into byte vectors.\nThis function supports encoding any types, including structs."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module std::bcs;\n\npublic native fun to_bytes<T>(t: &T): vector<u8>;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The following example shows how to encode a struct using BCS. The ",(0,i.jsx)(n.code,{children:"to_bytes"})," function can take any\nvalue and encode it as a vector of bytes."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/bcs.move anchor=encode",children:"use sui::bcs;\n\n// 0x01 - a single byte with value 1 (or 0 for false)\nlet bool_bytes = bcs::to_bytes(&true);\n// 0x2a - just a single byte\nlet u8_bytes = bcs::to_bytes(&42u8);\n// 0x2a00000000000000 - 8 bytes\nlet u64_bytes = bcs::to_bytes(&42u64);\n// address is a fixed sequence of 32 bytes\n// 0x0000000000000000000000000000000000000000000000000000000000000002\nlet addr = bcs::to_bytes(&@sui);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"encoding-a-struct",children:"Encoding a Struct"}),"\n",(0,i.jsx)(n.p,{children:"Structs encode similarly to simple types. Here is how to encode a struct using BCS:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/bcs.move anchor=encode_struct",children:'let data = CustomData {\n    num: 42,\n    string: b"hello, world!".to_string(),\n    value: true\n};\n\nlet struct_bytes = bcs::to_bytes(&data);\n\nlet mut custom_bytes = vector[];\ncustom_bytes.append(bcs::to_bytes(&42u8));\ncustom_bytes.append(bcs::to_bytes(&b"hello, world!".to_string()));\ncustom_bytes.append(bcs::to_bytes(&true));\n\n// struct is just a sequence of fields, so the bytes should be the same!\nassert!(&struct_bytes == &custom_bytes);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"decoding",children:"Decoding"}),"\n",(0,i.jsxs)(n.p,{children:["Because BCS does not self-describe and Move is statically typed, decoding requires prior knowledge\nof the data type. The ",(0,i.jsx)(n.code,{children:"sui::bcs"})," module provides various functions to assist with this process."]}),"\n",(0,i.jsx)(n.h3,{id:"wrapper-api",children:"Wrapper API"}),"\n",(0,i.jsxs)(n.p,{children:["BCS is implemented as a wrapper in Move. The decoder takes the bytes by value, and then allows the\ncaller to ",(0,i.jsx)(n.em,{children:"peel off"})," the data by calling different decoding functions, prefixed with ",(0,i.jsx)(n.code,{children:"peel_*"}),". The\ndata is split off the bytes, and the remainder bytes are kept in the wrapper until the\n",(0,i.jsx)(n.code,{children:"into_remainder_bytes"})," function is called."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/bcs.move anchor=decode",children:'use sui::bcs;\n\n// BCS instance should always be declared as mutable\nlet mut bcs = bcs::new(x"010000000000000000");\n\n// Same bytes can be read differently, for example: Option<u64>\nlet value: Option<u64> = bcs.peel_option_u64();\n\nassert!(value.is_some());\nassert!(value.borrow() == &0);\n\nlet remainder = bcs.into_remainder_bytes();\n\nassert!(remainder.length() == 0);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["There is a common practice to use multiple variables in a single ",(0,i.jsx)(n.code,{children:"let"})," statement during decoding. It\nmakes code a little bit more readable and helps to avoid unnecessary copying of the data."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/bcs.move anchor=chain_decode",children:'let mut bcs = bcs::new(x"0101010F0000000000F00000000000");\n\n// mind the order!!!\n// handy way to peel multiple values\nlet (bool_value, u8_value, u64_value) = (\n    bcs.peel_bool(),\n    bcs.peel_u8(),\n    bcs.peel_u64()\n);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"decoding-vectors",children:"Decoding Vectors"}),"\n",(0,i.jsx)(n.p,{children:"While most of the primitive types have a dedicated decoding function, vectors need special handling,\nwhich depends on the type of the elements. For vectors, first you need to decode the length of the\nvector, and then decode each element in a loop."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/bcs.move anchor=decode_vector",children:'let mut bcs = bcs::new(x"0101010F0000000000F00000000000");\n\n// bcs.peel_vec_length() peels the length of the vector :)\nlet mut len = bcs.peel_vec_length();\nlet mut vec = vector[];\n\n// then iterate depending on the data type\nwhile (len > 0) {\n    vec.push_back(bcs.peel_u64()); // or any other type\n    len = len - 1;\n};\n\nassert!(vec.length() == 1);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["For most common scenarios, ",(0,i.jsx)(n.code,{children:"bcs"})," module provides a basic set of functions for decoding vectors:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"peel_vec_address(): vector<address>"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"peel_vec_bool(): vector<bool>"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"peel_vec_u8(): vector<u8>"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"peel_vec_u64(): vector<u64>"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"peel_vec_u128(): vector<u128>"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"peel_vec_vec_u8(): vector<vector<u8>>"})," - vector of byte vectors"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"decoding-option",children:"Decoding Option"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"./../move-basics/option",children:"Option"})," is represented as a vector of either 0 or 1 element. To read an\noption, you would treat it like a vector and check its length (first byte - either 1 or 0)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/bcs.move anchor=decode_option",children:'let mut bcs = bcs::new(x"00");\nlet is_some = bcs.peel_bool();\n\nassert!(is_some == false);\n\nlet mut bcs = bcs::new(x"0101");\nlet is_some = bcs.peel_bool();\nlet value = bcs.peel_u8();\n\nassert!(is_some == true);\nassert!(value == 1);\n'})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"If you need to decode an option of a custom type, use the method in the code snippet above."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The most common scenarios, ",(0,i.jsx)(n.code,{children:"bcs"})," module provides a basic set of functions for decoding Option's:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"peel_option_address(): Option<address>"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"peel_option_bool(): Option<bool>"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"peel_option_u8(): Option<u8>"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"peel_option_u64(): Option<u64>"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"peel_option_u128(): Option<u128>"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"decoding-structs",children:"Decoding Structs"}),"\n",(0,i.jsx)(n.p,{children:"Structs are decoded field by field, and there is no standard function to automatically decode bytes\ninto a Move struct, and it would have been a violation of the Move's type system. Instead, you need\nto decode each field manually."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/bcs.move anchor=decode_struct",children:'// some bytes...\nlet mut bcs = bcs::new(x"0101010F0000000000F00000000000");\n\nlet (age, is_active, name) = (\n    bcs.peel_u8(),\n    bcs.peel_bool(),\n    bcs.peel_vec_u8().to_string()\n);\n\nlet user = User { age, is_active, name };\n'})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"Binary Canonical Serialization is an efficient binary format for structured data, ensuring\nconsistent serialization across platforms. The Sui Framework provides comprehensive tools for\nworking with BCS, allowing extensive functionality through built-in functions."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},5521:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>r});var t=s(6672);const i={},o=t.createContext(i);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);