"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2919],{5521:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>i});var a=s(6672);const o={},c=a.createContext(o);function t(e){const n=a.useContext(c);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),a.createElement(c.Provider,{value:n},e.children)}},5800:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>t,metadata:()=>a,toc:()=>r});const a=JSON.parse('{"id":"method-syntax","title":"Method Syntax | Reference","description":"","source":"@site/../reference/method-syntax.md","sourceDirName":".","slug":"/method-syntax","permalink":"/reference/method-syntax","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Method Syntax | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"13. Uses and Aliases","permalink":"/reference/uses"},"next":{"title":"15. Index Syntax","permalink":"/reference/index-syntax"}}');var o=s(3420),c=s(5521);const t={title:"Method Syntax | Reference",description:""},i="Methods",l={},r=[{value:"Syntax",id:"syntax",level:2},{value:"Method Resolution",id:"method-resolution",level:2},{value:"Functions in the Defining Module",id:"functions-in-the-defining-module",level:3},{value:"<code>use fun</code> Aliases",id:"use-fun-aliases",level:3},{value:"<code>public use fun</code> Aliases",id:"public-use-fun-aliases",level:3},{value:"Interactions with <code>use</code> Aliases",id:"interactions-with-use-aliases",level:3},{value:"Scoping",id:"scoping",level:3},{value:"Automatic Borrowing",id:"automatic-borrowing",level:2},{value:"Chaining",id:"chaining",level:2}];function u(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"methods",children:"Methods"})}),"\n",(0,o.jsxs)(n.p,{children:['As a syntactic convenience, some functions in Move can be called as "methods" on a value. This is done\nby using the ',(0,o.jsx)(n.code,{children:"."})," operator to call the function, where the value on the left-hand side of the ",(0,o.jsx)(n.code,{children:"."})," is\nthe first argument to the function (sometimes called the receiver). The type of that value\nstatically determines which function is called. This is an important difference from some other\nlanguages, where this syntax might indicate a dynamic call, where the function to be called is\ndetermined at runtime. In Move, all function calls are statically determined."]}),"\n",(0,o.jsxs)(n.p,{children:["In short, this syntax exists to make it easier to call functions without having to create an alias\nwith ",(0,o.jsx)(n.code,{children:"use"}),", and without having to explicitly borrow the first argument to the function.\nAdditionally, this can make code more readable, as it reduces the amount of boilerplate needed to\ncall a function and makes it easier to chain function calls."]}),"\n",(0,o.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,o.jsx)(n.p,{children:"The syntax for calling a method is as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",children:"<expression> . <identifier> <[type_arguments],*> ( <arguments> )\n"})}),"\n",(0,o.jsx)(n.p,{children:"For example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"coin.value();\n*nums.borrow_mut(i) = 5;\n"})}),"\n",(0,o.jsx)(n.h2,{id:"method-resolution",children:"Method Resolution"}),"\n",(0,o.jsxs)(n.p,{children:["When a method is called, the compiler will statically determine which function is called based on\nthe type of the receiver (the argument on the left-hand side of the ",(0,o.jsx)(n.code,{children:"."}),"). The compiler maintains a\nmapping from type and method name to the module and function name that should be called. This\nmapping is created form the ",(0,o.jsx)(n.code,{children:"use fun"})," aliases that are currently in scope, and from the appropriate\nfunctions in the receiver type's defining module. In all cases, the receiver type is the first\nargument to the function, whether by-value or by-reference."]}),"\n",(0,o.jsxs)(n.p,{children:['In this section, when we say a method "resolves" to a function, we mean that the compiler will\nstatically replace the method with a normal ',(0,o.jsx)(n.a,{href:"./functions",children:"function"})," call. For example if we have\n",(0,o.jsx)(n.code,{children:"x.foo(e)"})," with ",(0,o.jsx)(n.code,{children:"foo"})," resolving to ",(0,o.jsx)(n.code,{children:"a::m::foo"}),", the compiler will replace ",(0,o.jsx)(n.code,{children:"x.foo(e)"})," with\n",(0,o.jsx)(n.code,{children:"a::m::foo(x, e)"}),", potentially ",(0,o.jsx)(n.a,{href:"#automatic-borrowing",children:"automatically borrowing"})," ",(0,o.jsx)(n.code,{children:"x"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"functions-in-the-defining-module",children:"Functions in the Defining Module"}),"\n",(0,o.jsx)(n.p,{children:"In a type\u2019s defining module, the compiler will automatically create a method alias for any function\ndeclaration for its types when the type is the first argument in the function. For example,"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic struct X() has copy, drop, store;\npublic fun foo(x: &X) { ... }\npublic fun bar(flag: bool, x: &X) { ... }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The function ",(0,o.jsx)(n.code,{children:"foo"})," can be called as a method on a value of type ",(0,o.jsx)(n.code,{children:"X"}),". However, not the first argument\n(and one is not created for ",(0,o.jsx)(n.code,{children:"bool"})," since ",(0,o.jsx)(n.code,{children:"bool"})," is not defined in that module). For example,"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"fun example(x: a::m::X) {\n    x.foo(); // valid\n    // x.bar(true); ERROR!\n}\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"use-fun-aliases",children:[(0,o.jsx)(n.code,{children:"use fun"})," Aliases"]}),"\n",(0,o.jsxs)(n.p,{children:["Like a traditional ",(0,o.jsx)(n.a,{href:"uses",children:(0,o.jsx)(n.code,{children:"use"})}),", a ",(0,o.jsx)(n.code,{children:"use fun"})," statement creates an alias local to its current\nscope. This could be for the current module or the current expression block. However, the alias is\nassociated to a type."]}),"\n",(0,o.jsxs)(n.p,{children:["The syntax for a ",(0,o.jsx)(n.code,{children:"use fun"})," statement is as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"use fun <function> as <type>.<method alias>;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This creates an alias for the ",(0,o.jsx)(n.code,{children:"<function>"}),", which the ",(0,o.jsx)(n.code,{children:"<type>"})," can receive as ",(0,o.jsx)(n.code,{children:"<method alias>"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"For example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module a::cup;\n\npublic struct Cup<T>(T) has copy, drop, store;\n\npublic fun cup_borrow<T>(c: &Cup<T>): &T {\n    &c.0\n}\n\npublic fun cup_value<T>(c: Cup<T>): T {\n    let Cup(t) = c;\n    t\n}\n\npublic fun cup_swap<T: drop>(c: &mut Cup<T>, t: T) {\n    c.0 = t;\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We can now create ",(0,o.jsx)(n.code,{children:"use fun"})," aliases to these functions"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module b::example;\n\nuse fun a::cup::cup_borrow as Cup.borrow;\nuse fun a::cup::cup_value as Cup.value;\nuse fun a::cup::cup_swap as Cup.set;\n\nfun example(c: &mut Cup<u64>) {\n    let _ = c.borrow(); // resolves to a::cup::cup_borrow\n    let v = c.value(); // resolves to a::cup::cup_value\n    c.set(v * 2); // resolves to a::cup::cup_swap\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Note that the ",(0,o.jsx)(n.code,{children:"<function>"})," in the ",(0,o.jsx)(n.code,{children:"use fun"})," does not have to be a fully resolved path, and an alias\ncan be used instead, so the declarations in the above example could equivalently be written as"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"use a::cup::{Self, cup_swap};\n\nuse fun cup::cup_borrow as Cup.borrow;\nuse fun cup::cup_value as Cup.value;\nuse fun cup_swap as Cup.set;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["While these examples are cute for renaming the functions in the current module, the feature is\nperhaps more useful for declaring methods on types from other modules. For example, if we wanted to\nadd a new utility to ",(0,o.jsx)(n.code,{children:"Cup"}),", we could do so with a ",(0,o.jsx)(n.code,{children:"use fun"})," alias and still use method syntax"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module b::example;\n\nfun double(c: &Cup<u64>): Cup<u64> {\n    let v = c.value();\n    Cup::new(v * 2)\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Normally, we would be stuck having to call it as ",(0,o.jsx)(n.code,{children:"double(&c)"})," because ",(0,o.jsx)(n.code,{children:"b::example"})," did not define\n",(0,o.jsx)(n.code,{children:"Cup"}),", but instead we can use a ",(0,o.jsx)(n.code,{children:"use fun"})," alias"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"fun double_double(c: Cup<u64>): (Cup<u64>, Cup<u64>) {\n    use fun b::example::double as Cup.dub;\n    (c.dub(), c.dub()) // resolves to b::example::double in both calls\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["While ",(0,o.jsx)(n.code,{children:"use fun"})," can be made in any scope, the target ",(0,o.jsx)(n.code,{children:"<function>"})," of the ",(0,o.jsx)(n.code,{children:"use fun"})," must have a first\nargument that is the same as the ",(0,o.jsx)(n.code,{children:"<type>"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"public struct X() has copy, drop, store;\n\nfun new(): X { X() }\nfun flag(flag: bool): u8 { if (flag) 1 else 0 }\n\nuse fun new as X.new; // ERROR!\nuse fun flag as X.flag; // ERROR!\n// Neither `new` nor `flag` has first argument of type `X`\n"})}),"\n",(0,o.jsxs)(n.p,{children:["But any first argument of the ",(0,o.jsx)(n.code,{children:"<type>"})," can be used, including references and mutable references"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"public struct X() has copy, drop, store;\n\npublic fun by_val(_: X) {}\npublic fun by_ref(_: &X) {}\npublic fun by_mut(_: &mut X) {}\n\n// All 3 valid, in any scope\nuse fun by_val as X.v;\nuse fun by_ref as X.r;\nuse fun by_mut as X.m;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Note for generics, the methods are associated for ",(0,o.jsx)(n.em,{children:"all"})," instances of the generic type. You cannot\noverload the method to resolve to different functions depending on the instantiation."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"public struct Cup<T>(T) has copy, drop, store;\n\npublic fun value<T: copy>(c: &Cup<T>): T {\n    c.0\n}\n\nuse fun value as Cup<bool>.flag; // ERROR!\nuse fun value as Cup<u64>.num; // ERROR!\n// In both cases, `use fun` aliases cannot be generic, they must work for all instances of the type\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"public-use-fun-aliases",children:[(0,o.jsx)(n.code,{children:"public use fun"})," Aliases"]}),"\n",(0,o.jsxs)(n.p,{children:["Unlike a traditional ",(0,o.jsx)(n.a,{href:"uses",children:(0,o.jsx)(n.code,{children:"use"})}),", the ",(0,o.jsx)(n.code,{children:"use fun"})," statement can be made ",(0,o.jsx)(n.code,{children:"public"}),", which allows it\nto be used outside of its declared scope. A ",(0,o.jsx)(n.code,{children:"use fun"})," can be made ",(0,o.jsx)(n.code,{children:"public"})," if it is declared in the\nmodule that defines the receivers type, much like the method aliases that are\n",(0,o.jsx)(n.a,{href:"#functions-in-the-defining-module",children:"automatically created"})," for functions in the defining module. Or\nconversely, one can think that an implicit ",(0,o.jsx)(n.code,{children:"public use fun"})," is created automatically for every\nfunction in the defining module that has a first argument of the receiver type (if it is defined in\nthat module). Both of these views are equivalent."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module a::cup;\n\npublic struct Cup<T>(T) has copy, drop, store;\n\npublic use fun cup_borrow as Cup.borrow;\npublic fun cup_borrow<T>(c: &Cup<T>): &T {\n    &c.0\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, a public method alias is created for ",(0,o.jsx)(n.code,{children:"a::cup::Cup.borrow"})," and\n",(0,o.jsx)(n.code,{children:"a::cup::Cup.cup_borrow"}),". Both resolve to ",(0,o.jsx)(n.code,{children:"a::cup::cup_borrow"}),'. And both are "public" in the sense\nthat they can be used outside of ',(0,o.jsx)(n.code,{children:"a::cup"}),", without an additional ",(0,o.jsx)(n.code,{children:"use"})," or ",(0,o.jsx)(n.code,{children:"use fun"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module b::example;\n\nfun example<T: drop>(c: a::cup::Cup<u64>) {\n    c.borrow(); // resolves to a::cup::cup_borrow\n    c.cup_borrow(); // resolves to a::cup::cup_borrow\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"public use fun"})," declarations thus serve as a way of renaming a function if you want to give it\na cleaner name for use with method syntax. This is especially helpful if you have a module with\nmultiple types, and similarly named functions for each type."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module a::shapes;\n\npublic struct Rectangle { base: u64, height: u64 }\npublic struct Box { base: u64, height: u64, depth: u64 }\n\n// Rectangle and Box can have methods with the same name\n\npublic use fun rectangle_base as Rectangle.base;\npublic fun rectangle_base(rectangle: &Rectangle): u64 {\n    rectangle.base\n}\n\npublic use fun box_base as Box.base;\npublic fun box_base(box: &Box): u64 {\n    box.base\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Another use for ",(0,o.jsx)(n.code,{children:"public use fun"})," is adding methods to types from other modules. This can be helpful\nin conjunction with functions spread out across a single package."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module a::cup {\n    public struct Cup<T>(T) has copy, drop, store;\n\n    public fun new<T>(t: T): Cup<T> { Cup(t) }\n    public fun borrow<T>(c: &Cup<T>): &T {\n        &c.0\n    }\n    // `public use fun` to a function defined in another module\n    public use fun a::utils::split as Cup.split;\n}\n\nmodule a::utils {\n    use a::m::{Self, Cup};\n\n    public fun split<u64>(c: Cup<u64>): (Cup<u64>, Cup<u64>) {\n        let Cup(t) = c;\n        let half = t / 2;\n        let rem = if (t > 0) t - half else 0;\n        (cup::new(half), cup::new(rem))\n    }\n\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["And note that this ",(0,o.jsx)(n.code,{children:"public use fun"})," does not create a circular dependency, as the ",(0,o.jsx)(n.code,{children:"use fun"})," is not\npresent after the module is compiled--all methods are resolved statically."]}),"\n",(0,o.jsxs)(n.h3,{id:"interactions-with-use-aliases",children:["Interactions with ",(0,o.jsx)(n.code,{children:"use"})," Aliases"]}),"\n",(0,o.jsxs)(n.p,{children:["A small detail to note is that method aliases respect normal ",(0,o.jsx)(n.code,{children:"use"})," aliases."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module a::cup {\n    public struct Cup<T>(T) has copy, drop, store;\n\n    public fun cup_borrow<T>(c: &Cup<T>): &T {\n        &c.0\n    }\n}\n\nmodule b::other {\n    use a::cup::{Cup, cup_borrow as borrow};\n\n    fun example(c: &Cup<u64>) {\n        c.borrow(); // resolves to a::cup::cup_borrow\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["A helpful way to think about this is that ",(0,o.jsx)(n.code,{children:"use"})," creates an implicit ",(0,o.jsx)(n.code,{children:"use fun"})," alias for the function\nwhenever it can. In this case the ",(0,o.jsx)(n.code,{children:"use a::cup::cup_borrow as borrow"})," creates an implicit\n",(0,o.jsx)(n.code,{children:"use fun a::cup::cup_borrow as Cup.borrow"})," because it would be a valid ",(0,o.jsx)(n.code,{children:"use fun"})," alias. Both views\nare equivalent. This line of reasoning can inform how specific methods will resolve with shadowing.\nSee the cases in ",(0,o.jsx)(n.a,{href:"#scoping",children:"Scoping"})," for more details."]}),"\n",(0,o.jsx)(n.h3,{id:"scoping",children:"Scoping"}),"\n",(0,o.jsxs)(n.p,{children:["If not ",(0,o.jsx)(n.code,{children:"public"}),", a ",(0,o.jsx)(n.code,{children:"use fun"})," alias is local to its scope, much like a normal ",(0,o.jsx)(n.a,{href:"uses",children:(0,o.jsx)(n.code,{children:"use"})}),". For\nexample"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module a::m {\n    public struct X() has copy, drop, store;\n    public fun foo(_: &X) {}\n    public fun bar(_: &X) {}\n}\n\nmodule b::other {\n    use a::m::X;\n\n    use fun a::m::foo as X.f;\n\n    fun example(x: &X) {\n        x.f(); // resolves to a::m::foo\n        {\n            use a::m::bar as f;\n            x.f(); // resolves to a::m::bar\n        };\n        x.f(); // still resolves to a::m::foo\n        {\n            use fun a::m::bar as X.f;\n            x.f(); // resolves to a::m::bar\n        }\n    }\n"})}),"\n",(0,o.jsx)(n.h2,{id:"automatic-borrowing",children:"Automatic Borrowing"}),"\n",(0,o.jsx)(n.p,{children:"When resolving a method, the compiler will automatically borrow the receiver if the function expects\na reference. For example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic struct X() has copy, drop;\npublic fun by_val(_: X) {}\npublic fun by_ref(_: &X) {}\npublic fun by_mut(_: &mut X) {}\n\nfun example(mut x: X) {\n    x.by_ref(); // resolves to a::m::by_ref(&x)\n    x.by_mut(); // resolves to a::m::by_mut(&mut x)\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In these examples, ",(0,o.jsx)(n.code,{children:"x"})," was automatically borrowed to ",(0,o.jsx)(n.code,{children:"&x"})," and ",(0,o.jsx)(n.code,{children:"&mut x"})," respectively. This will also\nwork through field access"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic struct X() has copy, drop;\npublic fun by_val(_: X) {}\npublic fun by_ref(_: &X) {}\npublic fun by_mut(_: &mut X) {}\n\npublic struct Y has drop { x: X }\n\nfun example(mut y: Y) {\n    y.x.by_ref(); // resolves to a::m::by_ref(&y.x)\n    y.x.by_mut(); // resolves to a::m::by_mut(&mut y.x)\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Note that in both examples, the local variable had to be labeled as ",(0,o.jsx)(n.a,{href:"./variables",children:(0,o.jsx)(n.code,{children:"mut"})})," to allow\nfor the ",(0,o.jsx)(n.code,{children:"&mut"})," borrow. Without this, there would be an error saying that ",(0,o.jsx)(n.code,{children:"x"})," (or ",(0,o.jsx)(n.code,{children:"y"})," in the second\nexample) is not mutable."]}),"\n",(0,o.jsx)(n.p,{children:"Keep in mind that without a reference, normal rules for variable and field access come into play.\nMeaning a value might be moved or copied if it is not borrowed."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module a::m;\n\npublic struct X() has copy, drop;\npublic fun by_val(_: X) {}\npublic fun by_ref(_: &X) {}\npublic fun by_mut(_: &mut X) {}\n\npublic struct Y has drop { x: X }\npublic fun drop_y(y: Y) { y }\n\nfun example(y: Y) {\n    y.x.by_val(); // copies `y.x` since `by_val` is by-value and `X` has `copy`\n    y.drop_y(); // moves `y` since `drop_y` is by-value and `Y` does _not_ have `copy`\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"chaining",children:"Chaining"}),"\n",(0,o.jsx)(n.p,{children:"Method calls can be chained, because any expression can be the receiver of the method."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module a::shapes {\n    public struct Point has copy, drop, store { x: u64, y: u64 }\n    public struct Line has copy, drop, store { start: Point, end: Point }\n\n    public fun x(p: &Point): u64 { p.x }\n    public fun y(p: &Point): u64 { p.y }\n\n    public fun start(l: &Line): &Point { &l.start }\n    public fun end(l: &Line): &Point { &l.end }\n\n}\n\nmodule b::example {\n    use a::shapes::Line;\n\n    public fun x_values(l: Line): (u64, u64) {\n        (l.start().x(), l.end().x())\n    }\n\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this example for ",(0,o.jsx)(n.code,{children:"l.start().x()"}),", the compiler first resolves ",(0,o.jsx)(n.code,{children:"l.start()"})," to\n",(0,o.jsx)(n.code,{children:"a::shapes::start(&l)"}),". Then ",(0,o.jsx)(n.code,{children:".x()"})," is resolved to ",(0,o.jsx)(n.code,{children:"a::shapes::x(a::shapes::start(&l))"}),". Similarly\nfor ",(0,o.jsx)(n.code,{children:"l.end().x()"}),'. Keep in mind, this feature is not "special"--the left-hand side of the ',(0,o.jsx)(n.code,{children:"."}),' can be\nany expression, and the compiler will resolve the method call as normal. We simply draw attention to\nthis sort of "chaining" because it is a common practice to increase readability.']})]})}function d(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}}}]);