"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2803],{5521:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>i});var a=n(6672);const o={},s=a.createContext(o);function c(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),a.createElement(s.Provider,{value:t},e.children)}},5929:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>i,default:()=>l,frontMatter:()=>c,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"programmability/fast-path","title":"Fast Path","description":"Due to the object model and the data organization model of Sui, some operations can be performed in","source":"@site/../book/programmability/fast-path.md","sourceDirName":"programmability","slug":"/programmability/fast-path","permalink":"/programmability/fast-path","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{}}');var o=n(3420),s=n(5521);const c={},i="Fast Path",r={},h=[{value:"Frozen objects",id:"frozen-objects",level:2},{value:"In Practice",id:"in-practice",level:2},{value:"Special Case: Clock",id:"special-case-clock",level:2}];function u(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"fast-path",children:"Fast Path"})}),"\n",(0,o.jsxs)(t.p,{children:["Due to the object model and the data organization model of Sui, some operations can be performed in\na more efficient and parallelized way. This is called the ",(0,o.jsx)(t.strong,{children:"fast path"}),". Transaction that touches\nshared state requires consensus because it can be accessed by multiple parties at the same time.\nHowever, if the transaction only touches the private state (owned objects), there is no need for\nconsensus. This is the fast path."]}),"\n",(0,o.jsx)(t.p,{children:"We have a favorite example for this: a coffee machine and a coffee cup. The coffee machine placed in\nthe office is a shared resource - everyone can use it, but there can be only one user at a time. The\ncoffee cup, on the other hand, is a private resource - it belongs to a specific person, and only\nthat person can use it. To make coffee, one needs to use the coffee machine and wait if there's\nsomeone else using it. However, once the coffee is made and poured into the cup, the person can take\nthe cup and drink the coffee without waiting for anyone else."}),"\n",(0,o.jsx)(t.p,{children:"The same principle applies to Sui. If a transaction only touches the private state (the cup with\ncoffee), it can be executed without consensus. If it touches the shared state (the coffee machine),\nit requires consensus. This is the fast path."}),"\n",(0,o.jsx)(t.h2,{id:"frozen-objects",children:"Frozen objects"}),"\n",(0,o.jsx)(t.p,{children:'Consensus is only required for mutating the shared state. If the object is immutable, it is treated\nas a "constant" and can be accessed in parallel. Frozen objects can be used to share unchangeable\ndata between multiple parties without requiring consensus.'}),"\n",(0,o.jsx)(t.h2,{id:"in-practice",children:"In Practice"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/fast-path.move anchor=main",children:"module book::coffee_machine {\n    /// Coffee machine is a shared object, hence requires `key` ability.\n    public struct CoffeeMachine has key { id: UID, counter: u16 }\n\n    /// Cup is an owned object.\n    public struct Cup has key, store { id: UID, has_coffee: bool }\n\n    /// Initialize the module and share the `CoffeeMachine` object.\n    fun init(ctx: &mut TxContext) {\n        transfer::share_object(CoffeeMachine {\n            id: object::new(ctx),\n            counter: 0\n        });\n    }\n\n    /// Take a cup out of thin air. This is a fast path operation.\n    public fun take_cup(ctx: &mut TxContext): Cup {\n        Cup { id: object::new(ctx), has_coffee: false }\n    }\n\n    /// Make coffee and pour it into the cup. Requires consensus.\n    public fun make_coffee(machine: &mut CoffeeMachine, cup: &mut Cup) {\n        machine.counter = machine.counter + 1;\n        cup.has_coffee = true;\n    }\n\n    /// Drink coffee from the cup. This is a fast path operation.\n    public fun drink_coffee(cup: &mut Cup) {\n        cup.has_coffee = false;\n    }\n\n    /// Put the cup back. This is a fast path operation.\n    public fun put_back(cup: Cup) {\n        let Cup { id, has_coffee: _ } = cup;\n        id.delete();\n    }\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"special-case-clock",children:"Special Case: Clock"}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"Clock"})," object with the reserved address ",(0,o.jsx)(t.code,{children:"0x6"})," is a special case of a shared object which cannot\nbe passed by a mutable reference in a regular transaction. An attempt to do so will not succeed, and\nthe transaction will be rejected. Because of this limitation, the ",(0,o.jsx)(t.code,{children:"Clock"})," object can only be\naccessed immutably, which allows executing transactions in parallel without consensus."]})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}}}]);