"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2638],{5521:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>l});var o=n(6672);const t={},r=o.createContext(t);function i(e){const s=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),o.createElement(r.Provider,{value:s},e.children)}},7828:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"move-basics/expression","title":"Expression","description":"In programming languages, an expression is a unit of code that returns a value. In Move, almost","source":"@site/../book/move-basics/expression.md","sourceDirName":"move-basics","slug":"/move-basics/expression","permalink":"/move-basics/expression","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.4. Address Type","permalink":"/move-basics/address"},"next":{"title":"5.6. Structs","permalink":"/move-basics/struct"}}');var t=n(3420),r=n(5521);const i={},l="Expression",a={},c=[{value:"Literals",id:"literals",level:2},{value:"Operators",id:"operators",level:2},{value:"Blocks",id:"blocks",level:2},{value:"Function Calls",id:"function-calls",level:2},{value:"Control Flow Expressions",id:"control-flow-expressions",level:2}];function d(e){const s={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"expression",children:"Expression"})}),"\n",(0,t.jsxs)(s.p,{children:["In programming languages, an expression is a unit of code that returns a value. In Move, almost\neverything is an expression, with the sole exception of the ",(0,t.jsx)(s.code,{children:"let"})," statement, which is a declaration.\nIn this section, we cover the types of expressions and introduce the concept of scope."]}),"\n",(0,t.jsxs)(s.blockquote,{children:["\n",(0,t.jsxs)(s.p,{children:["Expressions are sequenced with semicolons ",(0,t.jsx)(s.code,{children:";"}),'. If there\'s "no expression" after the semicolon, the\ncompiler will insert a ',(0,t.jsx)(s.code,{children:"unit ()"}),", which represents an empty expression."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"literals",children:"Literals"}),"\n",(0,t.jsxs)(s.p,{children:["In the ",(0,t.jsx)(s.a,{href:"./primitive-types",children:"Primitive types"})," section, we introduced the basic types of Move. And to\nillustrate them, we used literals. A literal is a notation for representing a fixed value in source\ncode. Literals can be used to initialize variables or directly pass fixed values as arguments to\nfunctions. Move has the following literals:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Boolean values: ",(0,t.jsx)(s.code,{children:"true"})," and ",(0,t.jsx)(s.code,{children:"false"})]}),"\n",(0,t.jsxs)(s.li,{children:["Integer values: ",(0,t.jsx)(s.code,{children:"0"}),", ",(0,t.jsx)(s.code,{children:"1"}),", ",(0,t.jsx)(s.code,{children:"123123"})]}),"\n",(0,t.jsxs)(s.li,{children:["Hexadecimal values: Numbers prefixed with 0x to represent integers, such as ",(0,t.jsx)(s.code,{children:"0x0"}),", ",(0,t.jsx)(s.code,{children:"0x1"}),", ",(0,t.jsx)(s.code,{children:"0x123"})]}),"\n",(0,t.jsxs)(s.li,{children:["Byte vector values: Prefixed with ",(0,t.jsx)(s.code,{children:"b"}),", such as ",(0,t.jsx)(s.code,{children:'b"bytes_vector"'})]}),"\n",(0,t.jsxs)(s.li,{children:["Byte values: Hexadecimal literals prefixed with ",(0,t.jsx)(s.code,{children:"x"}),", such as ",(0,t.jsx)(s.code,{children:'x"0A"'})]}),"\n"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/expression.move anchor=literals",children:'let b = true;     // true is a literal\nlet n = 1000;     // 1000 is a literal\nlet h = 0x0A;     // 0x0A is a literal\nlet v = b"hello"; // b"hello" is a byte vector literal\nlet x = x"0A";    // x"0A" is a byte vector literal\nlet c = vector[1, 2, 3]; // vector[] is a vector literal\n'})}),"\n",(0,t.jsx)(s.h2,{id:"operators",children:"Operators"}),"\n",(0,t.jsx)(s.p,{children:"Arithmetic, logical, and bitwise operators are used to perform operations on values. Since these\noperations produce values, they are considered expressions."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/expression.move anchor=operators",children:"let sum = 1 + 2;   // 1 + 2 is an expression\nlet sum = (1 + 2); // the same expression with parentheses\nlet is_true = true && false; // true && false is an expression\nlet is_true = (true && false); // the same expression with parentheses\n"})}),"\n",(0,t.jsx)(s.h2,{id:"blocks",children:"Blocks"}),"\n",(0,t.jsxs)(s.p,{children:["A block is a sequence of statements and expressions enclosed in curly braces ",(0,t.jsx)(s.code,{children:"{}"}),". It returns the\nvalue of the last expression in the block (note that this final expression must not have an ending\nsemicolon). A block is an expression, so it can be used anywhere an expression is expected."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/expression.move anchor=block",children:"// block with an empty expression, however, the compiler will\n// insert an empty expression automatically: `let none = { () }`\n// let none = {};\n\n// block with let statements and an expression.\nlet sum = {\n    let a = 1;\n    let b = 2;\n    a + b // last expression is the value of the block\n};\n\n// block is an expression, so it can be used in an expression and\n// doesn't have to be assigned to a variable.\n{\n    let a = 1;\n    let b = 2;\n    a + b; // not returned - semicolon.\n    // compiler automatically inserts an empty expression `()`\n};\n"})}),"\n",(0,t.jsx)(s.h2,{id:"function-calls",children:"Function Calls"}),"\n",(0,t.jsxs)(s.p,{children:["We go into detail about functions in the ",(0,t.jsx)(s.a,{href:"./function",children:"Functions"})," section. However, we have already\nused function calls in previous sections, so it's worth mentioning them here. A function call is an\nexpression that calls a function and returns the value of the last expression in the function body,\nprovided the last expression does not have a terminating semi-colon."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/expression.move anchor=fun_call",children:"fun add(a: u8, b: u8): u8 {\n    a + b\n}\n\n#[test]\nfun some_other() {\n    let sum = add(1, 2); // not returned due to the semicolon.\n    // compiler automatically inserts an empty expression `()` as return value of the block\n}\n"})}),"\n",(0,t.jsx)(s.h2,{id:"control-flow-expressions",children:"Control Flow Expressions"}),"\n",(0,t.jsxs)(s.p,{children:["Control flow expressions are used to control the flow of the program. They are also expressions, so\nthey return a value. We cover control flow expressions in the ",(0,t.jsx)(s.a,{href:"./control-flow",children:"Control Flow"}),"\nsection. Here's a very brief overview:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/expression.move anchor=control_flow",children:"// if is an expression, so it returns a value; if there are 2 branches,\n// the types of the branches must match.\nif (bool_expr) expr1 else expr2;\n\n// while is an expression, but it returns `()`.\nwhile (bool_expr) { expr; };\n\n// loop is an expression, but returns `()` as well.\nloop { expr; break };\n"})})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);