"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[977],{5521:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var o=i(6672);const s={},t=o.createContext(s);function r(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(t.Provider,{value:n},e.children)}},9638:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"functions","title":"Functions | Reference","description":"","source":"@site/../reference/functions.md","sourceDirName":".","slug":"/functions","permalink":"/reference/functions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Functions | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"6.4 Pattern Matching","permalink":"/reference/control-flow/pattern-matching"},"next":{"title":"7.1 Macros","permalink":"/reference/functions/macros"}}');var s=i(3420),t=i(5521);const r={title:"Functions | Reference",description:""},l="Functions",c={},a=[{value:"Declaration",id:"declaration",level:2},{value:"Visibility",id:"visibility",level:3},{value:"<code>public</code> visibility",id:"public-visibility",level:4},{value:"<code>public(package)</code> visibility",id:"publicpackage-visibility",level:4},{value:"DEPRECATED <code>public(friend)</code> visibility",id:"deprecated-publicfriend-visibility",level:4},{value:"<code>entry</code> modifier",id:"entry-modifier",level:3},{value:"<code>macro</code> modifier",id:"macro-modifier",level:3},{value:"Name",id:"name",level:3},{value:"Type Parameters",id:"type-parameters",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Return type",id:"return-type",level:3},{value:"Function body",id:"function-body",level:3},{value:"Native Functions",id:"native-functions",level:3},{value:"Calling",id:"calling",level:2},{value:"Returning values",id:"returning-values",level:2},{value:"<code>return</code> expression",id:"return-expression",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"functions",children:"Functions"})}),"\n",(0,s.jsx)(n.p,{children:"Functions are declared inside of modules and define the logic and behavior of the module. Functions\ncan be reused, either being called from other functions or as entry points for execution."}),"\n",(0,s.jsx)(n.h2,{id:"declaration",children:"Declaration"}),"\n",(0,s.jsxs)(n.p,{children:["Functions are declared with the ",(0,s.jsx)(n.code,{children:"fun"})," keyword followed by the function name, type parameters,\nparameters, a return type, and finally the function body."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"<visibility>? <entry>? <macro>? fun <identifier><[type_parameters: constraint],*>([identifier: type],*): <return_type> <function_body>\n"})}),"\n",(0,s.jsx)(n.p,{children:"For example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun foo<T1, T2>(x: u64, y: T1, z: T2): (T2, T1, u64) { (z, y, x) }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"visibility",children:"Visibility"}),"\n",(0,s.jsx)(n.p,{children:"Module functions, by default, can only be called within the same module. These internal (sometimes\ncalled private) functions cannot be called from other modules or as entry points."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module a::m {\n    fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid\n}\n\nmodule b::other {\n    fun calls_m_foo(): u64 {\n        a::m::foo() // ERROR!\n//      ^^^^^^^^^^^ 'foo' is internal to 'a::m'\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To allow access from other modules, the function must be declared ",(0,s.jsx)(n.code,{children:"public"})," or ",(0,s.jsx)(n.code,{children:"public(package)"}),".\nTangential to visibility, an ",(0,s.jsx)(n.a,{href:"#entry-modifier",children:(0,s.jsx)(n.code,{children:"entry"})})," function can be called as an entry point for\nexecution."]}),"\n",(0,s.jsxs)(n.h4,{id:"public-visibility",children:[(0,s.jsx)(n.code,{children:"public"})," visibility"]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"public"})," function can be called by ",(0,s.jsx)(n.em,{children:"any"})," function defined in ",(0,s.jsx)(n.em,{children:"any"})," module. As shown in the\nfollowing example, a ",(0,s.jsx)(n.code,{children:"public"})," function can be called by:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"other functions defined in the same module,"}),"\n",(0,s.jsx)(n.li,{children:"functions defined in another module, or"}),"\n",(0,s.jsx)(n.li,{children:"as an entry point for execution."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module a::m {\n    public fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid\n}\n\nmodule b::other {\n    fun calls_m_foo(): u64 {\n        a::m::foo() // valid\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Fore more details on the entry point to execution see ",(0,s.jsx)(n.a,{href:"#entry-modifier",children:"the section below"}),"."]}),"\n",(0,s.jsxs)(n.h4,{id:"publicpackage-visibility",children:[(0,s.jsx)(n.code,{children:"public(package)"})," visibility"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"public(package)"})," visibility modifier is a more restricted form of the ",(0,s.jsx)(n.code,{children:"public"})," modifier to give\nmore control about where a function can be used. A ",(0,s.jsx)(n.code,{children:"public(package)"})," function can be called by:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"other functions defined in the same module, or"}),"\n",(0,s.jsx)(n.li,{children:"other functions defined in the same package (the same address)"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module a::m {\n    public(package) fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid\n}\n\nmodule a::n {\n    fun calls_m_foo(): u64 {\n        a::m::foo() // valid, also in `a`\n    }\n}\n\nmodule b::other {\n    fun calls_m_foo(): u64 {\n        a::m::foo() // ERROR!\n//      ^^^^^^^^^^^ 'foo' can only be called from a module in `a`\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"deprecated-publicfriend-visibility",children:["DEPRECATED ",(0,s.jsx)(n.code,{children:"public(friend)"})," visibility"]}),"\n",(0,s.jsxs)(n.p,{children:["Before the addition of ",(0,s.jsx)(n.code,{children:"public(package)"}),", ",(0,s.jsx)(n.code,{children:"public(friend)"})," was used to allow limited public access\nto functions in the same package, but where the list of allowed modules had to be explicitly\nenumerated by the callee's module. see ",(0,s.jsx)(n.a,{href:"./friends",children:"Friends"})," for more details."]}),"\n",(0,s.jsxs)(n.h3,{id:"entry-modifier",children:[(0,s.jsx)(n.code,{children:"entry"})," modifier"]}),"\n",(0,s.jsxs)(n.p,{children:["In addition to ",(0,s.jsx)(n.code,{children:"public"})," functions, you might have some functions in your modules that you want to\nuse as the entry point to execution. The ",(0,s.jsx)(n.code,{children:"entry"})," modifier is designed to allow module functions to\ninitiate execution, without having to expose the functionality to other modules."]}),"\n",(0,s.jsxs)(n.p,{children:["Essentially, the combination of ",(0,s.jsx)(n.code,{children:"public"})," and ",(0,s.jsx)(n.code,{children:"entry"}),' functions define the "main" functions of a\nmodule, and they specify where Move programs can start executing.']}),"\n",(0,s.jsxs)(n.p,{children:["Keep in mind though, an ",(0,s.jsx)(n.code,{children:"entry"})," function ",(0,s.jsx)(n.em,{children:"can"})," still be called by other Move functions. So while\nthey ",(0,s.jsx)(n.em,{children:"can"})," serve as the start of a Move program, they aren't restricted to that case."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module a::m {\n    entry fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid!\n}\n\nmodule a::n {\n    fun calls_m_foo(): u64 {\n        a::m::foo() // ERROR!\n//      ^^^^^^^^^^^ 'foo' is internal to 'a::m'\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"entry"})," functions may have restrictions on their parameters and return types. Although, these\nrestrictions are specific to each individual deployment of Move."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.a,{href:"https://docs.sui.io/concepts/sui-move-concepts/entry-functions",children:["The documentation for ",(0,s.jsx)(n.code,{children:"entry"})," functions on Sui can be found here."]}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["To enable easier testing, ",(0,s.jsx)(n.code,{children:"entry"})," functions can be called from\n",(0,s.jsxs)(n.a,{href:"./unit-testing",children:[(0,s.jsx)(n.code,{children:"#[test]"})," and ",(0,s.jsx)(n.code,{children:"#[test_only]"})]})," contexts."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module a::m {\n    entry fun foo(): u64 { 0 }\n}\nmodule a::m_test {\n    #[test]\n    fun my_test(): u64 { a::m::foo() } // valid!\n    #[test_only]\n    fun my_test_helper(): u64 { a::m::foo() } // valid!\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"macro-modifier",children:[(0,s.jsx)(n.code,{children:"macro"})," modifier"]}),"\n",(0,s.jsxs)(n.p,{children:["Unlike normal functions, ",(0,s.jsx)(n.code,{children:"macro"})," functions do not exist at runtime. Instead, these functions are\nsubstituted inline at each call site during compilation. These ",(0,s.jsx)(n.code,{children:"macro"})," functions leverage this\ncompilation process to provide functionality beyond standard functions, such as accepting\nhigher-order ",(0,s.jsx)(n.em,{children:"lambda"}),"-style functions as arguments. These lambda arguments, also expanded during\ncompilation, allow you to pass parts of the function body to the macro as arguments. For instance,\nconsider the following simple loop macro, where the loop body is supplied as a lambda:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"macro fun n_times($n: u64, $body: |u64| -> ()) {\n    let n = $n;\n    let mut i = 0;\n    while (i < n) {\n        $body(i);\n        i = i + 1;\n    }\n}\n\nfun example() {\n    let mut sum = 0;\n    n_times!(10, |x| sum = sum + x );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["See the chapter on ",(0,s.jsx)(n.a,{href:"./functions/macros",children:"macros"})," for more information."]}),"\n",(0,s.jsx)(n.h3,{id:"name",children:"Name"}),"\n",(0,s.jsxs)(n.p,{children:["Function names can start with letters ",(0,s.jsx)(n.code,{children:"a"})," to ",(0,s.jsx)(n.code,{children:"z"}),". After the first character, function names can\ncontain underscores ",(0,s.jsx)(n.code,{children:"_"}),", letters ",(0,s.jsx)(n.code,{children:"a"})," to ",(0,s.jsx)(n.code,{children:"z"}),", letters ",(0,s.jsx)(n.code,{children:"A"})," to ",(0,s.jsx)(n.code,{children:"Z"}),", or digits ",(0,s.jsx)(n.code,{children:"0"})," to ",(0,s.jsx)(n.code,{children:"9"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun fOO() {}\nfun bar_42() {}\nfun bAZ_19() {}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"type-parameters",children:"Type Parameters"}),"\n",(0,s.jsx)(n.p,{children:"After the name, functions can have type parameters"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun id<T>(x: T): T { x }\nfun example<T1: copy, T2>(x: T1, y: T2): (T1, T1, T2) { (copy x, x, y) }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For more details, see ",(0,s.jsx)(n.a,{href:"./generics",children:"Move generics"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsx)(n.p,{children:"Functions parameters are declared with a local variable name followed by a type annotation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun add(x: u64, y: u64): u64 { x + y }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We read this as ",(0,s.jsx)(n.code,{children:"x"})," has type ",(0,s.jsx)(n.code,{children:"u64"})]}),"\n",(0,s.jsx)(n.p,{children:"A function does not have to have any parameters at all."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun useless() { }\n"})}),"\n",(0,s.jsx)(n.p,{children:"This is very common for functions that create new or empty data structures"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module a::example;\n\npublic struct Counter { count: u64 }\n\nfun new_counter(): Counter {\n    Counter { count: 0 }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"return-type",children:"Return type"}),"\n",(0,s.jsx)(n.p,{children:"After the parameters, a function specifies its return type."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun zero(): u64 { 0 }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here ",(0,s.jsx)(n.code,{children:": u64"})," indicates that the function's return type is ",(0,s.jsx)(n.code,{children:"u64"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Using ",(0,s.jsx)(n.a,{href:"./primitive-types/tuples",children:"tuples"}),", a function can return multiple values:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun one_two_three(): (u64, u64, u64) { (0, 1, 2) }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If no return type is specified, the function has an implicit return type of unit ",(0,s.jsx)(n.code,{children:"()"}),". These\nfunctions are equivalent:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun just_unit(): () { () }\nfun just_unit() { () }\nfun just_unit() { }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As mentioned in the ",(0,s.jsx)(n.a,{href:"./primitive-types/tuples",children:"tuples section"}),', these tuple "values" do not exist as\nruntime values. This means that a function that returns unit ',(0,s.jsx)(n.code,{children:"()"})," does not return any value during\nexecution."]}),"\n",(0,s.jsx)(n.h3,{id:"function-body",children:"Function body"}),"\n",(0,s.jsx)(n.p,{children:"A function's body is an expression block. The return value of the function is the last value in the\nsequence"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun example(): u64 {\n    let mut x = 0;\n    x = x + 1;\n    x // returns 'x'\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"#returning-values",children:"the section below for more information on returns"})]}),"\n",(0,s.jsxs)(n.p,{children:["For more information on expression blocks, see ",(0,s.jsx)(n.a,{href:"./variables",children:"Move variables"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"native-functions",children:"Native Functions"}),"\n",(0,s.jsxs)(n.p,{children:["Some functions do not have a body specified, and instead have the body provided by the VM. These\nfunctions are marked ",(0,s.jsx)(n.code,{children:"native"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Without modifying the VM source code, a programmer cannot add new native functions. Furthermore, it\nis the intent that ",(0,s.jsx)(n.code,{children:"native"})," functions are used for either standard library code or for functionality\nneeded for the given Move environment."]}),"\n",(0,s.jsxs)(n.p,{children:["Most ",(0,s.jsx)(n.code,{children:"native"})," functions you will likely see are in standard library code, such as ",(0,s.jsx)(n.code,{children:"vector"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module std::vector {\n    native public fun length<Element>(v: &vector<Element>): u64;\n    ...\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"calling",children:"Calling"}),"\n",(0,s.jsx)(n.p,{children:"When calling a function, the name can be specified either through an alias or fully qualified"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module a::example {\n    public fun zero(): u64 { 0 }\n}\n\nmodule b::other {\n    use a::example::{Self, zero};\n    fun call_zero() {\n        // With the `use` above all of these calls are equivalent\n        a::example::zero();\n        example::zero();\n        zero();\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"When calling a function, an argument must be given for every parameter."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module a::example {\n    public fun takes_none(): u64 { 0 }\n    public fun takes_one(x: u64): u64 { x }\n    public fun takes_two(x: u64, y: u64): u64 { x + y }\n    public fun takes_three(x: u64, y: u64, z: u64): u64 { x + y + z }\n}\n\nmodule b::other {\n    fun call_all() {\n        a::example::takes_none();\n        a::example::takes_one(0);\n        a::example::takes_two(0, 1);\n        a::example::takes_three(0, 1, 2);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Type arguments can be either specified or inferred. Both calls are equivalent."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module a::example {\n    public fun id<T>(x: T): T { x }\n}\n\nmodule b::other {\n    fun call_all() {\n        a::example::id(0);\n        a::example::id<u64>(0);\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For more details, see ",(0,s.jsx)(n.a,{href:"./generics",children:"Move generics"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"returning-values",children:"Returning values"}),"\n",(0,s.jsx)(n.p,{children:'The result of a function, its "return value", is the final value of its function body. For example'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun add(x: u64, y: u64): u64 {\n    x + y\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The return value here is the result of ",(0,s.jsx)(n.code,{children:"x + y"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"#function-body",children:"As mentioned above"}),", the function's body is an ",(0,s.jsx)(n.a,{href:"./variables",children:"expression block"}),". The\nexpression block can sequence various statements, and the final expression in the block will be\nthe value of that block"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun double_and_add(x: u64, y: u64): u64 {\n    let double_x = x * 2;\n    let double_y = y * 2;\n    double_x + double_y\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The return value here is the result of ",(0,s.jsx)(n.code,{children:"double_x + double_y"})]}),"\n",(0,s.jsxs)(n.h3,{id:"return-expression",children:[(0,s.jsx)(n.code,{children:"return"})," expression"]}),"\n",(0,s.jsxs)(n.p,{children:["A function implicitly returns the value that its body evaluates to. However, functions can also use\nthe explicit ",(0,s.jsx)(n.code,{children:"return"})," expression:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun f1(): u64 { return 0 }\nfun f2(): u64 { 0 }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["These two functions are equivalent. In this slightly more involved example, the function subtracts\ntwo ",(0,s.jsx)(n.code,{children:"u64"})," values, but returns early with ",(0,s.jsx)(n.code,{children:"0"})," if the second value is too large:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun safe_sub(x: u64, y: u64): u64 {\n    if (y > x) return 0;\n    x - y\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that the body of this function could also have been written as ",(0,s.jsx)(n.code,{children:"if (y > x) 0 else x - y"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["However ",(0,s.jsx)(n.code,{children:"return"})," really shines is in exiting deep within other control flow constructs. In this\nexample, the function iterates through a vector to find the index of a given value:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"use std::vector;\nuse std::option::{Self, Option};\n\nfun index_of<T>(v: &vector<T>, target: &T): Option<u64> {\n    let mut i = 0;\n    let n = vector::length(v);\n    while (i < n) {\n        if (vector::borrow(v, i) == target) return option::some(i);\n        i = i + 1\n    };\n\n    option::none()\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Using ",(0,s.jsx)(n.code,{children:"return"})," without an argument is shorthand for ",(0,s.jsx)(n.code,{children:"return ()"}),". That is, the following two\nfunctions are equivalent:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun foo() { return }\nfun foo() { return () }\n"})})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);