"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[376],{5521:(e,i,n)=>{n.d(i,{R:()=>c,x:()=>o});var t=n(6672);const a={},s=t.createContext(a);function c(e){const i=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),t.createElement(s.Provider,{value:i},e.children)}},8122:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>r,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"programmability/dynamic-object-fields","title":"Dynamic Object Fields","description":"This section expands on the Dynamic Fields. Please, read it first to","source":"@site/../book/programmability/dynamic-object-fields.md","sourceDirName":"programmability","slug":"/programmability/dynamic-object-fields","permalink":"/programmability/dynamic-object-fields","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"8.7. Dynamic Fields","permalink":"/programmability/dynamic-fields"},"next":{"title":"8.9. Dynamic Collections","permalink":"/programmability/dynamic-collections"}}');var a=n(3420),s=n(5521);const c={},o="Dynamic Object Fields",r={},d=[{value:"Definition",id:"definition",level:2},{value:"Usage &amp; Differences with Dynamic Fields",id:"usage--differences-with-dynamic-fields",level:2},{value:"Pricing Differences",id:"pricing-differences",level:2},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const i={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"dynamic-object-fields",children:"Dynamic Object Fields"})}),"\n",(0,a.jsxs)(i.blockquote,{children:["\n",(0,a.jsxs)(i.p,{children:["This section expands on the ",(0,a.jsx)(i.a,{href:"./dynamic-fields",children:"Dynamic Fields"}),". Please, read it first to\nunderstand the basics of dynamic fields."]}),"\n"]}),"\n",(0,a.jsxs)(i.p,{children:["Another variation of dynamic fields is ",(0,a.jsx)(i.em,{children:"dynamic object fields"}),", which have certain differences from\nregular dynamic fields. In this section, we will cover the specifics of dynamic object fields and\nexplain how they differ from regular dynamic fields."]}),"\n",(0,a.jsxs)(i.blockquote,{children:["\n",(0,a.jsx)(i.p,{children:"General recommendation is to avoid using dynamic object fields in favor of (just) dynamic fields,\nespecially if there's no need for direct discovery through the ID. The extra costs of dynamic\nobject fields may not be justified by the benefits they provide."}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"definition",children:"Definition"}),"\n",(0,a.jsxs)(i.p,{children:["Dynamic Object Fields are defined in the ",(0,a.jsx)(i.code,{children:"sui::dynamic_object_fields"})," module in the\n",(0,a.jsx)(i.a,{href:"./sui-framework",children:"Sui Framework"}),". They are similar to dynamic fields in many ways, but unlike them,\ndynamic object fields have an extra constraint on the ",(0,a.jsx)(i.code,{children:"Value"})," type. The ",(0,a.jsx)(i.code,{children:"Value"})," must have a\ncombination of ",(0,a.jsx)(i.code,{children:"key"})," and ",(0,a.jsx)(i.code,{children:"store"}),", not just ",(0,a.jsx)(i.code,{children:"store"})," as in the case of dynamic fields."]}),"\n",(0,a.jsx)(i.p,{children:"They're less explicit in their framework definition, as the concept itself is more abstract:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-move",children:"module sui::dynamic_object_field;\n\n/// Internal object used for storing the field and the name associated with the\n/// value. The separate type is necessary to prevent key collision with direct\n/// usage of dynamic_field\npublic struct Wrapper<Name> has copy, drop, store {\n    name: Name,\n}\n"})}),"\n",(0,a.jsxs)(i.p,{children:["Unlike ",(0,a.jsx)(i.code,{children:"Field"})," type in the ",(0,a.jsx)(i.a,{href:"./dynamic-fields#definition",children:"Dynamic Fields"})," section, the ",(0,a.jsx)(i.code,{children:"Wrapper"})," type\nonly stores the name of the field. The value is the object itself, and is ",(0,a.jsx)(i.em,{children:"not wrapped"}),"."]}),"\n",(0,a.jsxs)(i.p,{children:["The constraints on the ",(0,a.jsx)(i.code,{children:"Value"})," type become visible in the methods available for dynamic object\nfields. Here's the signature for the ",(0,a.jsx)(i.code,{children:"add"})," function:"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-move",children:"/// Adds a dynamic object field to the object `object: &mut UID` at field\n/// specified by `name: Name`. Aborts with `EFieldAlreadyExists` if the object\n/// already has that field with that name.\npublic fun add<Name: copy + drop + store, Value: key + store>(\n    // we use &mut UID in several spots for access control\n    object: &mut UID,\n    name: Name,\n    value: Value,\n) { /* implementation omitted */ }\n"})}),"\n",(0,a.jsxs)(i.p,{children:["The rest of the methods which are identical to the ones in the\n",(0,a.jsx)(i.a,{href:"./dynamic-fields#usage",children:"Dynamic Fields"})," section have the same constraints on the ",(0,a.jsx)(i.code,{children:"Value"})," type.\nLet's list them for reference:"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"add"})," - adds a dynamic object field to the object"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"remove"})," - removes a dynamic object field from the object"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"borrow"})," - borrows a dynamic object field from the object"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"borrow_mut"})," - borrows a mutable reference to a dynamic object field from the object"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"exists_"})," - checks if a dynamic object field exists"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"exists_with_type"})," - checks if a dynamic object field exists with a specific type"]}),"\n"]}),"\n",(0,a.jsxs)(i.p,{children:["Additionally, there is an ",(0,a.jsx)(i.code,{children:"id"})," method which returns the ",(0,a.jsx)(i.code,{children:"ID"})," of the ",(0,a.jsx)(i.code,{children:"Value"})," object without\nspecifying its type."]}),"\n",(0,a.jsx)(i.h2,{id:"usage--differences-with-dynamic-fields",children:"Usage & Differences with Dynamic Fields"}),"\n",(0,a.jsxs)(i.p,{children:["The main difference between dynamic fields and dynamic object fields is that the latter allows\nstoring ",(0,a.jsx)(i.em,{children:"only objects"})," as values. This means that you can't store primitive types like ",(0,a.jsx)(i.code,{children:"u64"})," or\n",(0,a.jsx)(i.code,{children:"bool"}),". It may be considered a limitation, if not for the fact that dynamic object fields are ",(0,a.jsx)(i.em,{children:"not\nwrapped"})," into a separate object."]}),"\n",(0,a.jsxs)(i.blockquote,{children:["\n",(0,a.jsx)(i.p,{children:"The relaxed requirement for wrapping keeps the object available for off-chain discovery via its\nID. However, this property may not be outstanding if wrapped object indexing is implemented,\nmaking the dynamic object fields a redundant feature."}),"\n"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/dynamic-object-fields.move anchor=usage",children:'module book::dynamic_object_field;\n\nuse std::string::String;\n\n// there are two common aliases for the long module name: `dof` and\n// `ofield`. Both are commonly used and met in different projects.\nuse sui::dynamic_object_field as dof;\nuse sui::dynamic_field as df;\n\n/// The `Character` that we will use for the example\npublic struct Character has key { id: UID }\n\n/// Metadata that doesn\'t have the `key` ability\npublic struct Metadata has store, drop { name: String }\n\n/// Accessory that has the `key` and `store` abilities.\npublic struct Accessory has key, store { id: UID }\n\n#[test]\nfun equip_accessory() {\n    let ctx = &mut tx_context::dummy();\n    let mut character = Character { id: object::new(ctx) };\n\n    // Create an accessory and attach it to the character\n    let hat = Accessory { id: object::new(ctx) };\n\n    // Add the hat to the character. Just like with `dynamic_fields`\n    dof::add(&mut character.id, b"hat_key", hat);\n\n    // However for non-key structs we can only use `dynamic_field`\n    df::add(&mut character.id, b"metadata_key", Metadata {\n        name: b"John".to_string()\n    });\n\n    // Borrow the hat from the character\n    let hat_id = dof::id(&character.id, b"hat_key").extract(); // Option<ID>\n    let hat_ref: &Accessory = dof::borrow(&character.id, b"hat_key");\n    let hat_mut: &mut Accessory = dof::borrow_mut(&mut character.id, b"hat_key");\n    let hat: Accessory = dof::remove(&mut character.id, b"hat_key");\n\n    // Clean up, Metadata is an orphan now.\n    sui::test_utils::destroy(hat);\n    sui::test_utils::destroy(character);\n}\n'})}),"\n",(0,a.jsx)(i.h2,{id:"pricing-differences",children:"Pricing Differences"}),"\n",(0,a.jsx)(i.p,{children:"Dynamic Object Fields come a little more expensive than dynamic fields. Because of their internal\nstructure, they require 2 objects: the Wrapper for Name and the Value. Because of this, the cost of\nadding and accessing object fields (loading 2 objects compared to 1 for dynamic fields) is higher."}),"\n",(0,a.jsx)(i.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(i.p,{children:["Both dynamic field and dynamic object fields are powerful features which allow for innovative\nsolutions in applications. However, they are relatively low-level and require careful handling to\navoid orphaned fields. In the next section, we will introduce a higher-level abstraction -\n",(0,a.jsx)(i.a,{href:"./dynamic-collections",children:"Dynamic Collections"})," - which can help with managing dynamic fields and\nobjects more effectively."]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);