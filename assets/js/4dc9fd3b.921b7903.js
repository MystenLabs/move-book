"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4786],{5083:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"your-first-move/hello-world","title":"Hello, World!","description":"In this chapter, you will learn how to create a new package, write a simple module, compile it, and","source":"@site/../book/your-first-move/hello-world.md","sourceDirName":"your-first-move","slug":"/your-first-move/hello-world","permalink":"/your-first-move/hello-world","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"1.3. Move 2024","permalink":"/before-we-begin/move-2024"},"next":{"title":"3. Hello Sui!","permalink":"/your-first-move/hello-sui"}}');var l=t(3420),o=t(5521);const i={},r="Hello, World!",a={},d=[{value:"Create a New Package",id:"create-a-new-package",level:2},{value:"Directory Structure",id:"directory-structure",level:2},{value:"Manifest",id:"manifest",level:3},{value:"Sources",id:"sources",level:3},{value:"Tests",id:"tests",level:3},{value:"Other Folders",id:"other-folders",level:3},{value:"Compiling the Package",id:"compiling-the-package",level:2},{value:"Running Tests",id:"running-tests",level:2},{value:"Next Steps",id:"next-steps",level:2},{value:"Further Reading",id:"further-reading",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"hello-world",children:"Hello, World!"})}),"\n",(0,l.jsxs)(n.p,{children:["In this chapter, you will learn how to create a new package, write a simple module, compile it, and\nrun tests with the Move CLI. Make sure you have ",(0,l.jsx)(n.a,{href:"./../before-we-begin/install-sui",children:"installed Sui"}),"\nand set up your ",(0,l.jsx)(n.a,{href:"./../before-we-begin/ide-support",children:"IDE environment"}),". Run the command below to test\nif Sui has been installed correctly."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"# It should print the client version. E.g. sui-client 1.22.0-036299745.\nsui client --version\n"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Move CLI is a command-line interface for the Move language; it is built into the Sui binary and\nprovides a set of commands to manage packages, compile and test code."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"The structure of the chapter is as follows:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#create-a-new-package",children:"Create a New Package"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#directory-structure",children:"Directory Structure"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#compiling-the-package",children:"Compiling the Package"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#running-tests",children:"Running Tests"})}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"create-a-new-package",children:"Create a New Package"}),"\n",(0,l.jsxs)(n.p,{children:["To create a new program, we will use the ",(0,l.jsx)(n.code,{children:"sui move new"})," command followed by the name of the\napplication. Our first program will be called ",(0,l.jsx)(n.code,{children:"hello_world"}),"."]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["Note: In this and other chapters, if you see code blocks with lines starting with ",(0,l.jsx)(n.code,{children:"$"})," (dollar\nsign), it means that the following command should be run in a terminal. The sign should not be\nincluded. It's a common way of showing commands in terminal environments."]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"$ sui move new hello_world\n"})}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"sui move"})," command gives access to the Move CLI - a built-in compiler, test runner and a utility\nfor all things Move. The ",(0,l.jsx)(n.code,{children:"new"}),' command followed by the name of the package will create a new package\nin a new folder. In our case, the folder name is "hello_world".']}),"\n",(0,l.jsx)(n.p,{children:"We can view the contents of the folder to see that the package was created successfully."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"$ ls -l hello_world\nMove.toml\nsources\ntests\n"})}),"\n",(0,l.jsx)(n.h2,{id:"directory-structure",children:"Directory Structure"}),"\n",(0,l.jsx)(n.p,{children:"Move CLI will create a scaffold of the application and pre-create the directory structure and all\nnecessary files. Let's see what's inside."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-plaintext",children:"hello_world\n\u251c\u2500\u2500 Move.toml\n\u251c\u2500\u2500 sources\n\u2502   \u2514\u2500\u2500 hello_world.move\n\u2514\u2500\u2500 tests\n    \u2514\u2500\u2500 hello_world_tests.move\n"})}),"\n",(0,l.jsx)(n.h3,{id:"manifest",children:"Manifest"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"Move.toml"})," file, known as the ",(0,l.jsx)(n.a,{href:"./../concepts/manifest",children:"package manifest"}),", contains definitions\nand configuration settings for the package. It is used by the Move Compiler to manage package\nmetadata, fetch dependencies, and register named addresses. We will explain it in detail in the\n",(0,l.jsx)(n.a,{href:"./../concepts",children:"Concepts"})," chapter."]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"By default, the package features one named address - the name of the package."}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-toml",children:'[addresses]\nhello_world = "0x0"\n'})}),"\n",(0,l.jsx)(n.h3,{id:"sources",children:"Sources"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"sources/"})," directory contains the source files. Move source files have ",(0,l.jsx)(n.em,{children:".move"})," extension, and\nare typically named after the module defined in the file. For example, in our case, the file name is\n",(0,l.jsx)(n.em,{children:"hello_world.move"})," and the Move CLI has already placed commented out code inside:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"/*\n/// Module: hello_world\nmodule hello_world::hello_world;\n*/\n"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"/*"})," and ",(0,l.jsx)(n.code,{children:"*/"})," are the comment delimiters in Move. Everything in between is ignored by the\ncompiler and can be used for documentation or notes. We explain all ways to comment the code in\nthe ",(0,l.jsx)(n.a,{href:"./../move-basics/comments",children:"Basic Syntax"}),"."]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["The commented out code is a module definition, it starts with the keyword ",(0,l.jsx)(n.code,{children:"module"})," followed by a\nnamed address (or an address literal), and the module name. The module name is a unique identifier\nfor the module and has to be unique within the package. The module name is used to reference the\nmodule from other modules or transactions."]}),"\n",(0,l.jsx)(n.h3,{id:"tests",children:"Tests"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"tests/"})," directory contains package tests. The compiler excludes these files in the regular\nbuild process but uses them in ",(0,l.jsx)(n.em,{children:"test"})," and ",(0,l.jsx)(n.em,{children:"dev"})," modes. The tests are written in Move and are marked\nwith the ",(0,l.jsx)(n.code,{children:"#[test]"})," attribute. Tests can be grouped in a separate module (then it's usually called\n",(0,l.jsx)(n.em,{children:"module_name_tests.move"}),"), or inside the module they're testing."]}),"\n",(0,l.jsxs)(n.p,{children:["Modules, imports, constants and functions can be annotated with ",(0,l.jsx)(n.code,{children:"#[test_only]"}),". This attribute is\nused to exclude modules, functions or imports from the build process. This is useful when you want\nto add helpers for your tests without including them in the code that will be published on chain."]}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.em,{children:"hello_world_tests.move"})," file contains a commented out test module template:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:"/*\n#[test_only]\nmodule hello_world::hello_world_tests;\n// uncomment this line to import the module\n// use hello_world::hello_world;\n\nconst ENotImplemented: u64 = 0;\n\n#[test]\nfun test_hello_world() {\n    // pass\n}\n\n#[test, expected_failure(abort_code = hello_world::hello_world_tests::ENotImplemented)]\nfun test_hello_world_fail() {\n    abort ENotImplemented\n}\n*/\n"})}),"\n",(0,l.jsx)(n.h3,{id:"other-folders",children:"Other Folders"}),"\n",(0,l.jsxs)(n.p,{children:["Additionally, Move CLI supports the ",(0,l.jsx)(n.code,{children:"examples/"})," folder. The files there are treated similarly to the\nones placed under the ",(0,l.jsx)(n.code,{children:"tests/"})," folder - they're only built in the ",(0,l.jsx)(n.em,{children:"test"})," and ",(0,l.jsx)(n.em,{children:"dev"})," modes. They are\nto be examples of how to use the package or how to integrate it with other packages. The most\npopular use case is for documentation purposes and library packages."]}),"\n",(0,l.jsx)(n.h2,{id:"compiling-the-package",children:"Compiling the Package"}),"\n",(0,l.jsx)(n.p,{children:"Move is a compiled language, and as such, it requires the compilation of source files into Move\nBytecode. It contains only necessary information about the module, its members, and types, and\nexcludes comments and some identifiers (for example, for constants)."}),"\n",(0,l.jsxs)(n.p,{children:["To demonstrate these features, let's replace the contents of the ",(0,l.jsx)(n.em,{children:"sources/hello_world.move"})," file\nwith the following:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:'/// The module `hello_world` under named address `hello_world`.\n/// The named address is set in the `Move.toml`.\nmodule hello_world::hello_world;\n\n// Imports the `String` type from the Standard Library\nuse std::string::String;\n\n/// Returns the "Hello, World!" as a `String`.\npublic fun hello_world(): String {\n    b"Hello, World!".to_string()\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["During compilation, the code is built, but not run. A compiled package only includes functions that\ncan be called by other modules or in a transaction. We will explain these concepts in the\n",(0,l.jsx)(n.a,{href:"./../concepts",children:"Concepts"})," chapter. But now, let's see what happens when we run the ",(0,l.jsx)(n.em,{children:"sui move build"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"# run from the `hello_world` folder\n$ sui move build\n\n# alternatively, if you didn't `cd` into it\n$ sui move build --path hello_world\n"})}),"\n",(0,l.jsx)(n.p,{children:"It should output the following message on your console."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-plaintext",children:"UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Bridge\nINCLUDING DEPENDENCY DeepBook\nINCLUDING DEPENDENCY SuiSystem\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING hello_world\n"})}),"\n",(0,l.jsx)(n.p,{children:"During the compilation, Move Compiler automatically creates a build folder where it places all\nfetched and compiled dependencies as well as the bytecode for the modules of the current package."}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["If you're using a versioning system, such as Git, build folder should be ignored. For example, you\nshould use a ",(0,l.jsx)(n.code,{children:".gitignore"})," file and add ",(0,l.jsx)(n.code,{children:"build"})," to it."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"running-tests",children:"Running Tests"}),"\n",(0,l.jsxs)(n.p,{children:["Before we get to testing, we should add a test. Move Compiler supports tests written in Move and\nprovides the execution environment. The tests can be placed in both the source files and in the\n",(0,l.jsx)(n.code,{children:"tests/"})," folder. Tests are marked with the ",(0,l.jsx)(n.code,{children:"#[test]"})," attribute and are automatically discovered by\nthe compiler. We explain tests in depth in the ",(0,l.jsx)(n.a,{href:"./../move-basics/testing",children:"Testing"})," section."]}),"\n",(0,l.jsxs)(n.p,{children:["Replace the contents of the ",(0,l.jsx)(n.code,{children:"tests/hello_world_tests.move"})," with the following content:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-move",children:'#[test_only]\nmodule hello_world::hello_world_tests;\n\nuse hello_world::hello_world;\n\n#[test]\nfun test_hello_world() {\n    assert!(hello_world::hello_world() == b"Hello, World!".to_string(), 0);\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Here we import the ",(0,l.jsx)(n.code,{children:"hello_world"})," module, and call its ",(0,l.jsx)(n.code,{children:"hello_world"}),' function to test that the output\nis indeed the string "Hello, World!". Now, that we have tests in place, let\'s compile the package in\nthe test mode and run tests. Move CLI has the ',(0,l.jsx)(n.code,{children:"test"})," command for this:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"$ sui move test\n"})}),"\n",(0,l.jsx)(n.p,{children:"The output should be similar to the following:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-plaintext",children:"INCLUDING DEPENDENCY Bridge\nINCLUDING DEPENDENCY DeepBook\nINCLUDING DEPENDENCY SuiSystem\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING hello_world\nRunning Move unit tests\n[ PASS    ] 0x0::hello_world_tests::test_hello_world\nTest result: OK. Total tests: 1; passed: 1; failed: 0\n"})}),"\n",(0,l.jsx)(n.p,{children:"If you're running the tests outside of the package folder, you can specify the path to the package:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"$ sui move test --path hello_world\n"})}),"\n",(0,l.jsx)(n.p,{children:"You can also run a single or multiple tests at once by specifying a string. All the tests names\ncontaining the string will be run:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"$ sui move test test_hello\n"})}),"\n",(0,l.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,l.jsxs)(n.p,{children:["In this section, we explained the basics of a Move package: its structure, the manifest, the build,\nand test flows. ",(0,l.jsx)(n.a,{href:"./hello-sui",children:"On the next page"}),", we will write an application and see how the code\nis structured and what the language can do."]}),"\n",(0,l.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"./../concepts/manifest",children:"Package Manifest"})," section"]}),"\n",(0,l.jsxs)(n.li,{children:["Package in ",(0,l.jsx)(n.a,{href:"./../../reference/packages",children:"The Move Reference"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},5521:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var s=t(6672);const l={},o=s.createContext(l);function i(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);