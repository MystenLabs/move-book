"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[209],{5521:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>d});var s=r(6672);const t={},i=s.createContext(t);function c(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),s.createElement(i.Provider,{value:n},e.children)}},7466:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"primitive-types/references","title":"References | Reference","description":"","source":"@site/../reference/primitive-types/references.md","sourceDirName":"primitive-types","slug":"/primitive-types/references","permalink":"/reference/primitive-types/references","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"References | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"2.4 Vector","permalink":"/reference/primitive-types/vector"},"next":{"title":"2.6 Tuples and Unit","permalink":"/reference/primitive-types/tuples"}}');var t=r(3420),i=r(5521);const c={title:"References | Reference",description:""},d="References",o={},l=[{value:"Reference Operators",id:"reference-operators",level:2},{value:"Reading and Writing Through References",id:"reading-and-writing-through-references",level:2},{value:"<code>freeze</code> inference",id:"freeze-inference",level:2},{value:"Subtyping",id:"subtyping",level:3},{value:"Ownership",id:"ownership",level:2},{value:"References Cannot Be Stored",id:"references-cannot-be-stored",level:3}];function a(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"references",children:"References"})}),"\n",(0,t.jsxs)(n.p,{children:["Move has two types of references: immutable ",(0,t.jsx)(n.code,{children:"&"})," and mutable ",(0,t.jsx)(n.code,{children:"&mut"}),". Immutable references are read\nonly, and cannot modify the underlying value (or any of its fields). Mutable references allow for\nmodifications via a write through that reference. Move's type system enforces an ownership\ndiscipline that prevents reference errors."]}),"\n",(0,t.jsx)(n.h2,{id:"reference-operators",children:"Reference Operators"}),"\n",(0,t.jsxs)(n.p,{children:["Move provides operators for creating and extending references as well as converting a mutable\nreference to an immutable one. Here and elsewhere, we use the notation ",(0,t.jsx)(n.code,{children:"e: T"}),' for "expression ',(0,t.jsx)(n.code,{children:"e"}),"\nhas type ",(0,t.jsx)(n.code,{children:"T"}),'".']}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Syntax"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"&e"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"&T"})," where ",(0,t.jsx)(n.code,{children:"e: T"})," and ",(0,t.jsx)(n.code,{children:"T"})," is a non-reference type"]}),(0,t.jsxs)(n.td,{children:["Create an immutable reference to ",(0,t.jsx)(n.code,{children:"e"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"&mut e"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"&mut T"})," where ",(0,t.jsx)(n.code,{children:"e: T"})," and ",(0,t.jsx)(n.code,{children:"T"})," is a non-reference type"]}),(0,t.jsxs)(n.td,{children:["Create a mutable reference to ",(0,t.jsx)(n.code,{children:"e"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"&e.f"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"&T"})," where ",(0,t.jsx)(n.code,{children:"e.f: T"})]}),(0,t.jsxs)(n.td,{children:["Create an immutable reference to field ",(0,t.jsx)(n.code,{children:"f"})," of struct ",(0,t.jsx)(n.code,{children:"e"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"&mut e.f"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"&mut T"})," where ",(0,t.jsx)(n.code,{children:"e.f: T"})]}),(0,t.jsxs)(n.td,{children:["Create a mutable reference to field ",(0,t.jsx)(n.code,{children:"f"})," of struct",(0,t.jsx)(n.code,{children:"e"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"freeze(e)"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"&T"})," where ",(0,t.jsx)(n.code,{children:"e: &mut T"})]}),(0,t.jsxs)(n.td,{children:["Convert the mutable reference ",(0,t.jsx)(n.code,{children:"e"})," into an immutable reference."]})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"&e.f"})," and ",(0,t.jsx)(n.code,{children:"&mut e.f"})," operators can be used both to create a new reference into a struct or to\nextend an existing reference:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"let s = S { f: 10 };\nlet f_ref1: &u64 = &s.f; // works\nlet s_ref: &S = &s;\nlet f_ref2: &u64 = &s_ref.f // also works\n"})}),"\n",(0,t.jsx)(n.p,{children:"A reference expression with multiple fields works as long as both structs are in the same module:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"public struct A { b: B }\npublic struct B { c : u64 }\nfun f(a: &A): &u64 {\n    &a.b.c\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Finally, note that references to references are not allowed:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"let x = 7;\nlet y: &u64 = &x;\n// highlight-error\nlet z: &&u64 = &y; // ERROR! will not compile\n"})}),"\n",(0,t.jsx)(n.h2,{id:"reading-and-writing-through-references",children:"Reading and Writing Through References"}),"\n",(0,t.jsx)(n.p,{children:"Both mutable and immutable references can be read to produce a copy of the referenced value."}),"\n",(0,t.jsxs)(n.p,{children:["Only mutable references can be written. A write ",(0,t.jsx)(n.code,{children:"*x = v"})," discards the value previously stored in ",(0,t.jsx)(n.code,{children:"x"}),"\nand updates it with ",(0,t.jsx)(n.code,{children:"v"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Both operations use the C-like ",(0,t.jsx)(n.code,{children:"*"})," syntax. However, note that a read is an expression, whereas a\nwrite is a mutation that must occur on the left hand side of an equals."]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Syntax"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"*e"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"T"})," where ",(0,t.jsx)(n.code,{children:"e"})," is ",(0,t.jsx)(n.code,{children:"&T"})," or ",(0,t.jsx)(n.code,{children:"&mut T"})]}),(0,t.jsxs)(n.td,{children:["Read the value pointed to by ",(0,t.jsx)(n.code,{children:"e"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"*e1 = e2"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"()"})," where ",(0,t.jsx)(n.code,{children:"e1: &mut T"})," and ",(0,t.jsx)(n.code,{children:"e2: T"})]}),(0,t.jsxs)(n.td,{children:["Update the value in ",(0,t.jsx)(n.code,{children:"e1"})," with ",(0,t.jsx)(n.code,{children:"e2"}),"."]})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["In order for a reference to be read, the underlying type must have the\n",(0,t.jsxs)(n.a,{href:"../abilities",children:[(0,t.jsx)(n.code,{children:"copy"})," ability"]})," as reading the reference creates a new copy of the value. This rule\nprevents the copying of assets:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"fun copy_coin_via_ref_bad(c: Coin) {\n    let c_ref = &c;\n    // highlight-error\n    let counterfeit: Coin = *c_ref; // not allowed!\n    pay(c);\n    pay(counterfeit);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Dually: in order for a reference to be written to, the underlying type must have the\n",(0,t.jsxs)(n.a,{href:"../abilities",children:[(0,t.jsx)(n.code,{children:"drop"})," ability"]}),' as writing to the reference will discard (or "drop") the old value.\nThis rule prevents the destruction of resource values:']}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"fun destroy_coin_via_ref_bad(mut ten_coins: Coin, c: Coin) {\n    let ref = &mut ten_coins;\n    // highlight-error\n    *ref = c; // ERROR! not allowed--would destroy 10 coins!\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"freeze-inference",children:[(0,t.jsx)(n.code,{children:"freeze"})," inference"]}),"\n",(0,t.jsx)(n.p,{children:"A mutable reference can be used in a context where an immutable reference is expected:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"let mut x = 7;\nlet y: &u64 = &mut x;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This works because the under the hood, the compiler inserts ",(0,t.jsx)(n.code,{children:"freeze"})," instructions where they are\nneeded. Here are a few more examples of ",(0,t.jsx)(n.code,{children:"freeze"})," inference in action:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"fun takes_immut_returns_immut(x: &u64): &u64 { x }\n\n// freeze inference on return value\nfun takes_mut_returns_immut(x: &mut u64): &u64 { x }\n\nfun expression_examples() {\n    let mut x = 0;\n    let mut y = 0;\n    takes_immut_returns_immut(&x); // no inference\n    takes_immut_returns_immut(&mut x); // inferred freeze(&mut x)\n    takes_mut_returns_immut(&mut x); // no inference\n\n    assert!(&x == &mut y, 42); // inferred freeze(&mut y)\n}\n\nfun assignment_examples() {\n    let x = 0;\n    let y = 0;\n    let imm_ref: &u64 = &x;\n\n    imm_ref = &x; // no inference\n    imm_ref = &mut y; // inferred freeze(&mut y)\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"subtyping",children:"Subtyping"}),"\n",(0,t.jsxs)(n.p,{children:["With this ",(0,t.jsx)(n.code,{children:"freeze"})," inference, the Move type checker can view ",(0,t.jsx)(n.code,{children:"&mut T"})," as a subtype of ",(0,t.jsx)(n.code,{children:"&T"}),". As shown\nabove, this means that anywhere for any expression where a ",(0,t.jsx)(n.code,{children:"&T"})," value is used, a ",(0,t.jsx)(n.code,{children:"&mut T"})," value can\nalso be used. This terminology is used in error messages to concisely indicate that a ",(0,t.jsx)(n.code,{children:"&mut T"})," was\nneeded where a ",(0,t.jsx)(n.code,{children:"&T"})," was supplied. For example"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"module a::example {\n    fun read_and_assign(store: &mut u64, new_value: &u64) {\n        *store = *new_value\n    }\n\n    fun subtype_examples() {\n        let mut x: &u64 = &0;\n        let mut y: &mut u64 = &mut 1;\n\n        x = &mut 1; // valid\n        // highlight-error\n        y = &2; // ERROR! invalid!\n\n        read_and_assign(y, x); // valid\n        // highlight-error\n        read_and_assign(x, y); // ERROR! invalid!\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"will yield the following error messages"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"error:\n\n    \u250c\u2500\u2500 example.move:11:9 \u2500\u2500\u2500\n    \u2502\n 12 \u2502         y = &2; // invalid!\n    \u2502         ^ Invalid assignment to local 'y'\n    \xb7\n 12 \u2502         y = &2; // invalid!\n    \u2502             -- The type: '&{integer}'\n    \xb7\n  9 \u2502         let mut y: &mut u64 = &mut 1;\n    \u2502                    -------- Is not a subtype of: '&mut u64'\n    \u2502\n\nerror:\n\n    \u250c\u2500\u2500 example.move:14:9 \u2500\u2500\u2500\n    \u2502\n 15 \u2502         read_and_assign(x, y); // invalid!\n    \u2502         ^^^^^^^^^^^^^^^^^^^^^ Invalid call of 'a::example::read_and_assign'. Invalid argument for parameter 'store'\n    \xb7\n  8 \u2502         let mut x: &u64 = &0;\n    \u2502                    ---- The type: '&u64'\n    \xb7\n  3 \u2502     fun read_and_assign(store: &mut u64, new_value: &u64) {\n    \u2502                                -------- Is not a subtype of: '&mut u64'\n    \u2502\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The only other types that currently have subtyping are ",(0,t.jsx)(n.a,{href:"./tuples",children:"tuples"})]}),"\n",(0,t.jsx)(n.h2,{id:"ownership",children:"Ownership"}),"\n",(0,t.jsxs)(n.p,{children:["Both mutable and immutable references can always be copied and extended ",(0,t.jsx)(n.em,{children:"even if there are existing\ncopies or extensions of the same reference"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-move",children:"fun reference_copies(s: &mut S) {\n  let s_copy1 = s; // ok\n  let s_extension = &mut s.f; // also ok\n  let s_copy2 = s; // still ok\n  ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This might be surprising for programmers familiar with Rust's ownership system, which would reject\nthe code above. Move's type system is more permissive in its treatment of\n",(0,t.jsx)(n.a,{href:"./../variables#move-and-copy",children:"copies"}),", but equally strict in ensuring unique ownership of mutable\nreferences before writes."]}),"\n",(0,t.jsx)(n.h3,{id:"references-cannot-be-stored",children:"References Cannot Be Stored"}),"\n",(0,t.jsxs)(n.p,{children:["References and tuples are the ",(0,t.jsx)(n.em,{children:"only"})," types that cannot be stored as a field value of structs, which\nalso means that they cannot exist in storage or ",(0,t.jsx)(n.a,{href:"./../abilities/object",children:"objects"}),". All references\ncreated during program execution will be destroyed when a Move program terminates; they are entirely\nephemeral. This also applies to all types without the ",(0,t.jsx)(n.code,{children:"store"})," ability: any value of a non-",(0,t.jsx)(n.code,{children:"store"}),"\ntype must be destroyed before the program terminates."]}),"\n",(0,t.jsx)(n.p,{children:"This is another difference between Move and Rust, which allows references to be stored inside of\nstructs."}),"\n",(0,t.jsxs)(n.p,{children:["One could imagine a fancier, more expressive, type system that would allow references to be stored\nin structs. We could allow references inside of structs that do not have the ",(0,t.jsx)(n.code,{children:"store"}),"\n",(0,t.jsx)(n.a,{href:"./../abilities",children:"ability"}),", but the core difficulty is that Move has a fairly complex system for\ntracking static reference safety. This aspect of the type system would also have to be extended to\nsupport storing references inside of structs. In short, Move's reference safety system would have to\nexpand to support stored references, and it is something we are keeping an eye on as the language\nevolves."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}}}]);