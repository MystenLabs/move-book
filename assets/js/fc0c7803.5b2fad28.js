"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3959],{5521:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>r});var a=t(6672);const i={},s=a.createContext(i);function c(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),a.createElement(s.Provider,{value:n},e.children)}},6618:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"programmability/capability","title":"Pattern: Capability","description":"In programming, a capability is a token that gives the owner the right to perform a specific","source":"@site/../book/programmability/capability.md","sourceDirName":"programmability","slug":"/programmability/capability","permalink":"/programmability/capability","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"8.2. Module Initializer","permalink":"/programmability/module-initializer"},"next":{"title":"8.4. Epoch and Time","permalink":"/programmability/epoch-and-time"}}');var i=t(3420),s=t(5521);const c={},r="Pattern: Capability",o={},l=[{value:"Capability is an Object",id:"capability-is-an-object",level:2},{value:"Using <code>init</code> for Admin Capability",id:"using-init-for-admin-capability",level:2},{value:"Address Check vs Capability",id:"address-check-vs-capability",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"pattern-capability",children:"Pattern: Capability"})}),"\n",(0,i.jsxs)(n.p,{children:["In programming, a ",(0,i.jsx)(n.em,{children:"capability"})," is a token that gives the owner the right to perform a specific\naction. It is a pattern that is used to control access to resources and operations. A simple example\nof a capability is a key to a door. If you have the key, you can open the door. If you don't have\nthe key, you can't open the door. A more practical example is an Admin Capability which allows the\nowner to perform administrative operations, which regular users cannot."]}),"\n",(0,i.jsx)(n.h2,{id:"capability-is-an-object",children:"Capability is an Object"}),"\n",(0,i.jsxs)(n.p,{children:["In the ",(0,i.jsx)(n.a,{href:"./../object/",children:"Sui Object Model"}),", capabilities are represented as objects. An owner of an\nobject can pass this object to a function to prove that they have the right to perform a specific\naction. Due to strict typing, the function taking a capability as an argument can only be called\nwith the correct capability."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["There's a convention to name capabilities with the ",(0,i.jsx)(n.code,{children:"Cap"})," suffix, for example, ",(0,i.jsx)(n.code,{children:"AdminCap"})," or\n",(0,i.jsx)(n.code,{children:"KioskOwnerCap"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/capability.move anchor=main",children:"module book::capability;\n\nuse std::string::String;\nuse sui::event;\n\n/// The capability granting the application admin the right to create new\n/// accounts in the system.\npublic struct AdminCap has key, store { id: UID }\n\n/// The user account in the system.\npublic struct Account has key, store {\n    id: UID,\n    name: String\n}\n\n/// A simple `Ping` event with no data.\npublic struct Ping has copy, drop { by: ID }\n\n/// Creates a new account in the system. Requires the `AdminCap` capability\n/// to be passed as the first argument.\npublic fun new(_: &AdminCap, name: String, ctx: &mut TxContext): Account {\n    Account {\n        id: object::new(ctx),\n        name,\n    }\n}\n\n/// Account, and any other objects, can also be used as a Capability in the\n/// application. For example, to emit an event.\npublic fun send_ping(acc: &Account) {\n    event::emit(Ping {\n        by: acc.id.to_inner()\n    })\n}\n\n/// Updates the account name. Can only be called by the `Account` owner.\npublic fun update(account: &mut Account, name: String) {\n    account.name = name;\n}\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"using-init-for-admin-capability",children:["Using ",(0,i.jsx)(n.code,{children:"init"})," for Admin Capability"]}),"\n",(0,i.jsxs)(n.p,{children:["A very common practice is to create a single ",(0,i.jsx)(n.code,{children:"AdminCap"})," object on package publish. This way, the\napplication can have a setup phase where the admin account prepares the state of the application."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/capability-2.move anchor=admin_cap",children:"module book::admin_cap;\n\n/// The capability granting the admin privileges in the system.\n/// Created only once in the `init` function.\npublic struct AdminCap has key { id: UID }\n\n/// Create the AdminCap object on package publish and transfer it to the\n/// package owner.\nfun init(ctx: &mut TxContext) {\n    transfer::transfer(\n        AdminCap { id: object::new(ctx) },\n        ctx.sender()\n    )\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"address-check-vs-capability",children:"Address Check vs Capability"}),"\n",(0,i.jsx)(n.p,{children:"Utilizing objects as capabilities is a relatively new concept in blockchain programming. And in\nother smart-contract languages, authorization is often performed by checking the address of the\nsender. This pattern is still viable on Sui, however, overall recommendation is to use capabilities\nfor better security, discoverability, and code organization."}),"\n",(0,i.jsxs)(n.p,{children:["Let's look at how the ",(0,i.jsx)(n.code,{children:"new"})," function that creates a user would look like if it was using the address\ncheck:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/capability-3.move anchor=with_address",children:"/// Error code for unauthorized access.\nconst ENotAuthorized: u64 = 0;\n\n/// The application admin address.\nconst APPLICATION_ADMIN: address = @0xa11ce;\n\n/// Creates a new user in the system. Requires the sender to be the application\n/// admin.\npublic fun new(ctx: &mut TxContext): User {\n    assert!(ctx.sender() == APPLICATION_ADMIN, ENotAuthorized);\n    User { id: object::new(ctx) }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"And now, let's see how the same function would look like with the capability:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/capability-4.move anchor=with_capability",children:"/// Grants the owner the right to create new users in the system.\npublic struct AdminCap {}\n\n/// Creates a new user in the system. Requires the `AdminCap` capability to be\n/// passed as the first argument.\npublic fun new(_: &AdminCap, ctx: &mut TxContext): User {\n    User { id: object::new(ctx) }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Using capabilities has several advantages over the address check:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Migration of admin rights is easier with capabilities due to them being objects. In case of\naddress, if the admin address changes, all the functions that check the address need to be\nupdated - hence, require a package upgrade."}),"\n",(0,i.jsxs)(n.li,{children:["Function signatures are more descriptive with capabilities. It is clear that the ",(0,i.jsx)(n.code,{children:"new"})," function\nrequires the ",(0,i.jsx)(n.code,{children:"AdminCap"})," to be passed as an argument. And this function can't be called without it."]}),"\n",(0,i.jsx)(n.li,{children:"Object Capabilities don't require extra checks in the function body, and hence, decrease the\nchance of a developer mistake."}),"\n",(0,i.jsx)(n.li,{children:"An owned Capability also serves in discovery. The owner of the AdminCap can see the object in\ntheir account (via a Wallet or Explorer), and know that they have the admin rights. This is less\ntransparent with the address check."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"However, the address approach has its own advantages. For example, if an address is multisig, and\ntransaction building gets more complex, it might be easier to check the address. Also, if there's a\ncentral object of the application that is used in every function, it can store the admin address,\nand this would simplify migration. The central object approach is also valuable for revokable\ncapabilities, where the admin can revoke the capability from the user."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);