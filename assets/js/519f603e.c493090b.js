"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5202],{3961:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"programmability/module-initializer","title":"Module Initializer","description":"A common use case in many applications is to run certain code just once when the package is","source":"@site/../book/programmability/module-initializer.md","sourceDirName":"programmability","slug":"/programmability/module-initializer","permalink":"/programmability/module-initializer","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"8.2. Transaction Context","permalink":"/programmability/transaction-context"},"next":{"title":"8.4. Pattern: Capability","permalink":"/programmability/capability"}}');var a=t(2714),o=t(4811);const s={},r="Module Initializer",c={},l=[{value:"<code>init</code> Features",id:"init-features",level:2},{value:"Trust and Security",id:"trust-and-security",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"module-initializer",children:"Module Initializer"})}),"\n",(0,a.jsxs)(n.p,{children:["A common use case in many applications is to run certain code just once when the package is\npublished. Imagine a simple store module that needs to create the main Store object upon its\npublication. In Sui, this is achieved by defining an ",(0,a.jsx)(n.code,{children:"init"})," function within the module. This\nfunction will automatically be called when the module is published."]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["All of the modules' ",(0,a.jsx)(n.code,{children:"init"})," functions are called during the publishing process. Currently, this\nbehavior is limited to the publish command and does not extend to package upgrades."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/module-initializer.move anchor=main",children:"module book::shop;\n\n/// The Capability which grants the Shop owner the right to manage\n/// the shop.\npublic struct ShopOwnerCap has key, store { id: UID }\n\n/// The singular Shop itself, created in the `init` function.\npublic struct Shop has key {\n    id: UID,\n    /* ... */\n}\n\n// Called only once, upon module publication. It must be\n// private to prevent external invocation.\nfun init(ctx: &mut TxContext) {\n    // Transfers the ShopOwnerCap to the sender (publisher).\n    transfer::transfer(ShopOwnerCap {\n        id: object::new(ctx)\n    }, ctx.sender());\n\n    // Shares the Shop object.\n    transfer::share_object(Shop {\n        id: object::new(ctx)\n    });\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In the same package, another module can have its own ",(0,a.jsx)(n.code,{children:"init"})," function, encapsulating distinct logic."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/module-initializer-2.move anchor=other",children:"// In the same package as the `shop` module\nmodule book::bank;\n\npublic struct Bank has key {\n    id: UID,\n    /* ... */\n}\n\nfun init(ctx: &mut TxContext) {\n    transfer::share_object(Bank {\n        id: object::new(ctx)\n    });\n}\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"init-features",children:[(0,a.jsx)(n.code,{children:"init"})," Features"]}),"\n",(0,a.jsx)(n.p,{children:"The function is called on publish, if it is present in the module and follows the rules:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The function has to be named ",(0,a.jsx)(n.code,{children:"init"}),", be private and have no return values."]}),"\n",(0,a.jsxs)(n.li,{children:["Takes one or two arguments: ",(0,a.jsx)(n.a,{href:"./one-time-witness",children:"One Time Witness"})," (optional) and\n",(0,a.jsx)(n.a,{href:"./transaction-context",children:"TxContext"}),". With ",(0,a.jsx)(n.code,{children:"TxContext"})," always being the last argument."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"fun init(ctx: &mut TxContext) { /* ... */}\nfun init(otw: OTW, ctx: &mut TxContext) { /* ... */ }\n"})}),"\n",(0,a.jsxs)(n.p,{children:["TxContext can also be passed as immutable reference: ",(0,a.jsx)(n.code,{children:"&TxContext"}),". However, practically speaking, it\nshould always be ",(0,a.jsx)(n.code,{children:"&mut TxContext"})," since the ",(0,a.jsx)(n.code,{children:"init"})," function can't access the on-chain state and to\ncreate new objects it requires the mutable reference to the context."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",children:"fun init(ctx: &TxContext) { /* ... */}\nfun init(otw: OTW, ctx: &TxContext) { /* ... */ }\n"})}),"\n",(0,a.jsx)(n.h2,{id:"trust-and-security",children:"Trust and Security"}),"\n",(0,a.jsxs)(n.p,{children:["While ",(0,a.jsx)(n.code,{children:"init"})," function can be used to create sensitive objects once, it is important to know that the\nsame object (e.g. ",(0,a.jsx)(n.code,{children:"StoreOwnerCap"})," from the first example) can still be created in another function.\nEspecially given that new functions can be added to the module during an upgrade. So the ",(0,a.jsx)(n.code,{children:"init"}),"\nfunction is a good place to set up the initial state of the module, but it is not a security measure\non its own."]}),"\n",(0,a.jsxs)(n.p,{children:["There are ways to guarantee that the object was created only once, such as the\n",(0,a.jsx)(n.a,{href:"./one-time-witness",children:"One Time Witness"}),". And there are ways to limit or disable the upgrade of the\nmodule, which we will cover in the Package Upgrades chapter."]}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(n.p,{children:["As follows from the definition, the ",(0,a.jsx)(n.code,{children:"init"})," function is guaranteed to be called only once when the\nmodule is published. So it is a good place to put the code that initializes module's objects and\nsets up the environment and configuration."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, if there's a ",(0,a.jsx)(n.a,{href:"./capability",children:"Capability"})," which is required for certain actions, it\nshould be created in the ",(0,a.jsx)(n.code,{children:"init"})," function. In the next chapter we will talk about the ",(0,a.jsx)(n.code,{children:"Capability"}),"\npattern in more detail."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},4811:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var i=t(9378);const a={},o=i.createContext(a);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);