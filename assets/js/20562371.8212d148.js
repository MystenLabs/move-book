"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4393],{5521:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var o=n(6672);const a={},r=o.createContext(a);function i(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),o.createElement(r.Provider,{value:t},e.children)}},5769:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"programmability/hot-potato-pattern","title":"Pattern: Hot Potato","description":"A case in the abilities system - a struct without any abilities - is called hot potato. It cannot","source":"@site/../book/programmability/hot-potato-pattern.md","sourceDirName":"programmability","slug":"/programmability/hot-potato-pattern","permalink":"/programmability/hot-potato-pattern","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"8.15. Sui Framework","permalink":"/programmability/sui-framework"},"next":{"title":"8.17. BCS","permalink":"/programmability/bcs"}}');var a=n(3420),r=n(5521);const i={},s="Pattern: Hot Potato",c={},l=[{value:"Defining a Hot Potato",id:"defining-a-hot-potato",level:2},{value:"Example Usage",id:"example-usage",level:2},{value:"Applications",id:"applications",level:2},{value:"Borrowing",id:"borrowing",level:3},{value:"Flash Loans",id:"flash-loans",level:3},{value:"Variable-path Execution",id:"variable-path-execution",level:3},{value:"Compositional Patterns",id:"compositional-patterns",level:3},{value:"Usage in the Sui Framework",id:"usage-in-the-sui-framework",level:3},{value:"Summary",id:"summary",level:2}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"pattern-hot-potato",children:"Pattern: Hot Potato"})}),"\n",(0,a.jsxs)(t.p,{children:["A case in the abilities system - a struct without any abilities - is called ",(0,a.jsx)(t.em,{children:"hot potato"}),". It cannot\nbe stored (not as ",(0,a.jsx)(t.a,{href:"./../storage/key-ability",children:"an object"})," nor as\n",(0,a.jsx)(t.a,{href:"./../storage/store-ability",children:"a field in another struct"}),"), it cannot be\n",(0,a.jsx)(t.a,{href:"./../move-basics/copy-ability",children:"copied"})," or ",(0,a.jsx)(t.a,{href:"./../move-basics/drop-ability",children:"discarded"}),". Hence, once\nconstructed, it must be gracefully ",(0,a.jsx)(t.a,{href:"./../move-basics/struct",children:"unpacked by its module"}),", or the\ntransaction will abort due to unused value without drop."]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["If you're familiar with languages that support ",(0,a.jsx)(t.em,{children:"callbacks"}),", you can think of a hot potato as an\nobligation to call a callback function. If you don't call it, the transaction will abort."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The name comes from the children's game where a ball is passed quickly between players, and none of\nthe players want to be the last one holding it when the music stops, or they are out of the game.\nThis is the best illustration of the pattern - the instance of a hot-potato struct is passed between\ncalls, and none of the modules can keep it."}),"\n",(0,a.jsx)(t.h2,{id:"defining-a-hot-potato",children:"Defining a Hot Potato"}),"\n",(0,a.jsx)(t.p,{children:"A hot potato can be any struct with no abilities. For example, the following struct is a hot potato:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/hot-potato-pattern.move anchor=definition",children:"public struct Request {}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Because the ",(0,a.jsx)(t.code,{children:"Request"})," has no abilities and cannot be stored or ignored, the module must provide a\nfunction to unpack it. For example:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/hot-potato-pattern.move anchor=new_request",children:"/// Constructs a new `Request`\npublic fun new_request(): Request { Request {} }\n\n/// Unpacks the `Request`. Due to the nature of the hot potato, this function\n/// must be called to avoid aborting the transaction.\npublic fun confirm_request(request: Request) {\n    let Request {} = request;\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,a.jsxs)(t.p,{children:["In the following example, the ",(0,a.jsx)(t.code,{children:"Promise"})," hot potato is used to ensure that the borrowed value, when\ntaken from the container, is returned back to it. The ",(0,a.jsx)(t.code,{children:"Promise"})," struct contains the ID of the\nborrowed object, and the ID of the container, ensuring that the borrowed value was not swapped for\nanother and is returned to the correct container."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/hot-potato-pattern.move anchor=container_borrow",children:"/// A generic container for any Object with `key + store`. The Option type\n/// is used to allow taking and putting the value back.\npublic struct Container<T: key + store> has key {\n    id: UID,\n    value: Option<T>,\n}\n\n/// A Hot Potato struct that is used to ensure the borrowed value is returned.\npublic struct Promise {\n    /// The ID of the borrowed object. Ensures that there wasn't a value swap.\n    id: ID,\n    /// The ID of the container. Ensures that the borrowed value is returned to\n    /// the correct container.\n    container_id: ID,\n}\n\n/// A function that allows borrowing the value from the container.\npublic fun borrow_val<T: key + store>(container: &mut Container<T>): (T, Promise) {\n    assert!(container.value.is_some());\n    let value = container.value.extract();\n    let id = object::id(&value);\n    (value, Promise { id, container_id: object::id(container) })\n}\n\n/// Put the taken item back into the container.\npublic fun return_val<T: key + store>(\n    container: &mut Container<T>, value: T, promise: Promise\n) {\n    let Promise { id, container_id } = promise;\n    assert!(object::id(container) == container_id);\n    assert!(object::id(&value) == id);\n    container.value.fill(value);\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"applications",children:"Applications"}),"\n",(0,a.jsx)(t.p,{children:"Below we list some of the common use cases for the hot potato pattern."}),"\n",(0,a.jsx)(t.h3,{id:"borrowing",children:"Borrowing"}),"\n",(0,a.jsxs)(t.p,{children:["As shown in the ",(0,a.jsx)(t.a,{href:"#example-usage",children:"example above"}),", the hot potato is very effective for borrowing with\na guarantee that the borrowed value is returned to the correct container. While the example focuses\non a value stored inside an ",(0,a.jsx)(t.code,{children:"Option"}),", the same pattern can be applied to any other storage type, say\na ",(0,a.jsx)(t.a,{href:"./dynamic-fields",children:"dynamic field"}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"flash-loans",children:"Flash Loans"}),"\n",(0,a.jsx)(t.p,{children:"Canonical example of the hot potato pattern is flash loans. A flash loan is a loan that is borrowed\nand repaid in the same transaction. The borrowed funds are used to perform some operations, and the\nrepaid funds are returned to the lender. The hot potato pattern ensures that the borrowed funds are\nreturned to the lender."}),"\n",(0,a.jsx)(t.p,{children:"An example usage of this pattern may look like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-move",children:"// Borrow the funds from the lender.\nlet (asset_a, potato) = lender.borrow(amount);\n\n// Perform some operations with the borrowed funds.\nlet asset_b = dex.trade(loan);\nlet proceeds = another_contract::do_something(asset_b);\n\n// Keep the commission and return the rest to the lender.\nlet pay_back = proceeds.split(amount, ctx);\nlender.repay(pay_back, potato);\ntransfer::public_transfer(proceeds, ctx.sender());\n"})}),"\n",(0,a.jsx)(t.h3,{id:"variable-path-execution",children:"Variable-path Execution"}),"\n",(0,a.jsxs)(t.p,{children:["The hot potato pattern can be used to introduce variation in the execution path. For example, if\nthere is a module which allows purchasing a ",(0,a.jsx)(t.code,{children:"Phone"}),' for some "Bonus Points" or for USD, the hot\npotato can be used to decouple the purchase from the payment. The approach is very similar to how\nsome shops work - you take the item from the shelf, and then you go to the cashier to pay for it.']}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-move",metastring:"file=packages/samples/sources/programmability/hot-potato-pattern.move anchor=phone_shop",children:"/// A `Phone`. Can be purchased in a store.\npublic struct Phone has key, store { id: UID }\n\n/// A ticket that must be paid to purchase the `Phone`.\npublic struct Ticket { amount: u64 }\n\n/// Return the `Phone` and the `Ticket` that must be paid to purchase it.\npublic fun purchase_phone(ctx: &mut TxContext): (Phone, Ticket) {\n    (\n        Phone { id: object::new(ctx) },\n        Ticket { amount: 100 }\n    )\n}\n\n/// The customer may pay for the `Phone` with `BonusPoints` or `SUI`.\npublic fun pay_in_bonus_points(ticket: Ticket, payment: Coin<BONUS>) {\n    let Ticket { amount } = ticket;\n    assert!(payment.value() == amount);\n    abort // omitting the rest of the function\n}\n\n/// The customer may pay for the `Phone` with `USD`.\npublic fun pay_in_usd(ticket: Ticket, payment: Coin<USD>) {\n    let Ticket { amount } = ticket;\n    assert!(payment.value() == amount);\n    abort // omitting the rest of the function\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This decoupling technique allows separating the purchase logic from the payment logic, making the\ncode more modular and easier to maintain. The ",(0,a.jsx)(t.code,{children:"Ticket"})," could be split into its own module, providing\na basic interface for the payment, and the shop implementation could be extended to support other\ngoods without changing the payment logic."]}),"\n",(0,a.jsx)(t.h3,{id:"compositional-patterns",children:"Compositional Patterns"}),"\n",(0,a.jsx)(t.p,{children:"Hot potato can be used to link together different modules in a compositional way. Its module may\ndefine ways to interact with the hot potato, for example, stamp it with a type signature, or to\nextract some information from it. This way, the hot potato can be passed between different modules,\nand even different packages within the same transaction."}),"\n",(0,a.jsx)(t.p,{children:"The most important compositional pattern is the Request Pattern, which we will cover in the next\nsection."}),"\n",(0,a.jsx)(t.h3,{id:"usage-in-the-sui-framework",children:"Usage in the Sui Framework"}),"\n",(0,a.jsx)(t.p,{children:"The pattern is used in various forms in the Sui Framework. Here are some examples:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"https://docs.sui.io/references/framework/sui-framework/borrow",children:"sui::borrow"})," - uses hot potato to ensure that the borrowed value is returned to\nthe correct container."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"https://docs.sui.io/references/framework/sui-framework/transfer_policy",children:"sui::transfer_policy"})," - defines a ",(0,a.jsx)(t.code,{children:"TransferRequest"})," - a hot potato\nwhich can only be consumed if all conditions are met."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"https://docs.sui.io/references/framework/sui-framework/token",children:"sui::token"})," - in the Closed Loop Token system, an ",(0,a.jsx)(t.code,{children:"ActionRequest"})," carries the\ninformation about the performed action and collects approvals similarly to ",(0,a.jsx)(t.code,{children:"TransferRequest"}),"."]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"A hot potato is a struct without abilities, it must come with a way to create and destroy it."}),"\n",(0,a.jsx)(t.li,{children:"Hot potatoes are used to ensure that some action is taken before the transaction ends, similar to\na callback."}),"\n",(0,a.jsx)(t.li,{children:"Most common use cases for hot potato are borrowing, flash loans, variable-path execution, and\ncompositional patterns."}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}}}]);