"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3312],{5521:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>i});var t=s(6672);const a={},o=t.createContext(a);function c(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),t.createElement(o.Provider,{value:n},e.children)}},8278:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>i,default:()=>u,frontMatter:()=>c,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"move-basics/function","title":"Functions","description":"Functions are the building blocks of Move programs. They are called from","source":"@site/../book/move-basics/function.md","sourceDirName":"move-basics","slug":"/move-basics/function","permalink":"/move-basics/function","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.17. Aborting Execution","permalink":"/move-basics/assert-and-abort"},"next":{"title":"5.19. Struct Methods","permalink":"/move-basics/struct-methods"}}');var a=s(3420),o=s(5521);const c={},i="Functions",r={},l=[{value:"Function declaration",id:"function-declaration",level:2},{value:"Accessing functions",id:"accessing-functions",level:2},{value:"Multiple return values",id:"multiple-return-values",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"functions",children:"Functions"})}),"\n",(0,a.jsxs)(n.p,{children:["Functions are the building blocks of Move programs. They are called from\n",(0,a.jsx)(n.a,{href:"./../concepts/what-is-a-transaction",children:"user transactions"})," and from other functions and group\nexecutable code into reusable units. Functions can take arguments and return a value. They are\ndeclared with the ",(0,a.jsx)(n.code,{children:"fun"})," keyword at the module level. Just like any other module member, by default\nthey're private and can only be accessed from within the module."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/function.move anchor=math",children:"module book::math;\n\n#[test_only]\nuse std::unit_test::assert_eq;\n\n/// Function takes two arguments of type `u64` and returns their sum.\n/// The `public` visibility modifier makes the function accessible from\n/// outside the module.\npublic fun add(a: u64, b: u64): u64 {\n    a + b\n}\n\n#[test]\nfun test_add() {\n    let sum = add(1, 2);\n    assert_eq!(sum, 3);\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In this example, we define a function ",(0,a.jsx)(n.code,{children:"add"})," that takes two arguments of type ",(0,a.jsx)(n.code,{children:"u64"})," and returns their\nsum. The ",(0,a.jsx)(n.code,{children:"test_add"})," function, located in the same module, is a test function that calls ",(0,a.jsx)(n.code,{children:"add"}),". The\ntest uses the ",(0,a.jsx)(n.code,{children:"assert!"})," macro to compare the result of ",(0,a.jsx)(n.code,{children:"add"})," with the expected value. If the\ncondition inside ",(0,a.jsx)(n.code,{children:"assert!"})," evaluates to false, the execution is aborted automatically."]}),"\n",(0,a.jsx)(n.h2,{id:"function-declaration",children:"Function declaration"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["In Move, functions are typically named using the ",(0,a.jsx)(n.code,{children:"snake_case"})," convention. This means function\nnames should be all lowercase, with words separated by underscores. Examples include\n",(0,a.jsx)(n.code,{children:"do_something"}),", ",(0,a.jsx)(n.code,{children:"add"}),", ",(0,a.jsx)(n.code,{children:"get_balance"}),", ",(0,a.jsx)(n.code,{children:"is_authorized"}),", and so on."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["A function is declared with the ",(0,a.jsx)(n.code,{children:"fun"})," keyword followed by the function name (a valid Move\nidentifier), a list of arguments in parentheses, and a return type. The function body is a block of\ncode that contains a sequence of statements and expressions. The last expression the function body\nis the return value of the function."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/function.move anchor=return_nothing",children:"fun return_nothing() {\n    // empty expression, function returns `()`\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"accessing-functions",children:"Accessing functions"}),"\n",(0,a.jsxs)(n.p,{children:["Just like other module members, functions can be imported and accessed using a path. The path\nconsists of the module path and the function name, separated by ::. For example, if you have a\nfunction named ",(0,a.jsx)(n.code,{children:"add"})," in the ",(0,a.jsx)(n.code,{children:"math"})," module within the ",(0,a.jsx)(n.code,{children:"book"})," package, its full path would be\n",(0,a.jsx)(n.code,{children:"book::math::add"}),". If the module has already been imported, you can access it directly as\n",(0,a.jsx)(n.code,{children:"math::add"})," as in the following example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/function_use.move anchor=use_math",children:"module book::use_math;\n\nuse book::math;\n\nfun call_add() {\n    // function is called via the path\n    let sum = math::add(1, 2);\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"multiple-return-values",children:"Multiple return values"}),"\n",(0,a.jsx)(n.p,{children:"Move functions can return multiple values, which is particularly useful when you need to return more\nthan one piece of data from a function. The return type is specified as a tuple of types, and the\nreturn value is provided as a tuple of expressions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/function.move anchor=tuple_return",children:'fun get_name_and_age(): (vector<u8>, u8) {\n    (b"John", 25)\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The result of a function call with a tuple return has to be unpacked into variables via the\n",(0,a.jsx)(n.code,{children:"let (tuple)"})," syntax:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/function.move anchor=tuple_return_imm",children:'// Tuple must be destructured to access its elements.\n// Name and age are declared as immutable variables.\nlet (name, age) = get_name_and_age();\nassert_eq!(name, b"John");\nassert_eq!(age, 25);\n'})}),"\n",(0,a.jsxs)(n.p,{children:["If any of the declared values need to be declared as mutable, the ",(0,a.jsx)(n.code,{children:"mut"})," keyword is placed before the\nvariable name:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/function.move anchor=tuple_return_mut",children:"// declare name as mutable, age as immutable\nlet (mut name, age) = get_name_and_age();\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If some of the arguments are not used, they can be ignored with the ",(0,a.jsx)(n.code,{children:"_"})," symbol:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/function.move anchor=tuple_return_ignore",children:"// ignore the name, only use the age\nlet (_, age) = get_name_and_age();\n"})}),"\n",(0,a.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"./../../reference/functions",children:"Functions"})," in the Move Reference."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);