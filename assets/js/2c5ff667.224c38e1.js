"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6754],{3233:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>m,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"move-basics/importing-modules","title":"Importing Modules","description":"\x3c!--","source":"@site/../book/move-basics/importing-modules.md","sourceDirName":"move-basics","slug":"/move-basics/importing-modules","permalink":"/move-basics/importing-modules","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.8. Ability: Drop","permalink":"/move-basics/drop-ability"},"next":{"title":"5.10. Standard Library","permalink":"/move-basics/standard-library"}}');var a=o(3420),i=o(5521);const t={},r="Importing Modules",d={},c=[{value:"Importing a Module",id:"importing-a-module",level:2},{value:"Importing Members",id:"importing-members",level:2},{value:"Grouping Imports",id:"grouping-imports",level:2},{value:"Resolving Name Conflicts",id:"resolving-name-conflicts",level:2},{value:"Adding an External Dependency",id:"adding-an-external-dependency",level:2},{value:"Importing a Module from Another Package",id:"importing-a-module-from-another-package",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"importing-modules",children:"Importing Modules"})}),"\n",(0,a.jsx)(n.p,{children:"Move achieves high modularity and code reuse by allowing module imports. Modules within the same\npackage can import each other, and a new package can depend on already existing packages and use\ntheir modules too. This section will cover the basics of importing modules and how to use them in\nyour own code."}),"\n",(0,a.jsx)(n.h2,{id:"importing-a-module",children:"Importing a Module"}),"\n",(0,a.jsxs)(n.p,{children:["Modules defined in the same package can import each other. The ",(0,a.jsx)(n.code,{children:"use"})," keyword is followed by the\nmodule path, which consists of the package address (or alias) and the module name separated by ",(0,a.jsx)(n.code,{children:"::"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:'title="File: sources/module_one.move" file=packages/samples/sources/move-basics/importing-modules.move anchor=module_one',children:"module book::module_one;\n\n/// Struct defined in the same module.\npublic struct Character has drop {}\n\n/// Simple function that creates a new `Character` instance.\npublic fun new(): Character { Character {} }\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Another module defined in the same package can import the first module using the ",(0,a.jsx)(n.code,{children:"use"})," keyword."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:'title="File: sources/module_two.move" file=packages/samples/sources/move-basics/importing-modules-two.move anchor=module_two',children:"module book::module_two;\n\nuse book::module_one; // importing module_one from the same package\n\n/// Calls the `new` function from the `module_one` module.\npublic fun create_and_ignore() {\n    let _ = module_one::new();\n}\n"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["Note: Any item (struct, function, constant, etc.) that you want to import from another module must\nbe marked with the ",(0,a.jsx)(n.code,{children:"public"})," (or ",(0,a.jsx)(n.code,{children:"public(package)"})," - see ",(0,a.jsx)(n.a,{href:"./visibility",children:"visibility modifiers"}),")\nkeyword to make it accessible outside its defining module. For example, the ",(0,a.jsx)(n.code,{children:"Character"})," struct and\nthe ",(0,a.jsx)(n.code,{children:"new"})," function in ",(0,a.jsx)(n.code,{children:"module_one"})," are marked public so they can be used in ",(0,a.jsx)(n.code,{children:"module_two"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"importing-members",children:"Importing Members"}),"\n",(0,a.jsx)(n.p,{children:"You can also import specific members from a module. This is useful when you only need a single\nfunction or a single type from a module. The syntax is the same as for importing a module, but you\nadd the member name after the module path."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/importing-modules-members.move anchor=members",children:"module book::more_imports;\n\nuse book::module_one::new;       // imports the `new` function from the `module_one` module\nuse book::module_one::Character; // importing the `Character` struct from the `module_one` module\n\n/// Calls the `new` function from the `module_one` module.\npublic fun create_character(): Character {\n    new()\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"grouping-imports",children:"Grouping Imports"}),"\n",(0,a.jsxs)(n.p,{children:["Imports can be grouped into a single ",(0,a.jsx)(n.code,{children:"use"})," statement using curly braces ",(0,a.jsx)(n.code,{children:"{}"}),". This allows for\ncleaner and more organized code when importing multiple members from the same module or package."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/importing-modules-grouped.move anchor=grouped",children:"module book::grouped_imports;\n\n// imports the `new` function and the `Character` struct from\n// the `module_one` module\nuse book::module_one::{new, Character};\n\n/// Calls the `new` function from the `module_one` module.\npublic fun create_character(): Character {\n    new()\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Importing function names is less common in Move, since the function names can overlap and cause\nconfusion. A recommended practice is to import the entire module and use the module path to access\nthe function. Types have unique names and should be imported individually."}),"\n",(0,a.jsxs)(n.p,{children:["To import members and the module itself in the group import, you can use the ",(0,a.jsx)(n.code,{children:"Self"})," keyword. The\n",(0,a.jsx)(n.code,{children:"Self"})," keyword refers to the module itself and can be used to import the module and its members."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/importing-modules-self.move anchor=self",children:"module book::self_imports;\n\n// imports the `Character` struct, and the `module_one` module\nuse book::module_one::{Self, Character};\n\n/// Calls the `new` function from the `module_one` module.\npublic fun create_character(): Character {\n    module_one::new()\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"resolving-name-conflicts",children:"Resolving Name Conflicts"}),"\n",(0,a.jsxs)(n.p,{children:["When importing multiple members from different modules, it is possible to have name conflicts. For\nexample, if you import two modules that both have a function with the same name, you will need to\nuse the module path to access the function. It is also possible to have modules with the same name\nin different packages. To resolve the conflict and avoid ambiguity, Move offers the ",(0,a.jsx)(n.code,{children:"as"})," keyword to\nrename the imported member."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/importing-modules-conflict-resolution.move anchor=conflict",children:"module book::conflict_resolution;\n\n// `as` can be placed after any import, including group imports\nuse book::module_one::{Self as mod, Character as Char};\n\n/// Calls the `new` function from the `module_one` module.\npublic fun create(): Char {\n    mod::new()\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"adding-an-external-dependency",children:"Adding an External Dependency"}),"\n",(0,a.jsxs)(n.p,{children:["Move packages can depend on other packages; the dependencies are listed in the\n",(0,a.jsx)(n.a,{href:"./../concepts/manifest",children:"Package Manifest"})," file called ",(0,a.jsx)(n.code,{children:"Move.toml"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Package dependencies are defined in the ",(0,a.jsx)(n.a,{href:"./../concepts/manifest",children:"Package Manifest"})," as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ini",metastring:'title="Move.toml"',children:'[dependencies]\nExample = { git = "https://github.com/Example/example.git", subdir = "path/to/package", rev = "v1.2.3" }\nLocal = { local = "../my_other_package" }\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"dependencies"})," section contains an entry for each package dependency. The key of the entry is\nthe name of the package (",(0,a.jsx)(n.code,{children:"Example"})," or ",(0,a.jsx)(n.code,{children:"Local"})," in the example), and the value is either a git import\ntable or a local path. The git import contains the URL of the package, the subdirectory where the\npackage is located, and the revision of the package. The local path is a relative path to the qa\npackage directory."]}),"\n",(0,a.jsx)(n.p,{children:"If you add a dependency, all of its dependencies also become available to your package."}),"\n",(0,a.jsxs)(n.p,{children:["If a dependency is added to the ",(0,a.jsx)(n.code,{children:"Move.toml"})," file, the compiler will automatically fetch (and later\nrefetch) the dependencies when building the package."]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["Starting with version 1.45 of the sui CLI, the system packages are automatically included as\ndependencies for all packages if they are not present in ",(0,a.jsx)(n.code,{children:"Move.toml"}),". Therefore, ",(0,a.jsx)(n.code,{children:"MoveStdlib"}),",\n",(0,a.jsx)(n.code,{children:"Sui"}),", ",(0,a.jsx)(n.code,{children:"System"}),", ",(0,a.jsx)(n.code,{children:"Bridge"}),", and ",(0,a.jsx)(n.code,{children:"Deepbook"})," are all available without an explicit import."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"importing-a-module-from-another-package",children:"Importing a Module from Another Package"}),"\n",(0,a.jsxs)(n.p,{children:["Normally, packages define their addresses in the ",(0,a.jsx)(n.code,{children:"[addresses]"})," section. You can use aliases instead\nof full addresses. For example, instead of using ",(0,a.jsx)(n.code,{children:"0x2::coin"})," to reference the Sui ",(0,a.jsx)(n.code,{children:"coin"})," module, you\ncan use ",(0,a.jsx)(n.code,{children:"sui::coin"}),". The ",(0,a.jsx)(n.code,{children:"sui"})," alias is defined in the Sui Framework package's manifest. Similarly,\nthe ",(0,a.jsx)(n.code,{children:"std"})," alias is defined in the Standard Library package and can be used instead of ",(0,a.jsx)(n.code,{children:"0x1"})," to\naccess standard library modules."]}),"\n",(0,a.jsxs)(n.p,{children:["To import a module from another package, use the ",(0,a.jsx)(n.code,{children:"use"})," keyword followed by the module path. The\nmodule path consists of the package address (or alias) and the module name, separated by ",(0,a.jsx)(n.code,{children:"::"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/importing-modules-external.move anchor=external",children:"module book::imports;\n\nuse std::string; // std = 0x1, string is a module in the standard library\nuse sui::coin;   // sui = 0x2, coin is a module in the Sui Framework\n"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["Note: Module address names come from the ",(0,a.jsx)(n.code,{children:"[addresses]"})," section of the manifest file (",(0,a.jsx)(n.code,{children:"Move.toml"}),"),\nnot the names used in the ",(0,a.jsx)(n.code,{children:"[dependencies]"})," section."]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},5521:(e,n,o)=>{o.d(n,{R:()=>t,x:()=>r});var s=o(6672);const a={},i=s.createContext(a);function t(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);