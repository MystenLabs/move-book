"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2358],{1709:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>l,default:()=>a,frontMatter:()=>d,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"primitive-types/integers","title":"Integers | Reference","description":"","source":"@site/../reference/primitive-types/integers.md","sourceDirName":"primitive-types","slug":"/primitive-types/integers","permalink":"/reference/primitive-types/integers","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Integers | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"Primitive Types | Reference","permalink":"/reference/primitive-types"},"next":{"title":"2.2 Bool","permalink":"/reference/primitive-types/bool"}}');var n=t(2714),r=t(4811);const d={title:"Integers | Reference",description:""},l="Integers",c={},h=[{value:"Literals",id:"literals",level:2},{value:"Examples",id:"examples",level:3},{value:"Operations",id:"operations",level:2},{value:"Arithmetic",id:"arithmetic",level:3},{value:"Bitwise",id:"bitwise",level:3},{value:"Bit Shifts",id:"bit-shifts",level:3},{value:"Comparisons",id:"comparisons",level:3},{value:"Equality",id:"equality",level:3},{value:"Casting",id:"casting",level:2},{value:"Ownership",id:"ownership",level:2}];function o(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"integers",children:"Integers"})}),"\n",(0,n.jsxs)(i.p,{children:["Move supports six unsigned integer types: ",(0,n.jsx)(i.code,{children:"u8"}),", ",(0,n.jsx)(i.code,{children:"u16"}),", ",(0,n.jsx)(i.code,{children:"u32"}),", ",(0,n.jsx)(i.code,{children:"u64"}),", ",(0,n.jsx)(i.code,{children:"u128"}),", and ",(0,n.jsx)(i.code,{children:"u256"}),". Values of\nthese types range from 0 to a maximum that depends on the size of the type."]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Type"}),(0,n.jsx)(i.th,{children:"Value Range"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsxs)(i.td,{children:["Unsigned 8-bit integer, ",(0,n.jsx)(i.code,{children:"u8"})]}),(0,n.jsxs)(i.td,{children:["0 to 2",(0,n.jsx)("sup",{children:"8"})," - 1"]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsxs)(i.td,{children:["Unsigned 16-bit integer, ",(0,n.jsx)(i.code,{children:"u16"})]}),(0,n.jsxs)(i.td,{children:["0 to 2",(0,n.jsx)("sup",{children:"16"})," - 1"]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsxs)(i.td,{children:["Unsigned 32-bit integer, ",(0,n.jsx)(i.code,{children:"u32"})]}),(0,n.jsxs)(i.td,{children:["0 to 2",(0,n.jsx)("sup",{children:"32"})," - 1"]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsxs)(i.td,{children:["Unsigned 64-bit integer, ",(0,n.jsx)(i.code,{children:"u64"})]}),(0,n.jsxs)(i.td,{children:["0 to 2",(0,n.jsx)("sup",{children:"64"})," - 1"]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsxs)(i.td,{children:["Unsigned 128-bit integer, ",(0,n.jsx)(i.code,{children:"u128"})]}),(0,n.jsxs)(i.td,{children:["0 to 2",(0,n.jsx)("sup",{children:"128"})," - 1"]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsxs)(i.td,{children:["Unsigned 256-bit integer, ",(0,n.jsx)(i.code,{children:"u256"})]}),(0,n.jsxs)(i.td,{children:["0 to 2",(0,n.jsx)("sup",{children:"256"})," - 1"]})]})]})]}),"\n",(0,n.jsx)(i.h2,{id:"literals",children:"Literals"}),"\n",(0,n.jsxs)(i.p,{children:["Literal values for these types are specified either as a sequence of digits (e.g.,",(0,n.jsx)(i.code,{children:"112"}),") or as hex\nliterals, e.g., ",(0,n.jsx)(i.code,{children:"0xFF"}),". The type of the literal can optionally be added as a suffix, e.g., ",(0,n.jsx)(i.code,{children:"112u8"}),".\nIf the type is not specified, the compiler will try to infer the type from the context where the\nliteral is used. If the type cannot be inferred, it is assumed to be ",(0,n.jsx)(i.code,{children:"u64"}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["Number literals can be separated by underscores for grouping and readability. (e.g.,",(0,n.jsx)(i.code,{children:"1_234_5678"}),",\n",(0,n.jsx)(i.code,{children:"1_000u128"}),", ",(0,n.jsx)(i.code,{children:"0xAB_CD_12_35"}),")."]}),"\n",(0,n.jsx)(i.p,{children:"If a literal is too large for its specified (or inferred) size range, an error is reported."}),"\n",(0,n.jsx)(i.h3,{id:"examples",children:"Examples"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-move",children:"// literals with explicit annotations;\nlet explicit_u8 = 1u8;\nlet explicit_u16 = 1u16;\nlet explicit_u32 = 1u32;\nlet explicit_u64 = 2u64;\nlet explicit_u128 = 3u128;\nlet explicit_u256 = 1u256;\nlet explicit_u64_underscored = 154_322_973u64;\n\n// literals with simple inference\nlet simple_u8: u8 = 1;\nlet simple_u16: u16 = 1;\nlet simple_u32: u32 = 1;\nlet simple_u64: u64 = 2;\nlet simple_u128: u128 = 3;\nlet simple_u256: u256 = 1;\n\n// literals with more complex inference\nlet complex_u8 = 1; // inferred: u8\n// right hand argument to shift must be u8\nlet _unused = 10 << complex_u8;\n\nlet x: u8 = 38;\nlet complex_u8 = 2; // inferred: u8\n// arguments to `+` must have the same type\nlet _unused = x + complex_u8;\n\nlet complex_u128 = 133_876; // inferred: u128\n// inferred from function argument type\nfunction_that_takes_u128(complex_u128);\n\n// literals can be written in hex\nlet hex_u8: u8 = 0x1;\nlet hex_u16: u16 = 0x1BAE;\nlet hex_u32: u32 = 0xDEAD80;\nlet hex_u64: u64 = 0xCAFE;\nlet hex_u128: u128 = 0xDEADBEEF;\nlet hex_u256: u256 = 0x1123_456A_BCDE_F;\n"})}),"\n",(0,n.jsx)(i.h2,{id:"operations",children:"Operations"}),"\n",(0,n.jsx)(i.h3,{id:"arithmetic",children:"Arithmetic"}),"\n",(0,n.jsxs)(i.p,{children:["Each of these types supports the same set of checked arithmetic operations. For all of these\noperations, both arguments (the left and right side operands) ",(0,n.jsx)(i.em,{children:"must"})," be of the same type. If you\nneed to operate over values of different types, you will need to first perform a ",(0,n.jsx)(i.a,{href:"#casting",children:"cast"}),".\nSimilarly, if you expect the result of the operation to be too large for the integer type, perform a\n",(0,n.jsx)(i.a,{href:"#casting",children:"cast"})," to a larger size before performing the operation."]}),"\n",(0,n.jsx)(i.p,{children:"All arithmetic operations abort instead of behaving in a way that mathematical integers would not\n(e.g., overflow, underflow, divide-by-zero)."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Syntax"}),(0,n.jsx)(i.th,{children:"Operation"}),(0,n.jsx)(i.th,{children:"Aborts If"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"+"})}),(0,n.jsx)(i.td,{children:"addition"}),(0,n.jsx)(i.td,{children:"Result is too large for the integer type"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"-"})}),(0,n.jsx)(i.td,{children:"subtraction"}),(0,n.jsx)(i.td,{children:"Result is less than zero"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"*"})}),(0,n.jsx)(i.td,{children:"multiplication"}),(0,n.jsx)(i.td,{children:"Result is too large for the integer type"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"%"})}),(0,n.jsx)(i.td,{children:"modular division"}),(0,n.jsxs)(i.td,{children:["The divisor is ",(0,n.jsx)(i.code,{children:"0"})]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"/"})}),(0,n.jsx)(i.td,{children:"truncating division"}),(0,n.jsxs)(i.td,{children:["The divisor is ",(0,n.jsx)(i.code,{children:"0"})]})]})]})]}),"\n",(0,n.jsx)(i.h3,{id:"bitwise",children:"Bitwise"}),"\n",(0,n.jsx)(i.p,{children:"The integer types support the following bitwise operations that treat each number as a series of\nindividual bits, either 0 or 1, instead of as numerical integer values."}),"\n",(0,n.jsx)(i.p,{children:"Bitwise operations do not abort."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Syntax"}),(0,n.jsx)(i.th,{children:"Operation"}),(0,n.jsx)(i.th,{children:"Description"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"&"})}),(0,n.jsx)(i.td,{children:"bitwise and"}),(0,n.jsx)(i.td,{children:"Performs a boolean and for each bit pairwise"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)("code",{children:"|"})}),(0,n.jsx)(i.td,{children:"bitwise or"}),(0,n.jsx)(i.td,{children:"Performs a boolean or for each bit pairwise"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"^"})}),(0,n.jsx)(i.td,{children:"bitwise xor"}),(0,n.jsx)(i.td,{children:"Performs a boolean exclusive or for each bit pairwise"})]})]})]}),"\n",(0,n.jsx)(i.h3,{id:"bit-shifts",children:"Bit Shifts"}),"\n",(0,n.jsxs)(i.p,{children:["Similar to the bitwise operations, each integer type supports bit shifts. But unlike the other\noperations, the right hand side operand (how many bits to shift by) must ",(0,n.jsx)(i.em,{children:"always"})," be a ",(0,n.jsx)(i.code,{children:"u8"})," and need\nnot match the left side operand (the number you are shifting)."]}),"\n",(0,n.jsxs)(i.p,{children:["Bit shifts can abort if the number of bits to shift by is greater than or equal to ",(0,n.jsx)(i.code,{children:"8"}),", ",(0,n.jsx)(i.code,{children:"16"}),", ",(0,n.jsx)(i.code,{children:"32"}),",\n",(0,n.jsx)(i.code,{children:"64"}),", ",(0,n.jsx)(i.code,{children:"128"})," or ",(0,n.jsx)(i.code,{children:"256"})," for ",(0,n.jsx)(i.code,{children:"u8"}),", ",(0,n.jsx)(i.code,{children:"u16"}),", ",(0,n.jsx)(i.code,{children:"u32"}),", ",(0,n.jsx)(i.code,{children:"u64"}),", ",(0,n.jsx)(i.code,{children:"u128"})," and ",(0,n.jsx)(i.code,{children:"u256"})," respectively."]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Syntax"}),(0,n.jsx)(i.th,{children:"Operation"}),(0,n.jsx)(i.th,{children:"Aborts if"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"<<"})}),(0,n.jsx)(i.td,{children:"shift left"}),(0,n.jsx)(i.td,{children:"Number of bits to shift by is greater than the size of the integer type"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:">>"})}),(0,n.jsx)(i.td,{children:"shift right"}),(0,n.jsx)(i.td,{children:"Number of bits to shift by is greater than the size of the integer type"})]})]})]}),"\n",(0,n.jsx)(i.h3,{id:"comparisons",children:"Comparisons"}),"\n",(0,n.jsxs)(i.p,{children:["Integer types are the ",(0,n.jsx)(i.em,{children:"only"})," types in Move that can use the comparison operators. Both arguments\nneed to be of the same type. If you need to compare integers of different types, you must\n",(0,n.jsx)(i.a,{href:"#casting",children:"cast"})," one of them first."]}),"\n",(0,n.jsx)(i.p,{children:"Comparison operations do not abort."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Syntax"}),(0,n.jsx)(i.th,{children:"Operation"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"<"})}),(0,n.jsx)(i.td,{children:"less than"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:">"})}),(0,n.jsx)(i.td,{children:"greater than"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"<="})}),(0,n.jsx)(i.td,{children:"less than or equal to"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:">="})}),(0,n.jsx)(i.td,{children:"greater than or equal to"})]})]})]}),"\n",(0,n.jsx)(i.h3,{id:"equality",children:"Equality"}),"\n",(0,n.jsxs)(i.p,{children:["Like all types with ",(0,n.jsx)(i.a,{href:"./../abilities",children:(0,n.jsx)(i.code,{children:"drop"})}),", all integer types support the ",(0,n.jsx)(i.a,{href:"./../equality",children:'"equal"'}),"\nand ",(0,n.jsx)(i.a,{href:"./../equality",children:'"not equal"'})," operations. Both arguments need to be of the same type. If you need\nto compare integers of different types, you must ",(0,n.jsx)(i.a,{href:"#casting",children:"cast"})," one of them first."]}),"\n",(0,n.jsx)(i.p,{children:"Equality operations do not abort."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Syntax"}),(0,n.jsx)(i.th,{children:"Operation"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"=="})}),(0,n.jsx)(i.td,{children:"equal"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"!="})}),(0,n.jsx)(i.td,{children:"not equal"})]})]})]}),"\n",(0,n.jsxs)(i.p,{children:["For more details see the section on ",(0,n.jsx)(i.a,{href:"./../equality",children:"equality"})]}),"\n",(0,n.jsx)(i.h2,{id:"casting",children:"Casting"}),"\n",(0,n.jsx)(i.p,{children:"Integer types of one size can be cast to integer types of another size. Integers are the only types\nin Move that support casting."}),"\n",(0,n.jsxs)(i.p,{children:["Casts ",(0,n.jsx)(i.em,{children:"do not"})," truncate. Casting aborts if the result is too large for the specified type."]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Syntax"}),(0,n.jsx)(i.th,{children:"Operation"}),(0,n.jsx)(i.th,{children:"Aborts if"})]})}),(0,n.jsx)(i.tbody,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"(e as T)"})}),(0,n.jsxs)(i.td,{children:["Cast integer expression ",(0,n.jsx)(i.code,{children:"e"})," into an integer type ",(0,n.jsx)(i.code,{children:"T"})]}),(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.code,{children:"e"})," is too large to represent as a ",(0,n.jsx)(i.code,{children:"T"})]})]})})]}),"\n",(0,n.jsxs)(i.p,{children:["Here, the type of ",(0,n.jsx)(i.code,{children:"e"})," must be ",(0,n.jsx)(i.code,{children:"8"}),", ",(0,n.jsx)(i.code,{children:"16"}),", ",(0,n.jsx)(i.code,{children:"32"}),", ",(0,n.jsx)(i.code,{children:"64"}),", ",(0,n.jsx)(i.code,{children:"128"})," or ",(0,n.jsx)(i.code,{children:"256"})," and ",(0,n.jsx)(i.code,{children:"T"})," must be ",(0,n.jsx)(i.code,{children:"u8"}),", ",(0,n.jsx)(i.code,{children:"u16"}),",\n",(0,n.jsx)(i.code,{children:"u32"}),", ",(0,n.jsx)(i.code,{children:"u64"}),", ",(0,n.jsx)(i.code,{children:"u128"}),", or ",(0,n.jsx)(i.code,{children:"u256"}),"."]}),"\n",(0,n.jsx)(i.p,{children:"For example:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.code,{children:"(x as u8)"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.code,{children:"(y as u16)"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.code,{children:"(873u16 as u32)"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.code,{children:"(2u8 as u64)"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.code,{children:"(1 + 3 as u128)"})}),"\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.code,{children:"(4/2 + 12345 as u256)"})}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"ownership",children:"Ownership"}),"\n",(0,n.jsxs)(i.p,{children:["As with the other scalar values built-in to the language, integer values are implicitly copyable,\nmeaning they can be copied without an explicit instruction such as\n",(0,n.jsx)(i.a,{href:"./../variables#move-and-copy",children:(0,n.jsx)(i.code,{children:"copy"})}),"."]})]})}function a(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(o,{...e})}):o(e)}},4811:(e,i,t)=>{t.d(i,{R:()=>d,x:()=>l});var s=t(9378);const n={},r=s.createContext(n);function d(e){const i=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:d(e.components),s.createElement(r.Provider,{value:i},e.children)}}}]);