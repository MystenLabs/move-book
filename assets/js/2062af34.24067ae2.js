"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9405],{4811:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>l});var t=s(9378);const i={},o=t.createContext(i);function d(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),t.createElement(o.Provider,{value:n},e.children)}},9549:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>d,metadata:()=>t,toc:()=>r});const t=JSON.parse('{"id":"move-advanced/modes","title":"Modes","description":"Modes let you include unpublishable code only when you explicitly opt into a named build mode.","source":"@site/../book/move-advanced/modes.md","sourceDirName":"move-advanced","slug":"/move-advanced/modes","permalink":"/move-advanced/modes","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"Advanced Move Usage","permalink":"/move-advanced/"},"next":{"title":"2024 Migration Guide","permalink":"/guides/2024-migration-guide"}}');var i=s(2714),o=s(4811);const d={},l="Modes",a={},r=[{value:"Syntax",id:"syntax",level:2},{value:"Building with modes",id:"building-with-modes",level:2},{value:"Example \u2014 <code>test</code> mode (unit tests)",id:"example--test-mode-unit-tests",level:3},{value:"Example 2: Debug testing",id:"example-2-debug-testing",level:3},{value:"Publication",id:"publication",level:2},{value:"See also",id:"see-also",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"modes",children:"Modes"})}),"\n",(0,i.jsxs)(n.p,{children:["Modes let you include ",(0,i.jsx)(n.strong,{children:"unpublishable"})," code only when you explicitly opt into a named build ",(0,i.jsx)(n.code,{children:"mode"}),".\nThink of them as generalizations of the ",(0,i.jsx)(n.code,{children:"#[test_only]"})," ",(0,i.jsx)(n.a,{href:"../move-basics/testing",children:"test annotation"})," for\nany purpose you choose (e.g. ",(0,i.jsx)(n.code,{children:"debug"}),", ",(0,i.jsx)(n.code,{children:"benchmark"}),", ",(0,i.jsx)(n.code,{children:"spec"}),", or any other feature)."]}),"\n",(0,i.jsx)(n.p,{children:"Modes at a glance:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Annotate items with ",(0,i.jsx)(n.code,{children:"#[mode(name, ...)]"})," or use the shorthand ",(0,i.jsx)(n.code,{children:"#[test_only]"})," for the built-in\n",(0,i.jsx)(n.code,{children:"test"})," mode.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"#[test_only]"})," attribute is syntactic sugar for ",(0,i.jsx)(n.code,{children:"#[mode(test)]"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Build with ",(0,i.jsx)(n.code,{children:"--mode <name>"})," (or ",(0,i.jsx)(n.code,{children:"--test"})," for unit testing). Items whose mode list contains a name\nyou enabled are compiled in. Items whose mode list does ",(0,i.jsx)(n.strong,{children:"not"})," match are compiled ",(0,i.jsx)(n.strong,{children:"out"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Code compiled with any mode enabled is ",(0,i.jsx)(n.strong,{children:"not publishable"}),". This keeps debug/test scaffolding from\never making it on-chain."]}),"\n",(0,i.jsxs)(n.li,{children:["Items with ",(0,i.jsx)(n.strong,{children:"no"})," ",(0,i.jsx)(n.code,{children:"#[mode(...)]"}),"/",(0,i.jsx)(n.code,{children:"#[test_only]"})," annotation are always included."]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Tip: Modes are filters enforced at compile-time\u2014they don\u2019t affect bytecode at runtime. Use them\nfor helpers, simulators, and other mock types and functions that should never be published."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,i.jsxs)(n.p,{children:["Like ",(0,i.jsx)(n.code,{children:"#[test_only]"}),", You can attach a mode attribute to modules and to individual members:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"// Entire module is included only when a matching mode is enabled\n#[mode(debug)]\nmodule my_pkg::debug_tools {\n    public fun dump_state() { /* ... */ }\n}\n\nmodule my_pkg::library {\n    // This function exists only in `debug` or `test` builds\n    #[mode(debug, test)]\n    public fun assert_invariants() { /* ... */ }\n\n    // Test-only helper; equivalent to #[mode(test)]\n    #[test_only]\n    fun mk_fake() { /* ... */ }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As we can see here, multiple modes can be listed in a single attribute: ",(0,i.jsx)(n.code,{children:"#[mode(name1,name2,...)]"}),".\nThis item will be included during compilation if ",(0,i.jsx)(n.strong,{children:"any"})," of the listed names is enabled. In\naddition, any definition without a mode annotation is always included."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Tip: The annotation ",(0,i.jsx)(n.code,{children:"#[mode(test)]"})," is equivalent to ",(0,i.jsx)(n.code,{children:"#[test_only]"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"building-with-modes",children:"Building with modes"}),"\n",(0,i.jsx)(n.p,{children:"Use the Sui CLI to opt into a mode when building or testing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Build with a custom mode enabled\nsui move build --mode debug\n\n# Run tests; includes #[test_only] automatically\nsui move test --test\n\n# Combine: run unit tests with extra debug helpers\nsui move test --test --mode debug\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Items annotated with a mode you enabled are compiled ",(0,i.jsx)(n.strong,{children:"in"}),"; items annotated with a different,\nnon-enabled mode are compiled ",(0,i.jsx)(n.strong,{children:"out"}),". Unannotated items are always compiled in."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Publish safety"}),": Any artifact produced while a mode is enabled (including ",(0,i.jsx)(n.code,{children:"--test"}),") is non-publishable. Always run a clean build ",(0,i.jsx)(n.strong,{children:"without"})," ",(0,i.jsx)(n.code,{children:"--mode"}),"/",(0,i.jsx)(n.code,{children:"--test"})," before ",(0,i.jsx)(n.code,{children:"sui client publish"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"example--test-mode-unit-tests",children:["Example \u2014 ",(0,i.jsx)(n.code,{children:"test"})," mode (unit tests)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"#[test_only]"})," is the built-in mode for unit testing. It works exactly like a mode named ",(0,i.jsx)(n.code,{children:"test"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"#[mode(test)]\nmodule my_pkg::math_tests {\n    use my_pkg::math;\n\n    #[modetest]\n    fun add_basic() { /* ... */ }\n\n    // Private test helper\n    fun mk_case() { /* ... */ }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"To build and run:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Includes modules and members marked #[test_only]\nsui move test --test\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As described in the ",(0,i.jsx)(n.a,{href:"../move-basics/testing",children:"testing"})," documentation, this is a great way to\nkeep test helpers and test-only public functions out of published packages."]}),"\n",(0,i.jsx)(n.h3,{id:"example-2-debug-testing",children:"Example 2: Debug testing"}),"\n",(0,i.jsxs)(n.p,{children:["Suppose you have a ",(0,i.jsx)(n.code,{children:"bank"})," module with a ",(0,i.jsx)(n.code,{children:"transfer"})," function. You want to add debug logging in test\nruns where you can see internal state, but you only want to run that test with those logs during\ndevelopment (e.g., not during CI, etc). You can use a ",(0,i.jsx)(n.code,{children:"debug"})," mode for this."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:'module my_pkg::bank {\n    use std::error;\n\n    public fun transfer(from: &signer, to: address, amount: u64) {\n        // ... production logic ...\n    }\n}\n\n// Debug-only wrappers & helpers\n#[mode(debug)]\nmodule my_pkg::bank_debug {\n    use std::debug;\n    use my_pkg::bank;\n\n    public fun transfer_debug(from: &signer, to: address, amount: u64) {\n        // Perform debugging prints before the real call\n        debug::print(&b"[DEBUG] transfer begin".to_vector());\n        debug::print(&amount);\n        debug::print(&to);\n        // Main Call\n        bank::transfer(from, to, amount);\n        // More debugging prints\n        debug::print(&b"[DEBUG] transfer end".to_vector());\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Here, ",(0,i.jsx)(n.code,{children:"bank::transfer"})," is the ",(0,i.jsx)(n.strong,{children:"only"})," production entry point, with not printing. The\n",(0,i.jsx)(n.code,{children:"#[mode(debug)]"})," exposes ",(0,i.jsx)(n.code,{children:"bank_debug::{transfer_debug, dump_account, ...}"}),", however, which will\n",(0,i.jsx)(n.strong,{children:"only"})," be included in ",(0,i.jsx)(n.code,{children:"debug"}),"-mode builds. Now, we can write tests that use this extra visibility\nwithout affecting production code or other tests:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"#[test_only]\nmodule my_pkg::bank_tests {\n    use my_pkg::bank;\n\n    // Runs in all builds (no mode needed)\n    #[test]\n    fun transfer_basic() {\n        // create signers, call bank::transfer(...)\n    }\n\n    // Runs only with `--test --mode debug`\n    #[mode(debug)]\n    #[test]\n    fun transfer_with_logs() {\n        use my_pkg::bank_debug; // only exists in debug builds\n        // create signers, then:\n        bank_debug::transfer_debug(&signer, @bob, 100);\n        // assertions same as normal test; plus you see prints\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now we can execute this test with extra logging by enabling the ",(0,i.jsx)(n.code,{children:"debug"})," mode:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Standard tests (no debug helpers compiled in)\nsui move test\n\n# Debug tests with extra logging\nsui move test --mode debug\n"})}),"\n",(0,i.jsx)(n.p,{children:"This allows us to produce production bytecode, continuous integration tests, and debug logging\ntests, each at different times, without code duplication or complex branching."}),"\n",(0,i.jsx)(n.h2,{id:"publication",children:"Publication"}),"\n",(0,i.jsxs)(n.p,{children:["Code built with any mode enabled is non-publishable. Always do a clean build without ",(0,i.jsx)(n.code,{children:"--mode"})," or\n",(0,i.jsx)(n.code,{children:"--test"})," before publishing:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"sui move build   # no --mode, no --test\n"})}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../move-basics/testing",children:"Testing basics"})," in the Move Book."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/reference/modes",children:"Modes"})," in the Move Reference."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);