"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4173],{5521:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>u});var s=t(6672);const r={},i=s.createContext(r);function l(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function u(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(i.Provider,{value:n},e.children)}},8399:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>u,default:()=>d,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"primitive-types/tuples","title":"Tuples and Unit | Reference","description":"","source":"@site/../reference/primitive-types/tuples.md","sourceDirName":"primitive-types","slug":"/primitive-types/tuples","permalink":"/reference/primitive-types/tuples","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Tuples and Unit | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"2.5 References","permalink":"/reference/primitive-types/references"},"next":{"title":"3. Local Variables and Scopes","permalink":"/reference/variables"}}');var r=t(3420),i=t(5521);const l={title:"Tuples and Unit | Reference",description:""},u="Tuples and Unit",a={},o=[{value:"Literals",id:"literals",level:2},{value:"Examples",id:"examples",level:3},{value:"Operations",id:"operations",level:2},{value:"Destructuring",id:"destructuring",level:3},{value:"Subtyping",id:"subtyping",level:2},{value:"Ownership",id:"ownership",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"tuples-and-unit",children:"Tuples and Unit"})}),"\n",(0,r.jsxs)(n.p,{children:["Move does not fully support tuples as one might expect coming from another language with them as a\n",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/First-class_citizen",children:"first-class value"}),". However, in order to support\nmultiple return values, Move has tuple-like expressions. These expressions do not result in a\nconcrete value at runtime (there are no tuples in the bytecode), and as a result they are very\nlimited:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"They can only appear in expressions (usually in the return position for a function)."}),"\n",(0,r.jsx)(n.li,{children:"They cannot be bound to local variables."}),"\n",(0,r.jsx)(n.li,{children:"They cannot be bound to local variables."}),"\n",(0,r.jsx)(n.li,{children:"They cannot be stored in structs."}),"\n",(0,r.jsx)(n.li,{children:"Tuple types cannot be used to instantiate generics."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Similarly, ",(0,r.jsxs)(n.a,{href:"https://en.wikipedia.org/wiki/Unit_type",children:["unit ",(0,r.jsx)(n.code,{children:"()"})]})," is a type created by the Move source\nlanguage in order to be expression based. The unit value ",(0,r.jsx)(n.code,{children:"()"})," does not result in any runtime value.\nWe can consider unit",(0,r.jsx)(n.code,{children:"()"})," to be an empty tuple, and any restrictions that apply to tuples also apply\nto unit."]}),"\n",(0,r.jsxs)(n.p,{children:["It might feel weird to have tuples in the language at all given these restrictions. But one of the\nmost common use cases for tuples in other languages is for functions to allow functions to return\nmultiple values. Some languages work around this by forcing the users to write structs that contain\nthe multiple return values. However in Move, you cannot put references inside of\n",(0,r.jsx)(n.a,{href:"./../structs",children:"structs"}),". This required Move to support multiple return values. These multiple return\nvalues are all pushed on the stack at the bytecode level. At the source level, these multiple return\nvalues are represented using tuples."]}),"\n",(0,r.jsx)(n.h2,{id:"literals",children:"Literals"}),"\n",(0,r.jsx)(n.p,{children:"Tuples are created by a comma separated list of expressions inside of parentheses."}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Syntax"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"(): ()"})}),(0,r.jsx)(n.td,{children:"Unit, the empty tuple, or the tuple of arity 0"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"(e1, ..., en)"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"(e1, ..., en): (T1, ..., Tn)"})," where ",(0,r.jsx)(n.code,{children:"e_i: Ti"})," s.t. ",(0,r.jsx)(n.code,{children:"0 < i <= n"})," and ",(0,r.jsx)(n.code,{children:"n > 0"})]}),(0,r.jsxs)(n.td,{children:["A ",(0,r.jsx)(n.code,{children:"n"}),"-tuple, a tuple of arity ",(0,r.jsx)(n.code,{children:"n"}),", a tuple with ",(0,r.jsx)(n.code,{children:"n"})," elements"]})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["Note that ",(0,r.jsx)(n.code,{children:"(e)"})," does not have type ",(0,r.jsx)(n.code,{children:"(e): (t)"}),", in other words there is no tuple with one element. If\nthere is only a single element inside of the parentheses, the parentheses are only used for\ndisambiguation and do not carry any other special meaning."]}),"\n",(0,r.jsx)(n.p,{children:'Sometimes, tuples with two elements are called "pairs" and tuples with three elements are called\n"triples."'}),"\n",(0,r.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:'module 0::example;\n\n// all 3 of these functions are equivalent\n\n// when no return type is provided, it is assumed to be `()`\nfun returns_unit_1() { }\n\n// there is an implicit () value in empty expression blocks\nfun returns_unit_2(): () { }\n\n// explicit version of `returns_unit_1` and `returns_unit_2`\nfun returns_unit_3(): () { () }\n\n\nfun returns_3_values(): (u64, bool, address) {\n    (0, false, @0x42)\n}\nfun returns_4_values(x: &u64): (&u64, u8, u128, vector<u8>) {\n    (x, 0, 1, b"foobar")\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"operations",children:"Operations"}),"\n",(0,r.jsx)(n.p,{children:"The only operation that can be done on tuples currently is destructuring."}),"\n",(0,r.jsx)(n.h3,{id:"destructuring",children:"Destructuring"}),"\n",(0,r.jsxs)(n.p,{children:["For tuples of any size, they can be destructured in either a ",(0,r.jsx)(n.code,{children:"let"})," binding or in an assignment."]}),"\n",(0,r.jsx)(n.p,{children:"For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:'module 0x42::example;\n\n// all 3 of these functions are equivalent\nfun returns_unit() {}\nfun returns_2_values(): (bool, bool) { (true, false) }\nfun returns_4_values(x: &u64): (&u64, u8, u128, vector<u8>) { (x, 0, 1, b"foobar") }\n\nfun examples(cond: bool) {\n    let () = ();\n    let (mut x, mut y): (u8, u64) = (0, 1);\n    let (mut a, mut b, mut c, mut d) = (@0x0, 0, false, b"");\n\n    () = ();\n    (x, y) = if (cond) (1, 2) else (3, 4);\n    (a, b, c, d) = (@0x1, 1, true, b"1");\n}\n\nfun examples_with_function_calls() {\n    let () = returns_unit();\n    let (mut x, mut y): (bool, bool) = returns_2_values();\n    let (mut a, mut b, mut c, mut d) = returns_4_values(&0);\n\n    () = returns_unit();\n    (x, y) = returns_2_values();\n    (a, b, c, d) = returns_4_values(&1);\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["For more details, see ",(0,r.jsx)(n.a,{href:"./../variables",children:"Move Variables"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"subtyping",children:"Subtyping"}),"\n",(0,r.jsxs)(n.p,{children:["Along with references, tuples are the only types that have\n",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Subtyping",children:"subtyping"})," in Move. Tuples have subtyping only in the\nsense that subtype with references (in a covariant way)."]}),"\n",(0,r.jsx)(n.p,{children:"For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"let x: &u64 = &0;\nlet y: &mut u64 = &mut 1;\n\n// (&u64, &mut u64) is a subtype of (&u64, &u64)\n// since &mut u64 is a subtype of &u64\nlet (a, b): (&u64, &u64) = (x, y);\n\n// (&mut u64, &mut u64) is a subtype of (&u64, &u64)\n// since &mut u64 is a subtype of &u64\nlet (c, d): (&u64, &u64) = (y, y);\n\n// highlight-error-start\n// ERROR! (&u64, &mut u64) is NOT a subtype of (&mut u64, &mut u64)\n// since &u64 is NOT a subtype of &mut u64\nlet (e, f): (&mut u64, &mut u64) = (x, y);\n// highlight-error-end\n"})}),"\n",(0,r.jsx)(n.h2,{id:"ownership",children:"Ownership"}),"\n",(0,r.jsx)(n.p,{children:"As mentioned above, tuple values don't really exist at runtime. And currently they cannot be stored\ninto local variables because of this (but it is likely that this feature will come at some point in\nthe future). As such, tuples can only be moved currently, as copying them would require putting them\ninto a local variable first."})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);