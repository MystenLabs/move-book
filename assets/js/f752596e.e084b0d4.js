"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2394],{922:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"move-basics/type-reflection","title":"Type Reflection","description":"In programming languages, reflection is the ability of a program to examine and modify its own","source":"@site/../book/move-basics/type-reflection.md","sourceDirName":"move-basics","slug":"/move-basics/type-reflection","permalink":"/move-basics/type-reflection","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.24. Generics","permalink":"/move-basics/generics"},"next":{"title":"5.26. Testing","permalink":"/move-basics/testing"}}');var r=i(3420),s=i(5521);const a={},o="Type Reflection",d={},l=[{value:"Defining IDs vs. Original IDs",id:"defining-ids-vs-original-ids",level:2},{value:"In practice",id:"in-practice",level:2},{value:"Further Reading",id:"further-reading",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"type-reflection",children:"Type Reflection"})}),"\n",(0,r.jsxs)(n.p,{children:["In programming languages, ",(0,r.jsx)(n.em,{children:"reflection"})," is the ability of a program to examine and modify its own\nstructure and behavior. Move supports a limited form of reflection that lets you inspect the type of\na value at runtime. This is handy when you need to store type information in a homogeneous\ncollection, or when you want to check if a type comes from a particular package."]}),"\n",(0,r.jsxs)(n.p,{children:["Type reflection is implemented in the ",(0,r.jsx)(n.a,{href:"./standard-library",children:"Standard Library"})," module\n",(0,r.jsx)(n.a,{href:"https://docs.sui.io/references/framework/std/type_name",children:(0,r.jsx)(n.code,{children:"std::type_name"})}),". It provides a set of functions, main of which are\n",(0,r.jsx)(n.code,{children:"with_defining_ids"})," and ",(0,r.jsx)(n.code,{children:"with_original_ids"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:'let defining_type_name: TypeName = type_name::with_defining_ids<T>();\nlet original_type_name: TypeName = type_name::with_original_ids<T>();\n\n// Returns only "ID" of the package.\nlet defining_package: address = type_name::defining_id<T>();\nlet original_package: address = type_name::original_id<T>();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"defining-ids-vs-original-ids",children:"Defining IDs vs. Original IDs"}),"\n",(0,r.jsxs)(n.p,{children:["It is important to understand the difference between ",(0,r.jsx)(n.em,{children:"defining ID"})," and ",(0,r.jsx)(n.em,{children:"original ID"}),"."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Original ID is the first published ID of the package (before the first upgrade)."}),"\n",(0,r.jsx)(n.li,{children:"Defining ID is the package ID which introduced the reflected type, this property becomes crucial\nwhen new types are introduced in package upgrades."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["For example, suppose the first version of a package was published at ",(0,r.jsx)(n.code,{children:"0xA"})," and introduced the type\n",(0,r.jsx)(n.code,{children:"Version1"}),". Later, in an upgrade, the package moved to address ",(0,r.jsx)(n.code,{children:"0xB"})," and introduced a new type\n",(0,r.jsx)(n.code,{children:"Version2"}),". For ",(0,r.jsx)(n.code,{children:"Version1"}),", the defining ID and original ID are the same. For ",(0,r.jsx)(n.code,{children:"Version2"}),", however,\nthey differ: the original ID is ",(0,r.jsx)(n.code,{children:"0xA"}),", while the defining ID is ",(0,r.jsx)(n.code,{children:"0xB"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",children:"// Note: values `0xA` and `0xB` are used for illustration purposes only!\n// Don't attempt to run this code, as it will inevitably fail.\nmodule book::upgrade;\n\n// Introduced in initial version.\n// Defining ID: 0xA\n// Original ID: 0xA\n//\n// With Defining IDs: 0xA::upgrade::Version1\n// With Original IDs: 0xA::upgrade::Version1\npublic struct Version1 has drop {}\n\n// Introduced in a package upgrade.\n// Defining ID: 0xB\n// highlight-important\n// Original ID: 0xA\n//\n// With Defining IDs: 0xB::upgrade::Version2\n// highlight-important\n// With Original IDs: 0xA::upgrade::Version2\npublic struct Version2 has drop {}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"in-practice",children:"In practice"}),"\n",(0,r.jsx)(n.p,{children:"The module is straightforward, and operations allowed on the result are limited to getting a string\nrepresentation and extracting the module and address of the type."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/type-reflection.move anchor=main",children:'module book::type_reflection;\n\nuse std::ascii::String;\nuse std::type_name::{Self, TypeName};\n\n/// A function that returns the name of the type `T` and its module and address.\npublic fun do_i_know_you<T>(): (String, String, String) {\n    let type_name: TypeName = type_name::with_defining_ids<T>();\n\n    // there\'s a way to borrow\n    let str: &String = type_name.as_string();\n\n    let module_name: String = type_name.module_string();\n    let address_str: String = type_name.address_string();\n\n    // and a way to consume the value\n    let str = type_name.into_string();\n\n    (str, module_name, address_str)\n}\n\n#[test_only]\npublic struct MyType {}\n\n#[test_only]\nuse std::unit_test::assert_eq;\n\n#[test]\nfun test_type_reflection() {\n    let (type_name, module_name, _address_str) = do_i_know_you<MyType>();\n\n    assert_eq!(module_name, b"type_reflection".to_ascii_string());\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://docs.sui.io/references/framework/std/type_name",children:"std::type_name"})," module documentation."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},5521:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(6672);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);