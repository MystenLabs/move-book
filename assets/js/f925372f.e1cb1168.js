"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8885],{1107:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"equality","title":"Equality | Reference","description":"","source":"@site/../reference/equality.md","sourceDirName":".","slug":"/equality","permalink":"/reference/equality","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Equality | Reference","description":""},"sidebar":"referenceSidebar","previous":{"title":"3. Local Variables and Scopes","permalink":"/reference/variables"},"next":{"title":"Abort and Assert | Reference","permalink":"/reference/abort-and-assert"}}');var s=t(3420),i=t(5521);const a={title:"Equality | Reference",description:""},o="Equality",c={},l=[{value:"Operations",id:"operations",level:2},{value:"Typing",id:"typing",level:3},{value:"Typing with references",id:"typing-with-references",level:3},{value:"Automatic Borrowing",id:"automatic-borrowing",level:3},{value:"Restrictions",id:"restrictions",level:2},{value:"Avoid Extra Copies",id:"avoid-extra-copies",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"equality",children:"Equality"})}),"\n",(0,s.jsxs)(n.p,{children:["Move supports two equality operations ",(0,s.jsx)(n.code,{children:"=="})," and ",(0,s.jsx)(n.code,{children:"!="})]}),"\n",(0,s.jsx)(n.h2,{id:"operations",children:"Operations"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Syntax"}),(0,s.jsx)(n.th,{children:"Operation"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"=="})}),(0,s.jsx)(n.td,{children:"equal"}),(0,s.jsxs)(n.td,{children:["Returns ",(0,s.jsx)(n.code,{children:"true"})," if the two operands have the same value, ",(0,s.jsx)(n.code,{children:"false"})," otherwise"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"!="})}),(0,s.jsx)(n.td,{children:"not equal"}),(0,s.jsxs)(n.td,{children:["Returns ",(0,s.jsx)(n.code,{children:"true"})," if the two operands have different values, ",(0,s.jsx)(n.code,{children:"false"})," otherwise"]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"typing",children:"Typing"}),"\n",(0,s.jsxs)(n.p,{children:["Both the equal (",(0,s.jsx)(n.code,{children:"=="}),") and not-equal (",(0,s.jsx)(n.code,{children:"!="}),") operations only work if both operands are the same type"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:'0 == 0; // `true`\n1u128 == 2u128; // `false`\nb"hello" != x"00"; // `true`\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Equality and non-equality also work over ",(0,s.jsx)(n.em,{children:"all"})," user defined types!"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:'module 0::example;\n\npublic struct S has copy, drop { f: u64, s: vector<u8> }\n\nfun always_true(): bool {\n    let s = S { f: 0, s: b"" };\n    s == s\n}\n\nfun always_false(): bool {\n    let s = S { f: 0, s: b"" };\n    s != s\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"If the operands have different types, there is a type checking error"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"1u8 == 1u128; // ERROR!\n//     ^^^^^ expected an argument of type 'u8'\nb\"\" != 0; // ERROR!\n//     ^ expected an argument of type 'vector<u8>'\n"})}),"\n",(0,s.jsx)(n.h3,{id:"typing-with-references",children:"Typing with references"}),"\n",(0,s.jsxs)(n.p,{children:["When comparing ",(0,s.jsx)(n.a,{href:"./primitive-types/references",children:"references"}),", the type of the reference (immutable or\nmutable) does not matter. This means that you can compare an immutable ",(0,s.jsx)(n.code,{children:"&"})," reference with a mutable\none ",(0,s.jsx)(n.code,{children:"&mut"})," of the same underlying type."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let i = &0;\nlet m = &mut 1;\n\ni == m; // `false`\nm == i; // `false`\nm == m; // `true`\ni == i; // `true`\n"})}),"\n",(0,s.jsx)(n.p,{children:"The above is equivalent to applying an explicit freeze to each mutable reference where needed"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let i = &0;\nlet m = &mut 1;\n\ni == freeze(m); // `false`\nfreeze(m) == i; // `false`\nm == m; // `true`\ni == i; // `true`\n"})}),"\n",(0,s.jsx)(n.p,{children:"But again, the underlying type must be the same type"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let i = &0;\nlet s = &b\"\";\n\ni == s; // ERROR!\n//   ^ expected an argument of type '&u64'\n"})}),"\n",(0,s.jsx)(n.h3,{id:"automatic-borrowing",children:"Automatic Borrowing"}),"\n",(0,s.jsxs)(n.p,{children:["Starting in Move 2024 edition, the ",(0,s.jsx)(n.code,{children:"=="})," and ",(0,s.jsx)(n.code,{children:"!="})," operators automatically borrow their operands if\none of the operands is a reference and the other is not. This means that the following code works\nwithout any errors:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let r = &0;\n\n// In all cases, `0` is automatically borrowed as `&0`\nr == 0; // `true`\n0 == r; // `true`\nr != 0; // `false`\n0 != r; // `false`\n"})}),"\n",(0,s.jsx)(n.p,{children:"This automatic borrow is always an immutable borrow."}),"\n",(0,s.jsx)(n.h2,{id:"restrictions",children:"Restrictions"}),"\n",(0,s.jsxs)(n.p,{children:["Both ",(0,s.jsx)(n.code,{children:"=="})," and ",(0,s.jsx)(n.code,{children:"!="})," consume the value when comparing them. As a result, the type system enforces that\nthe type must have ",(0,s.jsx)(n.a,{href:"./abilities",children:(0,s.jsx)(n.code,{children:"drop"})}),". Recall that without the ",(0,s.jsxs)(n.a,{href:"./abilities",children:[(0,s.jsx)(n.code,{children:"drop"})," ability"]}),",\nownership must be transferred by the end of the function, and such values can only be explicitly\ndestroyed within their declaring module. If these were used directly with either equality ",(0,s.jsx)(n.code,{children:"=="})," or\nnon-equality ",(0,s.jsx)(n.code,{children:"!="}),", the value would be destroyed which would break ",(0,s.jsxs)(n.a,{href:"./abilities",children:[(0,s.jsx)(n.code,{children:"drop"})," ability"]}),"\nsafety guarantees!"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module 0::example;\n\npublic struct Coin has store { value: u64 }\nfun invalid(c1: Coin, c2: Coin) {\n    c1 == c2 // ERROR!\n//  ^^    ^^ These assets would be destroyed!\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["But, a programmer can ",(0,s.jsx)(n.em,{children:"always"})," borrow the value first instead of directly comparing the value, and\nreference types have the ",(0,s.jsxs)(n.a,{href:"./abilities",children:[(0,s.jsx)(n.code,{children:"drop"})," ability"]}),". For example"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module 0::example;\n\npublic struct Coin has store { value: u64 }\nfun swap_if_equal(c1: Coin, c2: Coin): (Coin, Coin) {\n    let are_equal = &c1 == c2; // valid, note `c2` is automatically borrowed\n    if (are_equal) (c2, c1) else (c1, c2)\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"avoid-extra-copies",children:"Avoid Extra Copies"}),"\n",(0,s.jsxs)(n.p,{children:["While a programmer ",(0,s.jsx)(n.em,{children:"can"})," compare any value whose type has ",(0,s.jsx)(n.a,{href:"./abilities",children:(0,s.jsx)(n.code,{children:"drop"})}),", a programmer should\noften compare by reference to avoid expensive copies."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let v1: vector<u8> = function_that_returns_vector();\nlet v2: vector<u8> = function_that_returns_vector();\nassert!(copy v1 == copy v2, 42);\n//      ^^^^       ^^^^\nuse_two_vectors(v1, v2);\n\nlet s1: Foo = function_that_returns_large_struct();\nlet s2: Foo = function_that_returns_large_struct();\nassert!(copy s1 == copy s2, 42);\n//      ^^^^       ^^^^\nuse_two_foos(s1, s2);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This code is perfectly acceptable (assuming ",(0,s.jsx)(n.code,{children:"Foo"})," has ",(0,s.jsx)(n.a,{href:"./abilities",children:(0,s.jsx)(n.code,{children:"drop"})}),"), just not efficient.\nThe highlighted copies can be removed and replaced with borrows"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"let v1: vector<u8> = function_that_returns_vector();\nlet v2: vector<u8> = function_that_returns_vector();\nassert!(&v1 == &v2, 42);\n//      ^      ^\nuse_two_vectors(v1, v2);\n\nlet s1: Foo = function_that_returns_large_struct();\nlet s2: Foo = function_that_returns_large_struct();\nassert!(&s1 == &s2, 42);\n//      ^      ^\nuse_two_foos(s1, s2);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The efficiency of the ",(0,s.jsx)(n.code,{children:"=="})," itself remains the same, but the ",(0,s.jsx)(n.code,{children:"copy"}),"s are removed and thus the program\nis more efficient."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},5521:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6672);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);