"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2121],{3473:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"storage/storage-functions","title":"Storage Functions","description":"The module that defines main storage operations is sui::transfer. It is implicitly imported in all","source":"@site/../book/storage/storage-functions.md","sourceDirName":"storage","slug":"/storage/storage-functions","permalink":"/storage/storage-functions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"7.1. Ability: Key","permalink":"/storage/key-ability"},"next":{"title":"7.3. Ability: Store","permalink":"/storage/store-ability"}}');var i=t(3420),a=t(5521);const c={},r="Storage Functions",o={},l=[{value:"Overview",id:"overview",level:2},{value:"Ownership and References: a Quick Recap",id:"ownership-and-references-a-quick-recap",level:2},{value:"Transfer",id:"transfer",level:2},{value:"Freeze",id:"freeze",level:2},{value:"Owned -&gt; Frozen",id:"owned---frozen",level:2},{value:"Share",id:"share",level:2},{value:"Special Case: Shared Object Deletion",id:"special-case-shared-object-deletion",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"storage-functions",children:"Storage Functions"})}),"\n",(0,i.jsxs)(n.p,{children:["The module that defines main storage operations is ",(0,i.jsx)(n.code,{children:"sui::transfer"}),". It is implicitly imported in all\npackages that depend on the ",(0,i.jsx)(n.a,{href:"./../programmability/sui-framework",children:"Sui Framework"}),", so, like other\nimplicitly imported modules (e.g. ",(0,i.jsx)(n.code,{children:"std::option"})," or ",(0,i.jsx)(n.code,{children:"std::vector"}),"), it does not require adding a use\nstatement."]}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"transfer"})," module provides functions to perform all three storage operations matching\n",(0,i.jsx)(n.a,{href:"./../object/ownership",children:"ownership types"})," which we explained:"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["On this page we will only talk about so-called ",(0,i.jsx)(n.em,{children:"restricted"})," storage operations, later we will\ncover ",(0,i.jsx)(n.em,{children:"public"})," ones, after the ",(0,i.jsx)(n.code,{children:"store"})," ability is introduced."]}),"\n"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Transfer"})," - send an object to an address, put it into ",(0,i.jsx)(n.em,{children:"account owned"})," state;"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Share"})," - put an object into a ",(0,i.jsx)(n.em,{children:"shared"})," state, so it is available to everyone;"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Freeze"})," - put an object into ",(0,i.jsx)(n.em,{children:"immutable"})," state, so it becomes a public constant and can never\nchange."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"transfer"})," module is a go-to for most of the storage operations, except a special case with\n",(0,i.jsx)(n.a,{href:"./../programmability/dynamic-fields",children:"Dynamic Fields"})," that awaits us in the next chapter."]}),"\n",(0,i.jsx)(n.h2,{id:"ownership-and-references-a-quick-recap",children:"Ownership and References: a Quick Recap"}),"\n",(0,i.jsxs)(n.p,{children:["In the ",(0,i.jsx)(n.a,{href:"./../move-basics/ownership-and-scope",children:"Ownership and Scope"})," and\n",(0,i.jsx)(n.a,{href:"./../move-basics/references",children:"References"})," chapters, we covered the basics of ownership and\nreferences in Move. It is important that you understand these concepts when using storage functions.\nHere is a quick recap of the most important points:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.em,{children:"move"})," semantics in Move means that the value is ",(0,i.jsx)(n.em,{children:"moved"})," from one scope to another. In other\nwords, if an instance of a type is passed to a function ",(0,i.jsx)(n.em,{children:"by value"}),", it is ",(0,i.jsx)(n.em,{children:"moved"})," to the function\nscope and can't be accessed in the caller scope anymore."]}),"\n",(0,i.jsxs)(n.li,{children:["To maintain the ownership of the value, you can pass it ",(0,i.jsx)(n.em,{children:"by reference"}),". Either by ",(0,i.jsx)(n.em,{children:"immutable\nreference"})," ",(0,i.jsx)(n.code,{children:"&T"})," or ",(0,i.jsx)(n.em,{children:"mutable reference"})," ",(0,i.jsx)(n.code,{children:"&mut T"}),". Then the value is ",(0,i.jsx)(n.em,{children:"borrowed"})," and can be accessed\nin the callee scope, however the owner stays the same."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"/// Moved by value\npublic fun take<T>(value: T) { /* value is moved here! */ abort 0 }\n\n/// For immutable reference\npublic fun borrow<T>(value: &T) { /* value is borrowed here! can be read */ abort 0 }\n\n/// For mutable reference\npublic fun borrow_mut<T>(value: &mut T) { /* value is mutably borrowed here! */ abort 0 }\n"})}),"\n",(0,i.jsx)(n.h2,{id:"transfer",children:"Transfer"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"transfer::transfer"})," function is a public function used to transfer an object to another\naddress. Its signature is as follows, only accepts a type with the ",(0,i.jsxs)(n.a,{href:"./key-ability",children:[(0,i.jsx)(n.code,{children:"key"})," ability"]}),"\nand an ",(0,i.jsx)(n.a,{href:"./../move-basics/address",children:"address"})," of the recipient. Please, note that the object is\npassed into the function ",(0,i.jsx)(n.em,{children:"by value"}),", therefore it is ",(0,i.jsx)(n.em,{children:"moved"})," to the function scope and then moved to\nthe recipient address:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module sui::transfer;\n\npublic fun transfer<T: key>(obj: T, recipient: address);\n"})}),"\n",(0,i.jsx)(n.p,{children:"In the next example, you can see how it can be used in a module that defines and sends an object to\nthe transaction sender."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module book::transfer_to_sender;\n\n/// A struct with `key` is an object. The first field is `id: UID`!\npublic struct AdminCap has key { id: UID }\n\n/// `init` function is a special function that is called when the module\n/// is published. It is a good place to create application objects.\nfun init(ctx: &mut TxContext) {\n    // Create a new `AdminCap` object, in this scope.\n    let admin_cap = AdminCap { id: object::new(ctx) };\n\n    // Transfer the object to the transaction sender.\n    transfer::transfer(admin_cap, ctx.sender());\n\n    // admin_cap is gone! Can't be accessed anymore.\n}\n\n/// Transfers the `AdminCap` object to the `recipient`. Thus, the recipient\n/// becomes the owner of the object, and only they can access it.\npublic fun transfer_admin_cap(cap: AdminCap, recipient: address) {\n    transfer::transfer(cap, recipient);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When the module is published, the ",(0,i.jsx)(n.code,{children:"init"})," function will get called, and the ",(0,i.jsx)(n.code,{children:"AdminCap"})," object which\nwe created there will be ",(0,i.jsx)(n.em,{children:"transferred"})," to the transaction sender. The ",(0,i.jsx)(n.code,{children:"ctx.sender()"})," function\nreturns the sender address for the current transaction."]}),"\n",(0,i.jsxs)(n.p,{children:["Once the ",(0,i.jsx)(n.code,{children:"AdminCap"})," has been transferred to the sender, for example, to ",(0,i.jsx)(n.code,{children:"0xa11ce"}),", the sender, and\nonly the sender, will be able to access the object. The object is now ",(0,i.jsx)(n.em,{children:"account owned"}),"."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Account owned objects are a subject to ",(0,i.jsx)(n.em,{children:"true ownership"})," - only the account owner can access them.\nThis is a fundamental concept in the Sui storage model."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Let's extend the example with a function that uses ",(0,i.jsx)(n.code,{children:"AdminCap"})," to authorize a mint of a new object\nand its transfer to another address:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"/// Some `Gift` object that the admin can `mint_and_transfer`.\npublic struct Gift has key { id: UID }\n\n/// Creates a new `Gift` object and transfers it to the `recipient`.\npublic fun mint_and_transfer(\n    _: &AdminCap, recipient: address, ctx: &mut TxContext\n) {\n    let gift = Gift { id: object::new(ctx) };\n    transfer::transfer(gift, recipient);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"mint_and_transfer"}),' function is a public function that "could" be called by anyone, but it\nrequires an ',(0,i.jsx)(n.code,{children:"AdminCap"})," object to be passed as the first argument by reference. Without it, the\nfunction will not be callable. This is a simple way to restrict access to privileged functions\ncalled ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.a,{href:"./../programmability/capability",children:"Capability"})}),". Because the ",(0,i.jsx)(n.code,{children:"AdminCap"})," object is ",(0,i.jsx)(n.em,{children:"account\nowned"}),", only ",(0,i.jsx)(n.code,{children:"0xa11ce"})," will be able to call the ",(0,i.jsx)(n.code,{children:"mint_and_transfer"})," function."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Gift"}),"s sent to recipients will also be ",(0,i.jsx)(n.em,{children:"account owned"}),", each gift being unique and owned\nexclusively by the recipient."]}),"\n",(0,i.jsx)(n.p,{children:"A quick recap:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"transfer"})," function is used to send an object to an address;"]}),"\n",(0,i.jsxs)(n.li,{children:["The object becomes ",(0,i.jsx)(n.em,{children:"account owned"})," and can only be accessed by the recipient;"]}),"\n",(0,i.jsxs)(n.li,{children:["Functions can be gated by requiring an object to be passed as an argument, creating a\n",(0,i.jsx)(n.em,{children:"capability"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"freeze",children:"Freeze"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"transfer::freeze_object"})," function is a public function that is used to put an object into an\n",(0,i.jsx)(n.em,{children:"immutable"})," state. Once an object is ",(0,i.jsx)(n.em,{children:"frozen"}),", it can never be changed, and it can be accessed by\nanyone by immutable reference."]}),"\n",(0,i.jsxs)(n.p,{children:["The function signature is as follows, only accepts a type with the\n",(0,i.jsxs)(n.a,{href:"./key-ability",children:[(0,i.jsx)(n.code,{children:"key"})," ability"]}),". Just like all other storage functions, it takes the object ",(0,i.jsx)(n.em,{children:"by\nvalue"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module sui::transfer;\n\npublic fun freeze_object<T: key>(obj: T);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's expand on the previous example and add a function that allows the admin to create a ",(0,i.jsx)(n.code,{children:"Config"}),"\nobject and freeze it:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"/// Some `Config` object that the admin can `create_and_freeze`.\npublic struct Config has key {\n    id: UID,\n    message: String\n}\n\n/// Creates a new `Config` object and freezes it.\npublic fun create_and_freeze(\n    _: &AdminCap,\n    message: String,\n    ctx: &mut TxContext\n) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Freeze the object so it becomes immutable.\n    transfer::freeze_object(config);\n}\n\n/// Returns the message from the `Config` object.\n/// Can access the object by immutable reference!\npublic fun message(c: &Config): String { c.message }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Config is an object that has a ",(0,i.jsx)(n.code,{children:"message"})," field, and the ",(0,i.jsx)(n.code,{children:"create_and_freeze"})," function creates a new\n",(0,i.jsx)(n.code,{children:"Config"})," and freezes it. Once the object is frozen, it can be accessed by anyone by immutable\nreference. The ",(0,i.jsx)(n.code,{children:"message"})," function is a public function that returns the message from the ",(0,i.jsx)(n.code,{children:"Config"}),"\nobject. Config is now publicly available by its ID, and the message can be read by anyone."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Function definitions are not connected to the object's state. It is possible to define a function\nthat takes a mutable reference to an object that is used as frozen. However, it won't be callable\non a frozen object."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"message"})," function can be called on an immutable ",(0,i.jsx)(n.code,{children:"Config"})," object, however, two functions below\nare not callable on a frozen object:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"// === Functions below can't be called on a frozen object! ===\n\n/// The function can be defined, but it won't be callable on a frozen object.\n/// Only immutable references are allowed.\npublic fun message_mut(c: &mut Config): &mut String { &mut c.message }\n\n/// Deletes the `Config` object, takes it by value.\n/// Can't be called on a frozen object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"To summarize:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"transfer::freeze_object"})," function is used to put an object into an ",(0,i.jsx)(n.em,{children:"immutable"})," state;"]}),"\n",(0,i.jsxs)(n.li,{children:["Once an object is ",(0,i.jsx)(n.em,{children:"frozen"}),", it can never be changed, deleted or transferred, and it can be\naccessed by anyone by immutable reference;"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"owned---frozen",children:"Owned -> Frozen"}),"\n",(0,i.jsxs)(n.p,{children:["Since the ",(0,i.jsx)(n.code,{children:"transfer::freeze_object"})," signature accepts any type with the ",(0,i.jsx)(n.code,{children:"key"})," ability, it can take\nan object that was created in the same scope, but it can also take an object that was owned by an\naccount. This means that the ",(0,i.jsx)(n.code,{children:"freeze_object"})," function can be used to ",(0,i.jsx)(n.em,{children:"freeze"})," an object that was\n",(0,i.jsx)(n.em,{children:"transferred"})," to the sender. For security concerns, we would not want to freeze the ",(0,i.jsx)(n.code,{children:"AdminCap"}),"\nobject - it would be a security risk to allow access to it to anyone. However, we can freeze the\n",(0,i.jsx)(n.code,{children:"Gift"})," object that was minted and transferred to the recipient:"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Single Owner -> Immutable conversion is possible!"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"/// Freezes the `Gift` object so it becomes immutable.\npublic fun freeze_gift(gift: Gift) {\n    transfer::freeze_object(gift);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"share",children:"Share"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"transfer::share_object"})," function is a public function used to put an object into a ",(0,i.jsx)(n.em,{children:"shared"}),"\nstate. Once an object is ",(0,i.jsx)(n.em,{children:"shared"}),", it can be accessed by anyone by a mutable reference (hence,\nimmutable too). The function signature is as follows, only accepts a type with the\n",(0,i.jsxs)(n.a,{href:"./key-ability",children:[(0,i.jsx)(n.code,{children:"key"})," ability"]}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"module sui::transfer;\n\npublic fun share_object<T: key>(obj: T);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Once an object is ",(0,i.jsx)(n.em,{children:"shared"}),", it is publicly available as a mutable reference."]}),"\n",(0,i.jsx)(n.h2,{id:"special-case-shared-object-deletion",children:"Special Case: Shared Object Deletion"}),"\n",(0,i.jsx)(n.p,{children:"While the shared object can't normally be taken by value, there is one special case where it can -\nif the function that takes it deletes the object. This is a special case in the Sui storage model,\nand it is used to allow the deletion of shared objects. To show how it works, we will create a\nfunction that creates and shares a Config object and then another one that deletes it:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"/// Creates a new `Config` object and shares it.\npublic fun create_and_share(message: String, ctx: &mut TxContext) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Share the object so it becomes shared.\n    transfer::share_object(config);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"create_and_share"})," function creates a new ",(0,i.jsx)(n.code,{children:"Config"})," object and shares it. The object is now\npublicly available as a mutable reference. Let's create a function that deletes the shared object:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"/// Deletes the `Config` object, takes it by value.\n/// Can be called on a shared object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"delete_config"})," function takes the ",(0,i.jsx)(n.code,{children:"Config"})," object by value and deletes it, and the Sui Verifier\nwould allow this call. However, if the function returned the ",(0,i.jsx)(n.code,{children:"Config"})," object back or attempted to\n",(0,i.jsx)(n.code,{children:"freeze"})," or ",(0,i.jsx)(n.code,{children:"transfer"})," it, the Sui Verifier would reject the transaction."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-move",children:"// Won't work!\npublic fun transfer_shared(c: Config, to: address) {\n    transfer::transfer(c, to);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"To summarize:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"share_object"})," function is used to put an object into a ",(0,i.jsx)(n.em,{children:"shared"})," state;"]}),"\n",(0,i.jsxs)(n.li,{children:["Once an object is ",(0,i.jsx)(n.em,{children:"shared"}),", it can be accessed by anyone by a mutable reference;"]}),"\n",(0,i.jsx)(n.li,{children:"Shared objects can be deleted, but they can't be transferred or frozen."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.p,{children:["Now that you know main features of the ",(0,i.jsx)(n.code,{children:"transfer"})," module, you can start building more complex\napplications on Sui that involve storage operations. In the next chapter, we will cover the\n",(0,i.jsx)(n.a,{href:"./store-ability",children:"Store Ability"})," which allows storing data inside objects and relaxes transfer\nrestrictions which we barely touched on here. And after that we will cover the\n",(0,i.jsx)(n.a,{href:"./uid-and-id",children:"UID and ID"})," types which are the most important types in the Sui storage model."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},5521:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>r});var s=t(6672);const i={},a=s.createContext(i);function c(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);