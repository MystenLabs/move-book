<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>所有权和引用</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Move 编程语言</a></li><li class="chapter-item expanded "><a href="../introduction/foreword.html"><strong aria-hidden="true">2.</strong> 序言</a></li><li class="chapter-item expanded "><a href="../introduction/getting-started.html"><strong aria-hidden="true">3.</strong> 快速入门</a></li><li class="chapter-item expanded "><a href="../syntax-basics/index.html"><strong aria-hidden="true">4.</strong> 语法基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../syntax-basics/concept.html"><strong aria-hidden="true">4.1.</strong> 基础概念</a></li><li class="chapter-item expanded "><a href="../syntax-basics/primitives.html"><strong aria-hidden="true">4.2.</strong> 基本类型</a></li><li class="chapter-item expanded "><a href="../syntax-basics/comments.html"><strong aria-hidden="true">4.3.</strong> 注释</a></li><li class="chapter-item expanded "><a href="../syntax-basics/expression-and-scope.html"><strong aria-hidden="true">4.4.</strong> 表达式和作用域</a></li><li class="chapter-item expanded "><a href="../syntax-basics/control-flow.html"><strong aria-hidden="true">4.5.</strong> 控制流</a></li><li class="chapter-item expanded "><a href="../syntax-basics/module.html"><strong aria-hidden="true">4.6.</strong> 模块和导入</a></li><li class="chapter-item expanded "><a href="../syntax-basics/constants.html"><strong aria-hidden="true">4.7.</strong> 常量</a></li><li class="chapter-item expanded "><a href="../syntax-basics/function.html"><strong aria-hidden="true">4.8.</strong> 函数</a></li></ol></li><li class="chapter-item expanded "><a href="../advanced-topics/index.html"><strong aria-hidden="true">5.</strong> 进阶主题</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../advanced-topics/struct.html"><strong aria-hidden="true">5.1.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../advanced-topics/types-with-abilities.html"><strong aria-hidden="true">5.2.</strong> Abilities</a></li><li class="chapter-item expanded "><a href="../advanced-topics/ownership-and-references.html" class="active"><strong aria-hidden="true">5.3.</strong> 所有权和引用</a></li><li class="chapter-item expanded "><a href="../advanced-topics/understanding-generics.html"><strong aria-hidden="true">5.4.</strong> 泛型</a></li><li class="chapter-item expanded "><a href="../advanced-topics/managing-collections-with-vectors.html"><strong aria-hidden="true">5.5.</strong> 数组</a></li></ol></li><li class="chapter-item expanded "><a href="../resources/index.html"><strong aria-hidden="true">6.</strong> 可编程的 Resource</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../resources/signer-type.html"><strong aria-hidden="true">6.1.</strong> 发送者和签署者</a></li><li class="chapter-item expanded "><a href="../resources/what-is-resource.html"><strong aria-hidden="true">6.2.</strong> 什么是 Resource</a></li><li class="chapter-item expanded "><a href="../resources/resource-by-example/index.html"><strong aria-hidden="true">6.3.</strong> Resource 举例</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../resources/resource-by-example/storing-new-resource.html"><strong aria-hidden="true">6.3.1.</strong> 创建和转移</a></li><li class="chapter-item expanded "><a href="../resources/resource-by-example/access-resource-with-borrow.html"><strong aria-hidden="true">6.3.2.</strong> 读取和修改</a></li><li class="chapter-item expanded "><a href="../resources/resource-by-example/destroy-resource.html"><strong aria-hidden="true">6.3.3.</strong> 使用和销毁</a></li><li class="chapter-item expanded "><a href="../resources/resource-by-example/furher-steps.html"><strong aria-hidden="true">6.3.4.</strong> 下一步</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../tutorials/index.html"><strong aria-hidden="true">7.</strong> 实例</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorials/erc20.html"><strong aria-hidden="true">7.1.</strong> ERC20 代币</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#所有权和引用" id="所有权和引用">所有权和引用</a></h1>
<p>Move VM 实现了类似 Rust 的所有权功能。关于所有权的详细描述，可以参考 <a href="https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html">Rust Book</a> 。</p>
<p>Rust 语法不同于 Move，某些示例可能不容易理解，但还是建议大家先阅读一下 Rust Book 中的所有权一章。当然，关于所有权的关键点本书也会逐一介绍。</p>
<blockquote>
<p>每个变量只有一个所有者作用域。当所有者作用域结束时，变量将被删除。</p>
</blockquote>
<p>变量的寿命与它的作用域一样长，我们曾经在表达式一章中看到过这种行为，大家还有没有印象？现在是了解其内部机制的绝佳时机了。</p>
<p>所有者是<em>拥有</em>某变量的作用域。变量可以在作用域内定义（例如，在脚本中使用关键字 let），也可以作为参数传递给作用域。由于 Move 中唯一的作用域是函数的作用域，所以除了这两种方法，没有其它方法可以将变量放入作用域。</p>
<p>每个变量只有一个所有者，这意味着当把变量作为参数传递给函数时，该函数将成为<em>新所有者</em>，并且第一个函数不再<em>拥有</em>该变量。或者可以说，第二个函数接管了变量的<em>所有权</em>。</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        // Module::T is a struct
        let a : Module::T = Module::create(10);

        // here variable `a` leaves scope of `main` function
        // and is being put into new scope of `M::value` function
        M::value(a);

        // variable a no longer exists in this scope
        // this code won't compile
        M::value(a);
    }
}
</code></pre>
<p>让我们看一下将变量传递给 value() 函数时，Move 内部发生的情况：</p>
<pre><code class="language-Move">module M {
    // create_fun skipped
    struct T { value: u8 }

    public fun create(value: u8): T {
        T { value }
    }

    // variable t of type M::T passed
    // `value()` function takes ownership
    public fun value(t: T): u8 {
        // we can use t as variable
        t.value
    }
    // function scope ends, t dropped, only u8 result returned
    // t no longer exists
}
</code></pre>
<p>我们可以看到，当函数 value() 结束时，t 将不复存在，返回的只是一个 u8 类型的值。如何让t仍然可用呢？当然，一种快速的解决方案是返回一个元组，该元组包含原始变量和其它结果，但是 Move 还有一个更好的解决方案。</p>
<h2><a class="header" href="#move-和-copy" id="move-和-copy">move 和 copy</a></h2>
<p>首先，我们了解一下 Move VM 的工作原理，以及将值传递给函数时会发生什么。Move VM 里有两个字节码指令：<em>MoveLoc</em> 和 <em>CopyLoc</em>，反映到 Move 语言层面，它们分别对应关键字<code>move</code>和<code>copy</code>。</p>
<p>将变量传递到另一个函数时，MoveLoc 指令被使用，它会被 <em>move</em>。我们可以像下面这样显式使用 <em>move</em> 关键字：</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let a : Module::T = Module::create(10);

        M::value(move a); // variable a is moved

        // local a is dropped
    }
}
</code></pre>
<p>这段代码是没有问题的，但是我们平常并不需要显示使用 <em>move</em>，缺省 a 会被 <em>move</em>。那么 <em>copy</em> 又是怎么回事呢？</p>
<h3><a class="header" href="#关键字-copy" id="关键字-copy">关键字 <code>copy</code></a></h3>
<p>如果想保留变量的值，同时仅将值的副本传递给某函数，则可以使用关键字 <code>copy</code>。</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let a : Module::T = Module::create(10);

        // we use keyword copy to clone structure
        // can be used as `let a_copy = copy a`
        M::value(copy a);
        M::value(a); // won't fail, a is still here
    }
}
</code></pre>
<p>上例中，我们第一次调用函数 value() 时，将变量 a 的副本传递给函数，并保留 a 在本地作用域中，以便第二次调用函数时再次使用它。</p>
<p>使用 <em>copy</em> 后，我们实际上复制了变量值从而增加了程序占用内存的大小。但是如果复制数据数据量比较大，它的内存消耗可能会很高。这里要注意了，在区块链中，交易执行时占用的内存资源是消耗交易费的，每个字节都会影响交易执行费用。因此不加限制的使用 copy 会浪费很多交易费。</p>
<p>现在，是时候学习<code>引用</code>了，它可以帮助我们避免不必要的<code> copy</code> 从而节省一些费用。</p>
<h2><a class="header" href="#引用" id="引用">引用</a></h2>
<p>许多编程语言都支持<code>引用</code>。<em>引用</em>是指向变量（通常是内存中的某个片段）的链接，你可以将其传递到程序的其他部分，而无需移动变量值。</p>
<blockquote>
<p>引用（标记为＆）使我们可以使用值而无需拥有所有权。</p>
</blockquote>
<p>我们修改一下上面的示例，看看如何使用引用。</p>
<pre><code class="language-Move">module M {
    struct T { value: u8 }
    // ...
    // ...
    // instead of passing a value, we'll pass a reference
    public fun value(t: &amp;T): u8 {
        t.value
    }
}
</code></pre>
<p>我们在参数类型 T 前添加了＆符号，这样就可以将参数类型T转换成了 T 的引用&amp;T。</p>
<blockquote>
<p>Move 支持两种类型的引用：不可变引用 &amp;（例如&amp;T）和可变引用 &amp;mut（例如&amp;mut T）。</p>
</blockquote>
<p>不可变的引用允许我们在不更改值的情况下读取值。可变引用赋予我们读取和更改值的能力。</p>
<pre><code class="language-Move">module M {
    struct T { value: u8 }

    // returned value is of non-reference type
    public fun create(value: u8): T {
        T { value }
    }

    // immutable references allow reading
    public fun value(t: &amp;T): u8 {
        t.value
    }

    // mutable references allow reading and changing the value
    public fun change(t: &amp;mut T, value: u8) {
        t.value = value;
    }
}
</code></pre>
<p>现在，让我们看看如何使用升级后的模块 M。</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let t = M::create(10);

        // create a reference directly
        M::change(&amp;mut t, 20);

        // or write reference to a variable
        let mut_ref_t = &amp;mut t;

        M::change(mut_ref_t, 100);

        // same with immutable ref
        let value = M::value(&amp;t);

        // this method also takes only references
        // printed value will be 100
        0x1::Debug::print&lt;u8&gt;(&amp;value);
    }
}
</code></pre>
<blockquote>
<p>使用不可变引用（＆）从结构体读取数据，使用可变引用（＆mut）修改它们。通过使用适当类型的引用，我们可以更加安全的读取模块，因为它能告诉代码的阅读者，该变量是否会被修改。</p>
</blockquote>
<h3><a class="header" href="#borrow-检查" id="borrow-检查">Borrow 检查</a></h3>
<p>Move 通过&quot;Borrow 检查&quot;来控制程序中&quot;引用&quot;的使用，这样有助于防止意外出错。为了理解这一点，我们看一个例子。</p>
<pre><code class="language-Move">module Borrow {

    struct B { value: u64 }
    struct A { b: B }

    // create A with inner B
    public fun create(value: u64): A {
        A { b: B { value } }
    }

    // give a mutable reference to inner B
    public fun ref_from_mut_a(a: &amp;mut A): &amp;mut B {
        &amp;mut a.b
    }

    // change B
    public fun change_b(b: &amp;mut B, value: u64) {
        b.value = value;
    }
}
</code></pre>
<pre><code class="language-Move">script {
    use {{sender}}::Borrow;

    fun main() {
        // create a struct A { b: B { value: u64 } }
        let a = Borrow::create(0);

        // get mutable reference to B from mut A
        let mut_a = &amp;mut a;
        let mut_b = Borrow::ref_from_mut_a(mut_a);

        // change B
        Borrow::change_b(mut_b, 100000);

        // get another mutable reference from A
        let _ = Borrow::ref_from_mut_a(mut_a);
    }
}
</code></pre>
<p>上面代码可以成功编译运行，不会报错。这里究竟发生了什么呢？首先，我们使用 A 的可变引用（&amp;mut A）来获取对其内部 struct B 的可变引用（&amp;mut B）。然后我们改变 B。然后可以再次通过 &amp;mut A 获取对 B 的可变引用。</p>
<p>但是，如果我们交换最后两个表达式，即首先尝试创建新的 &amp;mut A，而 &amp;mut B 仍然存在，会出现什么情况呢？</p>
<pre><code class="language-Move">let mut_a = &amp;mut a;
let mut_b = Borrow::ref_from_mut_a(mut_a);

let _ = Borrow::ref_from_mut_a(mut_a);

Borrow::change_b(mut_b, 100000);
</code></pre>
<p>编译器将会报错：</p>
<pre><code class="language-Move">    ┌── /scripts/script.move:10:17 ───
    │
 10 │         let _ = Borrow::ref_from_mut_a(mut_a);
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid usage of reference as function argument. Cannot transfer a mutable reference that is being borrowed
    ·
  8 │         let mut_b = Borrow::ref_from_mut_a(mut_a);
    │                     ----------------------------- It is still being mutably borrowed by this reference
    │
</code></pre>
<p>该代码不会编译成功。为什么？因为 &amp;mut A 已经被 &amp;mut B 借用。如果我们再将其作为参数传递，那么我们将陷入一种奇怪的情况，A 可以被更改，但 A 同时又被引用。而 mut_b 应该指向何处呢？</p>
<p>我们得出一些结论：</p>
<ol>
<li>编译器通过所谓的&quot;借用检查&quot;（最初是Rust语言的概念）来防止上面这些错误。编译器通过建立&quot;借用图&quot;，不允许被借用的值被&quot;move&quot;。这就是 Move 在区块链中如此安全的原因之一。</li>
<li>可以从引用创建新的引用，老的引用将被新引用&quot;借用&quot;。可变引用可以创建可变或者不可变引用，而不可变引用只能创建不可变引用。</li>
<li>当一个值被引用时，就无法&quot;move&quot;它了，因为其它值对它有依赖。</li>
</ol>
<h3><a class="header" href="#取值运算" id="取值运算">取值运算</a></h3>
<p>可以通过<code>取值</code>运算<code>*</code>来获取引用所指向的值。</p>
<blockquote>
<p>取值运算实际上是产生了一个副本，要确保这个值具有 <code>Copy</code> ability。</p>
</blockquote>
<pre><code class="language-Move">module M {
    struct T has copy {}

    // value t here is of reference type
    public fun deref(t: &amp;T): T {
        *t
    }
}
</code></pre>
<blockquote>
<p>取值运算不会将原始值 move 到当前作用域，实际上只是生成了一个副本。</p>
</blockquote>
<p>有一个技巧用来复制一个结构体的字段：就是使用<code>*&amp;</code>，引用并取值。我们来看一个例子：</p>
<pre><code class="language-Move">module M {
    struct H has copy {}
    struct T { inner: H }

    // ...

    // we can do it even from immutable reference!
    public fun copy_inner(t: &amp;T): H {
        *&amp;t.inner
    }
}
</code></pre>
<p>通过使用*&amp;（编译器会建议这样做），我们复制了结构体的内部值。</p>
<h3><a class="header" href="#引用基本类型" id="引用基本类型">引用基本类型</a></h3>
<p>基本类型非常简单，它们不需要作为引用传递，缺省会被复制。当基本类型的值被传给函数时，相当于使用了<code>copy</code>关键字，传递进函数的是它们的副本。当然你可以使用<code>move</code>关键字强制不产生副本，但是由于基本类型的大小很小，复制它们其实开销很小，甚至比通过引用或者&quot;move&quot;传递它们开销更小。</p>
<pre><code class="language-Move">script {
    use {{sender}}::M;

    fun main() {
        let a = 10;
        M::do_smth(a);
        let _ = a;
    }
}
</code></pre>
<p>也就是说，即使我们没有将<code>a</code>作为引用传递，该脚本也会编译。我们也无需添加<code>copy</code>，因为 VM 已经帮组我们添加了。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../advanced-topics/types-with-abilities.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../advanced-topics/understanding-generics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../advanced-topics/types-with-abilities.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../advanced-topics/understanding-generics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
