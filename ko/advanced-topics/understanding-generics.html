<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>제네릭 이해하기</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Move 프로그래밍 언어</a></li><li class="chapter-item expanded "><a href="../introduction/foreword.html"><strong aria-hidden="true">2.</strong> 서문</a></li><li class="chapter-item expanded "><a href="../introduction/getting-started.html"><strong aria-hidden="true">3.</strong> 시작하기</a></li><li class="chapter-item expanded "><a href="../syntax-basics/index.html"><strong aria-hidden="true">4.</strong> 구문 기본사항</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../syntax-basics/concept.html"><strong aria-hidden="true">4.1.</strong> 개념</a></li><li class="chapter-item expanded "><a href="../syntax-basics/primitives.html"><strong aria-hidden="true">4.2.</strong> 기본형</a></li><li class="chapter-item expanded "><a href="../syntax-basics/comments.html"><strong aria-hidden="true">4.3.</strong> 주석</a></li><li class="chapter-item expanded "><a href="../syntax-basics/expression-and-scope.html"><strong aria-hidden="true">4.4.</strong> 표현식과 스코프</a></li><li class="chapter-item expanded "><a href="../syntax-basics/control-flow.html"><strong aria-hidden="true">4.5.</strong> 제어 흐름</a></li><li class="chapter-item expanded "><a href="../syntax-basics/module.html"><strong aria-hidden="true">4.6.</strong> 모듈과 불러오기</a></li><li class="chapter-item expanded "><a href="../syntax-basics/constants.html"><strong aria-hidden="true">4.7.</strong> 상수</a></li><li class="chapter-item expanded "><a href="../syntax-basics/function.html"><strong aria-hidden="true">4.8.</strong> 함수</a></li></ol></li><li class="chapter-item expanded "><a href="../advanced-topics/index.html"><strong aria-hidden="true">5.</strong> 고급 주제</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../advanced-topics/struct.html"><strong aria-hidden="true">5.1.</strong> 구조</a></li><li class="chapter-item expanded "><a href="../advanced-topics/types-with-abilities.html"><strong aria-hidden="true">5.2.</strong> 능력을 지니는 유형</a></li><li class="chapter-item expanded "><a href="../advanced-topics/ownership-and-references.html"><strong aria-hidden="true">5.3.</strong> 소유권과 참조</a></li><li class="chapter-item expanded "><a href="../advanced-topics/understanding-generics.html" class="active"><strong aria-hidden="true">5.4.</strong> 제네릭 이해하기</a></li><li class="chapter-item expanded "><a href="../advanced-topics/managing-collections-with-vectors.html"><strong aria-hidden="true">5.5.</strong> 벡터로 집합 관리하기</a></li></ol></li><li class="chapter-item expanded "><a href="../resources/index.html"><strong aria-hidden="true">6.</strong> 프로그래밍 가능한 자원</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../resources/signer-type.html"><strong aria-hidden="true">6.1.</strong> 서명자로서의 전송자</a></li><li class="chapter-item expanded "><a href="../resources/what-is-resource.html"><strong aria-hidden="true">6.2.</strong> 리소스란 무엇인가</a></li><li class="chapter-item expanded "><a href="../resources/resource-by-example/index.html"><strong aria-hidden="true">6.3.</strong> 리소스별 예시</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../resources/resource-by-example/storing-new-resource.html"><strong aria-hidden="true">6.3.1.</strong> 리소스 생성 및 이동</a></li><li class="chapter-item expanded "><a href="../resources/resource-by-example/access-resource-with-borrow.html"><strong aria-hidden="true">6.3.2.</strong> 리소스 읽기 및 수정</a></li><li class="chapter-item expanded "><a href="../resources/resource-by-example/destroy-resource.html"><strong aria-hidden="true">6.3.3.</strong> 리소스 이전 및 파괴</a></li><li class="chapter-item expanded "><a href="../resources/resource-by-example/furher-steps.html"><strong aria-hidden="true">6.3.4.</strong> 추가 단계</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../tutorials/index.html"><strong aria-hidden="true">7.</strong> 튜토리얼</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorials/erc20.html"><strong aria-hidden="true">7.1.</strong> ERC20 토큰 작성</a></li></ol></li><li class="chapter-item expanded "><a href="../translations.html"><strong aria-hidden="true">8.</strong> 번역본</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#제네릭-이해하기" id="제네릭-이해하기">제네릭 이해하기</a></h1>
<p>제네릭은 블록체인 세계에서 Move 언어가 독특성을 지니게 하며 Move의 유연성의 근원으로 작용하기 때문에 Move에 필수불가결한 요소입니다.</p>
<p>우선 <a href="https://doc.rust-lang.org/stable/book/ch10-00-generics.html">Rust Book</a> 에서 인용하자면 제네릭은 구체적인 유형 또는 기타 속성을 대신하는 추상적인 대역입니다. 실제적인 측면에서 이야기하자면 제네릭은 단일 함수를 작성할 때 사용되는 방법으로, 어떠한 유형에도 사용할 수 있으며 이렇게 작성한 함수는 모든 유형의 견본 취급자로 사용될 수 있기 때문에 견본이라고 칭하기도 합니다.</p>
<p>Move에서 제네릭은 <code>struct</code>와 <code>function</code>의 서명에 적용될 수 있습니다.</p>
<h3><a class="header" href="#구조체-내부에서의-정의" id="구조체-내부에서의-정의">구조체 내부에서의 정의</a></h3>
<p>우선 <code>u64</code> 값을 저장하는 상자인 Box를 생성합시다. 이미 진행해 본 작업이므로 주석은 생략하겠습니다.</p>
<pre><code class="language-Move">module Storage {
    struct Box {
        value: u64
    }
}
</code></pre>
<p>이 상자는 <code>u64</code> 유형의 값만 저장할 수 있다는 건 자명한 사실입니다. 그러나 동일한 상자를 <code>u8</code> 유형이나 <code>bool</code>형에 대응하도록 생성하고 싶다면 어떻게 할까요? <code>Box1</code>과 <code>Box2</code>를 생성하는 게 좋을까요? 아니면 다른 모듈을 발행해야 할까요? 둘 다 오답입니다. 제네릭을 사용하면 되니까요.</p>
<pre><code class="language-Move">module Storage {
    struct Box&lt;T&gt; {
        value: T
    }
}
</code></pre>
<p>구조체 이름 옆에 <code>&lt;T&gt;</code>를 입력했습니다. 부등호 기호 <code>&lt;..&gt;</code>들은 제네릭의 유형을 정의하기 위해 사용하며, <code>T</code>는 이 구조체에서 우리가 견본으로 삼은 유형에 해당합니다. 구조체 바디 정의 내부에서는 <code>T</code>를 일반 유형으로 사용했습니다. <code>T</code>라는 유형은 실존하는 것이 아니라, <em>모든 유형</em>이 들어올 수 있도록 하는 문자입니다.</p>
<h3><a class="header" href="#함수-내-서명" id="함수-내-서명">함수 내 서명</a></h3>
<p>이제 <code>u64</code> 유형을 우선 값으로 사용할 이 구조체에 생성자를 생성하겠습니다.</p>
<pre><code class="language-Move">module Storage {
    struct Box&lt;T&gt; {
        value: T
    }

    // type u64 is put into angle brackets meaning
    // that we're using Box with type u64
    public fun create_box(value: u64): Box&lt;u64&gt; {
        Box&lt;u64&gt;{ value }
    }
}
</code></pre>
<p>제네릭은 명시된 유형 매개 변수를 가져야 하기 때문에 약간 더 복잡한 정의를 지니는데, 따라서 일반 구조체 <code>Box</code>는 <code>Box&lt;u64&gt;</code>가 됩니다. 제네릭의 부등호 기호 안에는 모든 유형을 전달할 수 있습니다. <code>create_box</code>메서드를 더욱 일반성을 띠도록 하여 사용자들이 유형을 명시할 수 있게 처리해 줍시다. 다른 제네릭을 함수 서명에 활용함으로써 말입니다</p>
<pre><code class="language-Move">module Storage {
    // ...
    public fun create_box&lt;T&gt;(value: T): Box&lt;T&gt; {
        Box&lt;T&gt; { value }
    }

    // we'll get to this a bit later, trust me
    public fun value&lt;T: copy&gt;(box: &amp;Box&lt;T&gt;): T {
        *&amp;box.value
    }
}
</code></pre>
<h3><a class="header" href="#함수-호출에서의-사용" id="함수-호출에서의-사용">함수 호출에서의 사용</a></h3>
<p>우리는 방금 구조체에서 진행했던 방식과 동일하게, 부등호들을 함수 서명에서 함수의 이름 바로 뒤에 추가했습니다. 이제 이 함수를 어떻게 사용하면 좋을까요? 함수 호출 상에서 유형을 명시해 주면 됩니다.</p>
<pre><code class="language-Move">script {
    use {{sender}}::Storage;
    use 0x1::Debug;

    fun main() {
        // value will be of type Storage::Box&lt;bool&gt;
        let bool_box = Storage::create_box&lt;bool&gt;(true);
        let bool_val = Storage::value(&amp;bool_box);

        assert(bool_val, 0);

        // we can do the same with integer
        let u64_box = Storage::create_box&lt;u64&gt;(1000000);
        let _ = Storage::value(&amp;u64_box);

        // let's do the same with another box!
        let u64_box_in_box = Storage::create_box&lt;Storage::Box&lt;u64&gt;&gt;(u64_box);

        // accessing value of this box in box will be tricky :)
        // Box&lt;u64&gt; is a type and Box&lt;Box&lt;u64&gt;&gt; is also a type
        let value: u64 = Storage::value&lt;u64&gt;(
            &amp;Storage::value&lt;Storage::Box&lt;u64&gt;&gt;( // Box&lt;u64&gt; type
                &amp;u64_box_in_box // Box&lt;Box&lt;u64&gt;&gt; type
            )
        );

        // you've already seen Debug::print&lt;T&gt; method
        // which also uses generics to print any type
        Debug::print&lt;u64&gt;(&amp;value);
    }
}
</code></pre>
<p>여기에서는 3가지 유형, 즉 <code>bool</code>형, <code>u64</code> 그리고 <code>Box&lt;u64&gt;</code>를 토대로 Box 구조체를 사용했습니다. 마지막 유형은 굉장히 복잡해 보이겠지만 작동 방식을 이해하고 좀 더 친숙해 진 다음에는 루틴의 일부가 될 것입니다.</p>
<!-- , Move opens in new way - the way you probably could never imagine in blockchains. -->
<p>더 진행하기에 앞서 잠시 되돌아갑시다. <code>Box</code> 구조체에 제네릭을 추가함으로써 이 상자는 <em>추상적</em>인 성격을 지니게 되었는데, 우리가 활용할 수 있는 용량에 비해 정의는 상당히 간단한 편입니다. 이제는 <code>u64</code>, <code>address</code>, 심지어 다른 <code>box</code>나 구조체를 아우르는 모든 유형을 가지는 Box를 생성할 수 있습니다.</p>
<h3><a class="header" href="#능력-확인의-제약-사항" id="능력-확인의-제약-사항">능력 확인의 제약 사항</a></h3>
<p><a href="/advanced-topics/abilities/README.html">능력</a> 에 대해 앞서 배웠는데, 제네릭에서는 능력을 “확인” 하거나 <em>제약</em>하게 됩니다. 제약의 경우 대응하는 능력에 따라 이름이 결정됩니다.</p>
<pre><code class="language-Move">fun name&lt;T: copy&gt;() {} // allow only values that can be copied
fun name&lt;T: copy + drop&gt;() {} // values can be copied and dropped
fun name&lt;T: key + store + drop + copy&gt;() {} // all 4 abilities are present
</code></pre>
<p>...또는 구조체의 경우</p>
<pre><code class="language-Move">struct name&lt;T: copy + drop&gt; { value: T } // T can be copied and dropped
struct name&lt;T: store&gt; { value: T } // T can be stored in global storage
</code></pre>
<blockquote>
<p>다음 구문을 숙지 바랍니다. <code>+</code>(plus)부호는 처음부터 직관적이지 않을 수 있으나, Move의 키워드 목록에서 유일하게 <code>+</code>를 사용하는 곳입니다.</p>
</blockquote>
<p>제약이 걸린 시스템의 예시입니다.</p>
<pre><code class="language-Move">module Storage {

    // contents of the box can be stored
    struct Box&lt;T: store&gt; has key, store {
        content: T
    }
}
</code></pre>
<p>또한 내부 유형(또는 제네릭 유형)은 반드시 컨테이너의 능력(<code>key</code>를 제외한 모든 능력이 해당)을 가져야 한다는 점도 숙지해 두십시오. 조금만 생각해 보면 모든 부분은 상식적이고 직관적입니다. <strong>copy(복사)</strong> 능력이 있는 구조체라면 내용 또한 복사 능력을 가져야 합니다. 그렇지 않다면 컨테이너 객체가 복사가능한 것으로 간주될 수 없을 것입니다. Move 컴파일러는 이 논리를 따르지 않는 코드도 컴파일하도록 허용하겠지만 해당 능력들은 사용할 수 없게 될 것입니다. 다음의 예시를 참조하십시오.</p>
<pre><code class="language-Move">module Storage {
    // non-copyable or droppable struct
    struct Error {}
    
    // constraints are not specified
    struct Box&lt;T&gt; has copy, drop {
        contents: T
    }

    // this method creates box with non-copyable or droppable contents
    public fun create_box(): Box&lt;Error&gt; {
        Box { contents: Error {} }
    }
}
</code></pre>
<p>이 코드는 성공적으로 컴파일 및 발행이 진행되었습니다. 그러나 실행해 보게 되면…</p>
<pre><code class="language-Move">script {
    fun main() {
        {{sender}}::Storage::create_box() // value is created and dropped
    }   
}
</code></pre>
<p>Box가 제외할 수 없다는 오류가 출력됩니다.</p>
<pre><code>   ┌── scripts/main.move:5:9 ───
   │
 5 │   Storage::create_box();
   │   ^^^^^^^^^^^^^^^^^^^^^ Cannot ignore values without the 'drop' ability. The value must be used
   │
</code></pre>
<p>이런 일이 발생하는 이유는 내부 값에 제외 능력이 없기 때문입니다. 컨테이너의 능력은 내용에 의해 자동으로 제한이 되므로, 예를 들어 복사, 제외 및 저장 능력을 가진 컨테이너 구조체가 있고 내부 구조체에는 제외 능력밖에 없다면 해당 컨테이너를 복사하거나 저장하는 것은 불가능할 것입니다. 또 다른 관점에서 볼 때 이 컨테이너는 내부 유형에 대한 제약 사항을 가질 필요가 없이, 내부에 어떤 유형이 들어있든지 사용될 수 있는 유연성을 확보하는 것도 가능합니다.</p>
<blockquote>
<p>그러나 실수를 피하기 위해 항상 점검을 게을리하지 말고, 필요하다면 함수와 구조체에서 제네릭 관련 제약사항을 명시하는 것이 좋습니다.</p>
</blockquote>
<p>아래 구조체가 보다 안전한 예시가 되겠습니다.</p>
<pre><code class="language-Move">// we add parent's constraints
// now inner type MUST be copyable and droppable
struct Box&lt;T: copy + drop&gt; has copy, drop {
    contents: T
}
</code></pre>
<h3><a class="header" href="#제네릭에서의-여러-유형" id="제네릭에서의-여러-유형">제네릭에서의 여러 유형</a></h3>
<p>유형은 한 개에서 그치지 않고 여러 개를 사용하는 것도 가능합니다. 제네릭 유형들은 부등호 기호 내부에 입력되며 쉼표로 분리합니다. 2가지 다른 유형을 가지는 상자 2개를 포함하는 새로운 유형인 <code>Shelf</code>를 추가해 봅시다.</p>
<pre><code class="language-Move">module Storage {

    struct Box&lt;T&gt; {
        value: T
    }

    struct Shelf&lt;T1, T2&gt; {
        box_1: Box&lt;T1&gt;,
        box_2: Box&lt;T2&gt;
    }

    public fun create_shelf&lt;Type1, Type2&gt;(
        box_1: Box&lt;Type1&gt;,
        box_2: Box&lt;Type2&gt;
    ): Shelf&lt;Type1, Type2&gt; {
        Shelf {
            box_1,
            box_2
        }
    }
}
</code></pre>
<p><code>Shelf</code>에 대응하는 유형 매개 변수를 수록하여 구조체의 필드 정의에 대응시켰습니다. 또한 여기에서 볼 수 있듯 제네릭 내부에 위치한 유형 매개 변수의 이름은 관계없습니다. 적절한 이름만 선택해 주면 되겠고, 각 유형 매개 변수는 정의 내부에서만 유효하기 때문에 <code>T1</code>이나 <code>T2</code>를 <code>T</code>와 대응시킬 필요는 없습니다.</p>
<p>다수의 제네릭 유형 매개 변수를 사용하는 것은 단일 변수의 사용 때와 크게 다르지 않습니다.</p>
<pre><code class="language-Move">script {
    use {{sender}}::Storage;

    fun main() {
        let b1 = Storage::create_box&lt;u64&gt;(100);
        let b2 = Storage::create_box&lt;u64&gt;(200);

        // you can use any types - so same ones are also valid
        let _ = Storage::create_shelf&lt;u64, u64&gt;(b1, b2);
    }
}
</code></pre>
<p><em>하나의 정의에서는 최대 18,446,744,073,709,551,615 (u64 크기) 개의 제네릭을 사용할 수 있습니다. 물론 이런 제한에 도달할 일은 전혀 없으니, 제한 받을 염려 없이 마음껏 필요한 만큼 사용하시면 됩니다.</em></p>
<h3><a class="header" href="#사용되지-않은-유형의-매개-변수" id="사용되지-않은-유형의-매개-변수">사용되지 않은 유형의 매개 변수</a></h3>
<p>제네릭에서 명시된 모든 유형이 사용될 필요는 없습니다. 다음의 예시를 참고해 주십시오.</p>
<pre><code class="language-Move">module Storage {

    // these two types will be used to mark
    // where box will be sent when it's taken from shelf
    struct Abroad {}
    struct Local {}

    // modified Box will have target property
    struct Box&lt;T, Destination&gt; {
        value: T
    }

    public fun create_box&lt;T, Dest&gt;(value: T): Box&lt;T, Dest&gt; {
        Box { value }
    }
}
</code></pre>
<p>때로는 작업에 제네릭을 제약 또는 상수로 사용하는 것도 적절한 선택입니다. 스크립트에서의 사용법을 함께 보도록 합시다.</p>
<pre><code class="language-Move">
script {
    use {{sender}}::Storage;

    fun main() {
        // value will be of type Storage::Box&lt;bool&gt;
        let _ = Storage::create_box&lt;bool, Storage::Abroad&gt;(true);
        let _ = Storage::create_box&lt;u64, Storage::Abroad&gt;(1000);

        let _ = Storage::create_box&lt;u128, Storage::Local&gt;(1000);
        let _ = Storage::create_box&lt;address, Storage::Local&gt;(0x1);

        // or even u64 destination!
        let _ = Storage::create_box&lt;address, u64&gt;(0x1);
    }
}
</code></pre>
<p>여기에서는 제네릭을 사용하여 유형을 표시했지만, 실제로 사용하지는 않습니다. 왜 이러한 정의가 중요한지는 자원 개념을 배울 때 함께 습득하시게 될 것입니다. 우선 지금은 제네릭의 또 다른 사용법이라고만 이해하셔도 무방합니다.</p>
<!-- ### Copyable

*Copyable kind* - is a kind of types, value of which can be copied. `struct`, `vector` and primitive types - are three main groups of types fitting into this kind.

To understand why Move needs this constraint let's see this example:

```Move
module M {
    public fun deref<T>(t: &T): T {
        *t
    }
}
```

By using *dereference* on a reference you can *copy* the original value and return it as a regular. But what if we've tried to use `resource` in this example? Resource can't be copied, hence this code would fail. Hopefully compiler won't let you compile this type, and kinds exist to manage cases like this.

```Move
module M {
    public fun deref<T: copyable>(t: &T): T {
        *t
    }
}
```

We've added `: copyable` constraint into generic definition, and now type `T` must be of kind *copyable*. So now function accepts only `struct`, `vector` and primitives as type parameters. This code compiles as constraint provides safety over used types and passing non-copyable value here is impossible.

### Resource

Another kind has only one type inside is a `resource` kind. It is used in the same manner:

```Move
module M {
    public fun smth<T: resource>(t: &T) {
        // do smth
    }
}
```

This example here is only needed to show syntax, we'll get to resources soon and you'll learn actual use cases for this constraint. -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../advanced-topics/ownership-and-references.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../advanced-topics/managing-collections-with-vectors.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../advanced-topics/ownership-and-references.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../advanced-topics/managing-collections-with-vectors.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
